var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
/**
* @vue/shared v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function makeMap(str, expectsLowerCase) {
  const set2 = new Set(str.split(","));
  return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove$1 = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$q = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$q.call(val, key);
const isArray$1 = Array.isArray;
const isMap$2 = (val) => toTypeString(val) === "[object Map]";
const isSet$2 = (val) => toTypeString(val) === "[object Set]";
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s = str ? `on${capitalize$1(str)}` : ``;
  return s;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber$1 = (val) => {
  const n = isString$1(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$1(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value) || isObject$1(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray$1(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$1(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap$2(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet$2(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol$1(val)) {
    return stringifySymbol(val);
  } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return isSymbol$1(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v;
};
/**
* @vue/reactivity v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last2 = this.parent.scopes.pop();
        if (last2 && last2 !== this) {
          this.parent.scopes[this.index] = last2;
          last2.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
let activeEffect;
class ReactiveEffect {
  constructor(fn, trigger2, scheduler2, scope) {
    this.fn = fn;
    this.trigger = trigger2;
    this.scheduler = scheduler2;
    this.active = true;
    this.deps = [];
    this._dirtyLevel = 4;
    this._trackId = 0;
    this._runnings = 0;
    this._shouldSchedule = false;
    this._depsLength = 0;
    recordEffectScope(this, scope);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (let i = 0; i < this._depsLength; i++) {
        const dep = this.deps[i];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(v) {
    this._dirtyLevel = v ? 4 : 0;
  }
  run() {
    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    let lastShouldTrack = shouldTrack;
    let lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  }
  stop() {
    var _a;
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      (_a = this.onStop) == null ? void 0 : _a.call(this);
      this.active = false;
    }
  }
}
function triggerComputed(computed2) {
  return computed2.value;
}
function preCleanupEffect(effect2) {
  effect2._trackId++;
  effect2._depsLength = 0;
}
function postCleanupEffect(effect2) {
  if (effect2.deps.length > effect2._depsLength) {
    for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
      cleanupDepEffect(effect2.deps[i], effect2);
    }
    effect2.deps.length = effect2._depsLength;
  }
}
function cleanupDepEffect(dep, effect2) {
  const trackId = dep.get(effect2);
  if (trackId !== void 0 && effect2._trackId !== trackId) {
    dep.delete(effect2);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function pauseScheduling() {
  pauseScheduleStack++;
}
function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
  if (dep.get(effect2) !== effect2._trackId) {
    dep.set(effect2, effect2._trackId);
    const oldDep = effect2.deps[effect2._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect2);
      }
      effect2.deps[effect2._depsLength++] = dep;
    } else {
      effect2._depsLength++;
    }
  }
}
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  pauseScheduling();
  for (const effect2 of dep.keys()) {
    let tracking;
    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
      effect2._dirtyLevel = dirtyLevel;
    }
    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2.trigger();
      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
        effect2._shouldSchedule = false;
        if (effect2.scheduler) {
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
  }
  resetScheduling();
}
const createDep = (cleanup, computed2) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed2;
  return dep;
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
function track(target, type4, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
    }
    trackEffect(
      activeEffect,
      dep
    );
  }
}
function trigger$1(target, type4, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type4 === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$1(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol$1(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type4) {
      case "add":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$2(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$2(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap$2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
        dep,
        4
      );
    }
  }
  resetScheduling();
}
function getDepFromReactive(object4, key) {
  var _a;
  return (_a = targetMap.get(object4)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$p(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$1(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$p;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$1(res)) {
      return isReadonly2 ? readonly$1(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result2 = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger$1(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger$1(target, "set", key, value);
      }
    }
    return result2;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result2 = Reflect.deleteProperty(target, key);
    if (result2 && hadKey) {
      trigger$1(target, "delete", key, void 0);
    }
    return result2;
  }
  has(target, key) {
    const result2 = Reflect.has(target, key);
    if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result2;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$1(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap2(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap2(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size$2(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add$2(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger$1(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger$1(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger$1(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result2 = target.delete(key);
  if (hadKey) {
    trigger$1(target, "delete", key, void 0);
  }
  return result2;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result2 = target.clear();
  if (hadItems) {
    trigger$1(target, "clear", void 0, void 0);
  }
  return result2;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach2(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap2(value), wrap2(key), observed);
    });
  };
}
function createIterableMethod(method4, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap$2(rawTarget);
    const isPair = method4 === "entries" || method4 === Symbol.iterator && targetIsMap;
    const isKeyOnly = method4 === "keys" && targetIsMap;
    const innerIterator = target[method4](...args);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type4) {
  return function(...args) {
    return type4 === "delete" ? false : type4 === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size$2(this);
    },
    has: has$1,
    add: add$2,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size$2(this);
    },
    has: has$1,
    add: add$2,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size$2(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size$2(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method4) => {
    mutableInstrumentations2[method4] = createIterableMethod(
      method4,
      false,
      false
    );
    readonlyInstrumentations2[method4] = createIterableMethod(
      method4,
      true,
      false
    );
    shallowInstrumentations2[method4] = createIterableMethod(
      method4,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method4] = createIterableMethod(
      method4,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly$1(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$1(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$1(value) ? readonly$1(value) : value;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this.getter = getter;
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this.effect = new ReactiveEffect(
      () => getter(this._value),
      () => triggerRefValue(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    );
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
      triggerRefValue(self2, 4);
    }
    trackRefValue(self2);
    if (self2.effect._dirtyLevel >= 2) {
      triggerRefValue(self2, 2);
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(v) {
    this.effect.dirty = v;
  }
  // #endregion
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function trackRefValue(ref2) {
  var _a;
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    trackEffect(
      activeEffect,
      (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
        () => ref2.dep = void 0,
        ref2 instanceof ComputedRefImpl ? ref2 : void 0
      )
    );
  }
}
function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    triggerEffects(
      dep,
      dirtyLevel
    );
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, 4);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction$1(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$1(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
/**
* @vue/runtime-core v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack$1 = [];
function warn$1$1(msg2, ...args) {
  pauseTracking();
  const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        msg2 + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg2}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack$1[stack$1.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last2 = normalizedStack[0];
    if (last2 && last2.vnode === currentVNode) {
      last2.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys2 = Object.keys(props);
  keys2.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys2.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$1(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$1(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type4, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type4);
  }
}
function callWithAsyncErrorHandling(fn, instance, type4, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type4, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type4);
      });
    }
    return res;
  }
  const values2 = [];
  for (let i = 0; i < fn.length; i++) {
    values2.push(callWithAsyncErrorHandling(fn[i], instance, type4, args));
  }
  return values2;
}
function handleError(err, instance, type4, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type4}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type4, contextVNode, throwInDev);
}
function logError(err, type4, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.pre) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$1(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number4, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
    }
    if (number4) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$1(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$1(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx2 = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx2)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx2);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render22,
    renderCache,
    data,
    setupState,
    ctx: ctx2,
    inheritAttrs
  } = instance;
  let result2;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result2 = normalizeVNode(
        render22.call(
          thisProxy,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx2
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render23 = Component;
      if (false)
        ;
      result2 = normalizeVNode(
        render23.length > 1 ? render23(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render23(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result2 = createVNode(Comment);
  }
  let root2 = result2;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root2 = cloneVNode(root2);
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root2.transition = vnode.transition;
  }
  {
    result2 = root2;
  }
  setCurrentRenderingInstance(prev);
  return result2;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent: parent2 }, el) {
  while (parent2) {
    const root2 = parent2.subTree;
    if (root2.suspense && root2.suspense.activeBranch === vnode) {
      root2.el = vnode.el;
    }
    if (root2 === vnode) {
      (vnode = parent2.vnode).el = el;
      parent2 = parent2.parent;
    } else {
      break;
    }
  }
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
const isSuspense = (type4) => type4.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$1(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const ssrContextKey$1 = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx2 = inject(ssrContextKey$1);
    return ctx2;
  }
};
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  once: once2,
  onTrack,
  onTrigger
} = EMPTY_OBJ) {
  if (cb && once2) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      unwatch();
    };
  }
  const instance = currentInstance;
  const reactiveGetter = (source2) => deep === true ? source2 : (
    // for deep: false, only traverse root-level properties
    traverse(source2, deep === false ? 1 : void 0)
  );
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$1(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
      cleanup = effect2.onStop = void 0;
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx2 = useSSRContext();
      ssrCleanup = ctx2.__watcherHandles || (ctx2.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active || !effect2.dirty) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler2;
  if (flush === "sync") {
    scheduler2 = job;
  } else if (flush === "post") {
    scheduler2 = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler2 = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, NOOP, scheduler2);
  const scope = getCurrentScope();
  const unwatch = () => {
    effect2.stop();
    if (scope) {
      remove$1(scope.effects, effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx2, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx2;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, depth, currentDepth = 0, seen) {
  if (!isObject$1(value) || value["__v_skip"]) {
    return value;
  }
  if (depth && depth > 0) {
    if (currentDepth >= depth) {
      return value;
    }
    currentDepth++;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, depth, currentDepth, seen);
  } else if (isArray$1(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, currentDepth, seen);
    }
  } else if (isSet$2(value) || isMap$2(value)) {
    value.forEach((v) => {
      traverse(v, depth, currentDepth, seen);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], depth, currentDepth, seen);
    }
  }
  return value;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.effect.dirty = true;
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$1(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? (
    // #7121 ensure get the child component subtree in case
    // it's been replaced during HMR
    vnode.children ? vnode.children[0] : void 0
  ) : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$1(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type4, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type4, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type4, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type4, target, keepAliveRoot) {
  const injected = injectHook(
    type4,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove$1(keepAliveRoot[type4], injected);
  }, target);
}
function injectHook(type4, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type4] || (target[type4] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type4, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function renderList(source, renderItem, cache2, index) {
  let ret;
  const cached = cache2 && cache2[index];
  if (isArray$1(source) || isString$1(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$1(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i = 0, l = keys2.length; i < l; i++) {
        const key = keys2[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index] = ret;
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode$1(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode$1(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode$1(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      i.effect.dirty = true;
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx: ctx2, setupState, data, props, accessCache, type: type4, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx2[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
        accessCache[key] = 4;
        return ctx2[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type4.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
      accessCache[key] = 4;
      return ctx2[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx: ctx2 } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx2[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx: ctx2, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx2, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$1(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx2 = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render22,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx2, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx2[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$1(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx2, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v) => c2.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx2, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register2, hook) {
    if (isArray$1(hook)) {
      hook.forEach((_hook) => register2(_hook.bind(publicThis)));
    } else if (hook) {
      register2(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$1(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render22 && instance.render === NOOP) {
    instance.render = render22;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx2, checkDuplicateProperties = NOOP) {
  if (isArray$1(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$1(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx2, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx2[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type4) {
  callWithAsyncErrorHandling(
    isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type4
  );
}
function createWatcher(raw, ctx2, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$1(raw)) {
    const handler = ctx2[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$1(raw)) {
    if (isArray$1(raw)) {
      raw.forEach((r) => createWatcher(r, ctx2, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx2[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base2 = instance.type;
  const { mixins, extends: extendsOptions } = base2;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base2);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base2;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base2, optionMergeStrategies);
  }
  if (isObject$1(base2)) {
    cache2.set(base2, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$1(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$1(to) && isArray$1(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render22, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$1(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    let isMounted2 = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin2, ...options) {
        if (installedPlugins.has(plugin2))
          ;
        else if (plugin2 && isFunction$1(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app, ...options);
        } else if (isFunction$1(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin2) {
        {
          if (!context.mixins.includes(mixin2)) {
            context.mixins.push(mixin2);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace2) {
        if (!isMounted2) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace2 === true) {
            namespace2 = "svg";
          } else if (namespace2 === false) {
            namespace2 = void 0;
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render22(vnode, rootContainer, namespace2);
          }
          isMounted2 = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted2) {
          render22(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger$1(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$1(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend$1({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$1(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type4, expectedTypes) {
  if (isArray$1(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type4));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type4) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx2) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx2);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx2 = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$1(value)) {
      slots[key] = normalizeSlot(key, value, ctx2);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type4 = children._;
    if (type4) {
      instance.slots = toRaw(children);
      def(children, "_", type4);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type4 = children._;
    if (type4) {
      if (optimized && type4 === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type4 === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$1(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref3) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString$1(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$1(existing) && remove$1(existing, refValue);
          } else {
            if (!isArray$1(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (hasOwn(setupState, ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (hasOwn(setupState, ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace2 = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount2(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type: type4, ref: ref3, shapeFlag } = n2;
    switch (type4) {
      case Text$2:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace2);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type4.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type4.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace2) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace2,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace2 = "svg";
    } else if (n2.type === "math") {
      namespace2 = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace2,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace2),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            namespace2,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace2);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace2),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace2),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace2
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace2);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace2);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                namespace2,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        namespace2
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace2, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace2) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace2,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            namespace2,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace2);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace2,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace2, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace2,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.effect.dirty = true;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace2, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent: parent2 } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent2, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace2
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent2 && isAsyncWrapper(parent2.vnode) && parent2.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent: parent2, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent2, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace2
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent2, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      NOOP,
      () => queueJob(update2),
      instance.scope
      // track it in component's effect scope
    );
    const update2 = instance.update = () => {
      if (effect2.dirty) {
        effect2.run();
      }
    };
    update2.id = instance.uid;
    toggleRecurse(instance, true);
    update2();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount2(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount2(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount2(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move2(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move2 = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type: type4, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move2(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type4.move(vnode, container, anchor, internals);
      return;
    }
    if (type4 === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move2(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type4 === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount2 = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type: type4,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type4 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type4 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type: type4, el, anchor, transition } = vnode;
    if (type4 === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type4 === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update: update2, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update2) {
      update2.active = false;
      unmount2(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount2(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  let isFlushing2 = false;
  const render22 = (vnode, container, namespace2) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount2(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace2
      );
    }
    if (!isFlushing2) {
      isFlushing2 = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing2 = false;
    }
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount2,
    m: move2,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render22,
    hydrate,
    createApp: createAppAPI(render22, hydrate)
  };
}
function resolveChildrenNamespace({ type: type4, props }, currentNamespace) {
  return currentNamespace === "svg" && type4 === "foreignObject" || currentNamespace === "mathml" && type4 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, update: update2 }, allowed) {
  effect2.allowRecurse = update2.allowRecurse = allowed;
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$1(ch1) && isArray$1(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text$2) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result2 = [0];
  let i, j, u, v, c2;
  const len2 = arr.length;
  for (i = 0; i < len2; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result2[result2.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result2.push(i);
        continue;
      }
      u = 0;
      v = result2.length - 1;
      while (u < v) {
        c2 = u + v >> 1;
        if (arr[result2[c2]] < arrI) {
          u = c2 + 1;
        } else {
          v = c2;
        }
      }
      if (arrI < arr[result2[u]]) {
        if (u > 0) {
          p2[i] = result2[u - 1];
        }
        result2[u] = i;
      }
    }
  }
  u = result2.length;
  v = result2[u - 1];
  while (u-- > 0) {
    result2[u] = v;
    v = p2[v];
  }
  return result2;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
const isTeleport = (type4) => type4.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$1(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        if (namespace2 === "svg" || isTargetSVG(target)) {
          namespace2 = "svg";
        } else if (namespace2 === "mathml" || isTargetMathML(target)) {
          namespace2 = "mathml";
        }
      }
      const mount2 = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      };
      if (disabled) {
        mount2(container, mainAnchor);
      } else if (target) {
        mount2(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace2 === "svg" || isTargetSVG(target)) {
        namespace2 = "svg";
      } else if (namespace2 === "mathml" || isTargetMathML(target)) {
        namespace2 = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount2, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount2(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move2 }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move2(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx2 = vnode.ctx;
  if (ctx2 && ctx2.ut) {
    let node = vnode.children[0].el;
    while (node && node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx2.uid);
      node = node.nextSibling;
    }
    ctx2.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text$2 = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type4, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type4,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type4, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type4,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type4, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type4 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type: type4,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type4.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type4, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type4 || type4 === NULL_DYNAMIC_COMPONENT) {
    type4 = Comment;
  }
  if (isVNode(type4)) {
    const cloned = cloneVNode(
      type4,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type4)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type4)) {
    type4 = type4.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$1(style2)) {
      if (isProxy(style2) && !isArray$1(style2)) {
        style2 = extend$1({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$1(type4) ? 1 : isSuspense(type4) ? 128 : isTeleport(type4) ? 64 : isObject$1(type4) ? 4 : isFunction$1(type4) ? 2 : 0;
  return createBaseVNode(
    type4,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref3, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text$2, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$1(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text$2, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type4 = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$1(children)) {
    type4 = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type4 = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type4 = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type4 = 16;
      children = [createTextVNode(children)];
    } else {
      type4 = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type4;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent2, suspense) {
  const type4 = vnode.type;
  const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type: type4,
    parent: parent2,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent2 ? parent2.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type4, appContext),
    emitsOptions: normalizeEmitsOptions(type4, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type4.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent2 ? parent2.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key]))
      setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1)
        setters.forEach((set2) => set2(v));
      else
        setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$1(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template2 = Component.template || resolveMergedOptions(instance).template;
      if (template2) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(
          extend$1(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template2, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match2 = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match2) {
      name = match2[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c2;
};
function h(type4, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type4, null, [propsOrChildren]);
      }
      return createVNode(type4, propsOrChildren);
    } else {
      return createVNode(type4, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type4, propsOrChildren, children);
  }
}
const version = "3.4.21";
/**
* @vue/runtime-dom v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent2, anchor) => {
    parent2.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent2 = child.parentNode;
    if (parent2) {
      parent2.removeChild(child);
    }
  },
  createElement: (tag2, namespace2, is, props) => {
    const el = namespace2 === "svg" ? doc.createElementNS(svgNS, tag2) : namespace2 === "mathml" ? doc.createElementNS(mathmlNS, tag2) : doc.createElement(tag2, is ? { is } : void 0);
    if (tag2 === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent2, anchor, namespace2, start, end) {
    const before2 = anchor ? anchor.previousSibling : parent2.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent2.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = namespace2 === "svg" ? `<svg>${content}</svg>` : namespace2 === "mathml" ? `<math>${content}</math>` : content;
      const template2 = templateContainer.content;
      if (namespace2 === "svg" || namespace2 === "mathml") {
        const wrapper = template2.firstChild;
        while (wrapper.firstChild) {
          template2.appendChild(wrapper.firstChild);
        }
        template2.removeChild(wrapper);
      }
      parent2.insertBefore(template2, anchor);
    }
    return [
      // first
      before2 ? before2.nextSibling : parent2.firstChild,
      // last
      anchor ? anchor.previousSibling : parent2.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray$1(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type: type4,
    duration: duration2,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration2);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type4, enterDuration, resolve);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type4, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration2) {
  if (duration2 == null) {
    return null;
  } else if (isObject$1(duration2)) {
    return [NumberOf(duration2.enter), NumberOf(duration2.leave)];
  } else {
    const n = NumberOf(duration2);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber$1(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type: type4, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type4) {
    return resolve();
  }
  const endEvent = type4 + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles2 = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles2[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type4 = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type4 = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type4 = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type4 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type4 ? type4 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type4 === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type: type4,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto")
    return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG2) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG2) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString$1(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$1(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style2, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style2, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style2, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style2[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style2.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style2.display : "";
    if (el[vShowHidden]) {
      style2.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray$1(val)) {
    val.forEach((v) => setStyle(style2, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG2, instance) {
  if (isSVG2 && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag2 = el.tagName;
  if (key === "value" && tag2 !== "PROGRESS" && // custom elements may use _value internally
  !tag2.includes("-")) {
    const oldValue = tag2 === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type4 = typeof el[key];
    if (type4 === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type4 === "string") {
      value = "";
      needRemove = true;
    } else if (type4 === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$1(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace2, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  const isSVG2 = namespace2 === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG2);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG2)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG2);
  }
};
function shouldSetAsProp(el, key, value, isSVG2) {
  if (isSVG2) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag2 = el.tagName;
    if (tag2 === "IMG" || tag2 === "VIDEO" || tag2 === "CANVAS" || tag2 === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$1(value)) {
    return false;
  }
  return key in el;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c2) => {
        const el = c2.el;
        const style2 = el.style;
        addTransitionClass(el, moveClass);
        style2.transform = style2.webkitTransform = style2.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag2 = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag2, null, children);
    };
  }
};
const removeMode = (props) => delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c2) {
  const el = c2.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c2) {
  newPositionMap.set(c2, c2.el.getBoundingClientRect());
}
function applyTranslation(c2) {
  const oldPos = positionMap.get(c2);
  const newPos = newPositionMap.get(c2);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c2.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c2;
  }
}
function hasCSSTransform(el, root2, moveClass) {
  const clone2 = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
    });
  }
  moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
  clone2.style.display = "none";
  const container = root2.nodeType === 1 ? root2 : root2.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount: mount2 } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount2(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var Symbol$1 = root.Symbol;
var objectProto$s = Object.prototype;
var hasOwnProperty$o = objectProto$s.hasOwnProperty;
var nativeObjectToString$3 = objectProto$s.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$o.call(value, symToStringTag$1), tag2 = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag2;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result2;
}
var objectProto$r = Object.prototype;
var nativeObjectToString$2 = objectProto$r.toString;
function objectToString(value) {
  return nativeObjectToString$2.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$3 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
}
var NAN$2 = 0 / 0;
function baseToNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN$2;
  }
  return +value;
}
function arrayMap(array4, iteratee2) {
  var index = -1, length = array4 == null ? 0 : array4.length, result2 = Array(length);
  while (++index < length) {
    result2[index] = iteratee2(array4[index], index, array4);
  }
  return result2;
}
var isArray = Array.isArray;
var INFINITY$5 = 1 / 0;
var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY$5 ? "-0" : result2;
}
function createMathOperation(operator, defaultValue) {
  return function(value, other) {
    var result2;
    if (value === void 0 && other === void 0) {
      return defaultValue;
    }
    if (value !== void 0) {
      result2 = value;
    }
    if (other !== void 0) {
      if (result2 === void 0) {
        return other;
      }
      if (typeof value == "string" || typeof other == "string") {
        value = baseToString(value);
        other = baseToString(other);
      } else {
        value = baseToNumber(value);
        other = baseToNumber(other);
      }
      result2 = operator(value, other);
    }
    return result2;
  };
}
var add = createMathOperation(function(augend, addend) {
  return augend + addend;
}, 0);
const add$1 = add;
var reWhitespace = /\s/;
function trimmedEndIndex(string3) {
  var index = string3.length;
  while (index-- && reWhitespace.test(string3.charAt(index))) {
  }
  return index;
}
var reTrimStart$2 = /^\s+/;
function baseTrim(string3) {
  return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart$2, "") : string3;
}
function isObject(value) {
  var type4 = typeof value;
  return value != null && (type4 == "object" || type4 == "function");
}
var NAN$1 = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN$1;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN$1 : +value;
}
var INFINITY$4 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$4 || value === -INFINITY$4) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
function toInteger(value) {
  var result2 = toFinite(value), remainder = result2 % 1;
  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
}
var FUNC_ERROR_TEXT$b = "Expected a function";
function after(n, func2) {
  if (typeof func2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$b);
  }
  n = toInteger(n);
  return function() {
    if (--n < 1) {
      return func2.apply(this, arguments);
    }
  };
}
function identity(value) {
  return value;
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag2 = baseGetTag(value);
  return tag2 == funcTag$2 || tag2 == genTag$1 || tag2 == asyncTag || tag2 == proxyTag;
}
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func2) {
  return !!maskSrcKey && maskSrcKey in func2;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func2) {
  if (func2 != null) {
    try {
      return funcToString$2.call(func2);
    } catch (e) {
    }
    try {
      return func2 + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$q = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$n = objectProto$q.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$n).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern4 = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource(value));
}
function getValue$1(object4, key) {
  return object4 == null ? void 0 : object4[key];
}
function getNative(object4, key) {
  var value = getValue$1(object4, key);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap$1 = getNative(root, "WeakMap");
var metaMap = WeakMap$1 && new WeakMap$1();
var baseSetData = !metaMap ? identity : function(func2, data) {
  metaMap.set(func2, data);
  return func2;
};
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object4() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object4.prototype = proto;
    var result2 = new object4();
    object4.prototype = void 0;
    return result2;
  };
}();
function createCtor(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
    return isObject(result2) ? result2 : thisBinding;
  };
}
var WRAP_BIND_FLAG$8 = 1;
function createBind(func2, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG$8, Ctor = createCtor(func2);
  function wrapper() {
    var fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
function apply(func2, thisArg, args) {
  switch (args.length) {
    case 0:
      return func2.call(thisArg);
    case 1:
      return func2.call(thisArg, args[0]);
    case 2:
      return func2.call(thisArg, args[0], args[1]);
    case 3:
      return func2.call(thisArg, args[0], args[1], args[2]);
  }
  return func2.apply(thisArg, args);
}
var nativeMax$g = Math.max;
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax$g(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result2[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result2[leftIndex++] = args[argsIndex++];
  }
  return result2;
}
var nativeMax$f = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax$f(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result2[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result2[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result2;
}
function countHolders(array4, placeholder) {
  var length = array4.length, result2 = 0;
  while (length--) {
    if (array4[length] === placeholder) {
      ++result2;
    }
  }
  return result2;
}
function baseLodash() {
}
var MAX_ARRAY_LENGTH$6 = 4294967295;
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH$6;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate(baseLodash.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
function noop() {
}
var getData = !metaMap ? noop : function(func2) {
  return metaMap.get(func2);
};
var realNames = {};
var objectProto$p = Object.prototype;
var hasOwnProperty$m = objectProto$p.hasOwnProperty;
function getFuncName(func2) {
  var result2 = func2.name + "", array4 = realNames[result2], length = hasOwnProperty$m.call(realNames, result2) ? array4.length : 0;
  while (length--) {
    var data = array4[length], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func2) {
      return data.name;
    }
  }
  return result2;
}
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate(baseLodash.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
function copyArray(source, array4) {
  var index = -1, length = source.length;
  array4 || (array4 = Array(length));
  while (++index < length) {
    array4[index] = source[index];
  }
  return array4;
}
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper) {
    return wrapper.clone();
  }
  var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
  result2.__actions__ = copyArray(wrapper.__actions__);
  result2.__index__ = wrapper.__index__;
  result2.__values__ = wrapper.__values__;
  return result2;
}
var objectProto$o = Object.prototype;
var hasOwnProperty$l = objectProto$o.hasOwnProperty;
function lodash(value) {
  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty$l.call(value, "__wrapped__")) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}
lodash.prototype = baseLodash.prototype;
lodash.prototype.constructor = lodash;
function isLaziable(func2) {
  var funcName = getFuncName(func2), other = lodash[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func2 === other) {
    return true;
  }
  var data = getData(other);
  return !!data && func2 === data[0];
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func2) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func2.apply(void 0, arguments);
  };
}
var setData = shortOut(baseSetData);
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
function getWrapDetails(source) {
  var match2 = source.match(reWrapDetails);
  return match2 ? match2[1].split(reSplitDetails) : [];
}
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
function constant(value) {
  return function() {
    return value;
  };
}
var defineProperty = function() {
  try {
    var func2 = getNative(Object, "defineProperty");
    func2({}, "", {});
    return func2;
  } catch (e) {
  }
}();
var baseSetToString = !defineProperty ? identity : function(func2, string3) {
  return defineProperty(func2, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string3),
    "writable": true
  });
};
const baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
function arrayEach(array4, iteratee2) {
  var index = -1, length = array4 == null ? 0 : array4.length;
  while (++index < length) {
    if (iteratee2(array4[index], index, array4) === false) {
      break;
    }
  }
  return array4;
}
function baseFindIndex(array4, predicate, fromIndex, fromRight) {
  var length = array4.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length) {
    if (predicate(array4[index], index, array4)) {
      return index;
    }
  }
  return -1;
}
function baseIsNaN(value) {
  return value !== value;
}
function strictIndexOf(array4, value, fromIndex) {
  var index = fromIndex - 1, length = array4.length;
  while (++index < length) {
    if (array4[index] === value) {
      return index;
    }
  }
  return -1;
}
function baseIndexOf(array4, value, fromIndex) {
  return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
}
function arrayIncludes(array4, value) {
  var length = array4 == null ? 0 : array4.length;
  return !!length && baseIndexOf(array4, value, 0) > -1;
}
var WRAP_BIND_FLAG$7 = 1, WRAP_BIND_KEY_FLAG$6 = 2, WRAP_CURRY_FLAG$6 = 8, WRAP_CURRY_RIGHT_FLAG$3 = 16, WRAP_PARTIAL_FLAG$6 = 32, WRAP_PARTIAL_RIGHT_FLAG$3 = 64, WRAP_ARY_FLAG$4 = 128, WRAP_REARG_FLAG$3 = 256, WRAP_FLIP_FLAG$2 = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG$4],
  ["bind", WRAP_BIND_FLAG$7],
  ["bindKey", WRAP_BIND_KEY_FLAG$6],
  ["curry", WRAP_CURRY_FLAG$6],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG$3],
  ["flip", WRAP_FLIP_FLAG$2],
  ["partial", WRAP_PARTIAL_FLAG$6],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG$3],
  ["rearg", WRAP_REARG_FLAG$3]
];
function updateWrapDetails(details, bitmask) {
  arrayEach(wrapFlags, function(pair) {
    var value = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
function setWrapToString(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
}
var WRAP_BIND_FLAG$6 = 1, WRAP_BIND_KEY_FLAG$5 = 2, WRAP_CURRY_BOUND_FLAG$1 = 4, WRAP_CURRY_FLAG$5 = 8, WRAP_PARTIAL_FLAG$5 = 32, WRAP_PARTIAL_RIGHT_FLAG$2 = 64;
function createRecurry(func2, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG$5, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG$5 : WRAP_PARTIAL_RIGHT_FLAG$2;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$2 : WRAP_PARTIAL_FLAG$5);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
    bitmask &= ~(WRAP_BIND_FLAG$6 | WRAP_BIND_KEY_FLAG$5);
  }
  var newData = [
    func2,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary2,
    arity
  ];
  var result2 = wrapFunc.apply(void 0, newData);
  if (isLaziable(func2)) {
    setData(result2, newData);
  }
  result2.placeholder = placeholder;
  return setWrapToString(result2, func2, bitmask);
}
function getHolder(func2) {
  var object4 = func2;
  return object4.placeholder;
}
var MAX_SAFE_INTEGER$6 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type4 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$6 : length;
  return !!length && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var nativeMin$e = Math.min;
function reorder(array4, indexes) {
  var arrLength = array4.length, length = nativeMin$e(indexes.length, arrLength), oldArray = copyArray(array4);
  while (length--) {
    var index = indexes[length];
    array4[length] = isIndex(index, arrLength) ? oldArray[index] : void 0;
  }
  return array4;
}
var PLACEHOLDER$1 = "__lodash_placeholder__";
function replaceHolders(array4, placeholder) {
  var index = -1, length = array4.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array4[index];
    if (value === placeholder || value === PLACEHOLDER$1) {
      array4[index] = PLACEHOLDER$1;
      result2[resIndex++] = index;
    }
  }
  return result2;
}
var WRAP_BIND_FLAG$5 = 1, WRAP_BIND_KEY_FLAG$4 = 2, WRAP_CURRY_FLAG$4 = 8, WRAP_CURRY_RIGHT_FLAG$2 = 16, WRAP_ARY_FLAG$3 = 128, WRAP_FLIP_FLAG$1 = 512;
function createHybrid(func2, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG$3, isBind = bitmask & WRAP_BIND_FLAG$5, isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4, isCurried = bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2), isFlip = bitmask & WRAP_FLIP_FLAG$1, Ctor = isBindKey ? void 0 : createCtor(func2);
  function wrapper() {
    var length = arguments.length, args = Array(length), index = length;
    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders(args, placeholder);
      return createRecurry(
        func2,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary2,
        arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func2] : func2;
    length = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary2 < length) {
      args.length = ary2;
    }
    if (this && this !== root && this instanceof wrapper) {
      fn = Ctor || createCtor(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
function createCurry(func2, bitmask, arity) {
  var Ctor = createCtor(func2);
  function wrapper() {
    var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
    while (index--) {
      args[index] = arguments[index];
    }
    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
    length -= holders.length;
    if (length < arity) {
      return createRecurry(
        func2,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length
      );
    }
    var fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
    return apply(fn, this, args);
  }
  return wrapper;
}
var WRAP_BIND_FLAG$4 = 1;
function createPartial(func2, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG$4, Ctor = createCtor(func2);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var PLACEHOLDER = "__lodash_placeholder__";
var WRAP_BIND_FLAG$3 = 1, WRAP_BIND_KEY_FLAG$3 = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG$3 = 8, WRAP_ARY_FLAG$2 = 128, WRAP_REARG_FLAG$2 = 256;
var nativeMin$d = Math.min;
function mergeData(data, source) {
  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG$3 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);
  var isCombo = srcBitmask == WRAP_ARY_FLAG$2 && bitmask == WRAP_CURRY_FLAG$3 || srcBitmask == WRAP_ARY_FLAG$2 && bitmask == WRAP_REARG_FLAG$2 && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG$3;
  if (!(isCommon || isCombo)) {
    return data;
  }
  if (srcBitmask & WRAP_BIND_FLAG$3) {
    data[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG$3 ? 0 : WRAP_CURRY_BOUND_FLAG;
  }
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
  }
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
  }
  value = source[7];
  if (value) {
    data[7] = value;
  }
  if (srcBitmask & WRAP_ARY_FLAG$2) {
    data[8] = data[8] == null ? source[8] : nativeMin$d(data[8], source[8]);
  }
  if (data[9] == null) {
    data[9] = source[9];
  }
  data[0] = source[0];
  data[1] = newBitmask;
  return data;
}
var FUNC_ERROR_TEXT$a = "Expected a function";
var WRAP_BIND_FLAG$2 = 1, WRAP_BIND_KEY_FLAG$2 = 2, WRAP_CURRY_FLAG$2 = 8, WRAP_CURRY_RIGHT_FLAG$1 = 16, WRAP_PARTIAL_FLAG$4 = 32, WRAP_PARTIAL_RIGHT_FLAG$1 = 64;
var nativeMax$e = Math.max;
function createWrap(func2, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2;
  if (!isBindKey && typeof func2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$a);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG$4 | WRAP_PARTIAL_RIGHT_FLAG$1);
    partials = holders = void 0;
  }
  ary2 = ary2 === void 0 ? ary2 : nativeMax$e(toInteger(ary2), 0);
  arity = arity === void 0 ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$1) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data = isBindKey ? void 0 : getData(func2);
  var newData = [
    func2,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary2,
    arity
  ];
  if (data) {
    mergeData(newData, data);
  }
  func2 = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func2.length : nativeMax$e(newData[9] - length, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1)) {
    bitmask &= ~(WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG$2) {
    var result2 = createBind(func2, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG$2 || bitmask == WRAP_CURRY_RIGHT_FLAG$1) {
    result2 = createCurry(func2, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG$4 || bitmask == (WRAP_BIND_FLAG$2 | WRAP_PARTIAL_FLAG$4)) && !holders.length) {
    result2 = createPartial(func2, bitmask, thisArg, partials);
  } else {
    result2 = createHybrid.apply(void 0, newData);
  }
  var setter = data ? baseSetData : setData;
  return setWrapToString(setter(result2, newData), func2, bitmask);
}
var WRAP_ARY_FLAG$1 = 128;
function ary(func2, n, guard) {
  n = guard ? void 0 : n;
  n = func2 && n == null ? func2.length : n;
  return createWrap(func2, WRAP_ARY_FLAG$1, void 0, void 0, void 0, void 0, n);
}
function baseAssignValue(object4, key, value) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object4, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object4[key] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$n = Object.prototype;
var hasOwnProperty$k = objectProto$n.hasOwnProperty;
function assignValue(object4, key, value) {
  var objValue = object4[key];
  if (!(hasOwnProperty$k.call(object4, key) && eq(objValue, value)) || value === void 0 && !(key in object4)) {
    baseAssignValue(object4, key, value);
  }
}
function copyObject(source, props, object4, customizer) {
  var isNew = !object4;
  object4 || (object4 = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object4[key], source[key], key, object4, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object4, key, newValue);
    } else {
      assignValue(object4, key, newValue);
    }
  }
  return object4;
}
var nativeMax$d = Math.max;
function overRest(func2, start, transform2) {
  start = nativeMax$d(start === void 0 ? func2.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax$d(args.length - start, 0), array4 = Array(length);
    while (++index < length) {
      array4[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform2(array4);
    return apply(func2, this, otherArgs);
  };
}
function baseRest(func2, start) {
  return setToString(overRest(func2, start, identity), func2 + "");
}
var MAX_SAFE_INTEGER$5 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$5;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function isIterateeCall(value, index, object4) {
  if (!isObject(object4)) {
    return false;
  }
  var type4 = typeof index;
  if (type4 == "number" ? isArrayLike(object4) && isIndex(index, object4.length) : type4 == "string" && index in object4) {
    return eq(object4[index], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object4, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object4 = Object(object4);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object4, source, index, customizer);
      }
    }
    return object4;
  });
}
var objectProto$m = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$m;
  return value === proto;
}
function baseTimes(n, iteratee2) {
  var index = -1, result2 = Array(n);
  while (++index < n) {
    result2[index] = iteratee2(index);
  }
  return result2;
}
var argsTag$3 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}
var objectProto$l = Object.prototype;
var hasOwnProperty$j = objectProto$l.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$l.propertyIsEnumerable;
var isArguments = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$j.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
const isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
const isBuffer$1 = isBuffer;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$4 = "[object Boolean]", dateTag$4 = "[object Date]", errorTag$3 = "[object Error]", funcTag$1 = "[object Function]", mapTag$9 = "[object Map]", numberTag$4 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$4 = "[object RegExp]", setTag$9 = "[object Set]", stringTag$4 = "[object String]", weakMapTag$3 = "[object WeakMap]";
var arrayBufferTag$4 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$4] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$4] = typedArrayTags[errorTag$3] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$9] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$4] = typedArrayTags[setTag$9] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$3] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func2) {
  return function(value) {
    return func2(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
const isTypedArray$1 = isTypedArray;
var objectProto$k = Object.prototype;
var hasOwnProperty$i = objectProto$k.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String) : [], length = result2.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$i.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length)))) {
      result2.push(key);
    }
  }
  return result2;
}
function overArg(func2, transform2) {
  return function(arg) {
    return func2(transform2(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var objectProto$j = Object.prototype;
var hasOwnProperty$h = objectProto$j.hasOwnProperty;
function baseKeys(object4) {
  if (!isPrototype(object4)) {
    return nativeKeys(object4);
  }
  var result2 = [];
  for (var key in Object(object4)) {
    if (hasOwnProperty$h.call(object4, key) && key != "constructor") {
      result2.push(key);
    }
  }
  return result2;
}
function keys(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
}
var objectProto$i = Object.prototype;
var hasOwnProperty$g = objectProto$i.hasOwnProperty;
var assign = createAssigner(function(object4, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object4);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty$g.call(source, key)) {
      assignValue(object4, key, source[key]);
    }
  }
});
const assign$1 = assign;
function nativeKeysIn(object4) {
  var result2 = [];
  if (object4 != null) {
    for (var key in Object(object4)) {
      result2.push(key);
    }
  }
  return result2;
}
var objectProto$h = Object.prototype;
var hasOwnProperty$f = objectProto$h.hasOwnProperty;
function baseKeysIn(object4) {
  if (!isObject(object4)) {
    return nativeKeysIn(object4);
  }
  var isProto = isPrototype(object4), result2 = [];
  for (var key in object4) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$f.call(object4, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
function keysIn(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4, true) : baseKeysIn(object4);
}
var assignIn = createAssigner(function(object4, source) {
  copyObject(source, keysIn(source), object4);
});
const extend = assignIn;
var assignInWith = createAssigner(function(object4, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object4, customizer);
});
const extendWith = assignInWith;
var assignWith = createAssigner(function(object4, source, srcIndex, customizer) {
  copyObject(source, keys(source), object4, customizer);
});
const assignWith$1 = assignWith;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object4) {
  if (isArray(value)) {
    return false;
  }
  var type4 = typeof value;
  if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object(object4);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$g = Object.prototype;
var hasOwnProperty$e = objectProto$g.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result2 = data[key];
    return result2 === HASH_UNDEFINED$2 ? void 0 : result2;
  }
  return hasOwnProperty$e.call(data, key) ? data[key] : void 0;
}
var objectProto$f = Object.prototype;
var hasOwnProperty$d = objectProto$f.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty$d.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array4, key) {
  var length = array4.length;
  while (length--) {
    if (eq(array4[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto$5 = Array.prototype;
var splice$2 = arrayProto$5.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$2.call(data, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type4 = typeof value;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result2 = getMapData(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$9 = "Expected a function";
function memoize(func2, resolver) {
  if (typeof func2 != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$9);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result2 = func2.apply(this, args);
    memoized.cache = cache2.set(key, result2) || cache2;
    return result2;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func2) {
  var result2 = memoize(func2, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result2.cache;
  return result2;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string3) {
  var result2 = [];
  if (string3.charCodeAt(0) === 46) {
    result2.push("");
  }
  string3.replace(rePropName, function(match2, number4, quote, subString) {
    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match2);
  });
  return result2;
});
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object4) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object4) ? [value] : stringToPath(toString(value));
}
var INFINITY$3 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY$3 ? "-0" : result2;
}
function baseGet(object4, path) {
  path = castPath(path, object4);
  var index = 0, length = path.length;
  while (object4 != null && index < length) {
    object4 = object4[toKey(path[index++])];
  }
  return index && index == length ? object4 : void 0;
}
function get(object4, path, defaultValue) {
  var result2 = object4 == null ? void 0 : baseGet(object4, path);
  return result2 === void 0 ? defaultValue : result2;
}
function baseAt(object4, paths) {
  var index = -1, length = paths.length, result2 = Array(length), skip = object4 == null;
  while (++index < length) {
    result2[index] = skip ? void 0 : get(object4, paths[index]);
  }
  return result2;
}
function arrayPush(array4, values2) {
  var index = -1, length = values2.length, offset = array4.length;
  while (++index < length) {
    array4[offset + index] = values2[index];
  }
  return array4;
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array4, depth, predicate, isStrict, result2) {
  var index = -1, length = array4.length;
  predicate || (predicate = isFlattenable);
  result2 || (result2 = []);
  while (++index < length) {
    var value = array4[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result2);
      } else {
        arrayPush(result2, value);
      }
    } else if (!isStrict) {
      result2[result2.length] = value;
    }
  }
  return result2;
}
function flatten$3(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseFlatten(array4, 1) : [];
}
function flatRest(func2) {
  return setToString(overRest(func2, void 0, flatten$3), func2 + "");
}
var at$1 = flatRest(baseAt);
const at$2 = at$1;
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype, objectProto$e = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$c = objectProto$e.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$c.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var domExcTag = "[object DOMException]", errorTag$2 = "[object Error]";
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  var tag2 = baseGetTag(value);
  return tag2 == errorTag$2 || tag2 == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
}
var attempt = baseRest(function(func2, args) {
  try {
    return apply(func2, void 0, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});
const attempt$1 = attempt;
var FUNC_ERROR_TEXT$8 = "Expected a function";
function before(n, func2) {
  var result2;
  if (typeof func2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$8);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result2 = func2.apply(this, arguments);
    }
    if (n <= 1) {
      func2 = void 0;
    }
    return result2;
  };
}
var WRAP_BIND_FLAG$1 = 1, WRAP_PARTIAL_FLAG$3 = 32;
var bind = baseRest(function(func2, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG$1;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bind));
    bitmask |= WRAP_PARTIAL_FLAG$3;
  }
  return createWrap(func2, bitmask, thisArg, partials, holders);
});
bind.placeholder = {};
const bind$1 = bind;
var bindAll = flatRest(function(object4, methodNames) {
  arrayEach(methodNames, function(key) {
    key = toKey(key);
    baseAssignValue(object4, key, bind$1(object4[key], object4));
  });
  return object4;
});
const bindAll$1 = bindAll;
var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG$1 = 2, WRAP_PARTIAL_FLAG$2 = 32;
var bindKey = baseRest(function(object4, key, partials) {
  var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG$1;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bindKey));
    bitmask |= WRAP_PARTIAL_FLAG$2;
  }
  return createWrap(key, bitmask, object4, partials, holders);
});
bindKey.placeholder = {};
const bindKey$1 = bindKey;
function baseSlice(array4, start, end) {
  var index = -1, length = array4.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result2 = Array(length);
  while (++index < length) {
    result2[index] = array4[index + start];
  }
  return result2;
}
function castSlice(array4, start, end) {
  var length = array4.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array4 : baseSlice(array4, start, end);
}
var rsAstralRange$3 = "\\ud800-\\udfff", rsComboMarksRange$4 = "\\u0300-\\u036f", reComboHalfMarksRange$4 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$4 = "\\u20d0-\\u20ff", rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4, rsVarRange$3 = "\\ufe0e\\ufe0f";
var rsZWJ$3 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$3 + rsAstralRange$3 + rsComboRange$4 + rsVarRange$3 + "]");
function hasUnicode(string3) {
  return reHasUnicode.test(string3);
}
function asciiToArray(string3) {
  return string3.split("");
}
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsAstral$1 = "[" + rsAstralRange$2 + "]", rsCombo$3 = "[" + rsComboRange$3 + "]", rsFitz$2 = "\\ud83c[\\udffb-\\udfff]", rsModifier$2 = "(?:" + rsCombo$3 + "|" + rsFitz$2 + ")", rsNonAstral$2 = "[^" + rsAstralRange$2 + "]", rsRegional$2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$2 = "\\u200d";
var reOptMod$2 = rsModifier$2 + "?", rsOptVar$2 = "[" + rsVarRange$2 + "]?", rsOptJoin$2 = "(?:" + rsZWJ$2 + "(?:" + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join("|") + ")" + rsOptVar$2 + reOptMod$2 + ")*", rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2, rsSymbol$1 = "(?:" + [rsNonAstral$2 + rsCombo$3 + "?", rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join("|") + ")";
var reUnicode$1 = RegExp(rsFitz$2 + "(?=" + rsFitz$2 + ")|" + rsSymbol$1 + rsSeq$2, "g");
function unicodeToArray(string3) {
  return string3.match(reUnicode$1) || [];
}
function stringToArray$1(string3) {
  return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
}
function createCaseFirst(methodName) {
  return function(string3) {
    string3 = toString(string3);
    var strSymbols = hasUnicode(string3) ? stringToArray$1(string3) : void 0;
    var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
    return chr[methodName]() + trailing;
  };
}
var upperFirst = createCaseFirst("toUpperCase");
function capitalize(string3) {
  return upperFirst(toString(string3).toLowerCase());
}
function arrayReduce(array4, iteratee2, accumulator, initAccum) {
  var index = -1, length = array4 == null ? 0 : array4.length;
  if (initAccum && length) {
    accumulator = array4[++index];
  }
  while (++index < length) {
    accumulator = iteratee2(accumulator, array4[index], index, array4);
  }
  return accumulator;
}
function basePropertyOf(object4) {
  return function(key) {
    return object4 == null ? void 0 : object4[key];
  };
}
var deburredLetters = {
  // Latin-1 Supplement block.
  "À": "A",
  "Á": "A",
  "Â": "A",
  "Ã": "A",
  "Ä": "A",
  "Å": "A",
  "à": "a",
  "á": "a",
  "â": "a",
  "ã": "a",
  "ä": "a",
  "å": "a",
  "Ç": "C",
  "ç": "c",
  "Ð": "D",
  "ð": "d",
  "È": "E",
  "É": "E",
  "Ê": "E",
  "Ë": "E",
  "è": "e",
  "é": "e",
  "ê": "e",
  "ë": "e",
  "Ì": "I",
  "Í": "I",
  "Î": "I",
  "Ï": "I",
  "ì": "i",
  "í": "i",
  "î": "i",
  "ï": "i",
  "Ñ": "N",
  "ñ": "n",
  "Ò": "O",
  "Ó": "O",
  "Ô": "O",
  "Õ": "O",
  "Ö": "O",
  "Ø": "O",
  "ò": "o",
  "ó": "o",
  "ô": "o",
  "õ": "o",
  "ö": "o",
  "ø": "o",
  "Ù": "U",
  "Ú": "U",
  "Û": "U",
  "Ü": "U",
  "ù": "u",
  "ú": "u",
  "û": "u",
  "ü": "u",
  "Ý": "Y",
  "ý": "y",
  "ÿ": "y",
  "Æ": "Ae",
  "æ": "ae",
  "Þ": "Th",
  "þ": "th",
  "ß": "ss",
  // Latin Extended-A block.
  "Ā": "A",
  "Ă": "A",
  "Ą": "A",
  "ā": "a",
  "ă": "a",
  "ą": "a",
  "Ć": "C",
  "Ĉ": "C",
  "Ċ": "C",
  "Č": "C",
  "ć": "c",
  "ĉ": "c",
  "ċ": "c",
  "č": "c",
  "Ď": "D",
  "Đ": "D",
  "ď": "d",
  "đ": "d",
  "Ē": "E",
  "Ĕ": "E",
  "Ė": "E",
  "Ę": "E",
  "Ě": "E",
  "ē": "e",
  "ĕ": "e",
  "ė": "e",
  "ę": "e",
  "ě": "e",
  "Ĝ": "G",
  "Ğ": "G",
  "Ġ": "G",
  "Ģ": "G",
  "ĝ": "g",
  "ğ": "g",
  "ġ": "g",
  "ģ": "g",
  "Ĥ": "H",
  "Ħ": "H",
  "ĥ": "h",
  "ħ": "h",
  "Ĩ": "I",
  "Ī": "I",
  "Ĭ": "I",
  "Į": "I",
  "İ": "I",
  "ĩ": "i",
  "ī": "i",
  "ĭ": "i",
  "į": "i",
  "ı": "i",
  "Ĵ": "J",
  "ĵ": "j",
  "Ķ": "K",
  "ķ": "k",
  "ĸ": "k",
  "Ĺ": "L",
  "Ļ": "L",
  "Ľ": "L",
  "Ŀ": "L",
  "Ł": "L",
  "ĺ": "l",
  "ļ": "l",
  "ľ": "l",
  "ŀ": "l",
  "ł": "l",
  "Ń": "N",
  "Ņ": "N",
  "Ň": "N",
  "Ŋ": "N",
  "ń": "n",
  "ņ": "n",
  "ň": "n",
  "ŋ": "n",
  "Ō": "O",
  "Ŏ": "O",
  "Ő": "O",
  "ō": "o",
  "ŏ": "o",
  "ő": "o",
  "Ŕ": "R",
  "Ŗ": "R",
  "Ř": "R",
  "ŕ": "r",
  "ŗ": "r",
  "ř": "r",
  "Ś": "S",
  "Ŝ": "S",
  "Ş": "S",
  "Š": "S",
  "ś": "s",
  "ŝ": "s",
  "ş": "s",
  "š": "s",
  "Ţ": "T",
  "Ť": "T",
  "Ŧ": "T",
  "ţ": "t",
  "ť": "t",
  "ŧ": "t",
  "Ũ": "U",
  "Ū": "U",
  "Ŭ": "U",
  "Ů": "U",
  "Ű": "U",
  "Ų": "U",
  "ũ": "u",
  "ū": "u",
  "ŭ": "u",
  "ů": "u",
  "ű": "u",
  "ų": "u",
  "Ŵ": "W",
  "ŵ": "w",
  "Ŷ": "Y",
  "ŷ": "y",
  "Ÿ": "Y",
  "Ź": "Z",
  "Ż": "Z",
  "Ž": "Z",
  "ź": "z",
  "ż": "z",
  "ž": "z",
  "Ĳ": "IJ",
  "ĳ": "ij",
  "Œ": "Oe",
  "œ": "oe",
  "ŉ": "'n",
  "ſ": "s"
};
var deburrLetter = basePropertyOf(deburredLetters);
const deburrLetter$1 = deburrLetter;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
var rsCombo$2 = "[" + rsComboRange$2 + "]";
var reComboMark = RegExp(rsCombo$2, "g");
function deburr(string3) {
  string3 = toString(string3);
  return string3 && string3.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
}
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string3) {
  return string3.match(reAsciiWord) || [];
}
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string3) {
  return reHasUnicodeWord.test(string3);
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange$1 = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo$1 = "[" + rsComboRange$1 + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange$1 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ$1 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsEmoji = "(?:" + [rsDingbat, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsSeq$1;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string3) {
  return string3.match(reUnicodeWord) || [];
}
function words(string3, pattern4, guard) {
  string3 = toString(string3);
  pattern4 = guard ? void 0 : pattern4;
  if (pattern4 === void 0) {
    return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
  }
  return string3.match(pattern4) || [];
}
var rsApos = "['’]";
var reApos = RegExp(rsApos, "g");
function createCompounder(callback) {
  return function(string3) {
    return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
  };
}
var camelCase = createCompounder(function(result2, word, index) {
  word = word.toLowerCase();
  return result2 + (index ? capitalize(word) : word);
});
const camelCase$1 = camelCase;
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray(value) ? value : [value];
}
var nativeIsFinite$1 = root.isFinite, nativeMin$c = Math.min;
function createRound(methodName) {
  var func2 = Math[methodName];
  return function(number4, precision) {
    number4 = toNumber(number4);
    precision = precision == null ? 0 : nativeMin$c(toInteger(precision), 292);
    if (precision && nativeIsFinite$1(number4)) {
      var pair = (toString(number4) + "e").split("e"), value = func2(pair[0] + "e" + (+pair[1] + precision));
      pair = (toString(value) + "e").split("e");
      return +(pair[0] + "e" + (+pair[1] - precision));
    }
    return func2(number4);
  };
}
var ceil = createRound("ceil");
const ceil$1 = ceil;
function chain(value) {
  var result2 = lodash(value);
  result2.__chain__ = true;
  return result2;
}
var nativeCeil$3 = Math.ceil, nativeMax$c = Math.max;
function chunk(array4, size2, guard) {
  if (guard ? isIterateeCall(array4, size2, guard) : size2 === void 0) {
    size2 = 1;
  } else {
    size2 = nativeMax$c(toInteger(size2), 0);
  }
  var length = array4 == null ? 0 : array4.length;
  if (!length || size2 < 1) {
    return [];
  }
  var index = 0, resIndex = 0, result2 = Array(nativeCeil$3(length / size2));
  while (index < length) {
    result2[resIndex++] = baseSlice(array4, index, index += size2);
  }
  return result2;
}
function baseClamp(number4, lower, upper) {
  if (number4 === number4) {
    if (upper !== void 0) {
      number4 = number4 <= upper ? number4 : upper;
    }
    if (lower !== void 0) {
      number4 = number4 >= lower ? number4 : lower;
    }
  }
  return number4;
}
function clamp(number4, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number4), lower, upper);
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result2 = data["delete"](key);
  this.size = data.size;
  return result2;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE$2 = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(object4, source) {
  return object4 && copyObject(source, keys(source), object4);
}
function baseAssignIn(object4, source) {
  return object4 && copyObject(source, keysIn(source), object4);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result2);
  return result2;
}
function arrayFilter(array4, predicate) {
  var index = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array4[index];
    if (predicate(value, index, array4)) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
function stubArray() {
  return [];
}
var objectProto$d = Object.prototype;
var propertyIsEnumerable = objectProto$d.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter(nativeGetSymbols$1(object4), function(symbol) {
    return propertyIsEnumerable.call(object4, symbol);
  });
};
function copySymbols(source, object4) {
  return copyObject(source, getSymbols(source), object4);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object4) {
  var result2 = [];
  while (object4) {
    arrayPush(result2, getSymbols(object4));
    object4 = getPrototype(object4);
  }
  return result2;
};
function copySymbolsIn(source, object4) {
  return copyObject(source, getSymbolsIn(source), object4);
}
function baseGetAllKeys(object4, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object4);
  return isArray(object4) ? result2 : arrayPush(result2, symbolsFunc(object4));
}
function getAllKeys(object4) {
  return baseGetAllKeys(object4, keys, getSymbols);
}
function getAllKeysIn(object4) {
  return baseGetAllKeys(object4, keysIn, getSymbolsIn);
}
var DataView = getNative(root, "DataView");
var Promise$1 = getNative(root, "Promise");
var Set$1 = getNative(root, "Set");
var mapTag$8 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$8 = "[object Set]", weakMapTag$2 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$8 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$8 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$2) {
  getTag = function(value) {
    var result2 = baseGetTag(value), Ctor = result2 == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$8;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$8;
        case weakMapCtorString:
          return weakMapTag$2;
      }
    }
    return result2;
  };
}
const getTag$1 = getTag;
var objectProto$c = Object.prototype;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
function initCloneArray(array4) {
  var length = array4.length, result2 = new array4.constructor(length);
  if (length && typeof array4[0] == "string" && hasOwnProperty$b.call(array4, "index")) {
    result2.index = array4.index;
    result2.input = array4.input;
  }
  return result2;
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result2).set(new Uint8Array$1(arrayBuffer));
  return result2;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags$1 = /\w*$/;
function cloneRegExp(regexp4) {
  var result2 = new regexp4.constructor(regexp4.source, reFlags$1.exec(regexp4));
  result2.lastIndex = regexp4.lastIndex;
  return result2;
}
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", mapTag$7 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$7 = "[object Set]", stringTag$3 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object4, tag2, isDeep) {
  var Ctor = object4.constructor;
  switch (tag2) {
    case arrayBufferTag$3:
      return cloneArrayBuffer(object4);
    case boolTag$3:
    case dateTag$3:
      return new Ctor(+object4);
    case dataViewTag$2:
      return cloneDataView(object4, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object4, isDeep);
    case mapTag$7:
      return new Ctor();
    case numberTag$3:
    case stringTag$3:
      return new Ctor(object4);
    case regexpTag$3:
      return cloneRegExp(object4);
    case setTag$7:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object4);
  }
}
function initCloneObject(object4) {
  return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate(getPrototype(object4)) : {};
}
var mapTag$6 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$6;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
const isMap$1 = isMap;
var setTag$6 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$6;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
const isSet$1 = isSet;
var CLONE_DEEP_FLAG$7 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$5 = 4;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$5 = "[object Map]", numberTag$2 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$2 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$5] = cloneableTags[numberTag$2] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$2] = cloneableTags[setTag$5] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag$1] = false;
function baseClone(value, bitmask, customizer, key, object4, stack2) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG$7, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$5;
  if (customizer) {
    result2 = object4 ? customizer(value, key, object4, stack2) : customizer(value);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result2 = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result2);
    }
  } else {
    var tag2 = getTag$1(value), isFunc = tag2 == funcTag || tag2 == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag2 == objectTag$1 || tag2 == argsTag$1 || isFunc && !object4) {
      result2 = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
      }
    } else {
      if (!cloneableTags[tag2]) {
        return object4 ? value : {};
      }
      result2 = initCloneByTag(value, tag2, isDeep);
    }
  }
  stack2 || (stack2 = new Stack());
  var stacked = stack2.get(value);
  if (stacked) {
    return stacked;
  }
  stack2.set(value, result2);
  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key2) {
      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
  });
  return result2;
}
var CLONE_SYMBOLS_FLAG$4 = 4;
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG$4);
}
var CLONE_DEEP_FLAG$6 = 1, CLONE_SYMBOLS_FLAG$3 = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG$6 | CLONE_SYMBOLS_FLAG$3);
}
var CLONE_DEEP_FLAG$5 = 1, CLONE_SYMBOLS_FLAG$2 = 4;
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone(value, CLONE_DEEP_FLAG$5 | CLONE_SYMBOLS_FLAG$2, customizer);
}
var CLONE_SYMBOLS_FLAG$1 = 4;
function cloneWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone(value, CLONE_SYMBOLS_FLAG$1, customizer);
}
function wrapperCommit() {
  return new LodashWrapper(this.value(), this.__chain__);
}
function compact(array4) {
  var index = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array4[index];
    if (value) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args = Array(length - 1), array4 = arguments[0], index = length;
  while (index--) {
    args[index - 1] = arguments[index];
  }
  return arrayPush(isArray(array4) ? copyArray(array4) : [array4], baseFlatten(args, 1));
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values2) {
  var index = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values2[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array4, predicate) {
  var index = -1, length = array4 == null ? 0 : array4.length;
  while (++index < length) {
    if (predicate(array4[index], index, array4)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array4, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array4);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack2.set(array4, other);
  stack2.set(other, array4);
  while (++index < arrLength) {
    var arrValue = array4[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array4, stack2) : customizer(arrValue, othValue, index, array4, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result2 = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen.push(othIndex);
        }
      })) {
        result2 = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result2 = false;
      break;
    }
  }
  stack2["delete"](array4);
  stack2["delete"](other);
  return result2;
}
function mapToArray(map2) {
  var index = -1, result2 = Array(map2.size);
  map2.forEach(function(value, key) {
    result2[++index] = [key, value];
  });
  return result2;
}
function setToArray(set2) {
  var index = -1, result2 = Array(set2.size);
  set2.forEach(function(value) {
    result2[++index] = value;
  });
  return result2;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag = "[object Error]", mapTag$4 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object4, other, tag2, bitmask, customizer, equalFunc, stack2) {
  switch (tag2) {
    case dataViewTag:
      if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
        return false;
      }
      object4 = object4.buffer;
      other = other.buffer;
    case arrayBufferTag$1:
      if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object4), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      return eq(+object4, +other);
    case errorTag:
      return object4.name == other.name && object4.message == other.message;
    case regexpTag$1:
    case stringTag$1:
      return object4 == other + "";
    case mapTag$4:
      var convert2 = mapToArray;
    case setTag$4:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert2 || (convert2 = setToArray);
      if (object4.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object4);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack2.set(object4, other);
      var result2 = equalArrays(convert2(object4), convert2(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object4);
      return result2;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object4) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function equalObjects(object4, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack2.get(object4);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object4;
  }
  var result2 = true;
  stack2.set(object4, other);
  stack2.set(other, object4);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object4[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object4, stack2) : customizer(objValue, othValue, key, object4, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result2 = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result2 && !skipCtor) {
    var objCtor = object4.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result2 = false;
    }
  }
  stack2["delete"](object4);
  stack2["delete"](other);
  return result2;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
function baseIsEqualDeep(object4, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray(object4), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag$1(object4), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object4)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new Stack());
    return objIsArr || isTypedArray$1(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$9.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$9.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new Stack());
  return equalObjects(object4, other, bitmask, customizer, equalFunc, stack2);
}
function baseIsEqual(value, other, bitmask, customizer, stack2) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object4, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object4 == null) {
    return !length;
  }
  object4 = Object(object4);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object4[data[0]] : !(data[0] in object4)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object4[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object4)) {
        return false;
      }
    } else {
      var stack2 = new Stack();
      if (customizer) {
        var result2 = customizer(objValue, srcValue, key, object4, source, stack2);
      }
      if (!(result2 === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result2)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject(value);
}
function getMatchData(object4) {
  var result2 = keys(object4), length = result2.length;
  while (length--) {
    var key = result2[length], value = object4[key];
    result2[length] = [key, value, isStrictComparable(value)];
  }
  return result2;
}
function matchesStrictComparable(key, srcValue) {
  return function(object4) {
    if (object4 == null) {
      return false;
    }
    return object4[key] === srcValue && (srcValue !== void 0 || key in Object(object4));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object4) {
    return object4 === source || baseIsMatch(object4, source, matchData);
  };
}
function baseHasIn(object4, key) {
  return object4 != null && key in Object(object4);
}
function hasPath(object4, path, hasFunc) {
  path = castPath(path, object4);
  var index = -1, length = path.length, result2 = false;
  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result2 = object4 != null && hasFunc(object4, key))) {
      break;
    }
    object4 = object4[key];
  }
  if (result2 || ++index != length) {
    return result2;
  }
  length = object4 == null ? 0 : object4.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object4) || isArguments$1(object4));
}
function hasIn(object4, path) {
  return object4 != null && hasPath(object4, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object4) {
    var objValue = get(object4, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object4, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object4) {
    return object4 == null ? void 0 : object4[key];
  };
}
function basePropertyDeep(path) {
  return function(object4) {
    return baseGet(object4, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var FUNC_ERROR_TEXT$7 = "Expected a function";
function cond(pairs) {
  var length = pairs == null ? 0 : pairs.length, toIteratee = baseIteratee;
  pairs = !length ? [] : arrayMap(pairs, function(pair) {
    if (typeof pair[1] != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$7);
    }
    return [toIteratee(pair[0]), pair[1]];
  });
  return baseRest(function(args) {
    var index = -1;
    while (++index < length) {
      var pair = pairs[index];
      if (apply(pair[0], this, args)) {
        return apply(pair[1], this, args);
      }
    }
  });
}
function baseConformsTo(object4, source, props) {
  var length = props.length;
  if (object4 == null) {
    return !length;
  }
  object4 = Object(object4);
  while (length--) {
    var key = props[length], predicate = source[key], value = object4[key];
    if (value === void 0 && !(key in object4) || !predicate(value)) {
      return false;
    }
  }
  return true;
}
function baseConforms(source) {
  var props = keys(source);
  return function(object4) {
    return baseConformsTo(object4, source, props);
  };
}
var CLONE_DEEP_FLAG$4 = 1;
function conforms(source) {
  return baseConforms(baseClone(source, CLONE_DEEP_FLAG$4));
}
function conformsTo(object4, source) {
  return source == null || baseConformsTo(object4, source, keys(source));
}
function arrayAggregator(array4, setter, iteratee2, accumulator) {
  var index = -1, length = array4 == null ? 0 : array4.length;
  while (++index < length) {
    var value = array4[index];
    setter(accumulator, value, iteratee2(value), array4);
  }
  return accumulator;
}
function createBaseFor(fromRight) {
  return function(object4, iteratee2, keysFunc) {
    var index = -1, iterable = Object(object4), props = keysFunc(object4), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee2(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object4;
  };
}
var baseFor = createBaseFor();
function baseForOwn(object4, iteratee2) {
  return object4 && baseFor(object4, iteratee2, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection2, iteratee2) {
    if (collection2 == null) {
      return collection2;
    }
    if (!isArrayLike(collection2)) {
      return eachFunc(collection2, iteratee2);
    }
    var length = collection2.length, index = fromRight ? length : -1, iterable = Object(collection2);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee2(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection2;
  };
}
var baseEach = createBaseEach(baseForOwn);
function baseAggregator(collection2, setter, iteratee2, accumulator) {
  baseEach(collection2, function(value, key, collection3) {
    setter(accumulator, value, iteratee2(value), collection3);
  });
  return accumulator;
}
function createAggregator(setter, initializer) {
  return function(collection2, iteratee2) {
    var func2 = isArray(collection2) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
    return func2(collection2, setter, baseIteratee(iteratee2), accumulator);
  };
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
var countBy = createAggregator(function(result2, value, key) {
  if (hasOwnProperty$8.call(result2, key)) {
    ++result2[key];
  } else {
    baseAssignValue(result2, key, 1);
  }
});
const countBy$1 = countBy;
function create(prototype, properties) {
  var result2 = baseCreate(prototype);
  return properties == null ? result2 : baseAssign(result2, properties);
}
var WRAP_CURRY_FLAG$1 = 8;
function curry(func2, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap(func2, WRAP_CURRY_FLAG$1, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curry.placeholder;
  return result2;
}
curry.placeholder = {};
var WRAP_CURRY_RIGHT_FLAG = 16;
function curryRight(func2, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap(func2, WRAP_CURRY_RIGHT_FLAG, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curryRight.placeholder;
  return result2;
}
curryRight.placeholder = {};
var now$1 = function() {
  return root.Date.now();
};
const now$2 = now$1;
var FUNC_ERROR_TEXT$6 = "Expected a function";
var nativeMax$b = Math.max, nativeMin$b = Math.min;
function debounce(func2, wait, options) {
  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$6);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$b(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result2 = func2.apply(thisArg, args);
    return result2;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result2;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin$b(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now$2();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result2;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result2 : trailingEdge(now$2());
  }
  function debounced() {
    var time2 = now$2(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result2;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function defaultTo(value, defaultValue) {
  return value == null || value !== value ? defaultValue : value;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var defaults = baseRest(function(object4, sources) {
  object4 = Object(object4);
  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }
  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object4[key];
      if (value === void 0 || eq(value, objectProto$8[key]) && !hasOwnProperty$7.call(object4, key)) {
        object4[key] = source[key];
      }
    }
  }
  return object4;
});
const defaults$1 = defaults;
function assignMergeValue(object4, key, value) {
  if (value !== void 0 && !eq(object4[key], value) || value === void 0 && !(key in object4)) {
    baseAssignValue(object4, key, value);
  }
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function safeGet(object4, key) {
  if (key === "constructor" && typeof object4[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object4[key];
}
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function baseMergeDeep(object4, source, key, srcIndex, mergeFunc, customizer, stack2) {
  var objValue = safeGet(object4, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
  if (stacked) {
    assignMergeValue(object4, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object4, source, stack2) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack2.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
    stack2["delete"](srcValue);
  }
  assignMergeValue(object4, key, newValue);
}
function baseMerge(object4, source, srcIndex, customizer, stack2) {
  if (object4 === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack2 || (stack2 = new Stack());
    if (isObject(srcValue)) {
      baseMergeDeep(object4, source, key, srcIndex, baseMerge, customizer, stack2);
    } else {
      var newValue = customizer ? customizer(safeGet(object4, key), srcValue, key + "", object4, source, stack2) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object4, key, newValue);
    }
  }, keysIn);
}
function customDefaultsMerge(objValue, srcValue, key, object4, source, stack2) {
  if (isObject(objValue) && isObject(srcValue)) {
    stack2.set(srcValue, objValue);
    baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack2);
    stack2["delete"](srcValue);
  }
  return objValue;
}
var mergeWith = createAssigner(function(object4, source, srcIndex, customizer) {
  baseMerge(object4, source, srcIndex, customizer);
});
const mergeWith$1 = mergeWith;
var defaultsDeep = baseRest(function(args) {
  args.push(void 0, customDefaultsMerge);
  return apply(mergeWith$1, void 0, args);
});
const defaultsDeep$1 = defaultsDeep;
var FUNC_ERROR_TEXT$5 = "Expected a function";
function baseDelay(func2, wait, args) {
  if (typeof func2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$5);
  }
  return setTimeout(function() {
    func2.apply(void 0, args);
  }, wait);
}
var defer = baseRest(function(func2, args) {
  return baseDelay(func2, 1, args);
});
const defer$1 = defer;
var delay = baseRest(function(func2, wait, args) {
  return baseDelay(func2, toNumber(wait) || 0, args);
});
const delay$1 = delay;
function arrayIncludesWith(array4, value, comparator2) {
  var index = -1, length = array4 == null ? 0 : array4.length;
  while (++index < length) {
    if (comparator2(value, array4[index])) {
      return true;
    }
  }
  return false;
}
var LARGE_ARRAY_SIZE$1 = 200;
function baseDifference(array4, values2, iteratee2, comparator2) {
  var index = -1, includes2 = arrayIncludes, isCommon = true, length = array4.length, result2 = [], valuesLength = values2.length;
  if (!length) {
    return result2;
  }
  if (iteratee2) {
    values2 = arrayMap(values2, baseUnary(iteratee2));
  }
  if (comparator2) {
    includes2 = arrayIncludesWith;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE$1) {
    includes2 = cacheHas;
    isCommon = false;
    values2 = new SetCache(values2);
  }
  outer:
    while (++index < length) {
      var value = array4[index], computed2 = iteratee2 == null ? value : iteratee2(value);
      value = comparator2 || value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values2[valuesIndex] === computed2) {
            continue outer;
          }
        }
        result2.push(value);
      } else if (!includes2(values2, computed2, comparator2)) {
        result2.push(value);
      }
    }
  return result2;
}
var difference = baseRest(function(array4, values2) {
  return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
});
const difference$1 = difference;
function last(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? array4[length - 1] : void 0;
}
var differenceBy = baseRest(function(array4, values2) {
  var iteratee2 = last(values2);
  if (isArrayLikeObject(iteratee2)) {
    iteratee2 = void 0;
  }
  return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true), baseIteratee(iteratee2)) : [];
});
const differenceBy$1 = differenceBy;
var differenceWith = baseRest(function(array4, values2) {
  var comparator2 = last(values2);
  if (isArrayLikeObject(comparator2)) {
    comparator2 = void 0;
  }
  return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true), void 0, comparator2) : [];
});
const differenceWith$1 = differenceWith;
var divide = createMathOperation(function(dividend, divisor) {
  return dividend / divisor;
}, 1);
const divide$1 = divide;
function drop(array4, n, guard) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger(n);
  return baseSlice(array4, n < 0 ? 0 : n, length);
}
function dropRight(array4, n, guard) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger(n);
  n = length - n;
  return baseSlice(array4, 0, n < 0 ? 0 : n);
}
function baseWhile(array4, predicate, isDrop, fromRight) {
  var length = array4.length, index = fromRight ? length : -1;
  while ((fromRight ? index-- : ++index < length) && predicate(array4[index], index, array4)) {
  }
  return isDrop ? baseSlice(array4, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array4, fromRight ? index + 1 : 0, fromRight ? length : index);
}
function dropRightWhile(array4, predicate) {
  return array4 && array4.length ? baseWhile(array4, baseIteratee(predicate), true, true) : [];
}
function dropWhile(array4, predicate) {
  return array4 && array4.length ? baseWhile(array4, baseIteratee(predicate), true) : [];
}
function castFunction(value) {
  return typeof value == "function" ? value : identity;
}
function forEach(collection2, iteratee2) {
  var func2 = isArray(collection2) ? arrayEach : baseEach;
  return func2(collection2, castFunction(iteratee2));
}
function arrayEachRight(array4, iteratee2) {
  var length = array4 == null ? 0 : array4.length;
  while (length--) {
    if (iteratee2(array4[length], length, array4) === false) {
      break;
    }
  }
  return array4;
}
var baseForRight = createBaseFor(true);
function baseForOwnRight(object4, iteratee2) {
  return object4 && baseForRight(object4, iteratee2, keys);
}
var baseEachRight = createBaseEach(baseForOwnRight, true);
const baseEachRight$1 = baseEachRight;
function forEachRight(collection2, iteratee2) {
  var func2 = isArray(collection2) ? arrayEachRight : baseEachRight$1;
  return func2(collection2, castFunction(iteratee2));
}
function endsWith(string3, target, position) {
  string3 = toString(string3);
  target = baseToString(target);
  var length = string3.length;
  position = position === void 0 ? length : baseClamp(toInteger(position), 0, length);
  var end = position;
  position -= target.length;
  return position >= 0 && string3.slice(position, end) == target;
}
function baseToPairs(object4, props) {
  return arrayMap(props, function(key) {
    return [key, object4[key]];
  });
}
function setToPairs(set2) {
  var index = -1, result2 = Array(set2.size);
  set2.forEach(function(value) {
    result2[++index] = [value, value];
  });
  return result2;
}
var mapTag$3 = "[object Map]", setTag$3 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object4) {
    var tag2 = getTag$1(object4);
    if (tag2 == mapTag$3) {
      return mapToArray(object4);
    }
    if (tag2 == setTag$3) {
      return setToPairs(object4);
    }
    return baseToPairs(object4, keysFunc(object4));
  };
}
var toPairs = createToPairs(keys);
const toPairs$1 = toPairs;
var toPairsIn = createToPairs(keysIn);
const toPairsIn$1 = toPairsIn;
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf(htmlEscapes);
const escapeHtmlChar$1 = escapeHtmlChar;
var reUnescapedHtml = /[&<>"']/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape(string3) {
  string3 = toString(string3);
  return string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar$1) : string3;
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
function escapeRegExp(string3) {
  string3 = toString(string3);
  return string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar, "\\$&") : string3;
}
function arrayEvery(array4, predicate) {
  var index = -1, length = array4 == null ? 0 : array4.length;
  while (++index < length) {
    if (!predicate(array4[index], index, array4)) {
      return false;
    }
  }
  return true;
}
function baseEvery(collection2, predicate) {
  var result2 = true;
  baseEach(collection2, function(value, index, collection3) {
    result2 = !!predicate(value, index, collection3);
    return result2;
  });
  return result2;
}
function every(collection2, predicate, guard) {
  var func2 = isArray(collection2) ? arrayEvery : baseEvery;
  if (guard && isIterateeCall(collection2, predicate, guard)) {
    predicate = void 0;
  }
  return func2(collection2, baseIteratee(predicate));
}
var MAX_ARRAY_LENGTH$5 = 4294967295;
function toLength(value) {
  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH$5) : 0;
}
function baseFill(array4, value, start, end) {
  var length = array4.length;
  start = toInteger(start);
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end === void 0 || end > length ? length : toInteger(end);
  if (end < 0) {
    end += length;
  }
  end = start > end ? 0 : toLength(end);
  while (start < end) {
    array4[start++] = value;
  }
  return array4;
}
function fill(array4, value, start, end) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return [];
  }
  if (start && typeof start != "number" && isIterateeCall(array4, value, start)) {
    start = 0;
    end = length;
  }
  return baseFill(array4, value, start, end);
}
function baseFilter(collection2, predicate) {
  var result2 = [];
  baseEach(collection2, function(value, index, collection3) {
    if (predicate(value, index, collection3)) {
      result2.push(value);
    }
  });
  return result2;
}
function filter(collection2, predicate) {
  var func2 = isArray(collection2) ? arrayFilter : baseFilter;
  return func2(collection2, baseIteratee(predicate));
}
function createFind(findIndexFunc) {
  return function(collection2, predicate, fromIndex) {
    var iterable = Object(collection2);
    if (!isArrayLike(collection2)) {
      var iteratee2 = baseIteratee(predicate);
      collection2 = keys(collection2);
      predicate = function(key) {
        return iteratee2(iterable[key], key, iterable);
      };
    }
    var index = findIndexFunc(collection2, predicate, fromIndex);
    return index > -1 ? iterable[iteratee2 ? collection2[index] : index] : void 0;
  };
}
var nativeMax$a = Math.max;
function findIndex$1(array4, predicate, fromIndex) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax$a(length + index, 0);
  }
  return baseFindIndex(array4, baseIteratee(predicate), index);
}
var find$1 = createFind(findIndex$1);
const find$2 = find$1;
function baseFindKey(collection2, predicate, eachFunc) {
  var result2;
  eachFunc(collection2, function(value, key, collection3) {
    if (predicate(value, key, collection3)) {
      result2 = key;
      return false;
    }
  });
  return result2;
}
function findKey$1(object4, predicate) {
  return baseFindKey(object4, baseIteratee(predicate), baseForOwn);
}
var nativeMax$9 = Math.max, nativeMin$a = Math.min;
function findLastIndex(array4, predicate, fromIndex) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== void 0) {
    index = toInteger(fromIndex);
    index = fromIndex < 0 ? nativeMax$9(length + index, 0) : nativeMin$a(index, length - 1);
  }
  return baseFindIndex(array4, baseIteratee(predicate), index, true);
}
var findLast = createFind(findLastIndex);
const findLast$1 = findLast;
function findLastKey(object4, predicate) {
  return baseFindKey(object4, baseIteratee(predicate), baseForOwnRight);
}
function head(array4) {
  return array4 && array4.length ? array4[0] : void 0;
}
function baseMap(collection2, iteratee2) {
  var index = -1, result2 = isArrayLike(collection2) ? Array(collection2.length) : [];
  baseEach(collection2, function(value, key, collection3) {
    result2[++index] = iteratee2(value, key, collection3);
  });
  return result2;
}
function map(collection2, iteratee2) {
  var func2 = isArray(collection2) ? arrayMap : baseMap;
  return func2(collection2, baseIteratee(iteratee2));
}
function flatMap(collection2, iteratee2) {
  return baseFlatten(map(collection2, iteratee2), 1);
}
var INFINITY$2 = 1 / 0;
function flatMapDeep(collection2, iteratee2) {
  return baseFlatten(map(collection2, iteratee2), INFINITY$2);
}
function flatMapDepth(collection2, iteratee2, depth) {
  depth = depth === void 0 ? 1 : toInteger(depth);
  return baseFlatten(map(collection2, iteratee2), depth);
}
var INFINITY$1 = 1 / 0;
function flattenDeep(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseFlatten(array4, INFINITY$1) : [];
}
function flattenDepth(array4, depth) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return [];
  }
  depth = depth === void 0 ? 1 : toInteger(depth);
  return baseFlatten(array4, depth);
}
var WRAP_FLIP_FLAG = 512;
function flip(func2) {
  return createWrap(func2, WRAP_FLIP_FLAG);
}
var floor = createRound("floor");
const floor$1 = floor;
var FUNC_ERROR_TEXT$4 = "Expected a function";
var WRAP_CURRY_FLAG = 8, WRAP_PARTIAL_FLAG$1 = 32, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG$1 = 256;
function createFlow(fromRight) {
  return flatRest(function(funcs) {
    var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func2 = funcs[index];
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$4);
      }
      if (prereq && !wrapper && getFuncName(func2) == "wrapper") {
        var wrapper = new LodashWrapper([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func2 = funcs[index];
      var funcName = getFuncName(func2), data = funcName == "wrapper" ? getData(func2) : void 0;
      if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG$1 | WRAP_REARG_FLAG$1) && !data[4].length && data[9] == 1) {
        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = func2.length == 1 && isLaziable(func2) ? wrapper[funcName]() : wrapper.thru(func2);
      }
    }
    return function() {
      var args = arguments, value = args[0];
      if (wrapper && args.length == 1 && isArray(value)) {
        return wrapper.plant(value).value();
      }
      var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
      while (++index2 < length) {
        result2 = funcs[index2].call(this, result2);
      }
      return result2;
    };
  });
}
var flow = createFlow();
const flow$1 = flow;
var flowRight = createFlow(true);
const flowRight$1 = flowRight;
function forIn(object4, iteratee2) {
  return object4 == null ? object4 : baseFor(object4, castFunction(iteratee2), keysIn);
}
function forInRight(object4, iteratee2) {
  return object4 == null ? object4 : baseForRight(object4, castFunction(iteratee2), keysIn);
}
function forOwn(object4, iteratee2) {
  return object4 && baseForOwn(object4, castFunction(iteratee2));
}
function forOwnRight(object4, iteratee2) {
  return object4 && baseForOwnRight(object4, castFunction(iteratee2));
}
function fromPairs(pairs) {
  var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
  while (++index < length) {
    var pair = pairs[index];
    result2[pair[0]] = pair[1];
  }
  return result2;
}
function baseFunctions(object4, props) {
  return arrayFilter(props, function(key) {
    return isFunction(object4[key]);
  });
}
function functions(object4) {
  return object4 == null ? [] : baseFunctions(object4, keys(object4));
}
function functionsIn(object4) {
  return object4 == null ? [] : baseFunctions(object4, keysIn(object4));
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var groupBy = createAggregator(function(result2, value, key) {
  if (hasOwnProperty$6.call(result2, key)) {
    result2[key].push(value);
  } else {
    baseAssignValue(result2, key, [value]);
  }
});
const groupBy$1 = groupBy;
function baseGt(value, other) {
  return value > other;
}
function createRelationalOperation(operator) {
  return function(value, other) {
    if (!(typeof value == "string" && typeof other == "string")) {
      value = toNumber(value);
      other = toNumber(other);
    }
    return operator(value, other);
  };
}
var gt = createRelationalOperation(baseGt);
const gt$1 = gt;
var gte = createRelationalOperation(function(value, other) {
  return value >= other;
});
const gte$1 = gte;
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function baseHas(object4, key) {
  return object4 != null && hasOwnProperty$5.call(object4, key);
}
function has(object4, path) {
  return object4 != null && hasPath(object4, path, baseHas);
}
var nativeMax$8 = Math.max, nativeMin$9 = Math.min;
function baseInRange(number4, start, end) {
  return number4 >= nativeMin$9(start, end) && number4 < nativeMax$8(start, end);
}
function inRange(number4, start, end) {
  start = toFinite(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite(end);
  }
  number4 = toNumber(number4);
  return baseInRange(number4, start, end);
}
var stringTag = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}
function baseValues(object4, props) {
  return arrayMap(props, function(key) {
    return object4[key];
  });
}
function values(object4) {
  return object4 == null ? [] : baseValues(object4, keys(object4));
}
var nativeMax$7 = Math.max;
function includes(collection2, value, fromIndex, guard) {
  collection2 = isArrayLike(collection2) ? collection2 : values(collection2);
  fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
  var length = collection2.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax$7(length + fromIndex, 0);
  }
  return isString(collection2) ? fromIndex <= length && collection2.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection2, value, fromIndex) > -1;
}
var nativeMax$6 = Math.max;
function indexOf(array4, value, fromIndex) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax$6(length + index, 0);
  }
  return baseIndexOf(array4, value, index);
}
function initial(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseSlice(array4, 0, -1) : [];
}
var nativeMin$8 = Math.min;
function baseIntersection(arrays, iteratee2, comparator2) {
  var includes2 = comparator2 ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
  while (othIndex--) {
    var array4 = arrays[othIndex];
    if (othIndex && iteratee2) {
      array4 = arrayMap(array4, baseUnary(iteratee2));
    }
    maxLength = nativeMin$8(array4.length, maxLength);
    caches[othIndex] = !comparator2 && (iteratee2 || length >= 120 && array4.length >= 120) ? new SetCache(othIndex && array4) : void 0;
  }
  array4 = arrays[0];
  var index = -1, seen = caches[0];
  outer:
    while (++index < length && result2.length < maxLength) {
      var value = array4[index], computed2 = iteratee2 ? iteratee2(value) : value;
      value = comparator2 || value !== 0 ? value : 0;
      if (!(seen ? cacheHas(seen, computed2) : includes2(result2, computed2, comparator2))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache2 = caches[othIndex];
          if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator2))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed2);
        }
        result2.push(value);
      }
    }
  return result2;
}
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}
var intersection = baseRest(function(arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
});
const intersection$1 = intersection;
var intersectionBy = baseRest(function(arrays) {
  var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
  if (iteratee2 === last(mapped)) {
    iteratee2 = void 0;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, baseIteratee(iteratee2)) : [];
});
const intersectionBy$1 = intersectionBy;
var intersectionWith = baseRest(function(arrays) {
  var comparator2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
  comparator2 = typeof comparator2 == "function" ? comparator2 : void 0;
  if (comparator2) {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, void 0, comparator2) : [];
});
const intersectionWith$1 = intersectionWith;
function baseInverter(object4, setter, iteratee2, accumulator) {
  baseForOwn(object4, function(value, key, object5) {
    setter(accumulator, iteratee2(value), key, object5);
  });
  return accumulator;
}
function createInverter(setter, toIteratee) {
  return function(object4, iteratee2) {
    return baseInverter(object4, setter, toIteratee(iteratee2), {});
  };
}
var objectProto$5 = Object.prototype;
var nativeObjectToString$1 = objectProto$5.toString;
var invert = createInverter(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString$1.call(value);
  }
  result2[value] = key;
}, constant(identity));
const invert$1 = invert;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
var nativeObjectToString = objectProto$4.toString;
var invertBy = createInverter(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString.call(value);
  }
  if (hasOwnProperty$4.call(result2, value)) {
    result2[value].push(key);
  } else {
    result2[value] = [key];
  }
}, baseIteratee);
const invertBy$1 = invertBy;
function parent(object4, path) {
  return path.length < 2 ? object4 : baseGet(object4, baseSlice(path, 0, -1));
}
function baseInvoke(object4, path, args) {
  path = castPath(path, object4);
  object4 = parent(object4, path);
  var func2 = object4 == null ? object4 : object4[toKey(last(path))];
  return func2 == null ? void 0 : apply(func2, object4, args);
}
var invoke = baseRest(baseInvoke);
const invoke$1 = invoke;
var invokeMap = baseRest(function(collection2, path, args) {
  var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection2) ? Array(collection2.length) : [];
  baseEach(collection2, function(value) {
    result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
  });
  return result2;
});
const invokeMap$1 = invokeMap;
var arrayBufferTag = "[object ArrayBuffer]";
function baseIsArrayBuffer(value) {
  return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
}
var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer;
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
const isArrayBuffer$1 = isArrayBuffer;
var boolTag = "[object Boolean]";
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
}
var dateTag = "[object Date]";
function baseIsDate(value) {
  return isObjectLike(value) && baseGetTag(value) == dateTag;
}
var nodeIsDate = nodeUtil && nodeUtil.isDate;
var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
const isDate$1 = isDate;
function isElement$1(value) {
  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
}
var mapTag$2 = "[object Map]", setTag$2 = "[object Set]";
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer$1(value) || isTypedArray$1(value) || isArguments$1(value))) {
    return !value.length;
  }
  var tag2 = getTag$1(value);
  if (tag2 == mapTag$2 || tag2 == setTag$2) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$3.call(value, key)) {
      return false;
    }
  }
  return true;
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result2 = customizer ? customizer(value, other) : void 0;
  return result2 === void 0 ? baseIsEqual(value, other, void 0, customizer) : !!result2;
}
var nativeIsFinite = root.isFinite;
function isFinite$1(value) {
  return typeof value == "number" && nativeIsFinite(value);
}
function isInteger(value) {
  return typeof value == "number" && value == toInteger(value);
}
function isMatch(object4, source) {
  return object4 === source || baseIsMatch(object4, source, getMatchData(source));
}
function isMatchWith(object4, source, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseIsMatch(object4, source, getMatchData(source), customizer);
}
var numberTag = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
}
function isNaN$1(value) {
  return isNumber(value) && value != +value;
}
var isMaskable = coreJsData ? isFunction : stubFalse;
var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
function isNative(value) {
  if (isMaskable(value)) {
    throw new Error(CORE_ERROR_TEXT);
  }
  return baseIsNative(value);
}
function isNil(value) {
  return value == null;
}
function isNull(value) {
  return value === null;
}
var regexpTag = "[object RegExp]";
function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
const isRegExp$1 = isRegExp;
var MAX_SAFE_INTEGER$4 = 9007199254740991;
function isSafeInteger(value) {
  return isInteger(value) && value >= -MAX_SAFE_INTEGER$4 && value <= MAX_SAFE_INTEGER$4;
}
function isUndefined(value) {
  return value === void 0;
}
var weakMapTag = "[object WeakMap]";
function isWeakMap(value) {
  return isObjectLike(value) && getTag$1(value) == weakMapTag;
}
var weakSetTag = "[object WeakSet]";
function isWeakSet(value) {
  return isObjectLike(value) && baseGetTag(value) == weakSetTag;
}
var CLONE_DEEP_FLAG$3 = 1;
function iteratee(func2) {
  return baseIteratee(typeof func2 == "function" ? func2 : baseClone(func2, CLONE_DEEP_FLAG$3));
}
var arrayProto$4 = Array.prototype;
var nativeJoin = arrayProto$4.join;
function join(array4, separator) {
  return array4 == null ? "" : nativeJoin.call(array4, separator);
}
var kebabCase$1 = createCompounder(function(result2, word, index) {
  return result2 + (index ? "-" : "") + word.toLowerCase();
});
const kebabCase$2 = kebabCase$1;
var keyBy = createAggregator(function(result2, value, key) {
  baseAssignValue(result2, key, value);
});
const keyBy$1 = keyBy;
function strictLastIndexOf(array4, value, fromIndex) {
  var index = fromIndex + 1;
  while (index--) {
    if (array4[index] === value) {
      return index;
    }
  }
  return index;
}
var nativeMax$5 = Math.max, nativeMin$7 = Math.min;
function lastIndexOf(array4, value, fromIndex) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return -1;
  }
  var index = length;
  if (fromIndex !== void 0) {
    index = toInteger(fromIndex);
    index = index < 0 ? nativeMax$5(length + index, 0) : nativeMin$7(index, length - 1);
  }
  return value === value ? strictLastIndexOf(array4, value, index) : baseFindIndex(array4, baseIsNaN, index, true);
}
var lowerCase = createCompounder(function(result2, word, index) {
  return result2 + (index ? " " : "") + word.toLowerCase();
});
const lowerCase$1 = lowerCase;
var lowerFirst = createCaseFirst("toLowerCase");
const lowerFirst$1 = lowerFirst;
function baseLt(value, other) {
  return value < other;
}
var lt = createRelationalOperation(baseLt);
const lt$1 = lt;
var lte = createRelationalOperation(function(value, other) {
  return value <= other;
});
const lte$1 = lte;
function mapKeys(object4, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee(iteratee2);
  baseForOwn(object4, function(value, key, object5) {
    baseAssignValue(result2, iteratee2(value, key, object5), value);
  });
  return result2;
}
function mapValues(object4, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee(iteratee2);
  baseForOwn(object4, function(value, key, object5) {
    baseAssignValue(result2, key, iteratee2(value, key, object5));
  });
  return result2;
}
var CLONE_DEEP_FLAG$2 = 1;
function matches(source) {
  return baseMatches(baseClone(source, CLONE_DEEP_FLAG$2));
}
var CLONE_DEEP_FLAG$1 = 1;
function matchesProperty(path, srcValue) {
  return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG$1));
}
function baseExtremum(array4, iteratee2, comparator2) {
  var index = -1, length = array4.length;
  while (++index < length) {
    var value = array4[index], current = iteratee2(value);
    if (current != null && (computed2 === void 0 ? current === current && !isSymbol(current) : comparator2(current, computed2))) {
      var computed2 = current, result2 = value;
    }
  }
  return result2;
}
function max(array4) {
  return array4 && array4.length ? baseExtremum(array4, identity, baseGt) : void 0;
}
function maxBy(array4, iteratee2) {
  return array4 && array4.length ? baseExtremum(array4, baseIteratee(iteratee2), baseGt) : void 0;
}
function baseSum(array4, iteratee2) {
  var result2, index = -1, length = array4.length;
  while (++index < length) {
    var current = iteratee2(array4[index]);
    if (current !== void 0) {
      result2 = result2 === void 0 ? current : result2 + current;
    }
  }
  return result2;
}
var NAN = 0 / 0;
function baseMean(array4, iteratee2) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseSum(array4, iteratee2) / length : NAN;
}
function mean(array4) {
  return baseMean(array4, identity);
}
function meanBy(array4, iteratee2) {
  return baseMean(array4, baseIteratee(iteratee2));
}
var merge$1 = createAssigner(function(object4, source, srcIndex) {
  baseMerge(object4, source, srcIndex);
});
var method = baseRest(function(path, args) {
  return function(object4) {
    return baseInvoke(object4, path, args);
  };
});
const method$1 = method;
var methodOf = baseRest(function(object4, args) {
  return function(path) {
    return baseInvoke(object4, path, args);
  };
});
const methodOf$1 = methodOf;
function min(array4) {
  return array4 && array4.length ? baseExtremum(array4, identity, baseLt) : void 0;
}
function minBy(array4, iteratee2) {
  return array4 && array4.length ? baseExtremum(array4, baseIteratee(iteratee2), baseLt) : void 0;
}
function mixin$1(object4, source, options) {
  var props = keys(source), methodNames = baseFunctions(source, props);
  var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object4);
  arrayEach(methodNames, function(methodName) {
    var func2 = source[methodName];
    object4[methodName] = func2;
    if (isFunc) {
      object4.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain2 || chainAll) {
          var result2 = object4(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
          actions.push({ "func": func2, "args": arguments, "thisArg": object4 });
          result2.__chain__ = chainAll;
          return result2;
        }
        return func2.apply(object4, arrayPush([this.value()], arguments));
      };
    }
  });
  return object4;
}
var multiply = createMathOperation(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
}, 1);
const multiply$1 = multiply;
var FUNC_ERROR_TEXT$3 = "Expected a function";
function negate(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
function iteratorToArray(iterator) {
  var data, result2 = [];
  while (!(data = iterator.next()).done) {
    result2.push(data.value);
  }
  return result2;
}
var mapTag$1 = "[object Map]", setTag$1 = "[object Set]";
var symIterator$1 = Symbol$1 ? Symbol$1.iterator : void 0;
function toArray$1(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString(value) ? stringToArray$1(value) : copyArray(value);
  }
  if (symIterator$1 && value[symIterator$1]) {
    return iteratorToArray(value[symIterator$1]());
  }
  var tag2 = getTag$1(value), func2 = tag2 == mapTag$1 ? mapToArray : tag2 == setTag$1 ? setToArray : values;
  return func2(value);
}
function wrapperNext() {
  if (this.__values__ === void 0) {
    this.__values__ = toArray$1(this.value());
  }
  var done = this.__index__ >= this.__values__.length, value = done ? void 0 : this.__values__[this.__index__++];
  return { "done": done, "value": value };
}
function baseNth(array4, n) {
  var length = array4.length;
  if (!length) {
    return;
  }
  n += n < 0 ? length : 0;
  return isIndex(n, length) ? array4[n] : void 0;
}
function nth(array4, n) {
  return array4 && array4.length ? baseNth(array4, toInteger(n)) : void 0;
}
function nthArg(n) {
  n = toInteger(n);
  return baseRest(function(args) {
    return baseNth(args, n);
  });
}
function baseUnset(object4, path) {
  path = castPath(path, object4);
  object4 = parent(object4, path);
  return object4 == null || delete object4[toKey(last(path))];
}
function customOmitClone(value) {
  return isPlainObject(value) ? void 0 : value;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit$1 = flatRest(function(object4, paths) {
  var result2 = {};
  if (object4 == null) {
    return result2;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object4);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object4, getAllKeysIn(object4), result2);
  if (isDeep) {
    result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result2, paths[length]);
  }
  return result2;
});
const omit$2 = omit$1;
function baseSet(object4, path, value, customizer) {
  if (!isObject(object4)) {
    return object4;
  }
  path = castPath(path, object4);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object4;
  while (nested != null && ++index < length) {
    var key = toKey(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object4;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object4;
}
function basePickBy(object4, paths, predicate) {
  var index = -1, length = paths.length, result2 = {};
  while (++index < length) {
    var path = paths[index], value = baseGet(object4, path);
    if (predicate(value, path)) {
      baseSet(result2, castPath(path, object4), value);
    }
  }
  return result2;
}
function pickBy(object4, predicate) {
  if (object4 == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object4), function(prop) {
    return [prop];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object4, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
function omitBy(object4, predicate) {
  return pickBy(object4, negate(baseIteratee(predicate)));
}
function once(func2) {
  return before(2, func2);
}
function baseSortBy(array4, comparer) {
  var length = array4.length;
  array4.sort(comparer);
  while (length--) {
    array4[length] = array4[length].value;
  }
  return array4;
}
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
function compareMultiple(object4, other, orders) {
  var index = -1, objCriteria = object4.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index < length) {
    var result2 = compareAscending(objCriteria[index], othCriteria[index]);
    if (result2) {
      if (index >= ordersLength) {
        return result2;
      }
      var order = orders[index];
      return result2 * (order == "desc" ? -1 : 1);
    }
  }
  return object4.index - other.index;
}
function baseOrderBy(collection2, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee2) {
      if (isArray(iteratee2)) {
        return function(value) {
          return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
        };
      }
      return iteratee2;
    });
  } else {
    iteratees = [identity];
  }
  var index = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
  var result2 = baseMap(collection2, function(value, key, collection3) {
    var criteria = arrayMap(iteratees, function(iteratee2) {
      return iteratee2(value);
    });
    return { "criteria": criteria, "index": ++index, "value": value };
  });
  return baseSortBy(result2, function(object4, other) {
    return compareMultiple(object4, other, orders);
  });
}
function orderBy(collection2, iteratees, orders, guard) {
  if (collection2 == null) {
    return [];
  }
  if (!isArray(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? void 0 : orders;
  if (!isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy(collection2, iteratees, orders);
}
function createOver(arrayFunc) {
  return flatRest(function(iteratees) {
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
    return baseRest(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee2) {
        return apply(iteratee2, thisArg, args);
      });
    });
  });
}
var over = createOver(arrayMap);
const over$1 = over;
var castRest = baseRest;
var nativeMin$6 = Math.min;
var overArgs = castRest(function(func2, transforms) {
  transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(baseIteratee)) : arrayMap(baseFlatten(transforms, 1), baseUnary(baseIteratee));
  var funcsLength = transforms.length;
  return baseRest(function(args) {
    var index = -1, length = nativeMin$6(args.length, funcsLength);
    while (++index < length) {
      args[index] = transforms[index].call(this, args[index]);
    }
    return apply(func2, this, args);
  });
});
const overArgs$1 = overArgs;
var overEvery = createOver(arrayEvery);
const overEvery$1 = overEvery;
var overSome = createOver(arraySome);
const overSome$1 = overSome;
var MAX_SAFE_INTEGER$3 = 9007199254740991;
var nativeFloor$3 = Math.floor;
function baseRepeat(string3, n) {
  var result2 = "";
  if (!string3 || n < 1 || n > MAX_SAFE_INTEGER$3) {
    return result2;
  }
  do {
    if (n % 2) {
      result2 += string3;
    }
    n = nativeFloor$3(n / 2);
    if (n) {
      string3 += string3;
    }
  } while (n);
  return result2;
}
var asciiSize = baseProperty("length");
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeSize(string3) {
  var result2 = reUnicode.lastIndex = 0;
  while (reUnicode.test(string3)) {
    ++result2;
  }
  return result2;
}
function stringSize(string3) {
  return hasUnicode(string3) ? unicodeSize(string3) : asciiSize(string3);
}
var nativeCeil$2 = Math.ceil;
function createPadding(length, chars) {
  chars = chars === void 0 ? " " : baseToString(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat(chars, length) : chars;
  }
  var result2 = baseRepeat(chars, nativeCeil$2(length / stringSize(chars)));
  return hasUnicode(chars) ? castSlice(stringToArray$1(result2), 0, length).join("") : result2.slice(0, length);
}
var nativeCeil$1 = Math.ceil, nativeFloor$2 = Math.floor;
function pad(string3, length, chars) {
  string3 = toString(string3);
  length = toInteger(length);
  var strLength = length ? stringSize(string3) : 0;
  if (!length || strLength >= length) {
    return string3;
  }
  var mid = (length - strLength) / 2;
  return createPadding(nativeFloor$2(mid), chars) + string3 + createPadding(nativeCeil$1(mid), chars);
}
function padEnd(string3, length, chars) {
  string3 = toString(string3);
  length = toInteger(length);
  var strLength = length ? stringSize(string3) : 0;
  return length && strLength < length ? string3 + createPadding(length - strLength, chars) : string3;
}
function padStart(string3, length, chars) {
  string3 = toString(string3);
  length = toInteger(length);
  var strLength = length ? stringSize(string3) : 0;
  return length && strLength < length ? createPadding(length - strLength, chars) + string3 : string3;
}
var reTrimStart$1 = /^\s+/;
var nativeParseInt = root.parseInt;
function parseInt$1(string3, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString(string3).replace(reTrimStart$1, ""), radix || 0);
}
var WRAP_PARTIAL_FLAG = 32;
var partial = baseRest(function(func2, partials) {
  var holders = replaceHolders(partials, getHolder(partial));
  return createWrap(func2, WRAP_PARTIAL_FLAG, void 0, partials, holders);
});
partial.placeholder = {};
const partial$1 = partial;
var WRAP_PARTIAL_RIGHT_FLAG = 64;
var partialRight = baseRest(function(func2, partials) {
  var holders = replaceHolders(partials, getHolder(partialRight));
  return createWrap(func2, WRAP_PARTIAL_RIGHT_FLAG, void 0, partials, holders);
});
partialRight.placeholder = {};
const partialRight$1 = partialRight;
var partition = createAggregator(function(result2, value, key) {
  result2[key ? 0 : 1].push(value);
}, function() {
  return [[], []];
});
const partition$1 = partition;
function basePick(object4, paths) {
  return basePickBy(object4, paths, function(value, path) {
    return hasIn(object4, path);
  });
}
var pick = flatRest(function(object4, paths) {
  return object4 == null ? {} : basePick(object4, paths);
});
const pick$1 = pick;
function wrapperPlant(value) {
  var result2, parent2 = this;
  while (parent2 instanceof baseLodash) {
    var clone2 = wrapperClone(parent2);
    clone2.__index__ = 0;
    clone2.__values__ = void 0;
    if (result2) {
      previous.__wrapped__ = clone2;
    } else {
      result2 = clone2;
    }
    var previous = clone2;
    parent2 = parent2.__wrapped__;
  }
  previous.__wrapped__ = value;
  return result2;
}
function propertyOf(object4) {
  return function(path) {
    return object4 == null ? void 0 : baseGet(object4, path);
  };
}
function baseIndexOfWith(array4, value, fromIndex, comparator2) {
  var index = fromIndex - 1, length = array4.length;
  while (++index < length) {
    if (comparator2(array4[index], value)) {
      return index;
    }
  }
  return -1;
}
var arrayProto$3 = Array.prototype;
var splice$1 = arrayProto$3.splice;
function basePullAll(array4, values2, iteratee2, comparator2) {
  var indexOf2 = comparator2 ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array4;
  if (array4 === values2) {
    values2 = copyArray(values2);
  }
  if (iteratee2) {
    seen = arrayMap(array4, baseUnary(iteratee2));
  }
  while (++index < length) {
    var fromIndex = 0, value = values2[index], computed2 = iteratee2 ? iteratee2(value) : value;
    while ((fromIndex = indexOf2(seen, computed2, fromIndex, comparator2)) > -1) {
      if (seen !== array4) {
        splice$1.call(seen, fromIndex, 1);
      }
      splice$1.call(array4, fromIndex, 1);
    }
  }
  return array4;
}
function pullAll(array4, values2) {
  return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2) : array4;
}
var pull = baseRest(pullAll);
const pull$1 = pull;
function pullAllBy(array4, values2, iteratee2) {
  return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, baseIteratee(iteratee2)) : array4;
}
function pullAllWith(array4, values2, comparator2) {
  return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, void 0, comparator2) : array4;
}
var arrayProto$2 = Array.prototype;
var splice = arrayProto$2.splice;
function basePullAt(array4, indexes) {
  var length = array4 ? indexes.length : 0, lastIndex = length - 1;
  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex(index)) {
        splice.call(array4, index, 1);
      } else {
        baseUnset(array4, index);
      }
    }
  }
  return array4;
}
var pullAt = flatRest(function(array4, indexes) {
  var length = array4 == null ? 0 : array4.length, result2 = baseAt(array4, indexes);
  basePullAt(array4, arrayMap(indexes, function(index) {
    return isIndex(index, length) ? +index : index;
  }).sort(compareAscending));
  return result2;
});
const pullAt$1 = pullAt;
var nativeFloor$1 = Math.floor, nativeRandom$1 = Math.random;
function baseRandom(lower, upper) {
  return lower + nativeFloor$1(nativeRandom$1() * (upper - lower + 1));
}
var freeParseFloat = parseFloat;
var nativeMin$5 = Math.min, nativeRandom = Math.random;
function random(lower, upper, floating) {
  if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
    upper = floating = void 0;
  }
  if (floating === void 0) {
    if (typeof upper == "boolean") {
      floating = upper;
      upper = void 0;
    } else if (typeof lower == "boolean") {
      floating = lower;
      lower = void 0;
    }
  }
  if (lower === void 0 && upper === void 0) {
    lower = 0;
    upper = 1;
  } else {
    lower = toFinite(lower);
    if (upper === void 0) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom();
    return nativeMin$5(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
  }
  return baseRandom(lower, upper);
}
var nativeCeil = Math.ceil, nativeMax$4 = Math.max;
function baseRange(start, end, step, fromRight) {
  var index = -1, length = nativeMax$4(nativeCeil((end - start) / (step || 1)), 0), result2 = Array(length);
  while (length--) {
    result2[fromRight ? length : ++index] = start;
    start += step;
  }
  return result2;
}
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
      end = step = void 0;
    }
    start = toFinite(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}
var range$1 = createRange();
const range$2 = range$1;
var rangeRight = createRange(true);
const rangeRight$1 = rangeRight;
var WRAP_REARG_FLAG = 256;
var rearg = flatRest(function(func2, indexes) {
  return createWrap(func2, WRAP_REARG_FLAG, void 0, void 0, void 0, indexes);
});
const rearg$1 = rearg;
function baseReduce(collection2, iteratee2, accumulator, initAccum, eachFunc) {
  eachFunc(collection2, function(value, index, collection3) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee2(accumulator, value, index, collection3);
  });
  return accumulator;
}
function reduce(collection2, iteratee2, accumulator) {
  var func2 = isArray(collection2) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
  return func2(collection2, baseIteratee(iteratee2), accumulator, initAccum, baseEach);
}
function arrayReduceRight(array4, iteratee2, accumulator, initAccum) {
  var length = array4 == null ? 0 : array4.length;
  if (initAccum && length) {
    accumulator = array4[--length];
  }
  while (length--) {
    accumulator = iteratee2(accumulator, array4[length], length, array4);
  }
  return accumulator;
}
function reduceRight(collection2, iteratee2, accumulator) {
  var func2 = isArray(collection2) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
  return func2(collection2, baseIteratee(iteratee2), accumulator, initAccum, baseEachRight$1);
}
function reject(collection2, predicate) {
  var func2 = isArray(collection2) ? arrayFilter : baseFilter;
  return func2(collection2, negate(baseIteratee(predicate)));
}
function remove(array4, predicate) {
  var result2 = [];
  if (!(array4 && array4.length)) {
    return result2;
  }
  var index = -1, indexes = [], length = array4.length;
  predicate = baseIteratee(predicate);
  while (++index < length) {
    var value = array4[index];
    if (predicate(value, index, array4)) {
      result2.push(value);
      indexes.push(index);
    }
  }
  basePullAt(array4, indexes);
  return result2;
}
function repeat(string3, n, guard) {
  if (guard ? isIterateeCall(string3, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger(n);
  }
  return baseRepeat(toString(string3), n);
}
function replace() {
  var args = arguments, string3 = toString(args[0]);
  return args.length < 3 ? string3 : string3.replace(args[1], args[2]);
}
var FUNC_ERROR_TEXT$2 = "Expected a function";
function rest(func2, start) {
  if (typeof func2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  start = start === void 0 ? start : toInteger(start);
  return baseRest(func2, start);
}
function result(object4, path, defaultValue) {
  path = castPath(path, object4);
  var index = -1, length = path.length;
  if (!length) {
    length = 1;
    object4 = void 0;
  }
  while (++index < length) {
    var value = object4 == null ? void 0 : object4[toKey(path[index])];
    if (value === void 0) {
      index = length;
      value = defaultValue;
    }
    object4 = isFunction(value) ? value.call(object4) : value;
  }
  return object4;
}
var arrayProto$1 = Array.prototype;
var nativeReverse = arrayProto$1.reverse;
function reverse(array4) {
  return array4 == null ? array4 : nativeReverse.call(array4);
}
var round = createRound("round");
const round$1 = round;
function arraySample(array4) {
  var length = array4.length;
  return length ? array4[baseRandom(0, length - 1)] : void 0;
}
function baseSample(collection2) {
  return arraySample(values(collection2));
}
function sample(collection2) {
  var func2 = isArray(collection2) ? arraySample : baseSample;
  return func2(collection2);
}
function shuffleSelf(array4, size2) {
  var index = -1, length = array4.length, lastIndex = length - 1;
  size2 = size2 === void 0 ? length : size2;
  while (++index < size2) {
    var rand = baseRandom(index, lastIndex), value = array4[rand];
    array4[rand] = array4[index];
    array4[index] = value;
  }
  array4.length = size2;
  return array4;
}
function arraySampleSize(array4, n) {
  return shuffleSelf(copyArray(array4), baseClamp(n, 0, array4.length));
}
function baseSampleSize(collection2, n) {
  var array4 = values(collection2);
  return shuffleSelf(array4, baseClamp(n, 0, array4.length));
}
function sampleSize(collection2, n, guard) {
  if (guard ? isIterateeCall(collection2, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger(n);
  }
  var func2 = isArray(collection2) ? arraySampleSize : baseSampleSize;
  return func2(collection2, n);
}
function set(object4, path, value) {
  return object4 == null ? object4 : baseSet(object4, path, value);
}
function setWith(object4, path, value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object4 == null ? object4 : baseSet(object4, path, value, customizer);
}
function arrayShuffle(array4) {
  return shuffleSelf(copyArray(array4));
}
function baseShuffle(collection2) {
  return shuffleSelf(values(collection2));
}
function shuffle(collection2) {
  var func2 = isArray(collection2) ? arrayShuffle : baseShuffle;
  return func2(collection2);
}
var mapTag = "[object Map]", setTag = "[object Set]";
function size$1(collection2) {
  if (collection2 == null) {
    return 0;
  }
  if (isArrayLike(collection2)) {
    return isString(collection2) ? stringSize(collection2) : collection2.length;
  }
  var tag2 = getTag$1(collection2);
  if (tag2 == mapTag || tag2 == setTag) {
    return collection2.size;
  }
  return baseKeys(collection2).length;
}
function slice(array4, start, end) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return [];
  }
  if (end && typeof end != "number" && isIterateeCall(array4, start, end)) {
    start = 0;
    end = length;
  } else {
    start = start == null ? 0 : toInteger(start);
    end = end === void 0 ? length : toInteger(end);
  }
  return baseSlice(array4, start, end);
}
var snakeCase = createCompounder(function(result2, word, index) {
  return result2 + (index ? "_" : "") + word.toLowerCase();
});
const snakeCase$1 = snakeCase;
function baseSome(collection2, predicate) {
  var result2;
  baseEach(collection2, function(value, index, collection3) {
    result2 = predicate(value, index, collection3);
    return !result2;
  });
  return !!result2;
}
function some(collection2, predicate, guard) {
  var func2 = isArray(collection2) ? arraySome : baseSome;
  if (guard && isIterateeCall(collection2, predicate, guard)) {
    predicate = void 0;
  }
  return func2(collection2, baseIteratee(predicate));
}
var sortBy = baseRest(function(collection2, iteratees) {
  if (collection2 == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection2, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection2, baseFlatten(iteratees, 1), []);
});
const sortBy$1 = sortBy;
var MAX_ARRAY_LENGTH$4 = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$4 - 1;
var nativeFloor = Math.floor, nativeMin$4 = Math.min;
function baseSortedIndexBy(array4, value, iteratee2, retHighest) {
  var low = 0, high = array4 == null ? 0 : array4.length;
  if (high === 0) {
    return 0;
  }
  value = iteratee2(value);
  var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === void 0;
  while (low < high) {
    var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array4[mid]), othIsDefined = computed2 !== void 0, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol(computed2);
    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed2 <= value : computed2 < value;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin$4(high, MAX_ARRAY_INDEX);
}
var MAX_ARRAY_LENGTH$3 = 4294967295, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH$3 >>> 1;
function baseSortedIndex(array4, value, retHighest) {
  var low = 0, high = array4 == null ? low : array4.length;
  if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = low + high >>> 1, computed2 = array4[mid];
      if (computed2 !== null && !isSymbol(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy(array4, value, identity, retHighest);
}
function sortedIndex(array4, value) {
  return baseSortedIndex(array4, value);
}
function sortedIndexBy(array4, value, iteratee2) {
  return baseSortedIndexBy(array4, value, baseIteratee(iteratee2));
}
function sortedIndexOf(array4, value) {
  var length = array4 == null ? 0 : array4.length;
  if (length) {
    var index = baseSortedIndex(array4, value);
    if (index < length && eq(array4[index], value)) {
      return index;
    }
  }
  return -1;
}
function sortedLastIndex(array4, value) {
  return baseSortedIndex(array4, value, true);
}
function sortedLastIndexBy(array4, value, iteratee2) {
  return baseSortedIndexBy(array4, value, baseIteratee(iteratee2), true);
}
function sortedLastIndexOf(array4, value) {
  var length = array4 == null ? 0 : array4.length;
  if (length) {
    var index = baseSortedIndex(array4, value, true) - 1;
    if (eq(array4[index], value)) {
      return index;
    }
  }
  return -1;
}
function baseSortedUniq(array4, iteratee2) {
  var index = -1, length = array4.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array4[index], computed2 = iteratee2 ? iteratee2(value) : value;
    if (!index || !eq(computed2, seen)) {
      var seen = computed2;
      result2[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result2;
}
function sortedUniq(array4) {
  return array4 && array4.length ? baseSortedUniq(array4) : [];
}
function sortedUniqBy(array4, iteratee2) {
  return array4 && array4.length ? baseSortedUniq(array4, baseIteratee(iteratee2)) : [];
}
var MAX_ARRAY_LENGTH$2 = 4294967295;
function split(string3, separator, limit) {
  if (limit && typeof limit != "number" && isIterateeCall(string3, separator, limit)) {
    separator = limit = void 0;
  }
  limit = limit === void 0 ? MAX_ARRAY_LENGTH$2 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string3 = toString(string3);
  if (string3 && (typeof separator == "string" || separator != null && !isRegExp$1(separator))) {
    separator = baseToString(separator);
    if (!separator && hasUnicode(string3)) {
      return castSlice(stringToArray$1(string3), 0, limit);
    }
  }
  return string3.split(separator, limit);
}
var FUNC_ERROR_TEXT$1 = "Expected a function";
var nativeMax$3 = Math.max;
function spread(func2, start) {
  if (typeof func2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  start = start == null ? 0 : nativeMax$3(toInteger(start), 0);
  return baseRest(function(args) {
    var array4 = args[start], otherArgs = castSlice(args, 0, start);
    if (array4) {
      arrayPush(otherArgs, array4);
    }
    return apply(func2, this, otherArgs);
  });
}
var startCase = createCompounder(function(result2, word, index) {
  return result2 + (index ? " " : "") + upperFirst(word);
});
const startCase$1 = startCase;
function startsWith(string3, target, position) {
  string3 = toString(string3);
  position = position == null ? 0 : baseClamp(toInteger(position), 0, string3.length);
  target = baseToString(target);
  return string3.slice(position, position + target.length) == target;
}
function stubObject() {
  return {};
}
function stubString() {
  return "";
}
function stubTrue() {
  return true;
}
var subtract = createMathOperation(function(minuend, subtrahend) {
  return minuend - subtrahend;
}, 0);
const subtract$1 = subtract;
function sum(array4) {
  return array4 && array4.length ? baseSum(array4, identity) : 0;
}
function sumBy(array4, iteratee2) {
  return array4 && array4.length ? baseSum(array4, baseIteratee(iteratee2)) : 0;
}
function tail(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseSlice(array4, 1, length) : [];
}
function take(array4, n, guard) {
  if (!(array4 && array4.length)) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger(n);
  return baseSlice(array4, 0, n < 0 ? 0 : n);
}
function takeRight(array4, n, guard) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger(n);
  n = length - n;
  return baseSlice(array4, n < 0 ? 0 : n, length);
}
function takeRightWhile(array4, predicate) {
  return array4 && array4.length ? baseWhile(array4, baseIteratee(predicate), false, true) : [];
}
function takeWhile(array4, predicate) {
  return array4 && array4.length ? baseWhile(array4, baseIteratee(predicate)) : [];
}
function tap(value, interceptor) {
  interceptor(value);
  return value;
}
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object4) {
  if (objValue === void 0 || eq(objValue, objectProto$2[key]) && !hasOwnProperty$2.call(object4, key)) {
    return srcValue;
  }
  return objValue;
}
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var reInterpolate = /<%=([\s\S]+?)%>/g;
const reInterpolate$1 = reInterpolate;
var reEscape = /<%-([\s\S]+?)%>/g;
const reEscape$1 = reEscape;
var reEvaluate = /<%([\s\S]+?)%>/g;
const reEvaluate$1 = reEvaluate;
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "escape": reEscape$1,
  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "evaluate": reEvaluate$1,
  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "interpolate": reInterpolate$1,
  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  "variable": "",
  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  "imports": {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    "_": { "escape": escape }
  }
};
const templateSettings$1 = templateSettings;
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function template(string3, options, guard) {
  var settings = templateSettings$1.imports._.templateSettings || templateSettings$1;
  if (guard && isIterateeCall(string3, options, guard)) {
    options = void 0;
  }
  string3 = toString(string3);
  options = extendWith({}, options, settings, customDefaultsAssignIn);
  var imports = extendWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
  var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate$1 ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
    "g"
  );
  var sourceURL = hasOwnProperty$1.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string3.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string3.slice(index, offset).replace(reUnescapedString, escapeStringChar);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match2.length;
    return match2;
  });
  source += "';\n";
  var variable = hasOwnProperty$1.call(options, "variable") && options.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result2 = attempt$1(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result2.source = source;
  if (isError(result2)) {
    throw result2;
  }
  return result2;
}
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func2, wait, options) {
  var leading = true, trailing = true;
  if (typeof func2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func2, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
function thru(value, interceptor) {
  return interceptor(value);
}
var MAX_SAFE_INTEGER$2 = 9007199254740991;
var MAX_ARRAY_LENGTH$1 = 4294967295;
var nativeMin$3 = Math.min;
function times(n, iteratee2) {
  n = toInteger(n);
  if (n < 1 || n > MAX_SAFE_INTEGER$2) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH$1, length = nativeMin$3(n, MAX_ARRAY_LENGTH$1);
  iteratee2 = castFunction(iteratee2);
  n -= MAX_ARRAY_LENGTH$1;
  var result2 = baseTimes(length, iteratee2);
  while (++index < n) {
    iteratee2(index);
  }
  return result2;
}
function wrapperToIterator() {
  return this;
}
function baseWrapperValue(value, actions) {
  var result2 = value;
  if (result2 instanceof LazyWrapper) {
    result2 = result2.value();
  }
  return arrayReduce(actions, function(result3, action) {
    return action.func.apply(action.thisArg, arrayPush([result3], action.args));
  }, result2);
}
function wrapperValue() {
  return baseWrapperValue(this.__wrapped__, this.__actions__);
}
function toLower(value) {
  return toString(value).toLowerCase();
}
function toPath(value) {
  if (isArray(value)) {
    return arrayMap(value, toKey);
  }
  return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function toSafeInteger(value) {
  return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER$1, MAX_SAFE_INTEGER$1) : value === 0 ? value : 0;
}
function toUpper(value) {
  return toString(value).toUpperCase();
}
function transform(object4, iteratee2, accumulator) {
  var isArr = isArray(object4), isArrLike = isArr || isBuffer$1(object4) || isTypedArray$1(object4);
  iteratee2 = baseIteratee(iteratee2);
  if (accumulator == null) {
    var Ctor = object4 && object4.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject(object4)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object4)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object4, function(value, index, object5) {
    return iteratee2(accumulator, value, index, object5);
  });
  return accumulator;
}
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;
  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1, length = strSymbols.length;
  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
function trim(string3, chars, guard) {
  string3 = toString(string3);
  if (string3 && (guard || chars === void 0)) {
    return baseTrim(string3);
  }
  if (!string3 || !(chars = baseToString(chars))) {
    return string3;
  }
  var strSymbols = stringToArray$1(string3), chrSymbols = stringToArray$1(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
  return castSlice(strSymbols, start, end).join("");
}
function trimEnd(string3, chars, guard) {
  string3 = toString(string3);
  if (string3 && (guard || chars === void 0)) {
    return string3.slice(0, trimmedEndIndex(string3) + 1);
  }
  if (!string3 || !(chars = baseToString(chars))) {
    return string3;
  }
  var strSymbols = stringToArray$1(string3), end = charsEndIndex(strSymbols, stringToArray$1(chars)) + 1;
  return castSlice(strSymbols, 0, end).join("");
}
var reTrimStart = /^\s+/;
function trimStart(string3, chars, guard) {
  string3 = toString(string3);
  if (string3 && (guard || chars === void 0)) {
    return string3.replace(reTrimStart, "");
  }
  if (!string3 || !(chars = baseToString(chars))) {
    return string3;
  }
  var strSymbols = stringToArray$1(string3), start = charsStartIndex(strSymbols, stringToArray$1(chars));
  return castSlice(strSymbols, start).join("");
}
var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
var reFlags = /\w*$/;
function truncate(string3, options) {
  var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
  if (isObject(options)) {
    var separator = "separator" in options ? options.separator : separator;
    length = "length" in options ? toInteger(options.length) : length;
    omission = "omission" in options ? baseToString(options.omission) : omission;
  }
  string3 = toString(string3);
  var strLength = string3.length;
  if (hasUnicode(string3)) {
    var strSymbols = stringToArray$1(string3);
    strLength = strSymbols.length;
  }
  if (length >= strLength) {
    return string3;
  }
  var end = length - stringSize(omission);
  if (end < 1) {
    return omission;
  }
  var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string3.slice(0, end);
  if (separator === void 0) {
    return result2 + omission;
  }
  if (strSymbols) {
    end += result2.length - end;
  }
  if (isRegExp$1(separator)) {
    if (string3.slice(end).search(separator)) {
      var match2, substring = result2;
      if (!separator.global) {
        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g");
      }
      separator.lastIndex = 0;
      while (match2 = separator.exec(substring)) {
        var newEnd = match2.index;
      }
      result2 = result2.slice(0, newEnd === void 0 ? end : newEnd);
    }
  } else if (string3.indexOf(baseToString(separator), end) != end) {
    var index = result2.lastIndexOf(separator);
    if (index > -1) {
      result2 = result2.slice(0, index);
    }
  }
  return result2 + omission;
}
function unary(func2) {
  return ary(func2, 1);
}
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
const unescapeHtmlChar$1 = unescapeHtmlChar;
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reHasEscapedHtml = RegExp(reEscapedHtml.source);
function unescape(string3) {
  string3 = toString(string3);
  return string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar$1) : string3;
}
var INFINITY = 1 / 0;
var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop : function(values2) {
  return new Set$1(values2);
};
var LARGE_ARRAY_SIZE = 200;
function baseUniq(array4, iteratee2, comparator2) {
  var index = -1, includes2 = arrayIncludes, length = array4.length, isCommon = true, result2 = [], seen = result2;
  if (comparator2) {
    isCommon = false;
    includes2 = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set2 = iteratee2 ? null : createSet(array4);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes2 = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee2 ? [] : result2;
  }
  outer:
    while (++index < length) {
      var value = array4[index], computed2 = iteratee2 ? iteratee2(value) : value;
      value = comparator2 || value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed2) {
            continue outer;
          }
        }
        if (iteratee2) {
          seen.push(computed2);
        }
        result2.push(value);
      } else if (!includes2(seen, computed2, comparator2)) {
        if (seen !== result2) {
          seen.push(computed2);
        }
        result2.push(value);
      }
    }
  return result2;
}
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});
const union$1 = union;
var unionBy = baseRest(function(arrays) {
  var iteratee2 = last(arrays);
  if (isArrayLikeObject(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee2));
});
const unionBy$1 = unionBy;
var unionWith = baseRest(function(arrays) {
  var comparator2 = last(arrays);
  comparator2 = typeof comparator2 == "function" ? comparator2 : void 0;
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), void 0, comparator2);
});
const unionWith$1 = unionWith;
function uniq(array4) {
  return array4 && array4.length ? baseUniq(array4) : [];
}
function uniqBy(array4, iteratee2) {
  return array4 && array4.length ? baseUniq(array4, baseIteratee(iteratee2)) : [];
}
function uniqWith(array4, comparator2) {
  comparator2 = typeof comparator2 == "function" ? comparator2 : void 0;
  return array4 && array4.length ? baseUniq(array4, void 0, comparator2) : [];
}
var idCounter$1 = 0;
function uniqueId(prefix2) {
  var id = ++idCounter$1;
  return toString(prefix2) + id;
}
function unset(object4, path) {
  return object4 == null ? true : baseUnset(object4, path);
}
var nativeMax$2 = Math.max;
function unzip(array4) {
  if (!(array4 && array4.length)) {
    return [];
  }
  var length = 0;
  array4 = arrayFilter(array4, function(group) {
    if (isArrayLikeObject(group)) {
      length = nativeMax$2(group.length, length);
      return true;
    }
  });
  return baseTimes(length, function(index) {
    return arrayMap(array4, baseProperty(index));
  });
}
function unzipWith(array4, iteratee2) {
  if (!(array4 && array4.length)) {
    return [];
  }
  var result2 = unzip(array4);
  if (iteratee2 == null) {
    return result2;
  }
  return arrayMap(result2, function(group) {
    return apply(iteratee2, void 0, group);
  });
}
function baseUpdate(object4, path, updater, customizer) {
  return baseSet(object4, path, updater(baseGet(object4, path)), customizer);
}
function update(object4, path, updater) {
  return object4 == null ? object4 : baseUpdate(object4, path, castFunction(updater));
}
function updateWith(object4, path, updater, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object4 == null ? object4 : baseUpdate(object4, path, castFunction(updater), customizer);
}
var upperCase = createCompounder(function(result2, word, index) {
  return result2 + (index ? " " : "") + word.toUpperCase();
});
const upperCase$1 = upperCase;
function valuesIn(object4) {
  return object4 == null ? [] : baseValues(object4, keysIn(object4));
}
var without = baseRest(function(array4, values2) {
  return isArrayLikeObject(array4) ? baseDifference(array4, values2) : [];
});
const without$1 = without;
function wrap(value, wrapper) {
  return partial$1(castFunction(wrapper), value);
}
var wrapperAt = flatRest(function(paths) {
  var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object4) {
    return baseAt(object4, paths);
  };
  if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
    return this.thru(interceptor);
  }
  value = value.slice(start, +start + (length ? 1 : 0));
  value.__actions__.push({
    "func": thru,
    "args": [interceptor],
    "thisArg": void 0
  });
  return new LodashWrapper(value, this.__chain__).thru(function(array4) {
    if (length && !array4.length) {
      array4.push(void 0);
    }
    return array4;
  });
});
const at = wrapperAt;
function wrapperChain() {
  return chain(this);
}
function wrapperReverse() {
  var value = this.__wrapped__;
  if (value instanceof LazyWrapper) {
    var wrapped = value;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      "func": thru,
      "args": [reverse],
      "thisArg": void 0
    });
    return new LodashWrapper(wrapped, this.__chain__);
  }
  return this.thru(reverse);
}
function baseXor(arrays, iteratee2, comparator2) {
  var length = arrays.length;
  if (length < 2) {
    return length ? baseUniq(arrays[0]) : [];
  }
  var index = -1, result2 = Array(length);
  while (++index < length) {
    var array4 = arrays[index], othIndex = -1;
    while (++othIndex < length) {
      if (othIndex != index) {
        result2[index] = baseDifference(result2[index] || array4, arrays[othIndex], iteratee2, comparator2);
      }
    }
  }
  return baseUniq(baseFlatten(result2, 1), iteratee2, comparator2);
}
var xor = baseRest(function(arrays) {
  return baseXor(arrayFilter(arrays, isArrayLikeObject));
});
const xor$1 = xor;
var xorBy = baseRest(function(arrays) {
  var iteratee2 = last(arrays);
  if (isArrayLikeObject(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee2));
});
const xorBy$1 = xorBy;
var xorWith = baseRest(function(arrays) {
  var comparator2 = last(arrays);
  comparator2 = typeof comparator2 == "function" ? comparator2 : void 0;
  return baseXor(arrayFilter(arrays, isArrayLikeObject), void 0, comparator2);
});
const xorWith$1 = xorWith;
var zip = baseRest(unzip);
const zip$1 = zip;
function baseZipObject(props, values2, assignFunc) {
  var index = -1, length = props.length, valsLength = values2.length, result2 = {};
  while (++index < length) {
    var value = index < valsLength ? values2[index] : void 0;
    assignFunc(result2, props[index], value);
  }
  return result2;
}
function zipObject(props, values2) {
  return baseZipObject(props || [], values2 || [], assignValue);
}
function zipObjectDeep(props, values2) {
  return baseZipObject(props || [], values2 || [], baseSet);
}
var zipWith = baseRest(function(arrays) {
  var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : void 0;
  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
  return unzipWith(arrays, iteratee2);
});
const zipWith$1 = zipWith;
const array = {
  chunk,
  compact,
  concat,
  difference: difference$1,
  differenceBy: differenceBy$1,
  differenceWith: differenceWith$1,
  drop,
  dropRight,
  dropRightWhile,
  dropWhile,
  fill,
  findIndex: findIndex$1,
  findLastIndex,
  first: head,
  flatten: flatten$3,
  flattenDeep,
  flattenDepth,
  fromPairs,
  head,
  indexOf,
  initial,
  intersection: intersection$1,
  intersectionBy: intersectionBy$1,
  intersectionWith: intersectionWith$1,
  join,
  last,
  lastIndexOf,
  nth,
  pull: pull$1,
  pullAll,
  pullAllBy,
  pullAllWith,
  pullAt: pullAt$1,
  remove,
  reverse,
  slice,
  sortedIndex,
  sortedIndexBy,
  sortedIndexOf,
  sortedLastIndex,
  sortedLastIndexBy,
  sortedLastIndexOf,
  sortedUniq,
  sortedUniqBy,
  tail,
  take,
  takeRight,
  takeRightWhile,
  takeWhile,
  union: union$1,
  unionBy: unionBy$1,
  unionWith: unionWith$1,
  uniq,
  uniqBy,
  uniqWith,
  unzip,
  unzipWith,
  without: without$1,
  xor: xor$1,
  xorBy: xorBy$1,
  xorWith: xorWith$1,
  zip: zip$1,
  zipObject,
  zipObjectDeep,
  zipWith: zipWith$1
};
const collection = {
  countBy: countBy$1,
  each: forEach,
  eachRight: forEachRight,
  every,
  filter,
  find: find$2,
  findLast: findLast$1,
  flatMap,
  flatMapDeep,
  flatMapDepth,
  forEach,
  forEachRight,
  groupBy: groupBy$1,
  includes,
  invokeMap: invokeMap$1,
  keyBy: keyBy$1,
  map,
  orderBy,
  partition: partition$1,
  reduce,
  reduceRight,
  reject,
  sample,
  sampleSize,
  shuffle,
  size: size$1,
  some,
  sortBy: sortBy$1
};
const date = {
  now: now$2
};
const func = {
  after,
  ary,
  before,
  bind: bind$1,
  bindKey: bindKey$1,
  curry,
  curryRight,
  debounce,
  defer: defer$1,
  delay: delay$1,
  flip,
  memoize,
  negate,
  once,
  overArgs: overArgs$1,
  partial: partial$1,
  partialRight: partialRight$1,
  rearg: rearg$1,
  rest,
  spread,
  throttle,
  unary,
  wrap
};
const lang = {
  castArray,
  clone,
  cloneDeep,
  cloneDeepWith,
  cloneWith,
  conformsTo,
  eq,
  gt: gt$1,
  gte: gte$1,
  isArguments: isArguments$1,
  isArray,
  isArrayBuffer: isArrayBuffer$1,
  isArrayLike,
  isArrayLikeObject,
  isBoolean,
  isBuffer: isBuffer$1,
  isDate: isDate$1,
  isElement: isElement$1,
  isEmpty,
  isEqual,
  isEqualWith,
  isError,
  isFinite: isFinite$1,
  isFunction,
  isInteger,
  isLength,
  isMap: isMap$1,
  isMatch,
  isMatchWith,
  isNaN: isNaN$1,
  isNative,
  isNil,
  isNull,
  isNumber,
  isObject,
  isObjectLike,
  isPlainObject,
  isRegExp: isRegExp$1,
  isSafeInteger,
  isSet: isSet$1,
  isString,
  isSymbol,
  isTypedArray: isTypedArray$1,
  isUndefined,
  isWeakMap,
  isWeakSet,
  lt: lt$1,
  lte: lte$1,
  toArray: toArray$1,
  toFinite,
  toInteger,
  toLength,
  toNumber,
  toPlainObject,
  toSafeInteger,
  toString
};
const math = {
  add: add$1,
  ceil: ceil$1,
  divide: divide$1,
  floor: floor$1,
  max,
  maxBy,
  mean,
  meanBy,
  min,
  minBy,
  multiply: multiply$1,
  round: round$1,
  subtract: subtract$1,
  sum,
  sumBy
};
const number = {
  clamp,
  inRange,
  random
};
const object = {
  assign: assign$1,
  assignIn: extend,
  assignInWith: extendWith,
  assignWith: assignWith$1,
  at: at$2,
  create,
  defaults: defaults$1,
  defaultsDeep: defaultsDeep$1,
  entries: toPairs$1,
  entriesIn: toPairsIn$1,
  extend,
  extendWith,
  findKey: findKey$1,
  findLastKey,
  forIn,
  forInRight,
  forOwn,
  forOwnRight,
  functions,
  functionsIn,
  get,
  has,
  hasIn,
  invert: invert$1,
  invertBy: invertBy$1,
  invoke: invoke$1,
  keys,
  keysIn,
  mapKeys,
  mapValues,
  merge: merge$1,
  mergeWith: mergeWith$1,
  omit: omit$2,
  omitBy,
  pick: pick$1,
  pickBy,
  result,
  set,
  setWith,
  toPairs: toPairs$1,
  toPairsIn: toPairsIn$1,
  transform,
  unset,
  update,
  updateWith,
  values,
  valuesIn
};
const seq = {
  at,
  chain,
  commit: wrapperCommit,
  lodash,
  next: wrapperNext,
  plant: wrapperPlant,
  reverse: wrapperReverse,
  tap,
  thru,
  toIterator: wrapperToIterator,
  toJSON: wrapperValue,
  value: wrapperValue,
  valueOf: wrapperValue,
  wrapperChain
};
const string$1 = {
  camelCase: camelCase$1,
  capitalize,
  deburr,
  endsWith,
  escape,
  escapeRegExp,
  kebabCase: kebabCase$2,
  lowerCase: lowerCase$1,
  lowerFirst: lowerFirst$1,
  pad,
  padEnd,
  padStart,
  parseInt: parseInt$1,
  repeat,
  replace,
  snakeCase: snakeCase$1,
  split,
  startCase: startCase$1,
  startsWith,
  template,
  templateSettings: templateSettings$1,
  toLower,
  toUpper,
  trim,
  trimEnd,
  trimStart,
  truncate,
  unescape,
  upperCase: upperCase$1,
  upperFirst,
  words
};
const util = {
  attempt: attempt$1,
  bindAll: bindAll$1,
  cond,
  conforms,
  constant,
  defaultTo,
  flow: flow$1,
  flowRight: flowRight$1,
  identity,
  iteratee,
  matches,
  matchesProperty,
  method: method$1,
  methodOf: methodOf$1,
  mixin: mixin$1,
  noop,
  nthArg,
  over: over$1,
  overEvery: overEvery$1,
  overSome: overSome$1,
  property,
  propertyOf,
  range: range$2,
  rangeRight: rangeRight$1,
  stubArray,
  stubFalse,
  stubObject,
  stubString,
  stubTrue,
  times,
  toPath,
  uniqueId
};
function lazyClone() {
  var result2 = new LazyWrapper(this.__wrapped__);
  result2.__actions__ = copyArray(this.__actions__);
  result2.__dir__ = this.__dir__;
  result2.__filtered__ = this.__filtered__;
  result2.__iteratees__ = copyArray(this.__iteratees__);
  result2.__takeCount__ = this.__takeCount__;
  result2.__views__ = copyArray(this.__views__);
  return result2;
}
function lazyReverse() {
  if (this.__filtered__) {
    var result2 = new LazyWrapper(this);
    result2.__dir__ = -1;
    result2.__filtered__ = true;
  } else {
    result2 = this.clone();
    result2.__dir__ *= -1;
  }
  return result2;
}
var nativeMax$1 = Math.max, nativeMin$2 = Math.min;
function getView(start, end, transforms) {
  var index = -1, length = transforms.length;
  while (++index < length) {
    var data = transforms[index], size2 = data.size;
    switch (data.type) {
      case "drop":
        start += size2;
        break;
      case "dropRight":
        end -= size2;
        break;
      case "take":
        end = nativeMin$2(end, start + size2);
        break;
      case "takeRight":
        start = nativeMax$1(start, end - size2);
        break;
    }
  }
  return { "start": start, "end": end };
}
var LAZY_FILTER_FLAG$1 = 1, LAZY_MAP_FLAG = 2;
var nativeMin$1 = Math.min;
function lazyValue() {
  var array4 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array4), isRight = dir < 0, arrLength = isArr ? array4.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin$1(length, this.__takeCount__);
  if (!isArr || !isRight && arrLength == length && takeCount == length) {
    return baseWrapperValue(array4, this.__actions__);
  }
  var result2 = [];
  outer:
    while (length-- && resIndex < takeCount) {
      index += dir;
      var iterIndex = -1, value = array4[index];
      while (++iterIndex < iterLength) {
        var data = iteratees[iterIndex], iteratee2 = data.iteratee, type4 = data.type, computed2 = iteratee2(value);
        if (type4 == LAZY_MAP_FLAG) {
          value = computed2;
        } else if (!computed2) {
          if (type4 == LAZY_FILTER_FLAG$1) {
            continue outer;
          } else {
            break outer;
          }
        }
      }
      result2[resIndex++] = value;
    }
  return result2;
}
/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var VERSION = "4.17.21";
var WRAP_BIND_KEY_FLAG = 2;
var LAZY_FILTER_FLAG = 1, LAZY_WHILE_FLAG = 3;
var MAX_ARRAY_LENGTH = 4294967295;
var arrayProto = Array.prototype, objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var symIterator = Symbol$1 ? Symbol$1.iterator : void 0;
var nativeMax = Math.max, nativeMin = Math.min;
var mixin = /* @__PURE__ */ function(func2) {
  return function(object4, source, options) {
    if (options == null) {
      var isObj = isObject(source), props = isObj && keys(source), methodNames = props && props.length && baseFunctions(source, props);
      if (!(methodNames ? methodNames.length : isObj)) {
        options = source;
        source = object4;
        object4 = this;
      }
    }
    return func2(object4, source, options);
  };
}(mixin$1);
lodash.after = func.after;
lodash.ary = func.ary;
lodash.assign = object.assign;
lodash.assignIn = object.assignIn;
lodash.assignInWith = object.assignInWith;
lodash.assignWith = object.assignWith;
lodash.at = object.at;
lodash.before = func.before;
lodash.bind = func.bind;
lodash.bindAll = util.bindAll;
lodash.bindKey = func.bindKey;
lodash.castArray = lang.castArray;
lodash.chain = seq.chain;
lodash.chunk = array.chunk;
lodash.compact = array.compact;
lodash.concat = array.concat;
lodash.cond = util.cond;
lodash.conforms = util.conforms;
lodash.constant = util.constant;
lodash.countBy = collection.countBy;
lodash.create = object.create;
lodash.curry = func.curry;
lodash.curryRight = func.curryRight;
lodash.debounce = func.debounce;
lodash.defaults = object.defaults;
lodash.defaultsDeep = object.defaultsDeep;
lodash.defer = func.defer;
lodash.delay = func.delay;
lodash.difference = array.difference;
lodash.differenceBy = array.differenceBy;
lodash.differenceWith = array.differenceWith;
lodash.drop = array.drop;
lodash.dropRight = array.dropRight;
lodash.dropRightWhile = array.dropRightWhile;
lodash.dropWhile = array.dropWhile;
lodash.fill = array.fill;
lodash.filter = collection.filter;
lodash.flatMap = collection.flatMap;
lodash.flatMapDeep = collection.flatMapDeep;
lodash.flatMapDepth = collection.flatMapDepth;
lodash.flatten = array.flatten;
lodash.flattenDeep = array.flattenDeep;
lodash.flattenDepth = array.flattenDepth;
lodash.flip = func.flip;
lodash.flow = util.flow;
lodash.flowRight = util.flowRight;
lodash.fromPairs = array.fromPairs;
lodash.functions = object.functions;
lodash.functionsIn = object.functionsIn;
lodash.groupBy = collection.groupBy;
lodash.initial = array.initial;
lodash.intersection = array.intersection;
lodash.intersectionBy = array.intersectionBy;
lodash.intersectionWith = array.intersectionWith;
lodash.invert = object.invert;
lodash.invertBy = object.invertBy;
lodash.invokeMap = collection.invokeMap;
lodash.iteratee = util.iteratee;
lodash.keyBy = collection.keyBy;
lodash.keys = keys;
lodash.keysIn = object.keysIn;
lodash.map = collection.map;
lodash.mapKeys = object.mapKeys;
lodash.mapValues = object.mapValues;
lodash.matches = util.matches;
lodash.matchesProperty = util.matchesProperty;
lodash.memoize = func.memoize;
lodash.merge = object.merge;
lodash.mergeWith = object.mergeWith;
lodash.method = util.method;
lodash.methodOf = util.methodOf;
lodash.mixin = mixin;
lodash.negate = negate;
lodash.nthArg = util.nthArg;
lodash.omit = object.omit;
lodash.omitBy = object.omitBy;
lodash.once = func.once;
lodash.orderBy = collection.orderBy;
lodash.over = util.over;
lodash.overArgs = func.overArgs;
lodash.overEvery = util.overEvery;
lodash.overSome = util.overSome;
lodash.partial = func.partial;
lodash.partialRight = func.partialRight;
lodash.partition = collection.partition;
lodash.pick = object.pick;
lodash.pickBy = object.pickBy;
lodash.property = util.property;
lodash.propertyOf = util.propertyOf;
lodash.pull = array.pull;
lodash.pullAll = array.pullAll;
lodash.pullAllBy = array.pullAllBy;
lodash.pullAllWith = array.pullAllWith;
lodash.pullAt = array.pullAt;
lodash.range = util.range;
lodash.rangeRight = util.rangeRight;
lodash.rearg = func.rearg;
lodash.reject = collection.reject;
lodash.remove = array.remove;
lodash.rest = func.rest;
lodash.reverse = array.reverse;
lodash.sampleSize = collection.sampleSize;
lodash.set = object.set;
lodash.setWith = object.setWith;
lodash.shuffle = collection.shuffle;
lodash.slice = array.slice;
lodash.sortBy = collection.sortBy;
lodash.sortedUniq = array.sortedUniq;
lodash.sortedUniqBy = array.sortedUniqBy;
lodash.split = string$1.split;
lodash.spread = func.spread;
lodash.tail = array.tail;
lodash.take = array.take;
lodash.takeRight = array.takeRight;
lodash.takeRightWhile = array.takeRightWhile;
lodash.takeWhile = array.takeWhile;
lodash.tap = seq.tap;
lodash.throttle = func.throttle;
lodash.thru = thru;
lodash.toArray = lang.toArray;
lodash.toPairs = object.toPairs;
lodash.toPairsIn = object.toPairsIn;
lodash.toPath = util.toPath;
lodash.toPlainObject = lang.toPlainObject;
lodash.transform = object.transform;
lodash.unary = func.unary;
lodash.union = array.union;
lodash.unionBy = array.unionBy;
lodash.unionWith = array.unionWith;
lodash.uniq = array.uniq;
lodash.uniqBy = array.uniqBy;
lodash.uniqWith = array.uniqWith;
lodash.unset = object.unset;
lodash.unzip = array.unzip;
lodash.unzipWith = array.unzipWith;
lodash.update = object.update;
lodash.updateWith = object.updateWith;
lodash.values = object.values;
lodash.valuesIn = object.valuesIn;
lodash.without = array.without;
lodash.words = string$1.words;
lodash.wrap = func.wrap;
lodash.xor = array.xor;
lodash.xorBy = array.xorBy;
lodash.xorWith = array.xorWith;
lodash.zip = array.zip;
lodash.zipObject = array.zipObject;
lodash.zipObjectDeep = array.zipObjectDeep;
lodash.zipWith = array.zipWith;
lodash.entries = object.toPairs;
lodash.entriesIn = object.toPairsIn;
lodash.extend = object.assignIn;
lodash.extendWith = object.assignInWith;
mixin(lodash, lodash);
lodash.add = math.add;
lodash.attempt = util.attempt;
lodash.camelCase = string$1.camelCase;
lodash.capitalize = string$1.capitalize;
lodash.ceil = math.ceil;
lodash.clamp = number.clamp;
lodash.clone = lang.clone;
lodash.cloneDeep = lang.cloneDeep;
lodash.cloneDeepWith = lang.cloneDeepWith;
lodash.cloneWith = lang.cloneWith;
lodash.conformsTo = lang.conformsTo;
lodash.deburr = string$1.deburr;
lodash.defaultTo = util.defaultTo;
lodash.divide = math.divide;
lodash.endsWith = string$1.endsWith;
lodash.eq = lang.eq;
lodash.escape = string$1.escape;
lodash.escapeRegExp = string$1.escapeRegExp;
lodash.every = collection.every;
lodash.find = collection.find;
lodash.findIndex = array.findIndex;
lodash.findKey = object.findKey;
lodash.findLast = collection.findLast;
lodash.findLastIndex = array.findLastIndex;
lodash.findLastKey = object.findLastKey;
lodash.floor = math.floor;
lodash.forEach = collection.forEach;
lodash.forEachRight = collection.forEachRight;
lodash.forIn = object.forIn;
lodash.forInRight = object.forInRight;
lodash.forOwn = object.forOwn;
lodash.forOwnRight = object.forOwnRight;
lodash.get = object.get;
lodash.gt = lang.gt;
lodash.gte = lang.gte;
lodash.has = object.has;
lodash.hasIn = object.hasIn;
lodash.head = array.head;
lodash.identity = identity;
lodash.includes = collection.includes;
lodash.indexOf = array.indexOf;
lodash.inRange = number.inRange;
lodash.invoke = object.invoke;
lodash.isArguments = lang.isArguments;
lodash.isArray = isArray;
lodash.isArrayBuffer = lang.isArrayBuffer;
lodash.isArrayLike = lang.isArrayLike;
lodash.isArrayLikeObject = lang.isArrayLikeObject;
lodash.isBoolean = lang.isBoolean;
lodash.isBuffer = lang.isBuffer;
lodash.isDate = lang.isDate;
lodash.isElement = lang.isElement;
lodash.isEmpty = lang.isEmpty;
lodash.isEqual = lang.isEqual;
lodash.isEqualWith = lang.isEqualWith;
lodash.isError = lang.isError;
lodash.isFinite = lang.isFinite;
lodash.isFunction = lang.isFunction;
lodash.isInteger = lang.isInteger;
lodash.isLength = lang.isLength;
lodash.isMap = lang.isMap;
lodash.isMatch = lang.isMatch;
lodash.isMatchWith = lang.isMatchWith;
lodash.isNaN = lang.isNaN;
lodash.isNative = lang.isNative;
lodash.isNil = lang.isNil;
lodash.isNull = lang.isNull;
lodash.isNumber = lang.isNumber;
lodash.isObject = isObject;
lodash.isObjectLike = lang.isObjectLike;
lodash.isPlainObject = lang.isPlainObject;
lodash.isRegExp = lang.isRegExp;
lodash.isSafeInteger = lang.isSafeInteger;
lodash.isSet = lang.isSet;
lodash.isString = lang.isString;
lodash.isSymbol = lang.isSymbol;
lodash.isTypedArray = lang.isTypedArray;
lodash.isUndefined = lang.isUndefined;
lodash.isWeakMap = lang.isWeakMap;
lodash.isWeakSet = lang.isWeakSet;
lodash.join = array.join;
lodash.kebabCase = string$1.kebabCase;
lodash.last = last;
lodash.lastIndexOf = array.lastIndexOf;
lodash.lowerCase = string$1.lowerCase;
lodash.lowerFirst = string$1.lowerFirst;
lodash.lt = lang.lt;
lodash.lte = lang.lte;
lodash.max = math.max;
lodash.maxBy = math.maxBy;
lodash.mean = math.mean;
lodash.meanBy = math.meanBy;
lodash.min = math.min;
lodash.minBy = math.minBy;
lodash.stubArray = util.stubArray;
lodash.stubFalse = util.stubFalse;
lodash.stubObject = util.stubObject;
lodash.stubString = util.stubString;
lodash.stubTrue = util.stubTrue;
lodash.multiply = math.multiply;
lodash.nth = array.nth;
lodash.noop = util.noop;
lodash.now = date.now;
lodash.pad = string$1.pad;
lodash.padEnd = string$1.padEnd;
lodash.padStart = string$1.padStart;
lodash.parseInt = string$1.parseInt;
lodash.random = number.random;
lodash.reduce = collection.reduce;
lodash.reduceRight = collection.reduceRight;
lodash.repeat = string$1.repeat;
lodash.replace = string$1.replace;
lodash.result = object.result;
lodash.round = math.round;
lodash.sample = collection.sample;
lodash.size = collection.size;
lodash.snakeCase = string$1.snakeCase;
lodash.some = collection.some;
lodash.sortedIndex = array.sortedIndex;
lodash.sortedIndexBy = array.sortedIndexBy;
lodash.sortedIndexOf = array.sortedIndexOf;
lodash.sortedLastIndex = array.sortedLastIndex;
lodash.sortedLastIndexBy = array.sortedLastIndexBy;
lodash.sortedLastIndexOf = array.sortedLastIndexOf;
lodash.startCase = string$1.startCase;
lodash.startsWith = string$1.startsWith;
lodash.subtract = math.subtract;
lodash.sum = math.sum;
lodash.sumBy = math.sumBy;
lodash.template = string$1.template;
lodash.times = util.times;
lodash.toFinite = lang.toFinite;
lodash.toInteger = toInteger;
lodash.toLength = lang.toLength;
lodash.toLower = string$1.toLower;
lodash.toNumber = lang.toNumber;
lodash.toSafeInteger = lang.toSafeInteger;
lodash.toString = lang.toString;
lodash.toUpper = string$1.toUpper;
lodash.trim = string$1.trim;
lodash.trimEnd = string$1.trimEnd;
lodash.trimStart = string$1.trimStart;
lodash.truncate = string$1.truncate;
lodash.unescape = string$1.unescape;
lodash.uniqueId = util.uniqueId;
lodash.upperCase = string$1.upperCase;
lodash.upperFirst = string$1.upperFirst;
lodash.each = collection.forEach;
lodash.eachRight = collection.forEachRight;
lodash.first = array.head;
mixin(lodash, function() {
  var source = {};
  baseForOwn(lodash, function(func2, methodName) {
    if (!hasOwnProperty.call(lodash.prototype, methodName)) {
      source[methodName] = func2;
    }
  });
  return source;
}(), { "chain": false });
lodash.VERSION = VERSION;
(lodash.templateSettings = string$1.templateSettings).imports._ = lodash;
arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
  lodash[methodName].placeholder = lodash;
});
arrayEach(["drop", "take"], function(methodName, index) {
  LazyWrapper.prototype[methodName] = function(n) {
    n = n === void 0 ? 1 : nativeMax(toInteger(n), 0);
    var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
    if (result2.__filtered__) {
      result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
    } else {
      result2.__views__.push({
        "size": nativeMin(n, MAX_ARRAY_LENGTH),
        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
      });
    }
    return result2;
  };
  LazyWrapper.prototype[methodName + "Right"] = function(n) {
    return this.reverse()[methodName](n).reverse();
  };
});
arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
  var type4 = index + 1, isFilter = type4 == LAZY_FILTER_FLAG || type4 == LAZY_WHILE_FLAG;
  LazyWrapper.prototype[methodName] = function(iteratee2) {
    var result2 = this.clone();
    result2.__iteratees__.push({
      "iteratee": baseIteratee(iteratee2),
      "type": type4
    });
    result2.__filtered__ = result2.__filtered__ || isFilter;
    return result2;
  };
});
arrayEach(["head", "last"], function(methodName, index) {
  var takeName = "take" + (index ? "Right" : "");
  LazyWrapper.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});
arrayEach(["initial", "tail"], function(methodName, index) {
  var dropName = "drop" + (index ? "" : "Right");
  LazyWrapper.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
  };
});
LazyWrapper.prototype.compact = function() {
  return this.filter(identity);
};
LazyWrapper.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};
LazyWrapper.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};
LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
  if (typeof path == "function") {
    return new LazyWrapper(this);
  }
  return this.map(function(value) {
    return baseInvoke(value, path, args);
  });
});
LazyWrapper.prototype.reject = function(predicate) {
  return this.filter(negate(baseIteratee(predicate)));
};
LazyWrapper.prototype.slice = function(start, end) {
  start = toInteger(start);
  var result2 = this;
  if (result2.__filtered__ && (start > 0 || end < 0)) {
    return new LazyWrapper(result2);
  }
  if (start < 0) {
    result2 = result2.takeRight(-start);
  } else if (start) {
    result2 = result2.drop(start);
  }
  if (end !== void 0) {
    end = toInteger(end);
    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
  }
  return result2;
};
LazyWrapper.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};
LazyWrapper.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH);
};
baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
  if (!lodashFunc) {
    return;
  }
  lodash.prototype[methodName] = function() {
    var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
    var interceptor = function(value2) {
      var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
      return isTaker && chainAll ? result3[0] : result3;
    };
    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
    if (!retUnwrapped && useLazy) {
      value = onlyLazy ? value : new LazyWrapper(this);
      var result2 = func2.apply(value, args);
      result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": void 0 });
      return new LodashWrapper(result2, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func2.apply(this, args);
    }
    result2 = this.thru(interceptor);
    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
  };
});
arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
  var func2 = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
  lodash.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value = this.value();
      return func2.apply(isArray(value) ? value : [], args);
    }
    return this[chainName](function(value2) {
      return func2.apply(isArray(value2) ? value2 : [], args);
    });
  };
});
baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
  var lodashFunc = lodash[methodName];
  if (lodashFunc) {
    var key = lodashFunc.name + "";
    if (!hasOwnProperty.call(realNames, key)) {
      realNames[key] = [];
    }
    realNames[key].push({ "name": methodName, "func": lodashFunc });
  }
});
realNames[createHybrid(void 0, WRAP_BIND_KEY_FLAG).name] = [{
  "name": "wrapper",
  "func": void 0
}];
LazyWrapper.prototype.clone = lazyClone;
LazyWrapper.prototype.reverse = lazyReverse;
LazyWrapper.prototype.value = lazyValue;
lodash.prototype.at = seq.at;
lodash.prototype.chain = seq.wrapperChain;
lodash.prototype.commit = seq.commit;
lodash.prototype.next = seq.next;
lodash.prototype.plant = seq.plant;
lodash.prototype.reverse = seq.reverse;
lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = seq.value;
lodash.prototype.first = lodash.prototype.head;
if (symIterator) {
  lodash.prototype[symIterator] = seq.toIterator;
}
function mitt(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var lib$1 = { exports: {} };
var _FullInternals = {};
var _CoreInternals = {};
var Global = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2._registerNode = exports2.Konva = exports2.glob = void 0;
  const PI_OVER_180 = Math.PI / 180;
  function detectBrowser() {
    return typeof window !== "undefined" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]");
  }
  exports2.glob = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" ? self : {};
  exports2.Konva = {
    _global: exports2.glob,
    version: "9.3.14",
    isBrowser: detectBrowser(),
    isUnminified: /param/.test((function(param) {
    }).toString()),
    dblClickWindow: 400,
    getAngle(angle) {
      return exports2.Konva.angleDeg ? angle * PI_OVER_180 : angle;
    },
    enableTrace: false,
    pointerEventsEnabled: true,
    autoDrawEnabled: true,
    hitOnDragEnabled: false,
    capturePointerEventsEnabled: false,
    _mouseListenClick: false,
    _touchListenClick: false,
    _pointerListenClick: false,
    _mouseInDblClickWindow: false,
    _touchInDblClickWindow: false,
    _pointerInDblClickWindow: false,
    _mouseDblClickPointerId: null,
    _touchDblClickPointerId: null,
    _pointerDblClickPointerId: null,
    _fixTextRendering: false,
    pixelRatio: typeof window !== "undefined" && window.devicePixelRatio || 1,
    dragDistance: 3,
    angleDeg: true,
    showWarnings: true,
    dragButtons: [0, 1],
    isDragging() {
      return exports2.Konva["DD"].isDragging;
    },
    isTransforming() {
      var _a;
      return (_a = exports2.Konva["Transformer"]) === null || _a === void 0 ? void 0 : _a.isTransforming();
    },
    isDragReady() {
      return !!exports2.Konva["DD"].node;
    },
    releaseCanvasOnDestroy: true,
    document: exports2.glob.document,
    _injectGlobal(Konva2) {
      exports2.glob.Konva = Konva2;
    }
  };
  const _registerNode = (NodeClass) => {
    exports2.Konva[NodeClass.prototype.getClassName()] = NodeClass;
  };
  exports2._registerNode = _registerNode;
  exports2.Konva._injectGlobal(exports2.Konva);
})(Global);
var Util = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Util = exports2.Transform = void 0;
  const Global_12 = Global;
  class Transform {
    constructor(m = [1, 0, 0, 1, 0, 0]) {
      this.dirty = false;
      this.m = m && m.slice() || [1, 0, 0, 1, 0, 0];
    }
    reset() {
      this.m[0] = 1;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 1;
      this.m[4] = 0;
      this.m[5] = 0;
    }
    copy() {
      return new Transform(this.m);
    }
    copyInto(tr) {
      tr.m[0] = this.m[0];
      tr.m[1] = this.m[1];
      tr.m[2] = this.m[2];
      tr.m[3] = this.m[3];
      tr.m[4] = this.m[4];
      tr.m[5] = this.m[5];
    }
    point(point) {
      var m = this.m;
      return {
        x: m[0] * point.x + m[2] * point.y + m[4],
        y: m[1] * point.x + m[3] * point.y + m[5]
      };
    }
    translate(x, y) {
      this.m[4] += this.m[0] * x + this.m[2] * y;
      this.m[5] += this.m[1] * x + this.m[3] * y;
      return this;
    }
    scale(sx, sy) {
      this.m[0] *= sx;
      this.m[1] *= sx;
      this.m[2] *= sy;
      this.m[3] *= sy;
      return this;
    }
    rotate(rad) {
      var c2 = Math.cos(rad);
      var s = Math.sin(rad);
      var m11 = this.m[0] * c2 + this.m[2] * s;
      var m12 = this.m[1] * c2 + this.m[3] * s;
      var m21 = this.m[0] * -s + this.m[2] * c2;
      var m22 = this.m[1] * -s + this.m[3] * c2;
      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      return this;
    }
    getTranslation() {
      return {
        x: this.m[4],
        y: this.m[5]
      };
    }
    skew(sx, sy) {
      var m11 = this.m[0] + this.m[2] * sy;
      var m12 = this.m[1] + this.m[3] * sy;
      var m21 = this.m[2] + this.m[0] * sx;
      var m22 = this.m[3] + this.m[1] * sx;
      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      return this;
    }
    multiply(matrix) {
      var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
      var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
      var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
      var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
      var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
      var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      this.m[4] = dx;
      this.m[5] = dy;
      return this;
    }
    invert() {
      var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
      var m0 = this.m[3] * d;
      var m1 = -this.m[1] * d;
      var m2 = -this.m[2] * d;
      var m3 = this.m[0] * d;
      var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
      var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
      this.m[0] = m0;
      this.m[1] = m1;
      this.m[2] = m2;
      this.m[3] = m3;
      this.m[4] = m4;
      this.m[5] = m5;
      return this;
    }
    getMatrix() {
      return this.m;
    }
    decompose() {
      var a = this.m[0];
      var b = this.m[1];
      var c2 = this.m[2];
      var d = this.m[3];
      var e = this.m[4];
      var f = this.m[5];
      var delta = a * d - b * c2;
      let result2 = {
        x: e,
        y: f,
        rotation: 0,
        scaleX: 0,
        scaleY: 0,
        skewX: 0,
        skewY: 0
      };
      if (a != 0 || b != 0) {
        var r = Math.sqrt(a * a + b * b);
        result2.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
        result2.scaleX = r;
        result2.scaleY = delta / r;
        result2.skewX = (a * c2 + b * d) / delta;
        result2.skewY = 0;
      } else if (c2 != 0 || d != 0) {
        var s = Math.sqrt(c2 * c2 + d * d);
        result2.rotation = Math.PI / 2 - (d > 0 ? Math.acos(-c2 / s) : -Math.acos(c2 / s));
        result2.scaleX = delta / s;
        result2.scaleY = s;
        result2.skewX = 0;
        result2.skewY = (a * c2 + b * d) / delta;
      } else
        ;
      result2.rotation = exports2.Util._getRotation(result2.rotation);
      return result2;
    }
  }
  exports2.Transform = Transform;
  var OBJECT_ARRAY = "[object Array]", OBJECT_NUMBER = "[object Number]", OBJECT_STRING = "[object String]", OBJECT_BOOLEAN = "[object Boolean]", PI_OVER_DEG180 = Math.PI / 180, DEG180_OVER_PI = 180 / Math.PI, HASH2 = "#", EMPTY_STRING2 = "", ZERO = "0", KONVA_WARNING = "Konva warning: ", KONVA_ERROR = "Konva error: ", RGB_PAREN = "rgb(", COLORS = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 132, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 255, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 203],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [119, 128, 144],
    slategrey: [119, 128, 144],
    snow: [255, 255, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    transparent: [255, 255, 255, 0],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 5]
  }, RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/, animQueue = [];
  const req = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame || function(f) {
    setTimeout(f, 60);
  };
  exports2.Util = {
    _isElement(obj) {
      return !!(obj && obj.nodeType == 1);
    },
    _isFunction(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
    },
    _isPlainObject(obj) {
      return !!obj && obj.constructor === Object;
    },
    _isArray(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
    },
    _isNumber(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_NUMBER && !isNaN(obj) && isFinite(obj);
    },
    _isString(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_STRING;
    },
    _isBoolean(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN;
    },
    isObject(val) {
      return val instanceof Object;
    },
    isValidSelector(selector) {
      if (typeof selector !== "string") {
        return false;
      }
      var firstChar = selector[0];
      return firstChar === "#" || firstChar === "." || firstChar === firstChar.toUpperCase();
    },
    _sign(number4) {
      if (number4 === 0) {
        return 1;
      }
      if (number4 > 0) {
        return 1;
      } else {
        return -1;
      }
    },
    requestAnimFrame(callback) {
      animQueue.push(callback);
      if (animQueue.length === 1) {
        req(function() {
          const queue2 = animQueue;
          animQueue = [];
          queue2.forEach(function(cb) {
            cb();
          });
        });
      }
    },
    createCanvasElement() {
      var canvas = document.createElement("canvas");
      try {
        canvas.style = canvas.style || {};
      } catch (e) {
      }
      return canvas;
    },
    createImageElement() {
      return document.createElement("img");
    },
    _isInDocument(el) {
      while (el = el.parentNode) {
        if (el == document) {
          return true;
        }
      }
      return false;
    },
    _urlToImage(url2, callback) {
      var imageObj = exports2.Util.createImageElement();
      imageObj.onload = function() {
        callback(imageObj);
      };
      imageObj.src = url2;
    },
    _rgbToHex(r, g, b) {
      return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    },
    _hexToRgb(hex3) {
      hex3 = hex3.replace(HASH2, EMPTY_STRING2);
      var bigint = parseInt(hex3, 16);
      return {
        r: bigint >> 16 & 255,
        g: bigint >> 8 & 255,
        b: bigint & 255
      };
    },
    getRandomColor() {
      var randColor = (Math.random() * 16777215 << 0).toString(16);
      while (randColor.length < 6) {
        randColor = ZERO + randColor;
      }
      return HASH2 + randColor;
    },
    getRGB(color) {
      var rgb;
      if (color in COLORS) {
        rgb = COLORS[color];
        return {
          r: rgb[0],
          g: rgb[1],
          b: rgb[2]
        };
      } else if (color[0] === HASH2) {
        return this._hexToRgb(color.substring(1));
      } else if (color.substr(0, 4) === RGB_PAREN) {
        rgb = RGB_REGEX.exec(color.replace(/ /g, ""));
        return {
          r: parseInt(rgb[1], 10),
          g: parseInt(rgb[2], 10),
          b: parseInt(rgb[3], 10)
        };
      } else {
        return {
          r: 0,
          g: 0,
          b: 0
        };
      }
    },
    colorToRGBA(str) {
      str = str || "black";
      return exports2.Util._namedColorToRBA(str) || exports2.Util._hex3ColorToRGBA(str) || exports2.Util._hex4ColorToRGBA(str) || exports2.Util._hex6ColorToRGBA(str) || exports2.Util._hex8ColorToRGBA(str) || exports2.Util._rgbColorToRGBA(str) || exports2.Util._rgbaColorToRGBA(str) || exports2.Util._hslColorToRGBA(str);
    },
    _namedColorToRBA(str) {
      var c2 = COLORS[str.toLowerCase()];
      if (!c2) {
        return null;
      }
      return {
        r: c2[0],
        g: c2[1],
        b: c2[2],
        a: 1
      };
    },
    _rgbColorToRGBA(str) {
      if (str.indexOf("rgb(") === 0) {
        str = str.match(/rgb\(([^)]+)\)/)[1];
        var parts = str.split(/ *, */).map(Number);
        return {
          r: parts[0],
          g: parts[1],
          b: parts[2],
          a: 1
        };
      }
    },
    _rgbaColorToRGBA(str) {
      if (str.indexOf("rgba(") === 0) {
        str = str.match(/rgba\(([^)]+)\)/)[1];
        var parts = str.split(/ *, */).map((n, index) => {
          if (n.slice(-1) === "%") {
            return index === 3 ? parseInt(n) / 100 : parseInt(n) / 100 * 255;
          }
          return Number(n);
        });
        return {
          r: parts[0],
          g: parts[1],
          b: parts[2],
          a: parts[3]
        };
      }
    },
    _hex8ColorToRGBA(str) {
      if (str[0] === "#" && str.length === 9) {
        return {
          r: parseInt(str.slice(1, 3), 16),
          g: parseInt(str.slice(3, 5), 16),
          b: parseInt(str.slice(5, 7), 16),
          a: parseInt(str.slice(7, 9), 16) / 255
        };
      }
    },
    _hex6ColorToRGBA(str) {
      if (str[0] === "#" && str.length === 7) {
        return {
          r: parseInt(str.slice(1, 3), 16),
          g: parseInt(str.slice(3, 5), 16),
          b: parseInt(str.slice(5, 7), 16),
          a: 1
        };
      }
    },
    _hex4ColorToRGBA(str) {
      if (str[0] === "#" && str.length === 5) {
        return {
          r: parseInt(str[1] + str[1], 16),
          g: parseInt(str[2] + str[2], 16),
          b: parseInt(str[3] + str[3], 16),
          a: parseInt(str[4] + str[4], 16) / 255
        };
      }
    },
    _hex3ColorToRGBA(str) {
      if (str[0] === "#" && str.length === 4) {
        return {
          r: parseInt(str[1] + str[1], 16),
          g: parseInt(str[2] + str[2], 16),
          b: parseInt(str[3] + str[3], 16),
          a: 1
        };
      }
    },
    _hslColorToRGBA(str) {
      if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(str)) {
        const [_, ...hsl] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(str);
        const h2 = Number(hsl[0]) / 360;
        const s = Number(hsl[1]) / 100;
        const l = Number(hsl[2]) / 100;
        let t2;
        let t3;
        let val;
        if (s === 0) {
          val = l * 255;
          return {
            r: Math.round(val),
            g: Math.round(val),
            b: Math.round(val),
            a: 1
          };
        }
        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }
        const t1 = 2 * l - t2;
        const rgb = [0, 0, 0];
        for (let i = 0; i < 3; i++) {
          t3 = h2 + 1 / 3 * -(i - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i] = val * 255;
        }
        return {
          r: Math.round(rgb[0]),
          g: Math.round(rgb[1]),
          b: Math.round(rgb[2]),
          a: 1
        };
      }
    },
    haveIntersection(r1, r2) {
      return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y);
    },
    cloneObject(obj) {
      var retObj = {};
      for (var key in obj) {
        if (this._isPlainObject(obj[key])) {
          retObj[key] = this.cloneObject(obj[key]);
        } else if (this._isArray(obj[key])) {
          retObj[key] = this.cloneArray(obj[key]);
        } else {
          retObj[key] = obj[key];
        }
      }
      return retObj;
    },
    cloneArray(arr) {
      return arr.slice(0);
    },
    degToRad(deg) {
      return deg * PI_OVER_DEG180;
    },
    radToDeg(rad) {
      return rad * DEG180_OVER_PI;
    },
    _degToRad(deg) {
      exports2.Util.warn("Util._degToRad is removed. Please use public Util.degToRad instead.");
      return exports2.Util.degToRad(deg);
    },
    _radToDeg(rad) {
      exports2.Util.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead.");
      return exports2.Util.radToDeg(rad);
    },
    _getRotation(radians) {
      return Global_12.Konva.angleDeg ? exports2.Util.radToDeg(radians) : radians;
    },
    _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    },
    throw(str) {
      throw new Error(KONVA_ERROR + str);
    },
    error(str) {
      console.error(KONVA_ERROR + str);
    },
    warn(str) {
      if (!Global_12.Konva.showWarnings) {
        return;
      }
      console.warn(KONVA_WARNING + str);
    },
    each(obj, func2) {
      for (var key in obj) {
        func2(key, obj[key]);
      }
    },
    _inRange(val, left, right) {
      return left <= val && val < right;
    },
    _getProjectionToSegment(x1, y1, x2, y2, x3, y3) {
      var x, y, dist;
      var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
      if (pd2 == 0) {
        x = x1;
        y = y1;
        dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
      } else {
        var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
        if (u < 0) {
          x = x1;
          y = y1;
          dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
        } else if (u > 1) {
          x = x2;
          y = y2;
          dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
        } else {
          x = x1 + u * (x2 - x1);
          y = y1 + u * (y2 - y1);
          dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
        }
      }
      return [x, y, dist];
    },
    _getProjectionToLine(pt, line, isClosed) {
      var pc = exports2.Util.cloneObject(pt);
      var dist = Number.MAX_VALUE;
      line.forEach(function(p1, i) {
        if (!isClosed && i === line.length - 1) {
          return;
        }
        var p2 = line[(i + 1) % line.length];
        var proj = exports2.Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
        var px = proj[0], py = proj[1], pdist = proj[2];
        if (pdist < dist) {
          pc.x = px;
          pc.y = py;
          dist = pdist;
        }
      });
      return pc;
    },
    _prepareArrayForTween(startArray, endArray, isClosed) {
      var n, start = [], end = [];
      if (startArray.length > endArray.length) {
        var temp = endArray;
        endArray = startArray;
        startArray = temp;
      }
      for (n = 0; n < startArray.length; n += 2) {
        start.push({
          x: startArray[n],
          y: startArray[n + 1]
        });
      }
      for (n = 0; n < endArray.length; n += 2) {
        end.push({
          x: endArray[n],
          y: endArray[n + 1]
        });
      }
      var newStart = [];
      end.forEach(function(point) {
        var pr = exports2.Util._getProjectionToLine(point, start, isClosed);
        newStart.push(pr.x);
        newStart.push(pr.y);
      });
      return newStart;
    },
    _prepareToStringify(obj) {
      var desc;
      obj.visitedByCircularReferenceRemoval = true;
      for (var key in obj) {
        if (!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == "object")) {
          continue;
        }
        desc = Object.getOwnPropertyDescriptor(obj, key);
        if (obj[key].visitedByCircularReferenceRemoval || exports2.Util._isElement(obj[key])) {
          if (desc.configurable) {
            delete obj[key];
          } else {
            return null;
          }
        } else if (exports2.Util._prepareToStringify(obj[key]) === null) {
          if (desc.configurable) {
            delete obj[key];
          } else {
            return null;
          }
        }
      }
      delete obj.visitedByCircularReferenceRemoval;
      return obj;
    },
    _assign(target, source) {
      for (var key in source) {
        target[key] = source[key];
      }
      return target;
    },
    _getFirstPointerId(evt) {
      if (!evt.touches) {
        return evt.pointerId || 999;
      } else {
        return evt.changedTouches[0].identifier;
      }
    },
    releaseCanvas(...canvases) {
      if (!Global_12.Konva.releaseCanvasOnDestroy)
        return;
      canvases.forEach((c2) => {
        c2.width = 0;
        c2.height = 0;
      });
    },
    drawRoundedRectPath(context, width, height, cornerRadius) {
      let topLeft = 0;
      let topRight = 0;
      let bottomLeft = 0;
      let bottomRight = 0;
      if (typeof cornerRadius === "number") {
        topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
      } else {
        topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
        topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
        bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
        bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
      }
      context.moveTo(topLeft, 0);
      context.lineTo(width - topRight, 0);
      context.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, false);
      context.lineTo(width, height - bottomRight);
      context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
      context.lineTo(bottomLeft, height);
      context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
      context.lineTo(0, topLeft);
      context.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
    }
  };
})(Util);
var Node$1 = {};
var Factory = {};
var Validators = {};
Object.defineProperty(Validators, "__esModule", { value: true });
Validators.getComponentValidator = Validators.getBooleanValidator = Validators.getNumberArrayValidator = Validators.getFunctionValidator = Validators.getStringOrGradientValidator = Validators.getStringValidator = Validators.getNumberOrAutoValidator = Validators.getNumberOrArrayOfNumbersValidator = Validators.getNumberValidator = Validators.alphaComponent = Validators.RGBComponent = void 0;
const Global_1$p = Global;
const Util_1$f = Util;
function _formatValue(val) {
  if (Util_1$f.Util._isString(val)) {
    return '"' + val + '"';
  }
  if (Object.prototype.toString.call(val) === "[object Number]") {
    return val;
  }
  if (Util_1$f.Util._isBoolean(val)) {
    return val;
  }
  return Object.prototype.toString.call(val);
}
function RGBComponent(val) {
  if (val > 255) {
    return 255;
  } else if (val < 0) {
    return 0;
  }
  return Math.round(val);
}
Validators.RGBComponent = RGBComponent;
function alphaComponent(val) {
  if (val > 1) {
    return 1;
  } else if (val < 1e-4) {
    return 1e-4;
  }
  return val;
}
Validators.alphaComponent = alphaComponent;
function getNumberValidator() {
  if (Global_1$p.Konva.isUnminified) {
    return function(val, attr) {
      if (!Util_1$f.Util._isNumber(val)) {
        Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number.');
      }
      return val;
    };
  }
}
Validators.getNumberValidator = getNumberValidator;
function getNumberOrArrayOfNumbersValidator(noOfElements) {
  if (Global_1$p.Konva.isUnminified) {
    return function(val, attr) {
      let isNumber2 = Util_1$f.Util._isNumber(val);
      let isValidArray = Util_1$f.Util._isArray(val) && val.length == noOfElements;
      if (!isNumber2 && !isValidArray) {
        Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or Array<number>(' + noOfElements + ")");
      }
      return val;
    };
  }
}
Validators.getNumberOrArrayOfNumbersValidator = getNumberOrArrayOfNumbersValidator;
function getNumberOrAutoValidator() {
  if (Global_1$p.Konva.isUnminified) {
    return function(val, attr) {
      var isNumber2 = Util_1$f.Util._isNumber(val);
      var isAuto = val === "auto";
      if (!(isNumber2 || isAuto)) {
        Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or "auto".');
      }
      return val;
    };
  }
}
Validators.getNumberOrAutoValidator = getNumberOrAutoValidator;
function getStringValidator() {
  if (Global_1$p.Konva.isUnminified) {
    return function(val, attr) {
      if (!Util_1$f.Util._isString(val)) {
        Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string.');
      }
      return val;
    };
  }
}
Validators.getStringValidator = getStringValidator;
function getStringOrGradientValidator() {
  if (Global_1$p.Konva.isUnminified) {
    return function(val, attr) {
      const isString2 = Util_1$f.Util._isString(val);
      const isGradient = Object.prototype.toString.call(val) === "[object CanvasGradient]" || val && val.addColorStop;
      if (!(isString2 || isGradient)) {
        Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string or a native gradient.');
      }
      return val;
    };
  }
}
Validators.getStringOrGradientValidator = getStringOrGradientValidator;
function getFunctionValidator() {
  if (Global_1$p.Konva.isUnminified) {
    return function(val, attr) {
      if (!Util_1$f.Util._isFunction(val)) {
        Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a function.');
      }
      return val;
    };
  }
}
Validators.getFunctionValidator = getFunctionValidator;
function getNumberArrayValidator() {
  if (Global_1$p.Konva.isUnminified) {
    return function(val, attr) {
      const TypedArray = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
      if (TypedArray && val instanceof TypedArray) {
        return val;
      }
      if (!Util_1$f.Util._isArray(val)) {
        Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a array of numbers.');
      } else {
        val.forEach(function(item) {
          if (!Util_1$f.Util._isNumber(item)) {
            Util_1$f.Util.warn('"' + attr + '" attribute has non numeric element ' + item + ". Make sure that all elements are numbers.");
          }
        });
      }
      return val;
    };
  }
}
Validators.getNumberArrayValidator = getNumberArrayValidator;
function getBooleanValidator() {
  if (Global_1$p.Konva.isUnminified) {
    return function(val, attr) {
      var isBool = val === true || val === false;
      if (!isBool) {
        Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a boolean.');
      }
      return val;
    };
  }
}
Validators.getBooleanValidator = getBooleanValidator;
function getComponentValidator(components) {
  if (Global_1$p.Konva.isUnminified) {
    return function(val, attr) {
      if (val === void 0 || val === null) {
        return val;
      }
      if (!Util_1$f.Util.isObject(val)) {
        Util_1$f.Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be an object with properties ' + components);
      }
      return val;
    };
  }
}
Validators.getComponentValidator = getComponentValidator;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Factory = void 0;
  const Util_12 = Util;
  const Validators_12 = Validators;
  var GET = "get", SET2 = "set";
  exports2.Factory = {
    addGetterSetter(constructor, attr, def2, validator2, after2) {
      exports2.Factory.addGetter(constructor, attr, def2);
      exports2.Factory.addSetter(constructor, attr, validator2, after2);
      exports2.Factory.addOverloadedGetterSetter(constructor, attr);
    },
    addGetter(constructor, attr, def2) {
      var method4 = GET + Util_12.Util._capitalize(attr);
      constructor.prototype[method4] = constructor.prototype[method4] || function() {
        var val = this.attrs[attr];
        return val === void 0 ? def2 : val;
      };
    },
    addSetter(constructor, attr, validator2, after2) {
      var method4 = SET2 + Util_12.Util._capitalize(attr);
      if (!constructor.prototype[method4]) {
        exports2.Factory.overWriteSetter(constructor, attr, validator2, after2);
      }
    },
    overWriteSetter(constructor, attr, validator2, after2) {
      var method4 = SET2 + Util_12.Util._capitalize(attr);
      constructor.prototype[method4] = function(val) {
        if (validator2 && val !== void 0 && val !== null) {
          val = validator2.call(this, val, attr);
        }
        this._setAttr(attr, val);
        if (after2) {
          after2.call(this);
        }
        return this;
      };
    },
    addComponentsGetterSetter(constructor, attr, components, validator2, after2) {
      var len2 = components.length, capitalize2 = Util_12.Util._capitalize, getter = GET + capitalize2(attr), setter = SET2 + capitalize2(attr), n, component;
      constructor.prototype[getter] = function() {
        var ret = {};
        for (n = 0; n < len2; n++) {
          component = components[n];
          ret[component] = this.getAttr(attr + capitalize2(component));
        }
        return ret;
      };
      var basicValidator = (0, Validators_12.getComponentValidator)(components);
      constructor.prototype[setter] = function(val) {
        var oldVal = this.attrs[attr], key;
        if (validator2) {
          val = validator2.call(this, val);
        }
        if (basicValidator) {
          basicValidator.call(this, val, attr);
        }
        for (key in val) {
          if (!val.hasOwnProperty(key)) {
            continue;
          }
          this._setAttr(attr + capitalize2(key), val[key]);
        }
        if (!val) {
          components.forEach((component2) => {
            this._setAttr(attr + capitalize2(component2), void 0);
          });
        }
        this._fireChangeEvent(attr, oldVal, val);
        if (after2) {
          after2.call(this);
        }
        return this;
      };
      exports2.Factory.addOverloadedGetterSetter(constructor, attr);
    },
    addOverloadedGetterSetter(constructor, attr) {
      var capitalizedAttr = Util_12.Util._capitalize(attr), setter = SET2 + capitalizedAttr, getter = GET + capitalizedAttr;
      constructor.prototype[attr] = function() {
        if (arguments.length) {
          this[setter](arguments[0]);
          return this;
        }
        return this[getter]();
      };
    },
    addDeprecatedGetterSetter(constructor, attr, def2, validator2) {
      Util_12.Util.error("Adding deprecated " + attr);
      var method4 = GET + Util_12.Util._capitalize(attr);
      var message = attr + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
      constructor.prototype[method4] = function() {
        Util_12.Util.error(message);
        var val = this.attrs[attr];
        return val === void 0 ? def2 : val;
      };
      exports2.Factory.addSetter(constructor, attr, validator2, function() {
        Util_12.Util.error(message);
      });
      exports2.Factory.addOverloadedGetterSetter(constructor, attr);
    },
    backCompat(constructor, methods) {
      Util_12.Util.each(methods, function(oldMethodName, newMethodName) {
        var method4 = constructor.prototype[newMethodName];
        var oldGetter = GET + Util_12.Util._capitalize(oldMethodName);
        var oldSetter = SET2 + Util_12.Util._capitalize(oldMethodName);
        function deprecated() {
          method4.apply(this, arguments);
          Util_12.Util.error('"' + oldMethodName + '" method is deprecated and will be removed soon. Use ""' + newMethodName + '" instead.');
        }
        constructor.prototype[oldMethodName] = deprecated;
        constructor.prototype[oldGetter] = deprecated;
        constructor.prototype[oldSetter] = deprecated;
      });
    },
    afterSetFilter() {
      this._filterUpToDate = false;
    }
  };
})(Factory);
var Canvas$1 = {};
var Context$1 = {};
Object.defineProperty(Context$1, "__esModule", { value: true });
Context$1.HitContext = Context$1.SceneContext = Context$1.Context = void 0;
const Util_1$e = Util;
const Global_1$o = Global;
function simplifyArray(arr) {
  var retArr = [], len2 = arr.length, util2 = Util_1$e.Util, n, val;
  for (n = 0; n < len2; n++) {
    val = arr[n];
    if (util2._isNumber(val)) {
      val = Math.round(val * 1e3) / 1e3;
    } else if (!util2._isString(val)) {
      val = val + "";
    }
    retArr.push(val);
  }
  return retArr;
}
var COMMA = ",", OPEN_PAREN = "(", CLOSE_PAREN = ")", OPEN_PAREN_BRACKET = "([", CLOSE_BRACKET_PAREN = "])", SEMICOLON = ";", DOUBLE_PAREN = "()", EQUALS = "=", CONTEXT_METHODS = [
  "arc",
  "arcTo",
  "beginPath",
  "bezierCurveTo",
  "clearRect",
  "clip",
  "closePath",
  "createLinearGradient",
  "createPattern",
  "createRadialGradient",
  "drawImage",
  "ellipse",
  "fill",
  "fillText",
  "getImageData",
  "createImageData",
  "lineTo",
  "moveTo",
  "putImageData",
  "quadraticCurveTo",
  "rect",
  "roundRect",
  "restore",
  "rotate",
  "save",
  "scale",
  "setLineDash",
  "setTransform",
  "stroke",
  "strokeText",
  "transform",
  "translate"
];
var CONTEXT_PROPERTIES = [
  "fillStyle",
  "strokeStyle",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY",
  "letterSpacing",
  "lineCap",
  "lineDashOffset",
  "lineJoin",
  "lineWidth",
  "miterLimit",
  "direction",
  "font",
  "textAlign",
  "textBaseline",
  "globalAlpha",
  "globalCompositeOperation",
  "imageSmoothingEnabled"
];
const traceArrMax = 100;
class Context {
  constructor(canvas) {
    this.canvas = canvas;
    if (Global_1$o.Konva.enableTrace) {
      this.traceArr = [];
      this._enableTrace();
    }
  }
  fillShape(shape) {
    if (shape.fillEnabled()) {
      this._fill(shape);
    }
  }
  _fill(shape) {
  }
  strokeShape(shape) {
    if (shape.hasStroke()) {
      this._stroke(shape);
    }
  }
  _stroke(shape) {
  }
  fillStrokeShape(shape) {
    if (shape.attrs.fillAfterStrokeEnabled) {
      this.strokeShape(shape);
      this.fillShape(shape);
    } else {
      this.fillShape(shape);
      this.strokeShape(shape);
    }
  }
  getTrace(relaxed, rounded) {
    var traceArr = this.traceArr, len2 = traceArr.length, str = "", n, trace, method4, args;
    for (n = 0; n < len2; n++) {
      trace = traceArr[n];
      method4 = trace.method;
      if (method4) {
        args = trace.args;
        str += method4;
        if (relaxed) {
          str += DOUBLE_PAREN;
        } else {
          if (Util_1$e.Util._isArray(args[0])) {
            str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
          } else {
            if (rounded) {
              args = args.map((a) => typeof a === "number" ? Math.floor(a) : a);
            }
            str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
          }
        }
      } else {
        str += trace.property;
        if (!relaxed) {
          str += EQUALS + trace.val;
        }
      }
      str += SEMICOLON;
    }
    return str;
  }
  clearTrace() {
    this.traceArr = [];
  }
  _trace(str) {
    var traceArr = this.traceArr, len2;
    traceArr.push(str);
    len2 = traceArr.length;
    if (len2 >= traceArrMax) {
      traceArr.shift();
    }
  }
  reset() {
    var pixelRatio = this.getCanvas().getPixelRatio();
    this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
  }
  getCanvas() {
    return this.canvas;
  }
  clear(bounds) {
    var canvas = this.getCanvas();
    if (bounds) {
      this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
    } else {
      this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
    }
  }
  _applyLineCap(shape) {
    const lineCap = shape.attrs.lineCap;
    if (lineCap) {
      this.setAttr("lineCap", lineCap);
    }
  }
  _applyOpacity(shape) {
    var absOpacity = shape.getAbsoluteOpacity();
    if (absOpacity !== 1) {
      this.setAttr("globalAlpha", absOpacity);
    }
  }
  _applyLineJoin(shape) {
    const lineJoin = shape.attrs.lineJoin;
    if (lineJoin) {
      this.setAttr("lineJoin", lineJoin);
    }
  }
  setAttr(attr, val) {
    this._context[attr] = val;
  }
  arc(x, y, radius, startAngle, endAngle, counterClockwise) {
    this._context.arc(x, y, radius, startAngle, endAngle, counterClockwise);
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._context.arcTo(x1, y1, x2, y2, radius);
  }
  beginPath() {
    this._context.beginPath();
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  clearRect(x, y, width, height) {
    this._context.clearRect(x, y, width, height);
  }
  clip(...args) {
    this._context.clip.apply(this._context, args);
  }
  closePath() {
    this._context.closePath();
  }
  createImageData(width, height) {
    var a = arguments;
    if (a.length === 2) {
      return this._context.createImageData(width, height);
    } else if (a.length === 1) {
      return this._context.createImageData(width);
    }
  }
  createLinearGradient(x0, y0, x1, y1) {
    return this._context.createLinearGradient(x0, y0, x1, y1);
  }
  createPattern(image, repetition) {
    return this._context.createPattern(image, repetition);
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);
  }
  drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
    var a = arguments, _context = this._context;
    if (a.length === 3) {
      _context.drawImage(image, sx, sy);
    } else if (a.length === 5) {
      _context.drawImage(image, sx, sy, sWidth, sHeight);
    } else if (a.length === 9) {
      _context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    }
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {
    this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise);
  }
  isPointInPath(x, y, path, fillRule) {
    if (path) {
      return this._context.isPointInPath(path, x, y, fillRule);
    }
    return this._context.isPointInPath(x, y, fillRule);
  }
  fill(...args) {
    this._context.fill.apply(this._context, args);
  }
  fillRect(x, y, width, height) {
    this._context.fillRect(x, y, width, height);
  }
  strokeRect(x, y, width, height) {
    this._context.strokeRect(x, y, width, height);
  }
  fillText(text, x, y, maxWidth) {
    if (maxWidth) {
      this._context.fillText(text, x, y, maxWidth);
    } else {
      this._context.fillText(text, x, y);
    }
  }
  measureText(text) {
    return this._context.measureText(text);
  }
  getImageData(sx, sy, sw, sh) {
    return this._context.getImageData(sx, sy, sw, sh);
  }
  lineTo(x, y) {
    this._context.lineTo(x, y);
  }
  moveTo(x, y) {
    this._context.moveTo(x, y);
  }
  rect(x, y, width, height) {
    this._context.rect(x, y, width, height);
  }
  roundRect(x, y, width, height, radii) {
    this._context.roundRect(x, y, width, height, radii);
  }
  putImageData(imageData, dx, dy) {
    this._context.putImageData(imageData, dx, dy);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this._context.quadraticCurveTo(cpx, cpy, x, y);
  }
  restore() {
    this._context.restore();
  }
  rotate(angle) {
    this._context.rotate(angle);
  }
  save() {
    this._context.save();
  }
  scale(x, y) {
    this._context.scale(x, y);
  }
  setLineDash(segments) {
    if (this._context.setLineDash) {
      this._context.setLineDash(segments);
    } else if ("mozDash" in this._context) {
      this._context["mozDash"] = segments;
    } else if ("webkitLineDash" in this._context) {
      this._context["webkitLineDash"] = segments;
    }
  }
  getLineDash() {
    return this._context.getLineDash();
  }
  setTransform(a, b, c2, d, e, f) {
    this._context.setTransform(a, b, c2, d, e, f);
  }
  stroke(path2d) {
    if (path2d) {
      this._context.stroke(path2d);
    } else {
      this._context.stroke();
    }
  }
  strokeText(text, x, y, maxWidth) {
    this._context.strokeText(text, x, y, maxWidth);
  }
  transform(a, b, c2, d, e, f) {
    this._context.transform(a, b, c2, d, e, f);
  }
  translate(x, y) {
    this._context.translate(x, y);
  }
  _enableTrace() {
    var that = this, len2 = CONTEXT_METHODS.length, origSetter = this.setAttr, n, args;
    var func2 = function(methodName) {
      var origMethod = that[methodName], ret;
      that[methodName] = function() {
        args = simplifyArray(Array.prototype.slice.call(arguments, 0));
        ret = origMethod.apply(that, arguments);
        that._trace({
          method: methodName,
          args
        });
        return ret;
      };
    };
    for (n = 0; n < len2; n++) {
      func2(CONTEXT_METHODS[n]);
    }
    that.setAttr = function() {
      origSetter.apply(that, arguments);
      var prop = arguments[0];
      var val = arguments[1];
      if (prop === "shadowOffsetX" || prop === "shadowOffsetY" || prop === "shadowBlur") {
        val = val / this.canvas.getPixelRatio();
      }
      that._trace({
        property: prop,
        val
      });
    };
  }
  _applyGlobalCompositeOperation(node) {
    const op = node.attrs.globalCompositeOperation;
    var def2 = !op || op === "source-over";
    if (!def2) {
      this.setAttr("globalCompositeOperation", op);
    }
  }
}
Context$1.Context = Context;
CONTEXT_PROPERTIES.forEach(function(prop) {
  Object.defineProperty(Context.prototype, prop, {
    get() {
      return this._context[prop];
    },
    set(val) {
      this._context[prop] = val;
    }
  });
});
class SceneContext extends Context {
  constructor(canvas, { willReadFrequently = false } = {}) {
    super(canvas);
    this._context = canvas._canvas.getContext("2d", {
      willReadFrequently
    });
  }
  _fillColor(shape) {
    var fill2 = shape.fill();
    this.setAttr("fillStyle", fill2);
    shape._fillFunc(this);
  }
  _fillPattern(shape) {
    this.setAttr("fillStyle", shape._getFillPattern());
    shape._fillFunc(this);
  }
  _fillLinearGradient(shape) {
    var grd = shape._getLinearGradient();
    if (grd) {
      this.setAttr("fillStyle", grd);
      shape._fillFunc(this);
    }
  }
  _fillRadialGradient(shape) {
    const grd = shape._getRadialGradient();
    if (grd) {
      this.setAttr("fillStyle", grd);
      shape._fillFunc(this);
    }
  }
  _fill(shape) {
    const hasColor = shape.fill(), fillPriority = shape.getFillPriority();
    if (hasColor && fillPriority === "color") {
      this._fillColor(shape);
      return;
    }
    const hasPattern = shape.getFillPatternImage();
    if (hasPattern && fillPriority === "pattern") {
      this._fillPattern(shape);
      return;
    }
    const hasLinearGradient = shape.getFillLinearGradientColorStops();
    if (hasLinearGradient && fillPriority === "linear-gradient") {
      this._fillLinearGradient(shape);
      return;
    }
    const hasRadialGradient = shape.getFillRadialGradientColorStops();
    if (hasRadialGradient && fillPriority === "radial-gradient") {
      this._fillRadialGradient(shape);
      return;
    }
    if (hasColor) {
      this._fillColor(shape);
    } else if (hasPattern) {
      this._fillPattern(shape);
    } else if (hasLinearGradient) {
      this._fillLinearGradient(shape);
    } else if (hasRadialGradient) {
      this._fillRadialGradient(shape);
    }
  }
  _strokeLinearGradient(shape) {
    const start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);
    if (colorStops) {
      for (var n = 0; n < colorStops.length; n += 2) {
        grd.addColorStop(colorStops[n], colorStops[n + 1]);
      }
      this.setAttr("strokeStyle", grd);
    }
  }
  _stroke(shape) {
    var dash = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();
    if (shape.hasStroke()) {
      if (!strokeScaleEnabled) {
        this.save();
        var pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      }
      this._applyLineCap(shape);
      if (dash && shape.dashEnabled()) {
        this.setLineDash(dash);
        this.setAttr("lineDashOffset", shape.dashOffset());
      }
      this.setAttr("lineWidth", shape.strokeWidth());
      if (!shape.getShadowForStrokeEnabled()) {
        this.setAttr("shadowColor", "rgba(0,0,0,0)");
      }
      var hasLinearGradient = shape.getStrokeLinearGradientColorStops();
      if (hasLinearGradient) {
        this._strokeLinearGradient(shape);
      } else {
        this.setAttr("strokeStyle", shape.stroke());
      }
      shape._strokeFunc(this);
      if (!strokeScaleEnabled) {
        this.restore();
      }
    }
  }
  _applyShadow(shape) {
    var _a, _b, _c;
    var color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : "black", blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {
      x: 0,
      y: 0
    }, scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;
    this.setAttr("shadowColor", color);
    this.setAttr("shadowBlur", blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));
    this.setAttr("shadowOffsetX", offset.x * scaleX);
    this.setAttr("shadowOffsetY", offset.y * scaleY);
  }
}
Context$1.SceneContext = SceneContext;
class HitContext extends Context {
  constructor(canvas) {
    super(canvas);
    this._context = canvas._canvas.getContext("2d", {
      willReadFrequently: true
    });
  }
  _fill(shape) {
    this.save();
    this.setAttr("fillStyle", shape.colorKey);
    shape._fillFuncHit(this);
    this.restore();
  }
  strokeShape(shape) {
    if (shape.hasHitStroke()) {
      this._stroke(shape);
    }
  }
  _stroke(shape) {
    if (shape.hasHitStroke()) {
      const strokeScaleEnabled = shape.getStrokeScaleEnabled();
      if (!strokeScaleEnabled) {
        this.save();
        var pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      }
      this._applyLineCap(shape);
      var hitStrokeWidth = shape.hitStrokeWidth();
      var strokeWidth = hitStrokeWidth === "auto" ? shape.strokeWidth() : hitStrokeWidth;
      this.setAttr("lineWidth", strokeWidth);
      this.setAttr("strokeStyle", shape.colorKey);
      shape._strokeFuncHit(this);
      if (!strokeScaleEnabled) {
        this.restore();
      }
    }
  }
}
Context$1.HitContext = HitContext;
Object.defineProperty(Canvas$1, "__esModule", { value: true });
Canvas$1.HitCanvas = Canvas$1.SceneCanvas = Canvas$1.Canvas = void 0;
const Util_1$d = Util;
const Context_1 = Context$1;
const Global_1$n = Global;
const Factory_1$z = Factory;
const Validators_1$y = Validators;
var _pixelRatio;
function getDevicePixelRatio() {
  if (_pixelRatio) {
    return _pixelRatio;
  }
  var canvas = Util_1$d.Util.createCanvasElement();
  var context = canvas.getContext("2d");
  _pixelRatio = function() {
    var devicePixelRatio2 = Global_1$n.Konva._global.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    return devicePixelRatio2 / backingStoreRatio;
  }();
  Util_1$d.Util.releaseCanvas(canvas);
  return _pixelRatio;
}
class Canvas {
  constructor(config) {
    this.pixelRatio = 1;
    this.width = 0;
    this.height = 0;
    this.isCache = false;
    var conf = config || {};
    var pixelRatio = conf.pixelRatio || Global_1$n.Konva.pixelRatio || getDevicePixelRatio();
    this.pixelRatio = pixelRatio;
    this._canvas = Util_1$d.Util.createCanvasElement();
    this._canvas.style.padding = "0";
    this._canvas.style.margin = "0";
    this._canvas.style.border = "0";
    this._canvas.style.background = "transparent";
    this._canvas.style.position = "absolute";
    this._canvas.style.top = "0";
    this._canvas.style.left = "0";
  }
  getContext() {
    return this.context;
  }
  getPixelRatio() {
    return this.pixelRatio;
  }
  setPixelRatio(pixelRatio) {
    var previousRatio = this.pixelRatio;
    this.pixelRatio = pixelRatio;
    this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
  }
  setWidth(width) {
    this.width = this._canvas.width = width * this.pixelRatio;
    this._canvas.style.width = width + "px";
    var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
    _context.scale(pixelRatio, pixelRatio);
  }
  setHeight(height) {
    this.height = this._canvas.height = height * this.pixelRatio;
    this._canvas.style.height = height + "px";
    var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
    _context.scale(pixelRatio, pixelRatio);
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setSize(width, height) {
    this.setWidth(width || 0);
    this.setHeight(height || 0);
  }
  toDataURL(mimeType, quality) {
    try {
      return this._canvas.toDataURL(mimeType, quality);
    } catch (e) {
      try {
        return this._canvas.toDataURL();
      } catch (err) {
        Util_1$d.Util.error("Unable to get data URL. " + err.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html.");
        return "";
      }
    }
  }
}
Canvas$1.Canvas = Canvas;
Factory_1$z.Factory.addGetterSetter(Canvas, "pixelRatio", void 0, (0, Validators_1$y.getNumberValidator)());
class SceneCanvas extends Canvas {
  constructor(config = { width: 0, height: 0, willReadFrequently: false }) {
    super(config);
    this.context = new Context_1.SceneContext(this, {
      willReadFrequently: config.willReadFrequently
    });
    this.setSize(config.width, config.height);
  }
}
Canvas$1.SceneCanvas = SceneCanvas;
class HitCanvas extends Canvas {
  constructor(config = { width: 0, height: 0 }) {
    super(config);
    this.hitCanvas = true;
    this.context = new Context_1.HitContext(this);
    this.setSize(config.width, config.height);
  }
}
Canvas$1.HitCanvas = HitCanvas;
var DragAndDrop = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DD = void 0;
  const Global_12 = Global;
  const Util_12 = Util;
  exports2.DD = {
    get isDragging() {
      var flag = false;
      exports2.DD._dragElements.forEach((elem) => {
        if (elem.dragStatus === "dragging") {
          flag = true;
        }
      });
      return flag;
    },
    justDragged: false,
    get node() {
      var node;
      exports2.DD._dragElements.forEach((elem) => {
        node = elem.node;
      });
      return node;
    },
    _dragElements: /* @__PURE__ */ new Map(),
    _drag(evt) {
      const nodesToFireEvents = [];
      exports2.DD._dragElements.forEach((elem, key) => {
        const { node } = elem;
        const stage = node.getStage();
        stage.setPointersPositions(evt);
        if (elem.pointerId === void 0) {
          elem.pointerId = Util_12.Util._getFirstPointerId(evt);
        }
        const pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
        if (!pos) {
          return;
        }
        if (elem.dragStatus !== "dragging") {
          var dragDistance = node.dragDistance();
          var distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));
          if (distance < dragDistance) {
            return;
          }
          node.startDrag({ evt });
          if (!node.isDragging()) {
            return;
          }
        }
        node._setDragPosition(evt, elem);
        nodesToFireEvents.push(node);
      });
      nodesToFireEvents.forEach((node) => {
        node.fire("dragmove", {
          type: "dragmove",
          target: node,
          evt
        }, true);
      });
    },
    _endDragBefore(evt) {
      const drawNodes = [];
      exports2.DD._dragElements.forEach((elem) => {
        const { node } = elem;
        const stage = node.getStage();
        if (evt) {
          stage.setPointersPositions(evt);
        }
        const pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
        if (!pos) {
          return;
        }
        if (elem.dragStatus === "dragging" || elem.dragStatus === "stopped") {
          exports2.DD.justDragged = true;
          Global_12.Konva._mouseListenClick = false;
          Global_12.Konva._touchListenClick = false;
          Global_12.Konva._pointerListenClick = false;
          elem.dragStatus = "stopped";
        }
        const drawNode = elem.node.getLayer() || elem.node instanceof Global_12.Konva["Stage"] && elem.node;
        if (drawNode && drawNodes.indexOf(drawNode) === -1) {
          drawNodes.push(drawNode);
        }
      });
      drawNodes.forEach((drawNode) => {
        drawNode.draw();
      });
    },
    _endDragAfter(evt) {
      exports2.DD._dragElements.forEach((elem, key) => {
        if (elem.dragStatus === "stopped") {
          elem.node.fire("dragend", {
            type: "dragend",
            target: elem.node,
            evt
          }, true);
        }
        if (elem.dragStatus !== "dragging") {
          exports2.DD._dragElements.delete(key);
        }
      });
    }
  };
  if (Global_12.Konva.isBrowser) {
    window.addEventListener("mouseup", exports2.DD._endDragBefore, true);
    window.addEventListener("touchend", exports2.DD._endDragBefore, true);
    window.addEventListener("mousemove", exports2.DD._drag);
    window.addEventListener("touchmove", exports2.DD._drag);
    window.addEventListener("mouseup", exports2.DD._endDragAfter, false);
    window.addEventListener("touchend", exports2.DD._endDragAfter, false);
  }
})(DragAndDrop);
Object.defineProperty(Node$1, "__esModule", { value: true });
Node$1.Node = void 0;
const Util_1$c = Util;
const Factory_1$y = Factory;
const Canvas_1$1 = Canvas$1;
const Global_1$m = Global;
const DragAndDrop_1 = DragAndDrop;
const Validators_1$x = Validators;
var ABSOLUTE_OPACITY = "absoluteOpacity", ALL_LISTENERS = "allEventListeners", ABSOLUTE_TRANSFORM = "absoluteTransform", ABSOLUTE_SCALE = "absoluteScale", CANVAS = "canvas", CHANGE = "Change", CHILDREN = "children", KONVA = "konva", LISTENING = "listening", MOUSEENTER = "mouseenter", MOUSELEAVE = "mouseleave", SET = "set", SHAPE = "Shape", SPACE$1 = " ", STAGE = "stage", TRANSFORM = "transform", UPPER_STAGE = "Stage", VISIBLE = "visible", TRANSFORM_CHANGE_STR$1 = [
  "xChange.konva",
  "yChange.konva",
  "scaleXChange.konva",
  "scaleYChange.konva",
  "skewXChange.konva",
  "skewYChange.konva",
  "rotationChange.konva",
  "offsetXChange.konva",
  "offsetYChange.konva",
  "transformsEnabledChange.konva"
].join(SPACE$1);
let idCounter = 1;
class Node {
  constructor(config) {
    this._id = idCounter++;
    this.eventListeners = {};
    this.attrs = {};
    this.index = 0;
    this._allEventListeners = null;
    this.parent = null;
    this._cache = /* @__PURE__ */ new Map();
    this._attachedDepsListeners = /* @__PURE__ */ new Map();
    this._lastPos = null;
    this._batchingTransformChange = false;
    this._needClearTransformCache = false;
    this._filterUpToDate = false;
    this._isUnderCache = false;
    this._dragEventId = null;
    this._shouldFireChangeEvents = false;
    this.setAttrs(config);
    this._shouldFireChangeEvents = true;
  }
  hasChildren() {
    return false;
  }
  _clearCache(attr) {
    if ((attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM) && this._cache.get(attr)) {
      this._cache.get(attr).dirty = true;
    } else if (attr) {
      this._cache.delete(attr);
    } else {
      this._cache.clear();
    }
  }
  _getCache(attr, privateGetter) {
    var cache2 = this._cache.get(attr);
    var isTransform = attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM;
    var invalid = cache2 === void 0 || isTransform && cache2.dirty === true;
    if (invalid) {
      cache2 = privateGetter.call(this);
      this._cache.set(attr, cache2);
    }
    return cache2;
  }
  _calculate(name, deps, getter) {
    if (!this._attachedDepsListeners.get(name)) {
      const depsString = deps.map((dep) => dep + "Change.konva").join(SPACE$1);
      this.on(depsString, () => {
        this._clearCache(name);
      });
      this._attachedDepsListeners.set(name, true);
    }
    return this._getCache(name, getter);
  }
  _getCanvasCache() {
    return this._cache.get(CANVAS);
  }
  _clearSelfAndDescendantCache(attr) {
    this._clearCache(attr);
    if (attr === ABSOLUTE_TRANSFORM) {
      this.fire("absoluteTransformChange");
    }
  }
  clearCache() {
    if (this._cache.has(CANVAS)) {
      const { scene, filter: filter2, hit } = this._cache.get(CANVAS);
      Util_1$c.Util.releaseCanvas(scene, filter2, hit);
      this._cache.delete(CANVAS);
    }
    this._clearSelfAndDescendantCache();
    this._requestDraw();
    return this;
  }
  cache(config) {
    var conf = config || {};
    var rect = {};
    if (conf.x === void 0 || conf.y === void 0 || conf.width === void 0 || conf.height === void 0) {
      rect = this.getClientRect({
        skipTransform: true,
        relativeTo: this.getParent() || void 0
      });
    }
    var width = Math.ceil(conf.width || rect.width), height = Math.ceil(conf.height || rect.height), pixelRatio = conf.pixelRatio, x = conf.x === void 0 ? Math.floor(rect.x) : conf.x, y = conf.y === void 0 ? Math.floor(rect.y) : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || false, hitCanvasPixelRatio = conf.hitCanvasPixelRatio || 1;
    if (!width || !height) {
      Util_1$c.Util.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
      return;
    }
    const extraPaddingX = Math.abs(Math.round(rect.x) - x) > 0.5 ? 1 : 0;
    const extraPaddingY = Math.abs(Math.round(rect.y) - y) > 0.5 ? 1 : 0;
    width += offset * 2 + extraPaddingX;
    height += offset * 2 + extraPaddingY;
    x -= offset;
    y -= offset;
    var cachedSceneCanvas = new Canvas_1$1.SceneCanvas({
      pixelRatio,
      width,
      height
    }), cachedFilterCanvas = new Canvas_1$1.SceneCanvas({
      pixelRatio,
      width: 0,
      height: 0,
      willReadFrequently: true
    }), cachedHitCanvas = new Canvas_1$1.HitCanvas({
      pixelRatio: hitCanvasPixelRatio,
      width,
      height
    }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();
    cachedHitCanvas.isCache = true;
    cachedSceneCanvas.isCache = true;
    this._cache.delete(CANVAS);
    this._filterUpToDate = false;
    if (conf.imageSmoothingEnabled === false) {
      cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = false;
      cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = false;
    }
    sceneContext.save();
    hitContext.save();
    sceneContext.translate(-x, -y);
    hitContext.translate(-x, -y);
    this._isUnderCache = true;
    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
    this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
    this.drawScene(cachedSceneCanvas, this);
    this.drawHit(cachedHitCanvas, this);
    this._isUnderCache = false;
    sceneContext.restore();
    hitContext.restore();
    if (drawBorder) {
      sceneContext.save();
      sceneContext.beginPath();
      sceneContext.rect(0, 0, width, height);
      sceneContext.closePath();
      sceneContext.setAttr("strokeStyle", "red");
      sceneContext.setAttr("lineWidth", 5);
      sceneContext.stroke();
      sceneContext.restore();
    }
    this._cache.set(CANVAS, {
      scene: cachedSceneCanvas,
      filter: cachedFilterCanvas,
      hit: cachedHitCanvas,
      x,
      y
    });
    this._requestDraw();
    return this;
  }
  isCached() {
    return this._cache.has(CANVAS);
  }
  getClientRect(config) {
    throw new Error('abstract "getClientRect" method call');
  }
  _transformedRect(rect, top) {
    var points = [
      { x: rect.x, y: rect.y },
      { x: rect.x + rect.width, y: rect.y },
      { x: rect.x + rect.width, y: rect.y + rect.height },
      { x: rect.x, y: rect.y + rect.height }
    ];
    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    var trans = this.getAbsoluteTransform(top);
    points.forEach(function(point) {
      var transformed = trans.point(point);
      if (minX === void 0) {
        minX = maxX = transformed.x;
        minY = maxY = transformed.y;
      }
      minX = Math.min(minX, transformed.x);
      minY = Math.min(minY, transformed.y);
      maxX = Math.max(maxX, transformed.x);
      maxY = Math.max(maxY, transformed.y);
    });
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  _drawCachedSceneCanvas(context) {
    context.save();
    context._applyOpacity(this);
    context._applyGlobalCompositeOperation(this);
    const canvasCache = this._getCanvasCache();
    context.translate(canvasCache.x, canvasCache.y);
    var cacheCanvas = this._getCachedSceneCanvas();
    var ratio = cacheCanvas.pixelRatio;
    context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);
    context.restore();
  }
  _drawCachedHitCanvas(context) {
    var canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;
    context.save();
    context.translate(canvasCache.x, canvasCache.y);
    context.drawImage(hitCanvas._canvas, 0, 0, hitCanvas.width / hitCanvas.pixelRatio, hitCanvas.height / hitCanvas.pixelRatio);
    context.restore();
  }
  _getCachedSceneCanvas() {
    var filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len2, imageData, n, filter2;
    if (filters) {
      if (!this._filterUpToDate) {
        var ratio = sceneCanvas.pixelRatio;
        filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);
        try {
          len2 = filters.length;
          filterContext.clear();
          filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
          imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());
          for (n = 0; n < len2; n++) {
            filter2 = filters[n];
            if (typeof filter2 !== "function") {
              Util_1$c.Util.error("Filter should be type of function, but got " + typeof filter2 + " instead. Please check correct filters");
              continue;
            }
            filter2.call(this, imageData);
            filterContext.putImageData(imageData, 0, 0);
          }
        } catch (e) {
          Util_1$c.Util.error("Unable to apply filter. " + e.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
        }
        this._filterUpToDate = true;
      }
      return filterCanvas;
    }
    return sceneCanvas;
  }
  on(evtStr, handler) {
    this._cache && this._cache.delete(ALL_LISTENERS);
    if (arguments.length === 3) {
      return this._delegate.apply(this, arguments);
    }
    var events2 = evtStr.split(SPACE$1), len2 = events2.length, n, event, parts, baseEvent, name;
    for (n = 0; n < len2; n++) {
      event = events2[n];
      parts = event.split(".");
      baseEvent = parts[0];
      name = parts[1] || "";
      if (!this.eventListeners[baseEvent]) {
        this.eventListeners[baseEvent] = [];
      }
      this.eventListeners[baseEvent].push({
        name,
        handler
      });
    }
    return this;
  }
  off(evtStr, callback) {
    var events2 = (evtStr || "").split(SPACE$1), len2 = events2.length, n, t, event, parts, baseEvent, name;
    this._cache && this._cache.delete(ALL_LISTENERS);
    if (!evtStr) {
      for (t in this.eventListeners) {
        this._off(t);
      }
    }
    for (n = 0; n < len2; n++) {
      event = events2[n];
      parts = event.split(".");
      baseEvent = parts[0];
      name = parts[1];
      if (baseEvent) {
        if (this.eventListeners[baseEvent]) {
          this._off(baseEvent, name, callback);
        }
      } else {
        for (t in this.eventListeners) {
          this._off(t, name, callback);
        }
      }
    }
    return this;
  }
  dispatchEvent(evt) {
    var e = {
      target: this,
      type: evt.type,
      evt
    };
    this.fire(evt.type, e);
    return this;
  }
  addEventListener(type4, handler) {
    this.on(type4, function(evt) {
      handler.call(this, evt.evt);
    });
    return this;
  }
  removeEventListener(type4) {
    this.off(type4);
    return this;
  }
  _delegate(event, selector, handler) {
    var stopNode = this;
    this.on(event, function(evt) {
      var targets = evt.target.findAncestors(selector, true, stopNode);
      for (var i = 0; i < targets.length; i++) {
        evt = Util_1$c.Util.cloneObject(evt);
        evt.currentTarget = targets[i];
        handler.call(targets[i], evt);
      }
    });
  }
  remove() {
    if (this.isDragging()) {
      this.stopDrag();
    }
    DragAndDrop_1.DD._dragElements.delete(this._id);
    this._remove();
    return this;
  }
  _clearCaches() {
    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
    this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
    this._clearSelfAndDescendantCache(STAGE);
    this._clearSelfAndDescendantCache(VISIBLE);
    this._clearSelfAndDescendantCache(LISTENING);
  }
  _remove() {
    this._clearCaches();
    var parent2 = this.getParent();
    if (parent2 && parent2.children) {
      parent2.children.splice(this.index, 1);
      parent2._setChildrenIndices();
      this.parent = null;
    }
  }
  destroy() {
    this.remove();
    this.clearCache();
    return this;
  }
  getAttr(attr) {
    var method4 = "get" + Util_1$c.Util._capitalize(attr);
    if (Util_1$c.Util._isFunction(this[method4])) {
      return this[method4]();
    }
    return this.attrs[attr];
  }
  getAncestors() {
    var parent2 = this.getParent(), ancestors = [];
    while (parent2) {
      ancestors.push(parent2);
      parent2 = parent2.getParent();
    }
    return ancestors;
  }
  getAttrs() {
    return this.attrs || {};
  }
  setAttrs(config) {
    this._batchTransformChanges(() => {
      var key, method4;
      if (!config) {
        return this;
      }
      for (key in config) {
        if (key === CHILDREN) {
          continue;
        }
        method4 = SET + Util_1$c.Util._capitalize(key);
        if (Util_1$c.Util._isFunction(this[method4])) {
          this[method4](config[key]);
        } else {
          this._setAttr(key, config[key]);
        }
      }
    });
    return this;
  }
  isListening() {
    return this._getCache(LISTENING, this._isListening);
  }
  _isListening(relativeTo) {
    const listening = this.listening();
    if (!listening) {
      return false;
    }
    const parent2 = this.getParent();
    if (parent2 && parent2 !== relativeTo && this !== relativeTo) {
      return parent2._isListening(relativeTo);
    } else {
      return true;
    }
  }
  isVisible() {
    return this._getCache(VISIBLE, this._isVisible);
  }
  _isVisible(relativeTo) {
    const visible = this.visible();
    if (!visible) {
      return false;
    }
    const parent2 = this.getParent();
    if (parent2 && parent2 !== relativeTo && this !== relativeTo) {
      return parent2._isVisible(relativeTo);
    } else {
      return true;
    }
  }
  shouldDrawHit(top, skipDragCheck = false) {
    if (top) {
      return this._isVisible(top) && this._isListening(top);
    }
    var layer = this.getLayer();
    var layerUnderDrag = false;
    DragAndDrop_1.DD._dragElements.forEach((elem) => {
      if (elem.dragStatus !== "dragging") {
        return;
      } else if (elem.node.nodeType === "Stage") {
        layerUnderDrag = true;
      } else if (elem.node.getLayer() === layer) {
        layerUnderDrag = true;
      }
    });
    var dragSkip = !skipDragCheck && !Global_1$m.Konva.hitOnDragEnabled && (layerUnderDrag || Global_1$m.Konva.isTransforming());
    return this.isListening() && this.isVisible() && !dragSkip;
  }
  show() {
    this.visible(true);
    return this;
  }
  hide() {
    this.visible(false);
    return this;
  }
  getZIndex() {
    return this.index || 0;
  }
  getAbsoluteZIndex() {
    var depth = this.getDepth(), that = this, index = 0, nodes, len2, n, child;
    function addChildren(children) {
      nodes = [];
      len2 = children.length;
      for (n = 0; n < len2; n++) {
        child = children[n];
        index++;
        if (child.nodeType !== SHAPE) {
          nodes = nodes.concat(child.getChildren().slice());
        }
        if (child._id === that._id) {
          n = len2;
        }
      }
      if (nodes.length > 0 && nodes[0].getDepth() <= depth) {
        addChildren(nodes);
      }
    }
    const stage = this.getStage();
    if (that.nodeType !== UPPER_STAGE && stage) {
      addChildren(stage.getChildren());
    }
    return index;
  }
  getDepth() {
    var depth = 0, parent2 = this.parent;
    while (parent2) {
      depth++;
      parent2 = parent2.parent;
    }
    return depth;
  }
  _batchTransformChanges(func2) {
    this._batchingTransformChange = true;
    func2();
    this._batchingTransformChange = false;
    if (this._needClearTransformCache) {
      this._clearCache(TRANSFORM);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    }
    this._needClearTransformCache = false;
  }
  setPosition(pos) {
    this._batchTransformChanges(() => {
      this.x(pos.x);
      this.y(pos.y);
    });
    return this;
  }
  getPosition() {
    return {
      x: this.x(),
      y: this.y()
    };
  }
  getRelativePointerPosition() {
    const stage = this.getStage();
    if (!stage) {
      return null;
    }
    var pos = stage.getPointerPosition();
    if (!pos) {
      return null;
    }
    var transform2 = this.getAbsoluteTransform().copy();
    transform2.invert();
    return transform2.point(pos);
  }
  getAbsolutePosition(top) {
    let haveCachedParent = false;
    let parent2 = this.parent;
    while (parent2) {
      if (parent2.isCached()) {
        haveCachedParent = true;
        break;
      }
      parent2 = parent2.parent;
    }
    if (haveCachedParent && !top) {
      top = true;
    }
    var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(), absoluteTransform = new Util_1$c.Transform(), offset = this.offset();
    absoluteTransform.m = absoluteMatrix.slice();
    absoluteTransform.translate(offset.x, offset.y);
    return absoluteTransform.getTranslation();
  }
  setAbsolutePosition(pos) {
    const { x, y, ...origTrans } = this._clearTransform();
    this.attrs.x = x;
    this.attrs.y = y;
    this._clearCache(TRANSFORM);
    var it = this._getAbsoluteTransform().copy();
    it.invert();
    it.translate(pos.x, pos.y);
    pos = {
      x: this.attrs.x + it.getTranslation().x,
      y: this.attrs.y + it.getTranslation().y
    };
    this._setTransform(origTrans);
    this.setPosition({ x: pos.x, y: pos.y });
    this._clearCache(TRANSFORM);
    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    return this;
  }
  _setTransform(trans) {
    var key;
    for (key in trans) {
      this.attrs[key] = trans[key];
    }
  }
  _clearTransform() {
    var trans = {
      x: this.x(),
      y: this.y(),
      rotation: this.rotation(),
      scaleX: this.scaleX(),
      scaleY: this.scaleY(),
      offsetX: this.offsetX(),
      offsetY: this.offsetY(),
      skewX: this.skewX(),
      skewY: this.skewY()
    };
    this.attrs.x = 0;
    this.attrs.y = 0;
    this.attrs.rotation = 0;
    this.attrs.scaleX = 1;
    this.attrs.scaleY = 1;
    this.attrs.offsetX = 0;
    this.attrs.offsetY = 0;
    this.attrs.skewX = 0;
    this.attrs.skewY = 0;
    return trans;
  }
  move(change) {
    var changeX = change.x, changeY = change.y, x = this.x(), y = this.y();
    if (changeX !== void 0) {
      x += changeX;
    }
    if (changeY !== void 0) {
      y += changeY;
    }
    this.setPosition({ x, y });
    return this;
  }
  _eachAncestorReverse(func2, top) {
    var family = [], parent2 = this.getParent(), len2, n;
    if (top && top._id === this._id) {
      return;
    }
    family.unshift(this);
    while (parent2 && (!top || parent2._id !== top._id)) {
      family.unshift(parent2);
      parent2 = parent2.parent;
    }
    len2 = family.length;
    for (n = 0; n < len2; n++) {
      func2(family[n]);
    }
  }
  rotate(theta) {
    this.rotation(this.rotation() + theta);
    return this;
  }
  moveToTop() {
    if (!this.parent) {
      Util_1$c.Util.warn("Node has no parent. moveToTop function is ignored.");
      return false;
    }
    var index = this.index, len2 = this.parent.getChildren().length;
    if (index < len2 - 1) {
      this.parent.children.splice(index, 1);
      this.parent.children.push(this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  moveUp() {
    if (!this.parent) {
      Util_1$c.Util.warn("Node has no parent. moveUp function is ignored.");
      return false;
    }
    var index = this.index, len2 = this.parent.getChildren().length;
    if (index < len2 - 1) {
      this.parent.children.splice(index, 1);
      this.parent.children.splice(index + 1, 0, this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  moveDown() {
    if (!this.parent) {
      Util_1$c.Util.warn("Node has no parent. moveDown function is ignored.");
      return false;
    }
    var index = this.index;
    if (index > 0) {
      this.parent.children.splice(index, 1);
      this.parent.children.splice(index - 1, 0, this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  moveToBottom() {
    if (!this.parent) {
      Util_1$c.Util.warn("Node has no parent. moveToBottom function is ignored.");
      return false;
    }
    var index = this.index;
    if (index > 0) {
      this.parent.children.splice(index, 1);
      this.parent.children.unshift(this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  setZIndex(zIndex) {
    if (!this.parent) {
      Util_1$c.Util.warn("Node has no parent. zIndex parameter is ignored.");
      return this;
    }
    if (zIndex < 0 || zIndex >= this.parent.children.length) {
      Util_1$c.Util.warn("Unexpected value " + zIndex + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
    }
    var index = this.index;
    this.parent.children.splice(index, 1);
    this.parent.children.splice(zIndex, 0, this);
    this.parent._setChildrenIndices();
    return this;
  }
  getAbsoluteOpacity() {
    return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
  }
  _getAbsoluteOpacity() {
    var absOpacity = this.opacity();
    var parent2 = this.getParent();
    if (parent2 && !parent2._isUnderCache) {
      absOpacity *= parent2.getAbsoluteOpacity();
    }
    return absOpacity;
  }
  moveTo(newContainer) {
    if (this.getParent() !== newContainer) {
      this._remove();
      newContainer.add(this);
    }
    return this;
  }
  toObject() {
    var attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;
    const obj = {
      attrs: {},
      className: this.getClassName()
    };
    for (key in attrs) {
      val = attrs[key];
      nonPlainObject = Util_1$c.Util.isObject(val) && !Util_1$c.Util._isPlainObject(val) && !Util_1$c.Util._isArray(val);
      if (nonPlainObject) {
        continue;
      }
      getter = typeof this[key] === "function" && this[key];
      delete attrs[key];
      defaultValue = getter ? getter.call(this) : null;
      attrs[key] = val;
      if (defaultValue !== val) {
        obj.attrs[key] = val;
      }
    }
    return Util_1$c.Util._prepareToStringify(obj);
  }
  toJSON() {
    return JSON.stringify(this.toObject());
  }
  getParent() {
    return this.parent;
  }
  findAncestors(selector, includeSelf, stopNode) {
    var res = [];
    if (includeSelf && this._isMatch(selector)) {
      res.push(this);
    }
    var ancestor = this.parent;
    while (ancestor) {
      if (ancestor === stopNode) {
        return res;
      }
      if (ancestor._isMatch(selector)) {
        res.push(ancestor);
      }
      ancestor = ancestor.parent;
    }
    return res;
  }
  isAncestorOf(node) {
    return false;
  }
  findAncestor(selector, includeSelf, stopNode) {
    return this.findAncestors(selector, includeSelf, stopNode)[0];
  }
  _isMatch(selector) {
    if (!selector) {
      return false;
    }
    if (typeof selector === "function") {
      return selector(this);
    }
    var selectorArr = selector.replace(/ /g, "").split(","), len2 = selectorArr.length, n, sel;
    for (n = 0; n < len2; n++) {
      sel = selectorArr[n];
      if (!Util_1$c.Util.isValidSelector(sel)) {
        Util_1$c.Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
        Util_1$c.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
        Util_1$c.Util.warn("Konva is awesome, right?");
      }
      if (sel.charAt(0) === "#") {
        if (this.id() === sel.slice(1)) {
          return true;
        }
      } else if (sel.charAt(0) === ".") {
        if (this.hasName(sel.slice(1))) {
          return true;
        }
      } else if (this.className === sel || this.nodeType === sel) {
        return true;
      }
    }
    return false;
  }
  getLayer() {
    var parent2 = this.getParent();
    return parent2 ? parent2.getLayer() : null;
  }
  getStage() {
    return this._getCache(STAGE, this._getStage);
  }
  _getStage() {
    var parent2 = this.getParent();
    if (parent2) {
      return parent2.getStage();
    } else {
      return null;
    }
  }
  fire(eventType, evt = {}, bubble) {
    evt.target = evt.target || this;
    if (bubble) {
      this._fireAndBubble(eventType, evt);
    } else {
      this._fire(eventType, evt);
    }
    return this;
  }
  getAbsoluteTransform(top) {
    if (top) {
      return this._getAbsoluteTransform(top);
    } else {
      return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
    }
  }
  _getAbsoluteTransform(top) {
    var at2;
    if (top) {
      at2 = new Util_1$c.Transform();
      this._eachAncestorReverse(function(node) {
        var transformsEnabled2 = node.transformsEnabled();
        if (transformsEnabled2 === "all") {
          at2.multiply(node.getTransform());
        } else if (transformsEnabled2 === "position") {
          at2.translate(node.x() - node.offsetX(), node.y() - node.offsetY());
        }
      }, top);
      return at2;
    } else {
      at2 = this._cache.get(ABSOLUTE_TRANSFORM) || new Util_1$c.Transform();
      if (this.parent) {
        this.parent.getAbsoluteTransform().copyInto(at2);
      } else {
        at2.reset();
      }
      var transformsEnabled = this.transformsEnabled();
      if (transformsEnabled === "all") {
        at2.multiply(this.getTransform());
      } else if (transformsEnabled === "position") {
        const x = this.attrs.x || 0;
        const y = this.attrs.y || 0;
        const offsetX = this.attrs.offsetX || 0;
        const offsetY = this.attrs.offsetY || 0;
        at2.translate(x - offsetX, y - offsetY);
      }
      at2.dirty = false;
      return at2;
    }
  }
  getAbsoluteScale(top) {
    var parent2 = this;
    while (parent2) {
      if (parent2._isUnderCache) {
        top = parent2;
      }
      parent2 = parent2.getParent();
    }
    const transform2 = this.getAbsoluteTransform(top);
    const attrs = transform2.decompose();
    return {
      x: attrs.scaleX,
      y: attrs.scaleY
    };
  }
  getAbsoluteRotation() {
    return this.getAbsoluteTransform().decompose().rotation;
  }
  getTransform() {
    return this._getCache(TRANSFORM, this._getTransform);
  }
  _getTransform() {
    var _a, _b;
    var m = this._cache.get(TRANSFORM) || new Util_1$c.Transform();
    m.reset();
    var x = this.x(), y = this.y(), rotation = Global_1$m.Konva.getAngle(this.rotation()), scaleX = (_a = this.attrs.scaleX) !== null && _a !== void 0 ? _a : 1, scaleY = (_b = this.attrs.scaleY) !== null && _b !== void 0 ? _b : 1, skewX = this.attrs.skewX || 0, skewY = this.attrs.skewY || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
    if (x !== 0 || y !== 0) {
      m.translate(x, y);
    }
    if (rotation !== 0) {
      m.rotate(rotation);
    }
    if (skewX !== 0 || skewY !== 0) {
      m.skew(skewX, skewY);
    }
    if (scaleX !== 1 || scaleY !== 1) {
      m.scale(scaleX, scaleY);
    }
    if (offsetX !== 0 || offsetY !== 0) {
      m.translate(-1 * offsetX, -1 * offsetY);
    }
    m.dirty = false;
    return m;
  }
  clone(obj) {
    var attrs = Util_1$c.Util.cloneObject(this.attrs), key, allListeners, len2, n, listener;
    for (key in obj) {
      attrs[key] = obj[key];
    }
    var node = new this.constructor(attrs);
    for (key in this.eventListeners) {
      allListeners = this.eventListeners[key];
      len2 = allListeners.length;
      for (n = 0; n < len2; n++) {
        listener = allListeners[n];
        if (listener.name.indexOf(KONVA) < 0) {
          if (!node.eventListeners[key]) {
            node.eventListeners[key] = [];
          }
          node.eventListeners[key].push(listener);
        }
      }
    }
    return node;
  }
  _toKonvaCanvas(config) {
    config = config || {};
    var box = this.getClientRect();
    var stage = this.getStage(), x = config.x !== void 0 ? config.x : Math.floor(box.x), y = config.y !== void 0 ? config.y : Math.floor(box.y), pixelRatio = config.pixelRatio || 1, canvas = new Canvas_1$1.SceneCanvas({
      width: config.width || Math.ceil(box.width) || (stage ? stage.width() : 0),
      height: config.height || Math.ceil(box.height) || (stage ? stage.height() : 0),
      pixelRatio
    }), context = canvas.getContext();
    const bufferCanvas = new Canvas_1$1.SceneCanvas({
      width: canvas.width / canvas.pixelRatio + Math.abs(x),
      height: canvas.height / canvas.pixelRatio + Math.abs(y),
      pixelRatio: canvas.pixelRatio
    });
    if (config.imageSmoothingEnabled === false) {
      context._context.imageSmoothingEnabled = false;
    }
    context.save();
    if (x || y) {
      context.translate(-1 * x, -1 * y);
    }
    this.drawScene(canvas, void 0, bufferCanvas);
    context.restore();
    return canvas;
  }
  toCanvas(config) {
    return this._toKonvaCanvas(config)._canvas;
  }
  toDataURL(config) {
    config = config || {};
    var mimeType = config.mimeType || null, quality = config.quality || null;
    var url2 = this._toKonvaCanvas(config).toDataURL(mimeType, quality);
    if (config.callback) {
      config.callback(url2);
    }
    return url2;
  }
  toImage(config) {
    return new Promise((resolve, reject2) => {
      try {
        const callback = config === null || config === void 0 ? void 0 : config.callback;
        if (callback)
          delete config.callback;
        Util_1$c.Util._urlToImage(this.toDataURL(config), function(img) {
          resolve(img);
          callback === null || callback === void 0 ? void 0 : callback(img);
        });
      } catch (err) {
        reject2(err);
      }
    });
  }
  toBlob(config) {
    return new Promise((resolve, reject2) => {
      try {
        const callback = config === null || config === void 0 ? void 0 : config.callback;
        if (callback)
          delete config.callback;
        this.toCanvas(config).toBlob((blob) => {
          resolve(blob);
          callback === null || callback === void 0 ? void 0 : callback(blob);
        }, config === null || config === void 0 ? void 0 : config.mimeType, config === null || config === void 0 ? void 0 : config.quality);
      } catch (err) {
        reject2(err);
      }
    });
  }
  setSize(size2) {
    this.width(size2.width);
    this.height(size2.height);
    return this;
  }
  getSize() {
    return {
      width: this.width(),
      height: this.height()
    };
  }
  getClassName() {
    return this.className || this.nodeType;
  }
  getType() {
    return this.nodeType;
  }
  getDragDistance() {
    if (this.attrs.dragDistance !== void 0) {
      return this.attrs.dragDistance;
    } else if (this.parent) {
      return this.parent.getDragDistance();
    } else {
      return Global_1$m.Konva.dragDistance;
    }
  }
  _off(type4, name, callback) {
    var evtListeners = this.eventListeners[type4], i, evtName, handler;
    for (i = 0; i < evtListeners.length; i++) {
      evtName = evtListeners[i].name;
      handler = evtListeners[i].handler;
      if ((evtName !== "konva" || name === "konva") && (!name || evtName === name) && (!callback || callback === handler)) {
        evtListeners.splice(i, 1);
        if (evtListeners.length === 0) {
          delete this.eventListeners[type4];
          break;
        }
        i--;
      }
    }
  }
  _fireChangeEvent(attr, oldVal, newVal) {
    this._fire(attr + CHANGE, {
      oldVal,
      newVal
    });
  }
  addName(name) {
    if (!this.hasName(name)) {
      var oldName = this.name();
      var newName = oldName ? oldName + " " + name : name;
      this.name(newName);
    }
    return this;
  }
  hasName(name) {
    if (!name) {
      return false;
    }
    const fullName = this.name();
    if (!fullName) {
      return false;
    }
    var names = (fullName || "").split(/\s/g);
    return names.indexOf(name) !== -1;
  }
  removeName(name) {
    var names = (this.name() || "").split(/\s/g);
    var index = names.indexOf(name);
    if (index !== -1) {
      names.splice(index, 1);
      this.name(names.join(" "));
    }
    return this;
  }
  setAttr(attr, val) {
    var func2 = this[SET + Util_1$c.Util._capitalize(attr)];
    if (Util_1$c.Util._isFunction(func2)) {
      func2.call(this, val);
    } else {
      this._setAttr(attr, val);
    }
    return this;
  }
  _requestDraw() {
    if (Global_1$m.Konva.autoDrawEnabled) {
      const drawNode = this.getLayer() || this.getStage();
      drawNode === null || drawNode === void 0 ? void 0 : drawNode.batchDraw();
    }
  }
  _setAttr(key, val) {
    var oldVal = this.attrs[key];
    if (oldVal === val && !Util_1$c.Util.isObject(val)) {
      return;
    }
    if (val === void 0 || val === null) {
      delete this.attrs[key];
    } else {
      this.attrs[key] = val;
    }
    if (this._shouldFireChangeEvents) {
      this._fireChangeEvent(key, oldVal, val);
    }
    this._requestDraw();
  }
  _setComponentAttr(key, component, val) {
    var oldVal;
    if (val !== void 0) {
      oldVal = this.attrs[key];
      if (!oldVal) {
        this.attrs[key] = this.getAttr(key);
      }
      this.attrs[key][component] = val;
      this._fireChangeEvent(key, oldVal, val);
    }
  }
  _fireAndBubble(eventType, evt, compareShape) {
    if (evt && this.nodeType === SHAPE) {
      evt.target = this;
    }
    var shouldStop = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && (compareShape && (this === compareShape || this.isAncestorOf && this.isAncestorOf(compareShape)) || this.nodeType === "Stage" && !compareShape);
    if (!shouldStop) {
      this._fire(eventType, evt);
      var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this) && !compareShape.isAncestorOf(this.parent);
      if ((evt && !evt.cancelBubble || !evt) && this.parent && this.parent.isListening() && !stopBubble) {
        if (compareShape && compareShape.parent) {
          this._fireAndBubble.call(this.parent, eventType, evt, compareShape);
        } else {
          this._fireAndBubble.call(this.parent, eventType, evt);
        }
      }
    }
  }
  _getProtoListeners(eventType) {
    var _a, _b, _c;
    const allListeners = (_a = this._cache.get(ALL_LISTENERS)) !== null && _a !== void 0 ? _a : {};
    let events2 = allListeners === null || allListeners === void 0 ? void 0 : allListeners[eventType];
    if (events2 === void 0) {
      events2 = [];
      let obj = Object.getPrototypeOf(this);
      while (obj) {
        const hierarchyEvents = (_c = (_b = obj.eventListeners) === null || _b === void 0 ? void 0 : _b[eventType]) !== null && _c !== void 0 ? _c : [];
        events2.push(...hierarchyEvents);
        obj = Object.getPrototypeOf(obj);
      }
      allListeners[eventType] = events2;
      this._cache.set(ALL_LISTENERS, allListeners);
    }
    return events2;
  }
  _fire(eventType, evt) {
    evt = evt || {};
    evt.currentTarget = this;
    evt.type = eventType;
    const topListeners = this._getProtoListeners(eventType);
    if (topListeners) {
      for (var i = 0; i < topListeners.length; i++) {
        topListeners[i].handler.call(this, evt);
      }
    }
    const selfListeners = this.eventListeners[eventType];
    if (selfListeners) {
      for (var i = 0; i < selfListeners.length; i++) {
        selfListeners[i].handler.call(this, evt);
      }
    }
  }
  draw() {
    this.drawScene();
    this.drawHit();
    return this;
  }
  _createDragElement(evt) {
    var pointerId = evt ? evt.pointerId : void 0;
    var stage = this.getStage();
    var ap = this.getAbsolutePosition();
    if (!stage) {
      return;
    }
    var pos = stage._getPointerById(pointerId) || stage._changedPointerPositions[0] || ap;
    DragAndDrop_1.DD._dragElements.set(this._id, {
      node: this,
      startPointerPos: pos,
      offset: {
        x: pos.x - ap.x,
        y: pos.y - ap.y
      },
      dragStatus: "ready",
      pointerId
    });
  }
  startDrag(evt, bubbleEvent = true) {
    if (!DragAndDrop_1.DD._dragElements.has(this._id)) {
      this._createDragElement(evt);
    }
    const elem = DragAndDrop_1.DD._dragElements.get(this._id);
    elem.dragStatus = "dragging";
    this.fire("dragstart", {
      type: "dragstart",
      target: this,
      evt: evt && evt.evt
    }, bubbleEvent);
  }
  _setDragPosition(evt, elem) {
    const pos = this.getStage()._getPointerById(elem.pointerId);
    if (!pos) {
      return;
    }
    var newNodePos = {
      x: pos.x - elem.offset.x,
      y: pos.y - elem.offset.y
    };
    var dbf = this.dragBoundFunc();
    if (dbf !== void 0) {
      const bounded = dbf.call(this, newNodePos, evt);
      if (!bounded) {
        Util_1$c.Util.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
      } else {
        newNodePos = bounded;
      }
    }
    if (!this._lastPos || this._lastPos.x !== newNodePos.x || this._lastPos.y !== newNodePos.y) {
      this.setAbsolutePosition(newNodePos);
      this._requestDraw();
    }
    this._lastPos = newNodePos;
  }
  stopDrag(evt) {
    const elem = DragAndDrop_1.DD._dragElements.get(this._id);
    if (elem) {
      elem.dragStatus = "stopped";
    }
    DragAndDrop_1.DD._endDragBefore(evt);
    DragAndDrop_1.DD._endDragAfter(evt);
  }
  setDraggable(draggable) {
    this._setAttr("draggable", draggable);
    this._dragChange();
  }
  isDragging() {
    const elem = DragAndDrop_1.DD._dragElements.get(this._id);
    return elem ? elem.dragStatus === "dragging" : false;
  }
  _listenDrag() {
    this._dragCleanup();
    this.on("mousedown.konva touchstart.konva", function(evt) {
      var shouldCheckButton = evt.evt["button"] !== void 0;
      var canDrag = !shouldCheckButton || Global_1$m.Konva.dragButtons.indexOf(evt.evt["button"]) >= 0;
      if (!canDrag) {
        return;
      }
      if (this.isDragging()) {
        return;
      }
      var hasDraggingChild = false;
      DragAndDrop_1.DD._dragElements.forEach((elem) => {
        if (this.isAncestorOf(elem.node)) {
          hasDraggingChild = true;
        }
      });
      if (!hasDraggingChild) {
        this._createDragElement(evt);
      }
    });
  }
  _dragChange() {
    if (this.attrs.draggable) {
      this._listenDrag();
    } else {
      this._dragCleanup();
      var stage = this.getStage();
      if (!stage) {
        return;
      }
      const dragElement = DragAndDrop_1.DD._dragElements.get(this._id);
      const isDragging = dragElement && dragElement.dragStatus === "dragging";
      const isReady = dragElement && dragElement.dragStatus === "ready";
      if (isDragging) {
        this.stopDrag();
      } else if (isReady) {
        DragAndDrop_1.DD._dragElements.delete(this._id);
      }
    }
  }
  _dragCleanup() {
    this.off("mousedown.konva");
    this.off("touchstart.konva");
  }
  isClientRectOnScreen(margin = { x: 0, y: 0 }) {
    const stage = this.getStage();
    if (!stage) {
      return false;
    }
    const screenRect = {
      x: -margin.x,
      y: -margin.y,
      width: stage.width() + 2 * margin.x,
      height: stage.height() + 2 * margin.y
    };
    return Util_1$c.Util.haveIntersection(screenRect, this.getClientRect());
  }
  static create(data, container) {
    if (Util_1$c.Util._isString(data)) {
      data = JSON.parse(data);
    }
    return this._createNode(data, container);
  }
  static _createNode(obj, container) {
    var className = Node.prototype.getClassName.call(obj), children = obj.children, no, len2, n;
    if (container) {
      obj.attrs.container = container;
    }
    if (!Global_1$m.Konva[className]) {
      Util_1$c.Util.warn('Can not find a node with class name "' + className + '". Fallback to "Shape".');
      className = "Shape";
    }
    const Class = Global_1$m.Konva[className];
    no = new Class(obj.attrs);
    if (children) {
      len2 = children.length;
      for (n = 0; n < len2; n++) {
        no.add(Node._createNode(children[n]));
      }
    }
    return no;
  }
}
Node$1.Node = Node;
Node.prototype.nodeType = "Node";
Node.prototype._attrsAffectingSize = [];
Node.prototype.eventListeners = {};
Node.prototype.on.call(Node.prototype, TRANSFORM_CHANGE_STR$1, function() {
  if (this._batchingTransformChange) {
    this._needClearTransformCache = true;
    return;
  }
  this._clearCache(TRANSFORM);
  this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
});
Node.prototype.on.call(Node.prototype, "visibleChange.konva", function() {
  this._clearSelfAndDescendantCache(VISIBLE);
});
Node.prototype.on.call(Node.prototype, "listeningChange.konva", function() {
  this._clearSelfAndDescendantCache(LISTENING);
});
Node.prototype.on.call(Node.prototype, "opacityChange.konva", function() {
  this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
});
const addGetterSetter = Factory_1$y.Factory.addGetterSetter;
addGetterSetter(Node, "zIndex");
addGetterSetter(Node, "absolutePosition");
addGetterSetter(Node, "position");
addGetterSetter(Node, "x", 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node, "y", 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node, "globalCompositeOperation", "source-over", (0, Validators_1$x.getStringValidator)());
addGetterSetter(Node, "opacity", 1, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node, "name", "", (0, Validators_1$x.getStringValidator)());
addGetterSetter(Node, "id", "", (0, Validators_1$x.getStringValidator)());
addGetterSetter(Node, "rotation", 0, (0, Validators_1$x.getNumberValidator)());
Factory_1$y.Factory.addComponentsGetterSetter(Node, "scale", ["x", "y"]);
addGetterSetter(Node, "scaleX", 1, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node, "scaleY", 1, (0, Validators_1$x.getNumberValidator)());
Factory_1$y.Factory.addComponentsGetterSetter(Node, "skew", ["x", "y"]);
addGetterSetter(Node, "skewX", 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node, "skewY", 0, (0, Validators_1$x.getNumberValidator)());
Factory_1$y.Factory.addComponentsGetterSetter(Node, "offset", ["x", "y"]);
addGetterSetter(Node, "offsetX", 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node, "offsetY", 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node, "dragDistance", null, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node, "width", 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node, "height", 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node, "listening", true, (0, Validators_1$x.getBooleanValidator)());
addGetterSetter(Node, "preventDefault", true, (0, Validators_1$x.getBooleanValidator)());
addGetterSetter(Node, "filters", null, function(val) {
  this._filterUpToDate = false;
  return val;
});
addGetterSetter(Node, "visible", true, (0, Validators_1$x.getBooleanValidator)());
addGetterSetter(Node, "transformsEnabled", "all", (0, Validators_1$x.getStringValidator)());
addGetterSetter(Node, "size");
addGetterSetter(Node, "dragBoundFunc");
addGetterSetter(Node, "draggable", false, (0, Validators_1$x.getBooleanValidator)());
Factory_1$y.Factory.backCompat(Node, {
  rotateDeg: "rotate",
  setRotationDeg: "setRotation",
  getRotationDeg: "getRotation"
});
var Container$1 = {};
Object.defineProperty(Container$1, "__esModule", { value: true });
Container$1.Container = void 0;
const Factory_1$x = Factory;
const Node_1$h = Node$1;
const Validators_1$w = Validators;
class Container extends Node_1$h.Node {
  constructor() {
    super(...arguments);
    this.children = [];
  }
  getChildren(filterFunc) {
    if (!filterFunc) {
      return this.children || [];
    }
    const children = this.children || [];
    var results = [];
    children.forEach(function(child) {
      if (filterFunc(child)) {
        results.push(child);
      }
    });
    return results;
  }
  hasChildren() {
    return this.getChildren().length > 0;
  }
  removeChildren() {
    this.getChildren().forEach((child) => {
      child.parent = null;
      child.index = 0;
      child.remove();
    });
    this.children = [];
    this._requestDraw();
    return this;
  }
  destroyChildren() {
    this.getChildren().forEach((child) => {
      child.parent = null;
      child.index = 0;
      child.destroy();
    });
    this.children = [];
    this._requestDraw();
    return this;
  }
  add(...children) {
    if (children.length === 0) {
      return this;
    }
    if (children.length > 1) {
      for (var i = 0; i < children.length; i++) {
        this.add(children[i]);
      }
      return this;
    }
    const child = children[0];
    if (child.getParent()) {
      child.moveTo(this);
      return this;
    }
    this._validateAdd(child);
    child.index = this.getChildren().length;
    child.parent = this;
    child._clearCaches();
    this.getChildren().push(child);
    this._fire("add", {
      child
    });
    this._requestDraw();
    return this;
  }
  destroy() {
    if (this.hasChildren()) {
      this.destroyChildren();
    }
    super.destroy();
    return this;
  }
  find(selector) {
    return this._generalFind(selector, false);
  }
  findOne(selector) {
    var result2 = this._generalFind(selector, true);
    return result2.length > 0 ? result2[0] : void 0;
  }
  _generalFind(selector, findOne) {
    var retArr = [];
    this._descendants((node) => {
      const valid = node._isMatch(selector);
      if (valid) {
        retArr.push(node);
      }
      if (valid && findOne) {
        return true;
      }
      return false;
    });
    return retArr;
  }
  _descendants(fn) {
    let shouldStop = false;
    const children = this.getChildren();
    for (const child of children) {
      shouldStop = fn(child);
      if (shouldStop) {
        return true;
      }
      if (!child.hasChildren()) {
        continue;
      }
      shouldStop = child._descendants(fn);
      if (shouldStop) {
        return true;
      }
    }
    return false;
  }
  toObject() {
    var obj = Node_1$h.Node.prototype.toObject.call(this);
    obj.children = [];
    this.getChildren().forEach((child) => {
      obj.children.push(child.toObject());
    });
    return obj;
  }
  isAncestorOf(node) {
    var parent2 = node.getParent();
    while (parent2) {
      if (parent2._id === this._id) {
        return true;
      }
      parent2 = parent2.getParent();
    }
    return false;
  }
  clone(obj) {
    var node = Node_1$h.Node.prototype.clone.call(this, obj);
    this.getChildren().forEach(function(no) {
      node.add(no.clone());
    });
    return node;
  }
  getAllIntersections(pos) {
    var arr = [];
    this.find("Shape").forEach((shape) => {
      if (shape.isVisible() && shape.intersects(pos)) {
        arr.push(shape);
      }
    });
    return arr;
  }
  _clearSelfAndDescendantCache(attr) {
    var _a;
    super._clearSelfAndDescendantCache(attr);
    if (this.isCached()) {
      return;
    }
    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function(node) {
      node._clearSelfAndDescendantCache(attr);
    });
  }
  _setChildrenIndices() {
    var _a;
    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function(child, n) {
      child.index = n;
    });
    this._requestDraw();
  }
  drawScene(can, top, bufferCanvas) {
    var layer = this.getLayer(), canvas = can || layer && layer.getCanvas(), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;
    var caching = canvas && canvas.isCache;
    if (!this.isVisible() && !caching) {
      return this;
    }
    if (cachedSceneCanvas) {
      context.save();
      var m = this.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._drawCachedSceneCanvas(context);
      context.restore();
    } else {
      this._drawChildren("drawScene", canvas, top, bufferCanvas);
    }
    return this;
  }
  drawHit(can, top) {
    if (!this.shouldDrawHit(top)) {
      return this;
    }
    var layer = this.getLayer(), canvas = can || layer && layer.hitCanvas, context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
    if (cachedHitCanvas) {
      context.save();
      var m = this.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._drawCachedHitCanvas(context);
      context.restore();
    } else {
      this._drawChildren("drawHit", canvas, top);
    }
    return this;
  }
  _drawChildren(drawMethod, canvas, top, bufferCanvas) {
    var _a;
    var context = canvas && canvas.getContext(), clipWidth = this.clipWidth(), clipHeight = this.clipHeight(), clipFunc = this.clipFunc(), hasClip = typeof clipWidth === "number" && typeof clipHeight === "number" || clipFunc;
    const selfCache = top === this;
    if (hasClip) {
      context.save();
      var transform2 = this.getAbsoluteTransform(top);
      var m = transform2.getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      context.beginPath();
      let clipArgs;
      if (clipFunc) {
        clipArgs = clipFunc.call(this, context, this);
      } else {
        var clipX = this.clipX();
        var clipY = this.clipY();
        context.rect(clipX || 0, clipY || 0, clipWidth, clipHeight);
      }
      context.clip.apply(context, clipArgs);
      m = transform2.copy().invert().getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    }
    var hasComposition = !selfCache && this.globalCompositeOperation() !== "source-over" && drawMethod === "drawScene";
    if (hasComposition) {
      context.save();
      context._applyGlobalCompositeOperation(this);
    }
    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      child[drawMethod](canvas, top, bufferCanvas);
    });
    if (hasComposition) {
      context.restore();
    }
    if (hasClip) {
      context.restore();
    }
  }
  getClientRect(config = {}) {
    var _a;
    var skipTransform = config.skipTransform;
    var relativeTo = config.relativeTo;
    var minX, minY, maxX, maxY;
    var selfRect = {
      x: Infinity,
      y: Infinity,
      width: 0,
      height: 0
    };
    var that = this;
    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      if (!child.visible()) {
        return;
      }
      var rect = child.getClientRect({
        relativeTo: that,
        skipShadow: config.skipShadow,
        skipStroke: config.skipStroke
      });
      if (rect.width === 0 && rect.height === 0) {
        return;
      }
      if (minX === void 0) {
        minX = rect.x;
        minY = rect.y;
        maxX = rect.x + rect.width;
        maxY = rect.y + rect.height;
      } else {
        minX = Math.min(minX, rect.x);
        minY = Math.min(minY, rect.y);
        maxX = Math.max(maxX, rect.x + rect.width);
        maxY = Math.max(maxY, rect.y + rect.height);
      }
    });
    var shapes = this.find("Shape");
    var hasVisible = false;
    for (var i = 0; i < shapes.length; i++) {
      var shape = shapes[i];
      if (shape._isVisible(this)) {
        hasVisible = true;
        break;
      }
    }
    if (hasVisible && minX !== void 0) {
      selfRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    } else {
      selfRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
    if (!skipTransform) {
      return this._transformedRect(selfRect, relativeTo);
    }
    return selfRect;
  }
}
Container$1.Container = Container;
Factory_1$x.Factory.addComponentsGetterSetter(Container, "clip", [
  "x",
  "y",
  "width",
  "height"
]);
Factory_1$x.Factory.addGetterSetter(Container, "clipX", void 0, (0, Validators_1$w.getNumberValidator)());
Factory_1$x.Factory.addGetterSetter(Container, "clipY", void 0, (0, Validators_1$w.getNumberValidator)());
Factory_1$x.Factory.addGetterSetter(Container, "clipWidth", void 0, (0, Validators_1$w.getNumberValidator)());
Factory_1$x.Factory.addGetterSetter(Container, "clipHeight", void 0, (0, Validators_1$w.getNumberValidator)());
Factory_1$x.Factory.addGetterSetter(Container, "clipFunc");
var Stage = {};
var PointerEvents = {};
Object.defineProperty(PointerEvents, "__esModule", { value: true });
PointerEvents.releaseCapture = PointerEvents.setPointerCapture = PointerEvents.hasPointerCapture = PointerEvents.createEvent = PointerEvents.getCapturedShape = void 0;
const Global_1$l = Global;
const Captures = /* @__PURE__ */ new Map();
const SUPPORT_POINTER_EVENTS = Global_1$l.Konva._global["PointerEvent"] !== void 0;
function getCapturedShape(pointerId) {
  return Captures.get(pointerId);
}
PointerEvents.getCapturedShape = getCapturedShape;
function createEvent(evt) {
  return {
    evt,
    pointerId: evt.pointerId
  };
}
PointerEvents.createEvent = createEvent;
function hasPointerCapture(pointerId, shape) {
  return Captures.get(pointerId) === shape;
}
PointerEvents.hasPointerCapture = hasPointerCapture;
function setPointerCapture(pointerId, shape) {
  releaseCapture(pointerId);
  const stage = shape.getStage();
  if (!stage)
    return;
  Captures.set(pointerId, shape);
  if (SUPPORT_POINTER_EVENTS) {
    shape._fire("gotpointercapture", createEvent(new PointerEvent("gotpointercapture")));
  }
}
PointerEvents.setPointerCapture = setPointerCapture;
function releaseCapture(pointerId, target) {
  const shape = Captures.get(pointerId);
  if (!shape)
    return;
  const stage = shape.getStage();
  if (stage && stage.content)
    ;
  Captures.delete(pointerId);
  if (SUPPORT_POINTER_EVENTS) {
    shape._fire("lostpointercapture", createEvent(new PointerEvent("lostpointercapture")));
  }
}
PointerEvents.releaseCapture = releaseCapture;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Stage = exports2.stages = void 0;
  const Util_12 = Util;
  const Factory_12 = Factory;
  const Container_12 = Container$1;
  const Global_12 = Global;
  const Canvas_12 = Canvas$1;
  const DragAndDrop_12 = DragAndDrop;
  const Global_22 = Global;
  const PointerEvents$1 = PointerEvents;
  var STAGE2 = "Stage", STRING = "string", PX = "px", MOUSEOUT = "mouseout", MOUSELEAVE2 = "mouseleave", MOUSEOVER = "mouseover", MOUSEENTER2 = "mouseenter", MOUSEMOVE = "mousemove", MOUSEDOWN = "mousedown", MOUSEUP = "mouseup", POINTERMOVE = "pointermove", POINTERDOWN = "pointerdown", POINTERUP = "pointerup", POINTERCANCEL = "pointercancel", LOSTPOINTERCAPTURE = "lostpointercapture", POINTEROUT = "pointerout", POINTERLEAVE = "pointerleave", POINTEROVER = "pointerover", POINTERENTER = "pointerenter", CONTEXTMENU = "contextmenu", TOUCHSTART = "touchstart", TOUCHEND = "touchend", TOUCHMOVE = "touchmove", TOUCHCANCEL = "touchcancel", WHEEL = "wheel", MAX_LAYERS_NUMBER = 5, EVENTS = [
    [MOUSEENTER2, "_pointerenter"],
    [MOUSEDOWN, "_pointerdown"],
    [MOUSEMOVE, "_pointermove"],
    [MOUSEUP, "_pointerup"],
    [MOUSELEAVE2, "_pointerleave"],
    [TOUCHSTART, "_pointerdown"],
    [TOUCHMOVE, "_pointermove"],
    [TOUCHEND, "_pointerup"],
    [TOUCHCANCEL, "_pointercancel"],
    [MOUSEOVER, "_pointerover"],
    [WHEEL, "_wheel"],
    [CONTEXTMENU, "_contextmenu"],
    [POINTERDOWN, "_pointerdown"],
    [POINTERMOVE, "_pointermove"],
    [POINTERUP, "_pointerup"],
    [POINTERCANCEL, "_pointercancel"],
    [LOSTPOINTERCAPTURE, "_lostpointercapture"]
  ];
  const EVENTS_MAP = {
    mouse: {
      [POINTEROUT]: MOUSEOUT,
      [POINTERLEAVE]: MOUSELEAVE2,
      [POINTEROVER]: MOUSEOVER,
      [POINTERENTER]: MOUSEENTER2,
      [POINTERMOVE]: MOUSEMOVE,
      [POINTERDOWN]: MOUSEDOWN,
      [POINTERUP]: MOUSEUP,
      [POINTERCANCEL]: "mousecancel",
      pointerclick: "click",
      pointerdblclick: "dblclick"
    },
    touch: {
      [POINTEROUT]: "touchout",
      [POINTERLEAVE]: "touchleave",
      [POINTEROVER]: "touchover",
      [POINTERENTER]: "touchenter",
      [POINTERMOVE]: TOUCHMOVE,
      [POINTERDOWN]: TOUCHSTART,
      [POINTERUP]: TOUCHEND,
      [POINTERCANCEL]: TOUCHCANCEL,
      pointerclick: "tap",
      pointerdblclick: "dbltap"
    },
    pointer: {
      [POINTEROUT]: POINTEROUT,
      [POINTERLEAVE]: POINTERLEAVE,
      [POINTEROVER]: POINTEROVER,
      [POINTERENTER]: POINTERENTER,
      [POINTERMOVE]: POINTERMOVE,
      [POINTERDOWN]: POINTERDOWN,
      [POINTERUP]: POINTERUP,
      [POINTERCANCEL]: POINTERCANCEL,
      pointerclick: "pointerclick",
      pointerdblclick: "pointerdblclick"
    }
  };
  const getEventType = (type4) => {
    if (type4.indexOf("pointer") >= 0) {
      return "pointer";
    }
    if (type4.indexOf("touch") >= 0) {
      return "touch";
    }
    return "mouse";
  };
  const getEventsMap = (eventType) => {
    const type4 = getEventType(eventType);
    if (type4 === "pointer") {
      return Global_12.Konva.pointerEventsEnabled && EVENTS_MAP.pointer;
    }
    if (type4 === "touch") {
      return EVENTS_MAP.touch;
    }
    if (type4 === "mouse") {
      return EVENTS_MAP.mouse;
    }
  };
  function checkNoClip(attrs = {}) {
    if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {
      Util_12.Util.warn("Stage does not support clipping. Please use clip for Layers or Groups.");
    }
    return attrs;
  }
  const NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;
  exports2.stages = [];
  class Stage2 extends Container_12.Container {
    constructor(config) {
      super(checkNoClip(config));
      this._pointerPositions = [];
      this._changedPointerPositions = [];
      this._buildDOM();
      this._bindContentEvents();
      exports2.stages.push(this);
      this.on("widthChange.konva heightChange.konva", this._resizeDOM);
      this.on("visibleChange.konva", this._checkVisibility);
      this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
        checkNoClip(this.attrs);
      });
      this._checkVisibility();
    }
    _validateAdd(child) {
      const isLayer = child.getType() === "Layer";
      const isFastLayer = child.getType() === "FastLayer";
      const valid = isLayer || isFastLayer;
      if (!valid) {
        Util_12.Util.throw("You may only add layers to the stage.");
      }
    }
    _checkVisibility() {
      if (!this.content) {
        return;
      }
      const style2 = this.visible() ? "" : "none";
      this.content.style.display = style2;
    }
    setContainer(container) {
      if (typeof container === STRING) {
        if (container.charAt(0) === ".") {
          var className = container.slice(1);
          container = document.getElementsByClassName(className)[0];
        } else {
          var id;
          if (container.charAt(0) !== "#") {
            id = container;
          } else {
            id = container.slice(1);
          }
          container = document.getElementById(id);
        }
        if (!container) {
          throw "Can not find container in document with id " + id;
        }
      }
      this._setAttr("container", container);
      if (this.content) {
        if (this.content.parentElement) {
          this.content.parentElement.removeChild(this.content);
        }
        container.appendChild(this.content);
      }
      return this;
    }
    shouldDrawHit() {
      return true;
    }
    clear() {
      var layers = this.children, len2 = layers.length, n;
      for (n = 0; n < len2; n++) {
        layers[n].clear();
      }
      return this;
    }
    clone(obj) {
      if (!obj) {
        obj = {};
      }
      obj.container = typeof document !== "undefined" && document.createElement("div");
      return Container_12.Container.prototype.clone.call(this, obj);
    }
    destroy() {
      super.destroy();
      var content = this.content;
      if (content && Util_12.Util._isInDocument(content)) {
        this.container().removeChild(content);
      }
      var index = exports2.stages.indexOf(this);
      if (index > -1) {
        exports2.stages.splice(index, 1);
      }
      Util_12.Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas);
      return this;
    }
    getPointerPosition() {
      const pos = this._pointerPositions[0] || this._changedPointerPositions[0];
      if (!pos) {
        Util_12.Util.warn(NO_POINTERS_MESSAGE);
        return null;
      }
      return {
        x: pos.x,
        y: pos.y
      };
    }
    _getPointerById(id) {
      return this._pointerPositions.find((p2) => p2.id === id);
    }
    getPointersPositions() {
      return this._pointerPositions;
    }
    getStage() {
      return this;
    }
    getContent() {
      return this.content;
    }
    _toKonvaCanvas(config) {
      config = config || {};
      config.x = config.x || 0;
      config.y = config.y || 0;
      config.width = config.width || this.width();
      config.height = config.height || this.height();
      var canvas = new Canvas_12.SceneCanvas({
        width: config.width,
        height: config.height,
        pixelRatio: config.pixelRatio || 1
      });
      var _context = canvas.getContext()._context;
      var layers = this.children;
      if (config.x || config.y) {
        _context.translate(-1 * config.x, -1 * config.y);
      }
      layers.forEach(function(layer) {
        if (!layer.isVisible()) {
          return;
        }
        var layerCanvas = layer._toKonvaCanvas(config);
        _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());
      });
      return canvas;
    }
    getIntersection(pos) {
      if (!pos) {
        return null;
      }
      var layers = this.children, len2 = layers.length, end = len2 - 1, n;
      for (n = end; n >= 0; n--) {
        const shape = layers[n].getIntersection(pos);
        if (shape) {
          return shape;
        }
      }
      return null;
    }
    _resizeDOM() {
      var width = this.width();
      var height = this.height();
      if (this.content) {
        this.content.style.width = width + PX;
        this.content.style.height = height + PX;
      }
      this.bufferCanvas.setSize(width, height);
      this.bufferHitCanvas.setSize(width, height);
      this.children.forEach((layer) => {
        layer.setSize({ width, height });
        layer.draw();
      });
    }
    add(layer, ...rest2) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      super.add(layer);
      var length = this.children.length;
      if (length > MAX_LAYERS_NUMBER) {
        Util_12.Util.warn("The stage has " + length + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.");
      }
      layer.setSize({ width: this.width(), height: this.height() });
      layer.draw();
      if (Global_12.Konva.isBrowser) {
        this.content.appendChild(layer.canvas._canvas);
      }
      return this;
    }
    getParent() {
      return null;
    }
    getLayer() {
      return null;
    }
    hasPointerCapture(pointerId) {
      return PointerEvents$1.hasPointerCapture(pointerId, this);
    }
    setPointerCapture(pointerId) {
      PointerEvents$1.setPointerCapture(pointerId, this);
    }
    releaseCapture(pointerId) {
      PointerEvents$1.releaseCapture(pointerId, this);
    }
    getLayers() {
      return this.children;
    }
    _bindContentEvents() {
      if (!Global_12.Konva.isBrowser) {
        return;
      }
      EVENTS.forEach(([event, methodName]) => {
        this.content.addEventListener(event, (evt) => {
          this[methodName](evt);
        }, { passive: false });
      });
    }
    _pointerenter(evt) {
      this.setPointersPositions(evt);
      const events2 = getEventsMap(evt.type);
      if (events2) {
        this._fire(events2.pointerenter, {
          evt,
          target: this,
          currentTarget: this
        });
      }
    }
    _pointerover(evt) {
      this.setPointersPositions(evt);
      const events2 = getEventsMap(evt.type);
      if (events2) {
        this._fire(events2.pointerover, {
          evt,
          target: this,
          currentTarget: this
        });
      }
    }
    _getTargetShape(evenType) {
      let shape = this[evenType + "targetShape"];
      if (shape && !shape.getStage()) {
        shape = null;
      }
      return shape;
    }
    _pointerleave(evt) {
      const events2 = getEventsMap(evt.type);
      const eventType = getEventType(evt.type);
      if (!events2) {
        return;
      }
      this.setPointersPositions(evt);
      var targetShape = this._getTargetShape(eventType);
      var eventsEnabled = !(Global_12.Konva.isDragging() || Global_12.Konva.isTransforming()) || Global_12.Konva.hitOnDragEnabled;
      if (targetShape && eventsEnabled) {
        targetShape._fireAndBubble(events2.pointerout, { evt });
        targetShape._fireAndBubble(events2.pointerleave, { evt });
        this._fire(events2.pointerleave, {
          evt,
          target: this,
          currentTarget: this
        });
        this[eventType + "targetShape"] = null;
      } else if (eventsEnabled) {
        this._fire(events2.pointerleave, {
          evt,
          target: this,
          currentTarget: this
        });
        this._fire(events2.pointerout, {
          evt,
          target: this,
          currentTarget: this
        });
      }
      this.pointerPos = null;
      this._pointerPositions = [];
    }
    _pointerdown(evt) {
      const events2 = getEventsMap(evt.type);
      const eventType = getEventType(evt.type);
      if (!events2) {
        return;
      }
      this.setPointersPositions(evt);
      var triggeredOnShape = false;
      this._changedPointerPositions.forEach((pos) => {
        var shape = this.getIntersection(pos);
        DragAndDrop_12.DD.justDragged = false;
        Global_12.Konva["_" + eventType + "ListenClick"] = true;
        if (!shape || !shape.isListening()) {
          this[eventType + "ClickStartShape"] = void 0;
          return;
        }
        if (Global_12.Konva.capturePointerEventsEnabled) {
          shape.setPointerCapture(pos.id);
        }
        this[eventType + "ClickStartShape"] = shape;
        shape._fireAndBubble(events2.pointerdown, {
          evt,
          pointerId: pos.id
        });
        triggeredOnShape = true;
        const isTouch = evt.type.indexOf("touch") >= 0;
        if (shape.preventDefault() && evt.cancelable && isTouch) {
          evt.preventDefault();
        }
      });
      if (!triggeredOnShape) {
        this._fire(events2.pointerdown, {
          evt,
          target: this,
          currentTarget: this,
          pointerId: this._pointerPositions[0].id
        });
      }
    }
    _pointermove(evt) {
      const events2 = getEventsMap(evt.type);
      const eventType = getEventType(evt.type);
      if (!events2) {
        return;
      }
      if (Global_12.Konva.isDragging() && DragAndDrop_12.DD.node.preventDefault() && evt.cancelable) {
        evt.preventDefault();
      }
      this.setPointersPositions(evt);
      var eventsEnabled = !(Global_12.Konva.isDragging() || Global_12.Konva.isTransforming()) || Global_12.Konva.hitOnDragEnabled;
      if (!eventsEnabled) {
        return;
      }
      var processedShapesIds = {};
      let triggeredOnShape = false;
      var targetShape = this._getTargetShape(eventType);
      this._changedPointerPositions.forEach((pos) => {
        const shape = PointerEvents$1.getCapturedShape(pos.id) || this.getIntersection(pos);
        const pointerId = pos.id;
        const event = { evt, pointerId };
        var differentTarget = targetShape !== shape;
        if (differentTarget && targetShape) {
          targetShape._fireAndBubble(events2.pointerout, { ...event }, shape);
          targetShape._fireAndBubble(events2.pointerleave, { ...event }, shape);
        }
        if (shape) {
          if (processedShapesIds[shape._id]) {
            return;
          }
          processedShapesIds[shape._id] = true;
        }
        if (shape && shape.isListening()) {
          triggeredOnShape = true;
          if (differentTarget) {
            shape._fireAndBubble(events2.pointerover, { ...event }, targetShape);
            shape._fireAndBubble(events2.pointerenter, { ...event }, targetShape);
            this[eventType + "targetShape"] = shape;
          }
          shape._fireAndBubble(events2.pointermove, { ...event });
        } else {
          if (targetShape) {
            this._fire(events2.pointerover, {
              evt,
              target: this,
              currentTarget: this,
              pointerId
            });
            this[eventType + "targetShape"] = null;
          }
        }
      });
      if (!triggeredOnShape) {
        this._fire(events2.pointermove, {
          evt,
          target: this,
          currentTarget: this,
          pointerId: this._changedPointerPositions[0].id
        });
      }
    }
    _pointerup(evt) {
      const events2 = getEventsMap(evt.type);
      const eventType = getEventType(evt.type);
      if (!events2) {
        return;
      }
      this.setPointersPositions(evt);
      const clickStartShape = this[eventType + "ClickStartShape"];
      const clickEndShape = this[eventType + "ClickEndShape"];
      var processedShapesIds = {};
      let triggeredOnShape = false;
      this._changedPointerPositions.forEach((pos) => {
        const shape = PointerEvents$1.getCapturedShape(pos.id) || this.getIntersection(pos);
        if (shape) {
          shape.releaseCapture(pos.id);
          if (processedShapesIds[shape._id]) {
            return;
          }
          processedShapesIds[shape._id] = true;
        }
        const pointerId = pos.id;
        const event = { evt, pointerId };
        let fireDblClick = false;
        if (Global_12.Konva["_" + eventType + "InDblClickWindow"]) {
          fireDblClick = true;
          clearTimeout(this[eventType + "DblTimeout"]);
        } else if (!DragAndDrop_12.DD.justDragged) {
          Global_12.Konva["_" + eventType + "InDblClickWindow"] = true;
          clearTimeout(this[eventType + "DblTimeout"]);
        }
        this[eventType + "DblTimeout"] = setTimeout(function() {
          Global_12.Konva["_" + eventType + "InDblClickWindow"] = false;
        }, Global_12.Konva.dblClickWindow);
        if (shape && shape.isListening()) {
          triggeredOnShape = true;
          this[eventType + "ClickEndShape"] = shape;
          shape._fireAndBubble(events2.pointerup, { ...event });
          if (Global_12.Konva["_" + eventType + "ListenClick"] && clickStartShape && clickStartShape === shape) {
            shape._fireAndBubble(events2.pointerclick, { ...event });
            if (fireDblClick && clickEndShape && clickEndShape === shape) {
              shape._fireAndBubble(events2.pointerdblclick, { ...event });
            }
          }
        } else {
          this[eventType + "ClickEndShape"] = null;
          if (Global_12.Konva["_" + eventType + "ListenClick"]) {
            this._fire(events2.pointerclick, {
              evt,
              target: this,
              currentTarget: this,
              pointerId
            });
          }
          if (fireDblClick) {
            this._fire(events2.pointerdblclick, {
              evt,
              target: this,
              currentTarget: this,
              pointerId
            });
          }
        }
      });
      if (!triggeredOnShape) {
        this._fire(events2.pointerup, {
          evt,
          target: this,
          currentTarget: this,
          pointerId: this._changedPointerPositions[0].id
        });
      }
      Global_12.Konva["_" + eventType + "ListenClick"] = false;
      if (evt.cancelable && eventType !== "touch") {
        evt.preventDefault();
      }
    }
    _contextmenu(evt) {
      this.setPointersPositions(evt);
      var shape = this.getIntersection(this.getPointerPosition());
      if (shape && shape.isListening()) {
        shape._fireAndBubble(CONTEXTMENU, { evt });
      } else {
        this._fire(CONTEXTMENU, {
          evt,
          target: this,
          currentTarget: this
        });
      }
    }
    _wheel(evt) {
      this.setPointersPositions(evt);
      var shape = this.getIntersection(this.getPointerPosition());
      if (shape && shape.isListening()) {
        shape._fireAndBubble(WHEEL, { evt });
      } else {
        this._fire(WHEEL, {
          evt,
          target: this,
          currentTarget: this
        });
      }
    }
    _pointercancel(evt) {
      this.setPointersPositions(evt);
      const shape = PointerEvents$1.getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());
      if (shape) {
        shape._fireAndBubble(POINTERUP, PointerEvents$1.createEvent(evt));
      }
      PointerEvents$1.releaseCapture(evt.pointerId);
    }
    _lostpointercapture(evt) {
      PointerEvents$1.releaseCapture(evt.pointerId);
    }
    setPointersPositions(evt) {
      var contentPosition = this._getContentPosition(), x = null, y = null;
      evt = evt ? evt : window.event;
      if (evt.touches !== void 0) {
        this._pointerPositions = [];
        this._changedPointerPositions = [];
        Array.prototype.forEach.call(evt.touches, (touch) => {
          this._pointerPositions.push({
            id: touch.identifier,
            x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
            y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
          });
        });
        Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {
          this._changedPointerPositions.push({
            id: touch.identifier,
            x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
            y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
          });
        });
      } else {
        x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;
        y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;
        this.pointerPos = {
          x,
          y
        };
        this._pointerPositions = [{ x, y, id: Util_12.Util._getFirstPointerId(evt) }];
        this._changedPointerPositions = [
          { x, y, id: Util_12.Util._getFirstPointerId(evt) }
        ];
      }
    }
    _setPointerPosition(evt) {
      Util_12.Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.');
      this.setPointersPositions(evt);
    }
    _getContentPosition() {
      if (!this.content || !this.content.getBoundingClientRect) {
        return {
          top: 0,
          left: 0,
          scaleX: 1,
          scaleY: 1
        };
      }
      var rect = this.content.getBoundingClientRect();
      return {
        top: rect.top,
        left: rect.left,
        scaleX: rect.width / this.content.clientWidth || 1,
        scaleY: rect.height / this.content.clientHeight || 1
      };
    }
    _buildDOM() {
      this.bufferCanvas = new Canvas_12.SceneCanvas({
        width: this.width(),
        height: this.height()
      });
      this.bufferHitCanvas = new Canvas_12.HitCanvas({
        pixelRatio: 1,
        width: this.width(),
        height: this.height()
      });
      if (!Global_12.Konva.isBrowser) {
        return;
      }
      var container = this.container();
      if (!container) {
        throw "Stage has no container. A container is required.";
      }
      container.innerHTML = "";
      this.content = document.createElement("div");
      this.content.style.position = "relative";
      this.content.style.userSelect = "none";
      this.content.className = "konvajs-content";
      this.content.setAttribute("role", "presentation");
      container.appendChild(this.content);
      this._resizeDOM();
    }
    cache() {
      Util_12.Util.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.");
      return this;
    }
    clearCache() {
      return this;
    }
    batchDraw() {
      this.getChildren().forEach(function(layer) {
        layer.batchDraw();
      });
      return this;
    }
  }
  exports2.Stage = Stage2;
  Stage2.prototype.nodeType = STAGE2;
  (0, Global_22._registerNode)(Stage2);
  Factory_12.Factory.addGetterSetter(Stage2, "container");
  if (Global_12.Konva.isBrowser) {
    document.addEventListener("visibilitychange", () => {
      exports2.stages.forEach((stage) => {
        stage.batchDraw();
      });
    });
  }
})(Stage);
var Layer$1 = {};
var Shape = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Shape = exports2.shapes = void 0;
  const Global_12 = Global;
  const Util_12 = Util;
  const Factory_12 = Factory;
  const Node_12 = Node$1;
  const Validators_12 = Validators;
  const Global_22 = Global;
  const PointerEvents$1 = PointerEvents;
  var HAS_SHADOW = "hasShadow";
  var SHADOW_RGBA = "shadowRGBA";
  var patternImage = "patternImage";
  var linearGradient = "linearGradient";
  var radialGradient = "radialGradient";
  let dummyContext2;
  function getDummyContext2() {
    if (dummyContext2) {
      return dummyContext2;
    }
    dummyContext2 = Util_12.Util.createCanvasElement().getContext("2d");
    return dummyContext2;
  }
  exports2.shapes = {};
  function _fillFunc2(context) {
    const fillRule = this.attrs.fillRule;
    if (fillRule) {
      context.fill(fillRule);
    } else {
      context.fill();
    }
  }
  function _strokeFunc2(context) {
    context.stroke();
  }
  function _fillFuncHit(context) {
    const fillRule = this.attrs.fillRule;
    if (fillRule) {
      context.fill(fillRule);
    } else {
      context.fill();
    }
  }
  function _strokeFuncHit(context) {
    context.stroke();
  }
  function _clearHasShadowCache() {
    this._clearCache(HAS_SHADOW);
  }
  function _clearGetShadowRGBACache() {
    this._clearCache(SHADOW_RGBA);
  }
  function _clearFillPatternCache() {
    this._clearCache(patternImage);
  }
  function _clearLinearGradientCache() {
    this._clearCache(linearGradient);
  }
  function _clearRadialGradientCache() {
    this._clearCache(radialGradient);
  }
  class Shape2 extends Node_12.Node {
    constructor(config) {
      super(config);
      let key;
      while (true) {
        key = Util_12.Util.getRandomColor();
        if (key && !(key in exports2.shapes)) {
          break;
        }
      }
      this.colorKey = key;
      exports2.shapes[key] = this;
    }
    getContext() {
      Util_12.Util.warn("shape.getContext() method is deprecated. Please do not use it.");
      return this.getLayer().getContext();
    }
    getCanvas() {
      Util_12.Util.warn("shape.getCanvas() method is deprecated. Please do not use it.");
      return this.getLayer().getCanvas();
    }
    getSceneFunc() {
      return this.attrs.sceneFunc || this["_sceneFunc"];
    }
    getHitFunc() {
      return this.attrs.hitFunc || this["_hitFunc"];
    }
    hasShadow() {
      return this._getCache(HAS_SHADOW, this._hasShadow);
    }
    _hasShadow() {
      return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
    }
    _getFillPattern() {
      return this._getCache(patternImage, this.__getFillPattern);
    }
    __getFillPattern() {
      if (this.fillPatternImage()) {
        var ctx2 = getDummyContext2();
        const pattern4 = ctx2.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
        if (pattern4 && pattern4.setTransform) {
          const tr = new Util_12.Transform();
          tr.translate(this.fillPatternX(), this.fillPatternY());
          tr.rotate(Global_12.Konva.getAngle(this.fillPatternRotation()));
          tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());
          tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
          const m = tr.getMatrix();
          const matrix = typeof DOMMatrix === "undefined" ? {
            a: m[0],
            b: m[1],
            c: m[2],
            d: m[3],
            e: m[4],
            f: m[5]
          } : new DOMMatrix(m);
          pattern4.setTransform(matrix);
        }
        return pattern4;
      }
    }
    _getLinearGradient() {
      return this._getCache(linearGradient, this.__getLinearGradient);
    }
    __getLinearGradient() {
      var colorStops = this.fillLinearGradientColorStops();
      if (colorStops) {
        var ctx2 = getDummyContext2();
        var start = this.fillLinearGradientStartPoint();
        var end = this.fillLinearGradientEndPoint();
        var grd = ctx2.createLinearGradient(start.x, start.y, end.x, end.y);
        for (var n = 0; n < colorStops.length; n += 2) {
          grd.addColorStop(colorStops[n], colorStops[n + 1]);
        }
        return grd;
      }
    }
    _getRadialGradient() {
      return this._getCache(radialGradient, this.__getRadialGradient);
    }
    __getRadialGradient() {
      var colorStops = this.fillRadialGradientColorStops();
      if (colorStops) {
        var ctx2 = getDummyContext2();
        var start = this.fillRadialGradientStartPoint();
        var end = this.fillRadialGradientEndPoint();
        var grd = ctx2.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());
        for (var n = 0; n < colorStops.length; n += 2) {
          grd.addColorStop(colorStops[n], colorStops[n + 1]);
        }
        return grd;
      }
    }
    getShadowRGBA() {
      return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
    }
    _getShadowRGBA() {
      if (!this.hasShadow()) {
        return;
      }
      var rgba2 = Util_12.Util.colorToRGBA(this.shadowColor());
      if (rgba2) {
        return "rgba(" + rgba2.r + "," + rgba2.g + "," + rgba2.b + "," + rgba2.a * (this.shadowOpacity() || 1) + ")";
      }
    }
    hasFill() {
      return this._calculate("hasFill", [
        "fillEnabled",
        "fill",
        "fillPatternImage",
        "fillLinearGradientColorStops",
        "fillRadialGradientColorStops"
      ], () => {
        return this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops());
      });
    }
    hasStroke() {
      return this._calculate("hasStroke", [
        "strokeEnabled",
        "strokeWidth",
        "stroke",
        "strokeLinearGradientColorStops"
      ], () => {
        return this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops());
      });
    }
    hasHitStroke() {
      const width = this.hitStrokeWidth();
      if (width === "auto") {
        return this.hasStroke();
      }
      return this.strokeEnabled() && !!width;
    }
    intersects(point) {
      var stage = this.getStage();
      if (!stage) {
        return false;
      }
      const bufferHitCanvas = stage.bufferHitCanvas;
      bufferHitCanvas.getContext().clear();
      this.drawHit(bufferHitCanvas, void 0, true);
      const p2 = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
      return p2[3] > 0;
    }
    destroy() {
      Node_12.Node.prototype.destroy.call(this);
      delete exports2.shapes[this.colorKey];
      delete this.colorKey;
      return this;
    }
    _useBufferCanvas(forceFill) {
      var _a;
      const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;
      if (!perfectDrawEnabled) {
        return false;
      }
      const hasFill = forceFill || this.hasFill();
      const hasStroke = this.hasStroke();
      const isTransparent = this.getAbsoluteOpacity() !== 1;
      if (hasFill && hasStroke && isTransparent) {
        return true;
      }
      const hasShadow = this.hasShadow();
      const strokeForShadow = this.shadowForStrokeEnabled();
      if (hasFill && hasStroke && hasShadow && strokeForShadow) {
        return true;
      }
      return false;
    }
    setStrokeHitEnabled(val) {
      Util_12.Util.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.");
      if (val) {
        this.hitStrokeWidth("auto");
      } else {
        this.hitStrokeWidth(0);
      }
    }
    getStrokeHitEnabled() {
      if (this.hitStrokeWidth() === 0) {
        return false;
      } else {
        return true;
      }
    }
    getSelfRect() {
      var size2 = this.size();
      return {
        x: this._centroid ? -size2.width / 2 : 0,
        y: this._centroid ? -size2.height / 2 : 0,
        width: size2.width,
        height: size2.height
      };
    }
    getClientRect(config = {}) {
      let hasCachedParent = false;
      let parent2 = this.getParent();
      while (parent2) {
        if (parent2.isCached()) {
          hasCachedParent = true;
          break;
        }
        parent2 = parent2.getParent();
      }
      const skipTransform = config.skipTransform;
      const relativeTo = config.relativeTo || hasCachedParent && this.getStage() || void 0;
      const fillRect = this.getSelfRect();
      const applyStroke = !config.skipStroke && this.hasStroke();
      const strokeWidth = applyStroke && this.strokeWidth() || 0;
      const fillAndStrokeWidth = fillRect.width + strokeWidth;
      const fillAndStrokeHeight = fillRect.height + strokeWidth;
      const applyShadow = !config.skipShadow && this.hasShadow();
      const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;
      const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;
      const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
      const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);
      const blurRadius = applyShadow && this.shadowBlur() || 0;
      const width = preWidth + blurRadius * 2;
      const height = preHeight + blurRadius * 2;
      const rect = {
        width,
        height,
        x: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,
        y: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y
      };
      if (!skipTransform) {
        return this._transformedRect(rect, relativeTo);
      }
      return rect;
    }
    drawScene(can, top, bufferCanvas) {
      var layer = this.getLayer();
      var canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferContext;
      var skipBuffer = canvas.isCache;
      var cachingSelf = top === this;
      if (!this.isVisible() && !cachingSelf) {
        return this;
      }
      if (cachedCanvas) {
        context.save();
        var m = this.getAbsoluteTransform(top).getMatrix();
        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        this._drawCachedSceneCanvas(context);
        context.restore();
        return this;
      }
      if (!drawFunc) {
        return this;
      }
      context.save();
      if (this._useBufferCanvas() && !skipBuffer) {
        stage = this.getStage();
        const bc = bufferCanvas || stage.bufferCanvas;
        bufferContext = bc.getContext();
        bufferContext.clear();
        bufferContext.save();
        bufferContext._applyLineJoin(this);
        var o = this.getAbsoluteTransform(top).getMatrix();
        bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
        drawFunc.call(this, bufferContext, this);
        bufferContext.restore();
        var ratio = bc.pixelRatio;
        if (hasShadow) {
          context._applyShadow(this);
        }
        context._applyOpacity(this);
        context._applyGlobalCompositeOperation(this);
        context.drawImage(bc._canvas, 0, 0, bc.width / ratio, bc.height / ratio);
      } else {
        context._applyLineJoin(this);
        if (!cachingSelf) {
          var o = this.getAbsoluteTransform(top).getMatrix();
          context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
          context._applyOpacity(this);
          context._applyGlobalCompositeOperation(this);
        }
        if (hasShadow) {
          context._applyShadow(this);
        }
        drawFunc.call(this, context, this);
      }
      context.restore();
      return this;
    }
    drawHit(can, top, skipDragCheck = false) {
      if (!this.shouldDrawHit(top, skipDragCheck)) {
        return this;
      }
      var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
      if (!this.colorKey) {
        Util_12.Util.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()");
      }
      if (cachedHitCanvas) {
        context.save();
        var m = this.getAbsoluteTransform(top).getMatrix();
        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        this._drawCachedHitCanvas(context);
        context.restore();
        return this;
      }
      if (!drawFunc) {
        return this;
      }
      context.save();
      context._applyLineJoin(this);
      const selfCache = this === top;
      if (!selfCache) {
        var o = this.getAbsoluteTransform(top).getMatrix();
        context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
      }
      drawFunc.call(this, context, this);
      context.restore();
      return this;
    }
    drawHitFromCache(alphaThreshold = 0) {
      var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len2, rgbColorKey, i, alpha;
      hitContext.clear();
      hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);
      try {
        hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
        hitData = hitImageData.data;
        len2 = hitData.length;
        rgbColorKey = Util_12.Util._hexToRgb(this.colorKey);
        for (i = 0; i < len2; i += 4) {
          alpha = hitData[i + 3];
          if (alpha > alphaThreshold) {
            hitData[i] = rgbColorKey.r;
            hitData[i + 1] = rgbColorKey.g;
            hitData[i + 2] = rgbColorKey.b;
            hitData[i + 3] = 255;
          } else {
            hitData[i + 3] = 0;
          }
        }
        hitContext.putImageData(hitImageData, 0, 0);
      } catch (e) {
        Util_12.Util.error("Unable to draw hit graph from cached scene canvas. " + e.message);
      }
      return this;
    }
    hasPointerCapture(pointerId) {
      return PointerEvents$1.hasPointerCapture(pointerId, this);
    }
    setPointerCapture(pointerId) {
      PointerEvents$1.setPointerCapture(pointerId, this);
    }
    releaseCapture(pointerId) {
      PointerEvents$1.releaseCapture(pointerId, this);
    }
  }
  exports2.Shape = Shape2;
  Shape2.prototype._fillFunc = _fillFunc2;
  Shape2.prototype._strokeFunc = _strokeFunc2;
  Shape2.prototype._fillFuncHit = _fillFuncHit;
  Shape2.prototype._strokeFuncHit = _strokeFuncHit;
  Shape2.prototype._centroid = false;
  Shape2.prototype.nodeType = "Shape";
  (0, Global_22._registerNode)(Shape2);
  Shape2.prototype.eventListeners = {};
  Shape2.prototype.on.call(Shape2.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearHasShadowCache);
  Shape2.prototype.on.call(Shape2.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearGetShadowRGBACache);
  Shape2.prototype.on.call(Shape2.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", _clearFillPatternCache);
  Shape2.prototype.on.call(Shape2.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", _clearLinearGradientCache);
  Shape2.prototype.on.call(Shape2.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", _clearRadialGradientCache);
  Factory_12.Factory.addGetterSetter(Shape2, "stroke", void 0, (0, Validators_12.getStringOrGradientValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "strokeWidth", 2, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "fillAfterStrokeEnabled", false);
  Factory_12.Factory.addGetterSetter(Shape2, "hitStrokeWidth", "auto", (0, Validators_12.getNumberOrAutoValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "strokeHitEnabled", true, (0, Validators_12.getBooleanValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "perfectDrawEnabled", true, (0, Validators_12.getBooleanValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "shadowForStrokeEnabled", true, (0, Validators_12.getBooleanValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "lineJoin");
  Factory_12.Factory.addGetterSetter(Shape2, "lineCap");
  Factory_12.Factory.addGetterSetter(Shape2, "sceneFunc");
  Factory_12.Factory.addGetterSetter(Shape2, "hitFunc");
  Factory_12.Factory.addGetterSetter(Shape2, "dash");
  Factory_12.Factory.addGetterSetter(Shape2, "dashOffset", 0, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "shadowColor", void 0, (0, Validators_12.getStringValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "shadowBlur", 0, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "shadowOpacity", 1, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addComponentsGetterSetter(Shape2, "shadowOffset", ["x", "y"]);
  Factory_12.Factory.addGetterSetter(Shape2, "shadowOffsetX", 0, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "shadowOffsetY", 0, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "fillPatternImage");
  Factory_12.Factory.addGetterSetter(Shape2, "fill", void 0, (0, Validators_12.getStringOrGradientValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "fillPatternX", 0, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "fillPatternY", 0, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "fillLinearGradientColorStops");
  Factory_12.Factory.addGetterSetter(Shape2, "strokeLinearGradientColorStops");
  Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientStartRadius", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientEndRadius", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientColorStops");
  Factory_12.Factory.addGetterSetter(Shape2, "fillPatternRepeat", "repeat");
  Factory_12.Factory.addGetterSetter(Shape2, "fillEnabled", true);
  Factory_12.Factory.addGetterSetter(Shape2, "strokeEnabled", true);
  Factory_12.Factory.addGetterSetter(Shape2, "shadowEnabled", true);
  Factory_12.Factory.addGetterSetter(Shape2, "dashEnabled", true);
  Factory_12.Factory.addGetterSetter(Shape2, "strokeScaleEnabled", true);
  Factory_12.Factory.addGetterSetter(Shape2, "fillPriority", "color");
  Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillPatternOffset", ["x", "y"]);
  Factory_12.Factory.addGetterSetter(Shape2, "fillPatternOffsetX", 0, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "fillPatternOffsetY", 0, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillPatternScale", ["x", "y"]);
  Factory_12.Factory.addGetterSetter(Shape2, "fillPatternScaleX", 1, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addGetterSetter(Shape2, "fillPatternScaleY", 1, (0, Validators_12.getNumberValidator)());
  Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillLinearGradientStartPoint", [
    "x",
    "y"
  ]);
  Factory_12.Factory.addComponentsGetterSetter(Shape2, "strokeLinearGradientStartPoint", [
    "x",
    "y"
  ]);
  Factory_12.Factory.addGetterSetter(Shape2, "fillLinearGradientStartPointX", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "strokeLinearGradientStartPointX", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "fillLinearGradientStartPointY", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "strokeLinearGradientStartPointY", 0);
  Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillLinearGradientEndPoint", [
    "x",
    "y"
  ]);
  Factory_12.Factory.addComponentsGetterSetter(Shape2, "strokeLinearGradientEndPoint", [
    "x",
    "y"
  ]);
  Factory_12.Factory.addGetterSetter(Shape2, "fillLinearGradientEndPointX", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "strokeLinearGradientEndPointX", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "fillLinearGradientEndPointY", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "strokeLinearGradientEndPointY", 0);
  Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillRadialGradientStartPoint", [
    "x",
    "y"
  ]);
  Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientStartPointX", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientStartPointY", 0);
  Factory_12.Factory.addComponentsGetterSetter(Shape2, "fillRadialGradientEndPoint", [
    "x",
    "y"
  ]);
  Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientEndPointX", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "fillRadialGradientEndPointY", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "fillPatternRotation", 0);
  Factory_12.Factory.addGetterSetter(Shape2, "fillRule", void 0, (0, Validators_12.getStringValidator)());
  Factory_12.Factory.backCompat(Shape2, {
    dashArray: "dash",
    getDashArray: "getDash",
    setDashArray: "getDash",
    drawFunc: "sceneFunc",
    getDrawFunc: "getSceneFunc",
    setDrawFunc: "setSceneFunc",
    drawHitFunc: "hitFunc",
    getDrawHitFunc: "getHitFunc",
    setDrawHitFunc: "setHitFunc"
  });
})(Shape);
Object.defineProperty(Layer$1, "__esModule", { value: true });
Layer$1.Layer = void 0;
const Util_1$b = Util;
const Container_1$1 = Container$1;
const Node_1$g = Node$1;
const Factory_1$w = Factory;
const Canvas_1 = Canvas$1;
const Validators_1$v = Validators;
const Shape_1$g = Shape;
const Global_1$k = Global;
var HASH = "#", BEFORE_DRAW = "beforeDraw", DRAW = "draw", INTERSECTION_OFFSETS = [
  { x: 0, y: 0 },
  { x: -1, y: -1 },
  { x: 1, y: -1 },
  { x: 1, y: 1 },
  { x: -1, y: 1 }
], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;
class Layer extends Container_1$1.Container {
  constructor(config) {
    super(config);
    this.canvas = new Canvas_1.SceneCanvas();
    this.hitCanvas = new Canvas_1.HitCanvas({
      pixelRatio: 1
    });
    this._waitingForDraw = false;
    this.on("visibleChange.konva", this._checkVisibility);
    this._checkVisibility();
    this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled);
    this._setSmoothEnabled();
  }
  createPNGStream() {
    const c2 = this.canvas._canvas;
    return c2.createPNGStream();
  }
  getCanvas() {
    return this.canvas;
  }
  getNativeCanvasElement() {
    return this.canvas._canvas;
  }
  getHitCanvas() {
    return this.hitCanvas;
  }
  getContext() {
    return this.getCanvas().getContext();
  }
  clear(bounds) {
    this.getContext().clear(bounds);
    this.getHitCanvas().getContext().clear(bounds);
    return this;
  }
  setZIndex(index) {
    super.setZIndex(index);
    var stage = this.getStage();
    if (stage && stage.content) {
      stage.content.removeChild(this.getNativeCanvasElement());
      if (index < stage.children.length - 1) {
        stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);
      } else {
        stage.content.appendChild(this.getNativeCanvasElement());
      }
    }
    return this;
  }
  moveToTop() {
    Node_1$g.Node.prototype.moveToTop.call(this);
    var stage = this.getStage();
    if (stage && stage.content) {
      stage.content.removeChild(this.getNativeCanvasElement());
      stage.content.appendChild(this.getNativeCanvasElement());
    }
    return true;
  }
  moveUp() {
    var moved = Node_1$g.Node.prototype.moveUp.call(this);
    if (!moved) {
      return false;
    }
    var stage = this.getStage();
    if (!stage || !stage.content) {
      return false;
    }
    stage.content.removeChild(this.getNativeCanvasElement());
    if (this.index < stage.children.length - 1) {
      stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);
    } else {
      stage.content.appendChild(this.getNativeCanvasElement());
    }
    return true;
  }
  moveDown() {
    if (Node_1$g.Node.prototype.moveDown.call(this)) {
      var stage = this.getStage();
      if (stage) {
        var children = stage.children;
        if (stage.content) {
          stage.content.removeChild(this.getNativeCanvasElement());
          stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);
        }
      }
      return true;
    }
    return false;
  }
  moveToBottom() {
    if (Node_1$g.Node.prototype.moveToBottom.call(this)) {
      var stage = this.getStage();
      if (stage) {
        var children = stage.children;
        if (stage.content) {
          stage.content.removeChild(this.getNativeCanvasElement());
          stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);
        }
      }
      return true;
    }
    return false;
  }
  getLayer() {
    return this;
  }
  remove() {
    var _canvas = this.getNativeCanvasElement();
    Node_1$g.Node.prototype.remove.call(this);
    if (_canvas && _canvas.parentNode && Util_1$b.Util._isInDocument(_canvas)) {
      _canvas.parentNode.removeChild(_canvas);
    }
    return this;
  }
  getStage() {
    return this.parent;
  }
  setSize({ width, height }) {
    this.canvas.setSize(width, height);
    this.hitCanvas.setSize(width, height);
    this._setSmoothEnabled();
    return this;
  }
  _validateAdd(child) {
    var type4 = child.getType();
    if (type4 !== "Group" && type4 !== "Shape") {
      Util_1$b.Util.throw("You may only add groups and shapes to a layer.");
    }
  }
  _toKonvaCanvas(config) {
    config = config || {};
    config.width = config.width || this.getWidth();
    config.height = config.height || this.getHeight();
    config.x = config.x !== void 0 ? config.x : this.x();
    config.y = config.y !== void 0 ? config.y : this.y();
    return Node_1$g.Node.prototype._toKonvaCanvas.call(this, config);
  }
  _checkVisibility() {
    const visible = this.visible();
    if (visible) {
      this.canvas._canvas.style.display = "block";
    } else {
      this.canvas._canvas.style.display = "none";
    }
  }
  _setSmoothEnabled() {
    this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
  }
  getWidth() {
    if (this.parent) {
      return this.parent.width();
    }
  }
  setWidth() {
    Util_1$b.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
  }
  getHeight() {
    if (this.parent) {
      return this.parent.height();
    }
  }
  setHeight() {
    Util_1$b.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
  }
  batchDraw() {
    if (!this._waitingForDraw) {
      this._waitingForDraw = true;
      Util_1$b.Util.requestAnimFrame(() => {
        this.draw();
        this._waitingForDraw = false;
      });
    }
    return this;
  }
  getIntersection(pos) {
    if (!this.isListening() || !this.isVisible()) {
      return null;
    }
    var spiralSearchDistance = 1;
    var continueSearch = false;
    while (true) {
      for (let i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
        const intersectionOffset = INTERSECTION_OFFSETS[i];
        const obj = this._getIntersection({
          x: pos.x + intersectionOffset.x * spiralSearchDistance,
          y: pos.y + intersectionOffset.y * spiralSearchDistance
        });
        const shape = obj.shape;
        if (shape) {
          return shape;
        }
        continueSearch = !!obj.antialiased;
        if (!obj.antialiased) {
          break;
        }
      }
      if (continueSearch) {
        spiralSearchDistance += 1;
      } else {
        return null;
      }
    }
  }
  _getIntersection(pos) {
    const ratio = this.hitCanvas.pixelRatio;
    const p2 = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;
    const p3 = p2[3];
    if (p3 === 255) {
      const colorKey = Util_1$b.Util._rgbToHex(p2[0], p2[1], p2[2]);
      const shape = Shape_1$g.shapes[HASH + colorKey];
      if (shape) {
        return {
          shape
        };
      }
      return {
        antialiased: true
      };
    } else if (p3 > 0) {
      return {
        antialiased: true
      };
    }
    return {};
  }
  drawScene(can, top) {
    var layer = this.getLayer(), canvas = can || layer && layer.getCanvas();
    this._fire(BEFORE_DRAW, {
      node: this
    });
    if (this.clearBeforeDraw()) {
      canvas.getContext().clear();
    }
    Container_1$1.Container.prototype.drawScene.call(this, canvas, top);
    this._fire(DRAW, {
      node: this
    });
    return this;
  }
  drawHit(can, top) {
    var layer = this.getLayer(), canvas = can || layer && layer.hitCanvas;
    if (layer && layer.clearBeforeDraw()) {
      layer.getHitCanvas().getContext().clear();
    }
    Container_1$1.Container.prototype.drawHit.call(this, canvas, top);
    return this;
  }
  enableHitGraph() {
    this.hitGraphEnabled(true);
    return this;
  }
  disableHitGraph() {
    this.hitGraphEnabled(false);
    return this;
  }
  setHitGraphEnabled(val) {
    Util_1$b.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead.");
    this.listening(val);
  }
  getHitGraphEnabled(val) {
    Util_1$b.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead.");
    return this.listening();
  }
  toggleHitCanvas() {
    if (!this.parent || !this.parent["content"]) {
      return;
    }
    var parent2 = this.parent;
    var added = !!this.hitCanvas._canvas.parentNode;
    if (added) {
      parent2.content.removeChild(this.hitCanvas._canvas);
    } else {
      parent2.content.appendChild(this.hitCanvas._canvas);
    }
  }
  destroy() {
    Util_1$b.Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas);
    return super.destroy();
  }
}
Layer$1.Layer = Layer;
Layer.prototype.nodeType = "Layer";
(0, Global_1$k._registerNode)(Layer);
Factory_1$w.Factory.addGetterSetter(Layer, "imageSmoothingEnabled", true);
Factory_1$w.Factory.addGetterSetter(Layer, "clearBeforeDraw", true);
Factory_1$w.Factory.addGetterSetter(Layer, "hitGraphEnabled", true, (0, Validators_1$v.getBooleanValidator)());
var FastLayer$1 = {};
Object.defineProperty(FastLayer$1, "__esModule", { value: true });
FastLayer$1.FastLayer = void 0;
const Util_1$a = Util;
const Layer_1 = Layer$1;
const Global_1$j = Global;
class FastLayer extends Layer_1.Layer {
  constructor(attrs) {
    super(attrs);
    this.listening(false);
    Util_1$a.Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
  }
}
FastLayer$1.FastLayer = FastLayer;
FastLayer.prototype.nodeType = "FastLayer";
(0, Global_1$j._registerNode)(FastLayer);
var Group$1 = {};
Object.defineProperty(Group$1, "__esModule", { value: true });
Group$1.Group = void 0;
const Util_1$9 = Util;
const Container_1 = Container$1;
const Global_1$i = Global;
class Group extends Container_1.Container {
  _validateAdd(child) {
    var type4 = child.getType();
    if (type4 !== "Group" && type4 !== "Shape") {
      Util_1$9.Util.throw("You may only add groups and shapes to groups.");
    }
  }
}
Group$1.Group = Group;
Group.prototype.nodeType = "Group";
(0, Global_1$i._registerNode)(Group);
var Animation$1 = {};
Object.defineProperty(Animation$1, "__esModule", { value: true });
Animation$1.Animation = void 0;
const Global_1$h = Global;
const Util_1$8 = Util;
const now = function() {
  if (Global_1$h.glob.performance && Global_1$h.glob.performance.now) {
    return function() {
      return Global_1$h.glob.performance.now();
    };
  }
  return function() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
}();
class Animation {
  constructor(func2, layers) {
    this.id = Animation.animIdCounter++;
    this.frame = {
      time: 0,
      timeDiff: 0,
      lastTime: now(),
      frameRate: 0
    };
    this.func = func2;
    this.setLayers(layers);
  }
  setLayers(layers) {
    let lays = [];
    if (layers) {
      lays = Array.isArray(layers) ? layers : [layers];
    }
    this.layers = lays;
    return this;
  }
  getLayers() {
    return this.layers;
  }
  addLayer(layer) {
    const layers = this.layers;
    const len2 = layers.length;
    for (let n = 0; n < len2; n++) {
      if (layers[n]._id === layer._id) {
        return false;
      }
    }
    this.layers.push(layer);
    return true;
  }
  isRunning() {
    const a = Animation;
    const animations = a.animations;
    const len2 = animations.length;
    for (let n = 0; n < len2; n++) {
      if (animations[n].id === this.id) {
        return true;
      }
    }
    return false;
  }
  start() {
    this.stop();
    this.frame.timeDiff = 0;
    this.frame.lastTime = now();
    Animation._addAnimation(this);
    return this;
  }
  stop() {
    Animation._removeAnimation(this);
    return this;
  }
  _updateFrameObject(time2) {
    this.frame.timeDiff = time2 - this.frame.lastTime;
    this.frame.lastTime = time2;
    this.frame.time += this.frame.timeDiff;
    this.frame.frameRate = 1e3 / this.frame.timeDiff;
  }
  static _addAnimation(anim) {
    this.animations.push(anim);
    this._handleAnimation();
  }
  static _removeAnimation(anim) {
    const id = anim.id;
    const animations = this.animations;
    const len2 = animations.length;
    for (let n = 0; n < len2; n++) {
      if (animations[n].id === id) {
        this.animations.splice(n, 1);
        break;
      }
    }
  }
  static _runFrames() {
    const layerHash = {};
    const animations = this.animations;
    for (let n = 0; n < animations.length; n++) {
      const anim = animations[n];
      const layers = anim.layers;
      const func2 = anim.func;
      anim._updateFrameObject(now());
      const layersLen = layers.length;
      let needRedraw;
      if (func2) {
        needRedraw = func2.call(anim, anim.frame) !== false;
      } else {
        needRedraw = true;
      }
      if (!needRedraw) {
        continue;
      }
      for (let i = 0; i < layersLen; i++) {
        const layer = layers[i];
        if (layer._id !== void 0) {
          layerHash[layer._id] = layer;
        }
      }
    }
    for (let key in layerHash) {
      if (!layerHash.hasOwnProperty(key)) {
        continue;
      }
      layerHash[key].batchDraw();
    }
  }
  static _animationLoop() {
    const Anim = Animation;
    if (Anim.animations.length) {
      Anim._runFrames();
      Util_1$8.Util.requestAnimFrame(Anim._animationLoop);
    } else {
      Anim.animRunning = false;
    }
  }
  static _handleAnimation() {
    if (!this.animRunning) {
      this.animRunning = true;
      Util_1$8.Util.requestAnimFrame(this._animationLoop);
    }
  }
}
Animation$1.Animation = Animation;
Animation.animations = [];
Animation.animIdCounter = 0;
Animation.animRunning = false;
var Tween = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Easings = exports2.Tween = void 0;
  const Util_12 = Util;
  const Animation_12 = Animation$1;
  const Node_12 = Node$1;
  const Global_12 = Global;
  var blacklist = {
    node: 1,
    duration: 1,
    easing: 1,
    onFinish: 1,
    yoyo: 1
  }, PAUSED = 1, PLAYING = 2, REVERSING = 3, idCounter2 = 0, colorAttrs = ["fill", "stroke", "shadowColor"];
  class TweenEngine {
    constructor(prop, propFunc, func2, begin, finish, duration2, yoyo) {
      this.prop = prop;
      this.propFunc = propFunc;
      this.begin = begin;
      this._pos = begin;
      this.duration = duration2;
      this._change = 0;
      this.prevPos = 0;
      this.yoyo = yoyo;
      this._time = 0;
      this._position = 0;
      this._startTime = 0;
      this._finish = 0;
      this.func = func2;
      this._change = finish - this.begin;
      this.pause();
    }
    fire(str) {
      var handler = this[str];
      if (handler) {
        handler();
      }
    }
    setTime(t) {
      if (t > this.duration) {
        if (this.yoyo) {
          this._time = this.duration;
          this.reverse();
        } else {
          this.finish();
        }
      } else if (t < 0) {
        if (this.yoyo) {
          this._time = 0;
          this.play();
        } else {
          this.reset();
        }
      } else {
        this._time = t;
        this.update();
      }
    }
    getTime() {
      return this._time;
    }
    setPosition(p2) {
      this.prevPos = this._pos;
      this.propFunc(p2);
      this._pos = p2;
    }
    getPosition(t) {
      if (t === void 0) {
        t = this._time;
      }
      return this.func(t, this.begin, this._change, this.duration);
    }
    play() {
      this.state = PLAYING;
      this._startTime = this.getTimer() - this._time;
      this.onEnterFrame();
      this.fire("onPlay");
    }
    reverse() {
      this.state = REVERSING;
      this._time = this.duration - this._time;
      this._startTime = this.getTimer() - this._time;
      this.onEnterFrame();
      this.fire("onReverse");
    }
    seek(t) {
      this.pause();
      this._time = t;
      this.update();
      this.fire("onSeek");
    }
    reset() {
      this.pause();
      this._time = 0;
      this.update();
      this.fire("onReset");
    }
    finish() {
      this.pause();
      this._time = this.duration;
      this.update();
      this.fire("onFinish");
    }
    update() {
      this.setPosition(this.getPosition(this._time));
      this.fire("onUpdate");
    }
    onEnterFrame() {
      var t = this.getTimer() - this._startTime;
      if (this.state === PLAYING) {
        this.setTime(t);
      } else if (this.state === REVERSING) {
        this.setTime(this.duration - t);
      }
    }
    pause() {
      this.state = PAUSED;
      this.fire("onPause");
    }
    getTimer() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
  }
  class Tween2 {
    constructor(config) {
      var that = this, node = config.node, nodeId = node._id, duration2, easing = config.easing || exports2.Easings.Linear, yoyo = !!config.yoyo, key;
      if (typeof config.duration === "undefined") {
        duration2 = 0.3;
      } else if (config.duration === 0) {
        duration2 = 1e-3;
      } else {
        duration2 = config.duration;
      }
      this.node = node;
      this._id = idCounter2++;
      var layers = node.getLayer() || (node instanceof Global_12.Konva["Stage"] ? node.getLayers() : null);
      if (!layers) {
        Util_12.Util.error("Tween constructor have `node` that is not in a layer. Please add node into layer first.");
      }
      this.anim = new Animation_12.Animation(function() {
        that.tween.onEnterFrame();
      }, layers);
      this.tween = new TweenEngine(key, function(i) {
        that._tweenFunc(i);
      }, easing, 0, 1, duration2 * 1e3, yoyo);
      this._addListeners();
      if (!Tween2.attrs[nodeId]) {
        Tween2.attrs[nodeId] = {};
      }
      if (!Tween2.attrs[nodeId][this._id]) {
        Tween2.attrs[nodeId][this._id] = {};
      }
      if (!Tween2.tweens[nodeId]) {
        Tween2.tweens[nodeId] = {};
      }
      for (key in config) {
        if (blacklist[key] === void 0) {
          this._addAttr(key, config[key]);
        }
      }
      this.reset();
      this.onFinish = config.onFinish;
      this.onReset = config.onReset;
      this.onUpdate = config.onUpdate;
    }
    _addAttr(key, end) {
      var node = this.node, nodeId = node._id, start, diff, tweenId, n, len2, trueEnd, trueStart, endRGBA;
      tweenId = Tween2.tweens[nodeId][key];
      if (tweenId) {
        delete Tween2.attrs[nodeId][tweenId][key];
      }
      start = node.getAttr(key);
      if (Util_12.Util._isArray(end)) {
        diff = [];
        len2 = Math.max(end.length, start.length);
        if (key === "points" && end.length !== start.length) {
          if (end.length > start.length) {
            trueStart = start;
            start = Util_12.Util._prepareArrayForTween(start, end, node.closed());
          } else {
            trueEnd = end;
            end = Util_12.Util._prepareArrayForTween(end, start, node.closed());
          }
        }
        if (key.indexOf("fill") === 0) {
          for (n = 0; n < len2; n++) {
            if (n % 2 === 0) {
              diff.push(end[n] - start[n]);
            } else {
              var startRGBA = Util_12.Util.colorToRGBA(start[n]);
              endRGBA = Util_12.Util.colorToRGBA(end[n]);
              start[n] = startRGBA;
              diff.push({
                r: endRGBA.r - startRGBA.r,
                g: endRGBA.g - startRGBA.g,
                b: endRGBA.b - startRGBA.b,
                a: endRGBA.a - startRGBA.a
              });
            }
          }
        } else {
          for (n = 0; n < len2; n++) {
            diff.push(end[n] - start[n]);
          }
        }
      } else if (colorAttrs.indexOf(key) !== -1) {
        start = Util_12.Util.colorToRGBA(start);
        endRGBA = Util_12.Util.colorToRGBA(end);
        diff = {
          r: endRGBA.r - start.r,
          g: endRGBA.g - start.g,
          b: endRGBA.b - start.b,
          a: endRGBA.a - start.a
        };
      } else {
        diff = end - start;
      }
      Tween2.attrs[nodeId][this._id][key] = {
        start,
        diff,
        end,
        trueEnd,
        trueStart
      };
      Tween2.tweens[nodeId][key] = this._id;
    }
    _tweenFunc(i) {
      var node = this.node, attrs = Tween2.attrs[node._id][this._id], key, attr, start, diff, newVal, n, len2, end;
      for (key in attrs) {
        attr = attrs[key];
        start = attr.start;
        diff = attr.diff;
        end = attr.end;
        if (Util_12.Util._isArray(start)) {
          newVal = [];
          len2 = Math.max(start.length, end.length);
          if (key.indexOf("fill") === 0) {
            for (n = 0; n < len2; n++) {
              if (n % 2 === 0) {
                newVal.push((start[n] || 0) + diff[n] * i);
              } else {
                newVal.push("rgba(" + Math.round(start[n].r + diff[n].r * i) + "," + Math.round(start[n].g + diff[n].g * i) + "," + Math.round(start[n].b + diff[n].b * i) + "," + (start[n].a + diff[n].a * i) + ")");
              }
            }
          } else {
            for (n = 0; n < len2; n++) {
              newVal.push((start[n] || 0) + diff[n] * i);
            }
          }
        } else if (colorAttrs.indexOf(key) !== -1) {
          newVal = "rgba(" + Math.round(start.r + diff.r * i) + "," + Math.round(start.g + diff.g * i) + "," + Math.round(start.b + diff.b * i) + "," + (start.a + diff.a * i) + ")";
        } else {
          newVal = start + diff * i;
        }
        node.setAttr(key, newVal);
      }
    }
    _addListeners() {
      this.tween.onPlay = () => {
        this.anim.start();
      };
      this.tween.onReverse = () => {
        this.anim.start();
      };
      this.tween.onPause = () => {
        this.anim.stop();
      };
      this.tween.onFinish = () => {
        var node = this.node;
        var attrs = Tween2.attrs[node._id][this._id];
        if (attrs.points && attrs.points.trueEnd) {
          node.setAttr("points", attrs.points.trueEnd);
        }
        if (this.onFinish) {
          this.onFinish.call(this);
        }
      };
      this.tween.onReset = () => {
        var node = this.node;
        var attrs = Tween2.attrs[node._id][this._id];
        if (attrs.points && attrs.points.trueStart) {
          node.points(attrs.points.trueStart);
        }
        if (this.onReset) {
          this.onReset();
        }
      };
      this.tween.onUpdate = () => {
        if (this.onUpdate) {
          this.onUpdate.call(this);
        }
      };
    }
    play() {
      this.tween.play();
      return this;
    }
    reverse() {
      this.tween.reverse();
      return this;
    }
    reset() {
      this.tween.reset();
      return this;
    }
    seek(t) {
      this.tween.seek(t * 1e3);
      return this;
    }
    pause() {
      this.tween.pause();
      return this;
    }
    finish() {
      this.tween.finish();
      return this;
    }
    destroy() {
      var nodeId = this.node._id, thisId = this._id, attrs = Tween2.tweens[nodeId], key;
      this.pause();
      for (key in attrs) {
        delete Tween2.tweens[nodeId][key];
      }
      delete Tween2.attrs[nodeId][thisId];
    }
  }
  exports2.Tween = Tween2;
  Tween2.attrs = {};
  Tween2.tweens = {};
  Node_12.Node.prototype.to = function(params) {
    var onFinish = params.onFinish;
    params.node = this;
    params.onFinish = function() {
      this.destroy();
      if (onFinish) {
        onFinish();
      }
    };
    var tween = new Tween2(params);
    tween.play();
  };
  exports2.Easings = {
    BackEaseIn(t, b, c2, d) {
      var s = 1.70158;
      return c2 * (t /= d) * t * ((s + 1) * t - s) + b;
    },
    BackEaseOut(t, b, c2, d) {
      var s = 1.70158;
      return c2 * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },
    BackEaseInOut(t, b, c2, d) {
      var s = 1.70158;
      if ((t /= d / 2) < 1) {
        return c2 / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
      }
      return c2 / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
    },
    ElasticEaseIn(t, b, c2, d, a, p2) {
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c2;
      }
      if (!p2) {
        p2 = d * 0.3;
      }
      if (!a || a < Math.abs(c2)) {
        a = c2;
        s = p2 / 4;
      } else {
        s = p2 / (2 * Math.PI) * Math.asin(c2 / a);
      }
      return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p2)) + b;
    },
    ElasticEaseOut(t, b, c2, d, a, p2) {
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c2;
      }
      if (!p2) {
        p2 = d * 0.3;
      }
      if (!a || a < Math.abs(c2)) {
        a = c2;
        s = p2 / 4;
      } else {
        s = p2 / (2 * Math.PI) * Math.asin(c2 / a);
      }
      return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p2) + c2 + b;
    },
    ElasticEaseInOut(t, b, c2, d, a, p2) {
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d / 2) === 2) {
        return b + c2;
      }
      if (!p2) {
        p2 = d * (0.3 * 1.5);
      }
      if (!a || a < Math.abs(c2)) {
        a = c2;
        s = p2 / 4;
      } else {
        s = p2 / (2 * Math.PI) * Math.asin(c2 / a);
      }
      if (t < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p2)) + b;
      }
      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p2) * 0.5 + c2 + b;
    },
    BounceEaseOut(t, b, c2, d) {
      if ((t /= d) < 1 / 2.75) {
        return c2 * (7.5625 * t * t) + b;
      } else if (t < 2 / 2.75) {
        return c2 * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
      } else if (t < 2.5 / 2.75) {
        return c2 * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
      } else {
        return c2 * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
      }
    },
    BounceEaseIn(t, b, c2, d) {
      return c2 - exports2.Easings.BounceEaseOut(d - t, 0, c2, d) + b;
    },
    BounceEaseInOut(t, b, c2, d) {
      if (t < d / 2) {
        return exports2.Easings.BounceEaseIn(t * 2, 0, c2, d) * 0.5 + b;
      } else {
        return exports2.Easings.BounceEaseOut(t * 2 - d, 0, c2, d) * 0.5 + c2 * 0.5 + b;
      }
    },
    EaseIn(t, b, c2, d) {
      return c2 * (t /= d) * t + b;
    },
    EaseOut(t, b, c2, d) {
      return -c2 * (t /= d) * (t - 2) + b;
    },
    EaseInOut(t, b, c2, d) {
      if ((t /= d / 2) < 1) {
        return c2 / 2 * t * t + b;
      }
      return -c2 / 2 * (--t * (t - 2) - 1) + b;
    },
    StrongEaseIn(t, b, c2, d) {
      return c2 * (t /= d) * t * t * t * t + b;
    },
    StrongEaseOut(t, b, c2, d) {
      return c2 * ((t = t / d - 1) * t * t * t * t + 1) + b;
    },
    StrongEaseInOut(t, b, c2, d) {
      if ((t /= d / 2) < 1) {
        return c2 / 2 * t * t * t * t * t + b;
      }
      return c2 / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    },
    Linear(t, b, c2, d) {
      return c2 * t / d + b;
    }
  };
})(Tween);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Konva = void 0;
  const Global_12 = Global;
  const Util_12 = Util;
  const Node_12 = Node$1;
  const Container_12 = Container$1;
  const Stage_1 = Stage;
  const Layer_12 = Layer$1;
  const FastLayer_1 = FastLayer$1;
  const Group_12 = Group$1;
  const DragAndDrop_12 = DragAndDrop;
  const Shape_12 = Shape;
  const Animation_12 = Animation$1;
  const Tween_1 = Tween;
  const Context_12 = Context$1;
  const Canvas_12 = Canvas$1;
  exports2.Konva = Util_12.Util._assign(Global_12.Konva, {
    Util: Util_12.Util,
    Transform: Util_12.Transform,
    Node: Node_12.Node,
    Container: Container_12.Container,
    Stage: Stage_1.Stage,
    stages: Stage_1.stages,
    Layer: Layer_12.Layer,
    FastLayer: FastLayer_1.FastLayer,
    Group: Group_12.Group,
    DD: DragAndDrop_12.DD,
    Shape: Shape_12.Shape,
    shapes: Shape_12.shapes,
    Animation: Animation_12.Animation,
    Tween: Tween_1.Tween,
    Easings: Tween_1.Easings,
    Context: Context_12.Context,
    Canvas: Canvas_12.Canvas
  });
  exports2.default = exports2.Konva;
})(_CoreInternals);
var Arc$1 = {};
Object.defineProperty(Arc$1, "__esModule", { value: true });
Arc$1.Arc = void 0;
const Factory_1$v = Factory;
const Shape_1$f = Shape;
const Global_1$g = Global;
const Validators_1$u = Validators;
const Global_2$3 = Global;
class Arc extends Shape_1$f.Shape {
  _sceneFunc(context) {
    var angle = Global_1$g.Konva.getAngle(this.angle()), clockwise = this.clockwise();
    context.beginPath();
    context.arc(0, 0, this.outerRadius(), 0, angle, clockwise);
    context.arc(0, 0, this.innerRadius(), angle, 0, !clockwise);
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.outerRadius() * 2;
  }
  getHeight() {
    return this.outerRadius() * 2;
  }
  setWidth(width) {
    this.outerRadius(width / 2);
  }
  setHeight(height) {
    this.outerRadius(height / 2);
  }
  getSelfRect() {
    const innerRadius = this.innerRadius();
    const outerRadius = this.outerRadius();
    const clockwise = this.clockwise();
    const angle = Global_1$g.Konva.getAngle(clockwise ? 360 - this.angle() : this.angle());
    const boundLeftRatio = Math.cos(Math.min(angle, Math.PI));
    const boundRightRatio = 1;
    const boundTopRatio = Math.sin(Math.min(Math.max(Math.PI, angle), 3 * Math.PI / 2));
    const boundBottomRatio = Math.sin(Math.min(angle, Math.PI / 2));
    const boundLeft = boundLeftRatio * (boundLeftRatio > 0 ? innerRadius : outerRadius);
    const boundRight = boundRightRatio * outerRadius;
    const boundTop = boundTopRatio * (boundTopRatio > 0 ? innerRadius : outerRadius);
    const boundBottom = boundBottomRatio * (boundBottomRatio > 0 ? outerRadius : innerRadius);
    return {
      x: boundLeft,
      y: clockwise ? -1 * boundBottom : boundTop,
      width: boundRight - boundLeft,
      height: boundBottom - boundTop
    };
  }
}
Arc$1.Arc = Arc;
Arc.prototype._centroid = true;
Arc.prototype.className = "Arc";
Arc.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
(0, Global_2$3._registerNode)(Arc);
Factory_1$v.Factory.addGetterSetter(Arc, "innerRadius", 0, (0, Validators_1$u.getNumberValidator)());
Factory_1$v.Factory.addGetterSetter(Arc, "outerRadius", 0, (0, Validators_1$u.getNumberValidator)());
Factory_1$v.Factory.addGetterSetter(Arc, "angle", 0, (0, Validators_1$u.getNumberValidator)());
Factory_1$v.Factory.addGetterSetter(Arc, "clockwise", false, (0, Validators_1$u.getBooleanValidator)());
var Arrow$1 = {};
var Line$2 = {};
Object.defineProperty(Line$2, "__esModule", { value: true });
Line$2.Line = void 0;
const Factory_1$u = Factory;
const Shape_1$e = Shape;
const Validators_1$t = Validators;
const Global_1$f = Global;
function getControlPoints(x0, y0, x1, y1, x2, y2, t) {
  var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)), d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), fa = t * d01 / (d01 + d12), fb = t * d12 / (d01 + d12), p1x = x1 - fa * (x2 - x0), p1y = y1 - fa * (y2 - y0), p2x = x1 + fb * (x2 - x0), p2y = y1 + fb * (y2 - y0);
  return [p1x, p1y, p2x, p2y];
}
function expandPoints(p2, tension) {
  var len2 = p2.length, allPoints = [], n, cp;
  for (n = 2; n < len2 - 2; n += 2) {
    cp = getControlPoints(p2[n - 2], p2[n - 1], p2[n], p2[n + 1], p2[n + 2], p2[n + 3], tension);
    if (isNaN(cp[0])) {
      continue;
    }
    allPoints.push(cp[0]);
    allPoints.push(cp[1]);
    allPoints.push(p2[n]);
    allPoints.push(p2[n + 1]);
    allPoints.push(cp[2]);
    allPoints.push(cp[3]);
  }
  return allPoints;
}
let Line$1 = class Line extends Shape_1$e.Shape {
  constructor(config) {
    super(config);
    this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
      this._clearCache("tensionPoints");
    });
  }
  _sceneFunc(context) {
    var points = this.points(), length = points.length, tension = this.tension(), closed = this.closed(), bezier = this.bezier(), tp, len2, n;
    if (!length) {
      return;
    }
    context.beginPath();
    context.moveTo(points[0], points[1]);
    if (tension !== 0 && length > 4) {
      tp = this.getTensionPoints();
      len2 = tp.length;
      n = closed ? 0 : 4;
      if (!closed) {
        context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
      }
      while (n < len2 - 2) {
        context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
      }
      if (!closed) {
        context.quadraticCurveTo(tp[len2 - 2], tp[len2 - 1], points[length - 2], points[length - 1]);
      }
    } else if (bezier) {
      n = 2;
      while (n < length) {
        context.bezierCurveTo(points[n++], points[n++], points[n++], points[n++], points[n++], points[n++]);
      }
    } else {
      for (n = 2; n < length; n += 2) {
        context.lineTo(points[n], points[n + 1]);
      }
    }
    if (closed) {
      context.closePath();
      context.fillStrokeShape(this);
    } else {
      context.strokeShape(this);
    }
  }
  getTensionPoints() {
    return this._getCache("tensionPoints", this._getTensionPoints);
  }
  _getTensionPoints() {
    if (this.closed()) {
      return this._getTensionPointsClosed();
    } else {
      return expandPoints(this.points(), this.tension());
    }
  }
  _getTensionPointsClosed() {
    var p2 = this.points(), len2 = p2.length, tension = this.tension(), firstControlPoints = getControlPoints(p2[len2 - 2], p2[len2 - 1], p2[0], p2[1], p2[2], p2[3], tension), lastControlPoints = getControlPoints(p2[len2 - 4], p2[len2 - 3], p2[len2 - 2], p2[len2 - 1], p2[0], p2[1], tension), middle = expandPoints(p2, tension), tp = [firstControlPoints[2], firstControlPoints[3]].concat(middle).concat([
      lastControlPoints[0],
      lastControlPoints[1],
      p2[len2 - 2],
      p2[len2 - 1],
      lastControlPoints[2],
      lastControlPoints[3],
      firstControlPoints[0],
      firstControlPoints[1],
      p2[0],
      p2[1]
    ]);
    return tp;
  }
  getWidth() {
    return this.getSelfRect().width;
  }
  getHeight() {
    return this.getSelfRect().height;
  }
  getSelfRect() {
    var points = this.points();
    if (points.length < 4) {
      return {
        x: points[0] || 0,
        y: points[1] || 0,
        width: 0,
        height: 0
      };
    }
    if (this.tension() !== 0) {
      points = [
        points[0],
        points[1],
        ...this._getTensionPoints(),
        points[points.length - 2],
        points[points.length - 1]
      ];
    } else {
      points = this.points();
    }
    var minX = points[0];
    var maxX = points[0];
    var minY = points[1];
    var maxY = points[1];
    var x, y;
    for (var i = 0; i < points.length / 2; i++) {
      x = points[i * 2];
      y = points[i * 2 + 1];
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
};
Line$2.Line = Line$1;
Line$1.prototype.className = "Line";
Line$1.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
(0, Global_1$f._registerNode)(Line$1);
Factory_1$u.Factory.addGetterSetter(Line$1, "closed", false);
Factory_1$u.Factory.addGetterSetter(Line$1, "bezier", false);
Factory_1$u.Factory.addGetterSetter(Line$1, "tension", 0, (0, Validators_1$t.getNumberValidator)());
Factory_1$u.Factory.addGetterSetter(Line$1, "points", [], (0, Validators_1$t.getNumberArrayValidator)());
var Path$1 = {};
var BezierFunctions = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.t2length = exports2.getQuadraticArcLength = exports2.getCubicArcLength = exports2.binomialCoefficients = exports2.cValues = exports2.tValues = void 0;
  exports2.tValues = [
    [],
    [],
    [
      -0.5773502691896257,
      0.5773502691896257
    ],
    [
      0,
      -0.7745966692414834,
      0.7745966692414834
    ],
    [
      -0.33998104358485626,
      0.33998104358485626,
      -0.8611363115940526,
      0.8611363115940526
    ],
    [
      0,
      -0.5384693101056831,
      0.5384693101056831,
      -0.906179845938664,
      0.906179845938664
    ],
    [
      0.6612093864662645,
      -0.6612093864662645,
      -0.2386191860831969,
      0.2386191860831969,
      -0.932469514203152,
      0.932469514203152
    ],
    [
      0,
      0.4058451513773972,
      -0.4058451513773972,
      -0.7415311855993945,
      0.7415311855993945,
      -0.9491079123427585,
      0.9491079123427585
    ],
    [
      -0.1834346424956498,
      0.1834346424956498,
      -0.525532409916329,
      0.525532409916329,
      -0.7966664774136267,
      0.7966664774136267,
      -0.9602898564975363,
      0.9602898564975363
    ],
    [
      0,
      -0.8360311073266358,
      0.8360311073266358,
      -0.9681602395076261,
      0.9681602395076261,
      -0.3242534234038089,
      0.3242534234038089,
      -0.6133714327005904,
      0.6133714327005904
    ],
    [
      -0.14887433898163122,
      0.14887433898163122,
      -0.4333953941292472,
      0.4333953941292472,
      -0.6794095682990244,
      0.6794095682990244,
      -0.8650633666889845,
      0.8650633666889845,
      -0.9739065285171717,
      0.9739065285171717
    ],
    [
      0,
      -0.26954315595234496,
      0.26954315595234496,
      -0.5190961292068118,
      0.5190961292068118,
      -0.7301520055740494,
      0.7301520055740494,
      -0.8870625997680953,
      0.8870625997680953,
      -0.978228658146057,
      0.978228658146057
    ],
    [
      -0.1252334085114689,
      0.1252334085114689,
      -0.3678314989981802,
      0.3678314989981802,
      -0.5873179542866175,
      0.5873179542866175,
      -0.7699026741943047,
      0.7699026741943047,
      -0.9041172563704749,
      0.9041172563704749,
      -0.9815606342467192,
      0.9815606342467192
    ],
    [
      0,
      -0.2304583159551348,
      0.2304583159551348,
      -0.44849275103644687,
      0.44849275103644687,
      -0.6423493394403402,
      0.6423493394403402,
      -0.8015780907333099,
      0.8015780907333099,
      -0.9175983992229779,
      0.9175983992229779,
      -0.9841830547185881,
      0.9841830547185881
    ],
    [
      -0.10805494870734367,
      0.10805494870734367,
      -0.31911236892788974,
      0.31911236892788974,
      -0.5152486363581541,
      0.5152486363581541,
      -0.6872929048116855,
      0.6872929048116855,
      -0.827201315069765,
      0.827201315069765,
      -0.9284348836635735,
      0.9284348836635735,
      -0.9862838086968123,
      0.9862838086968123
    ],
    [
      0,
      -0.20119409399743451,
      0.20119409399743451,
      -0.3941513470775634,
      0.3941513470775634,
      -0.5709721726085388,
      0.5709721726085388,
      -0.7244177313601701,
      0.7244177313601701,
      -0.8482065834104272,
      0.8482065834104272,
      -0.937273392400706,
      0.937273392400706,
      -0.9879925180204854,
      0.9879925180204854
    ],
    [
      -0.09501250983763744,
      0.09501250983763744,
      -0.2816035507792589,
      0.2816035507792589,
      -0.45801677765722737,
      0.45801677765722737,
      -0.6178762444026438,
      0.6178762444026438,
      -0.755404408355003,
      0.755404408355003,
      -0.8656312023878318,
      0.8656312023878318,
      -0.9445750230732326,
      0.9445750230732326,
      -0.9894009349916499,
      0.9894009349916499
    ],
    [
      0,
      -0.17848418149584785,
      0.17848418149584785,
      -0.3512317634538763,
      0.3512317634538763,
      -0.5126905370864769,
      0.5126905370864769,
      -0.6576711592166907,
      0.6576711592166907,
      -0.7815140038968014,
      0.7815140038968014,
      -0.8802391537269859,
      0.8802391537269859,
      -0.9506755217687678,
      0.9506755217687678,
      -0.9905754753144174,
      0.9905754753144174
    ],
    [
      -0.0847750130417353,
      0.0847750130417353,
      -0.2518862256915055,
      0.2518862256915055,
      -0.41175116146284263,
      0.41175116146284263,
      -0.5597708310739475,
      0.5597708310739475,
      -0.6916870430603532,
      0.6916870430603532,
      -0.8037049589725231,
      0.8037049589725231,
      -0.8926024664975557,
      0.8926024664975557,
      -0.9558239495713977,
      0.9558239495713977,
      -0.9915651684209309,
      0.9915651684209309
    ],
    [
      0,
      -0.16035864564022537,
      0.16035864564022537,
      -0.31656409996362983,
      0.31656409996362983,
      -0.46457074137596094,
      0.46457074137596094,
      -0.600545304661681,
      0.600545304661681,
      -0.7209661773352294,
      0.7209661773352294,
      -0.8227146565371428,
      0.8227146565371428,
      -0.9031559036148179,
      0.9031559036148179,
      -0.96020815213483,
      0.96020815213483,
      -0.9924068438435844,
      0.9924068438435844
    ],
    [
      -0.07652652113349734,
      0.07652652113349734,
      -0.22778585114164507,
      0.22778585114164507,
      -0.37370608871541955,
      0.37370608871541955,
      -0.5108670019508271,
      0.5108670019508271,
      -0.636053680726515,
      0.636053680726515,
      -0.7463319064601508,
      0.7463319064601508,
      -0.8391169718222188,
      0.8391169718222188,
      -0.912234428251326,
      0.912234428251326,
      -0.9639719272779138,
      0.9639719272779138,
      -0.9931285991850949,
      0.9931285991850949
    ],
    [
      0,
      -0.1455618541608951,
      0.1455618541608951,
      -0.2880213168024011,
      0.2880213168024011,
      -0.4243421202074388,
      0.4243421202074388,
      -0.5516188358872198,
      0.5516188358872198,
      -0.6671388041974123,
      0.6671388041974123,
      -0.7684399634756779,
      0.7684399634756779,
      -0.8533633645833173,
      0.8533633645833173,
      -0.9200993341504008,
      0.9200993341504008,
      -0.9672268385663063,
      0.9672268385663063,
      -0.9937521706203895,
      0.9937521706203895
    ],
    [
      -0.06973927331972223,
      0.06973927331972223,
      -0.20786042668822127,
      0.20786042668822127,
      -0.34193582089208424,
      0.34193582089208424,
      -0.469355837986757,
      0.469355837986757,
      -0.5876404035069116,
      0.5876404035069116,
      -0.6944872631866827,
      0.6944872631866827,
      -0.7878168059792081,
      0.7878168059792081,
      -0.8658125777203002,
      0.8658125777203002,
      -0.926956772187174,
      0.926956772187174,
      -0.9700604978354287,
      0.9700604978354287,
      -0.9942945854823992,
      0.9942945854823992
    ],
    [
      0,
      -0.1332568242984661,
      0.1332568242984661,
      -0.26413568097034495,
      0.26413568097034495,
      -0.3903010380302908,
      0.3903010380302908,
      -0.5095014778460075,
      0.5095014778460075,
      -0.6196098757636461,
      0.6196098757636461,
      -0.7186613631319502,
      0.7186613631319502,
      -0.8048884016188399,
      0.8048884016188399,
      -0.8767523582704416,
      0.8767523582704416,
      -0.9329710868260161,
      0.9329710868260161,
      -0.9725424712181152,
      0.9725424712181152,
      -0.9947693349975522,
      0.9947693349975522
    ],
    [
      -0.06405689286260563,
      0.06405689286260563,
      -0.1911188674736163,
      0.1911188674736163,
      -0.3150426796961634,
      0.3150426796961634,
      -0.4337935076260451,
      0.4337935076260451,
      -0.5454214713888396,
      0.5454214713888396,
      -0.6480936519369755,
      0.6480936519369755,
      -0.7401241915785544,
      0.7401241915785544,
      -0.820001985973903,
      0.820001985973903,
      -0.8864155270044011,
      0.8864155270044011,
      -0.9382745520027328,
      0.9382745520027328,
      -0.9747285559713095,
      0.9747285559713095,
      -0.9951872199970213,
      0.9951872199970213
    ]
  ];
  exports2.cValues = [
    [],
    [],
    [1, 1],
    [
      0.8888888888888888,
      0.5555555555555556,
      0.5555555555555556
    ],
    [
      0.6521451548625461,
      0.6521451548625461,
      0.34785484513745385,
      0.34785484513745385
    ],
    [
      0.5688888888888889,
      0.47862867049936647,
      0.47862867049936647,
      0.23692688505618908,
      0.23692688505618908
    ],
    [
      0.3607615730481386,
      0.3607615730481386,
      0.46791393457269104,
      0.46791393457269104,
      0.17132449237917036,
      0.17132449237917036
    ],
    [
      0.4179591836734694,
      0.3818300505051189,
      0.3818300505051189,
      0.27970539148927664,
      0.27970539148927664,
      0.1294849661688697,
      0.1294849661688697
    ],
    [
      0.362683783378362,
      0.362683783378362,
      0.31370664587788727,
      0.31370664587788727,
      0.22238103445337448,
      0.22238103445337448,
      0.10122853629037626,
      0.10122853629037626
    ],
    [
      0.3302393550012598,
      0.1806481606948574,
      0.1806481606948574,
      0.08127438836157441,
      0.08127438836157441,
      0.31234707704000286,
      0.31234707704000286,
      0.26061069640293544,
      0.26061069640293544
    ],
    [
      0.29552422471475287,
      0.29552422471475287,
      0.26926671930999635,
      0.26926671930999635,
      0.21908636251598204,
      0.21908636251598204,
      0.1494513491505806,
      0.1494513491505806,
      0.06667134430868814,
      0.06667134430868814
    ],
    [
      0.2729250867779006,
      0.26280454451024665,
      0.26280454451024665,
      0.23319376459199048,
      0.23319376459199048,
      0.18629021092773426,
      0.18629021092773426,
      0.1255803694649046,
      0.1255803694649046,
      0.05566856711617366,
      0.05566856711617366
    ],
    [
      0.24914704581340277,
      0.24914704581340277,
      0.2334925365383548,
      0.2334925365383548,
      0.20316742672306592,
      0.20316742672306592,
      0.16007832854334622,
      0.16007832854334622,
      0.10693932599531843,
      0.10693932599531843,
      0.04717533638651183,
      0.04717533638651183
    ],
    [
      0.2325515532308739,
      0.22628318026289723,
      0.22628318026289723,
      0.2078160475368885,
      0.2078160475368885,
      0.17814598076194574,
      0.17814598076194574,
      0.13887351021978725,
      0.13887351021978725,
      0.09212149983772845,
      0.09212149983772845,
      0.04048400476531588,
      0.04048400476531588
    ],
    [
      0.2152638534631578,
      0.2152638534631578,
      0.2051984637212956,
      0.2051984637212956,
      0.18553839747793782,
      0.18553839747793782,
      0.15720316715819355,
      0.15720316715819355,
      0.12151857068790319,
      0.12151857068790319,
      0.08015808715976021,
      0.08015808715976021,
      0.03511946033175186,
      0.03511946033175186
    ],
    [
      0.2025782419255613,
      0.19843148532711158,
      0.19843148532711158,
      0.1861610000155622,
      0.1861610000155622,
      0.16626920581699392,
      0.16626920581699392,
      0.13957067792615432,
      0.13957067792615432,
      0.10715922046717194,
      0.10715922046717194,
      0.07036604748810812,
      0.07036604748810812,
      0.03075324199611727,
      0.03075324199611727
    ],
    [
      0.1894506104550685,
      0.1894506104550685,
      0.18260341504492358,
      0.18260341504492358,
      0.16915651939500254,
      0.16915651939500254,
      0.14959598881657674,
      0.14959598881657674,
      0.12462897125553388,
      0.12462897125553388,
      0.09515851168249279,
      0.09515851168249279,
      0.062253523938647894,
      0.062253523938647894,
      0.027152459411754096,
      0.027152459411754096
    ],
    [
      0.17944647035620653,
      0.17656270536699264,
      0.17656270536699264,
      0.16800410215645004,
      0.16800410215645004,
      0.15404576107681028,
      0.15404576107681028,
      0.13513636846852548,
      0.13513636846852548,
      0.11188384719340397,
      0.11188384719340397,
      0.08503614831717918,
      0.08503614831717918,
      0.0554595293739872,
      0.0554595293739872,
      0.02414830286854793,
      0.02414830286854793
    ],
    [
      0.1691423829631436,
      0.1691423829631436,
      0.16427648374583273,
      0.16427648374583273,
      0.15468467512626524,
      0.15468467512626524,
      0.14064291467065065,
      0.14064291467065065,
      0.12255520671147846,
      0.12255520671147846,
      0.10094204410628717,
      0.10094204410628717,
      0.07642573025488905,
      0.07642573025488905,
      0.0497145488949698,
      0.0497145488949698,
      0.02161601352648331,
      0.02161601352648331
    ],
    [
      0.1610544498487837,
      0.15896884339395434,
      0.15896884339395434,
      0.15276604206585967,
      0.15276604206585967,
      0.1426067021736066,
      0.1426067021736066,
      0.12875396253933621,
      0.12875396253933621,
      0.11156664554733399,
      0.11156664554733399,
      0.09149002162245,
      0.09149002162245,
      0.06904454273764123,
      0.06904454273764123,
      0.0448142267656996,
      0.0448142267656996,
      0.019461788229726478,
      0.019461788229726478
    ],
    [
      0.15275338713072584,
      0.15275338713072584,
      0.14917298647260374,
      0.14917298647260374,
      0.14209610931838204,
      0.14209610931838204,
      0.13168863844917664,
      0.13168863844917664,
      0.11819453196151841,
      0.11819453196151841,
      0.10193011981724044,
      0.10193011981724044,
      0.08327674157670475,
      0.08327674157670475,
      0.06267204833410907,
      0.06267204833410907,
      0.04060142980038694,
      0.04060142980038694,
      0.017614007139152118,
      0.017614007139152118
    ],
    [
      0.14608113364969041,
      0.14452440398997005,
      0.14452440398997005,
      0.13988739479107315,
      0.13988739479107315,
      0.13226893863333747,
      0.13226893863333747,
      0.12183141605372853,
      0.12183141605372853,
      0.10879729916714838,
      0.10879729916714838,
      0.09344442345603386,
      0.09344442345603386,
      0.0761001136283793,
      0.0761001136283793,
      0.057134425426857205,
      0.057134425426857205,
      0.036953789770852494,
      0.036953789770852494,
      0.016017228257774335,
      0.016017228257774335
    ],
    [
      0.13925187285563198,
      0.13925187285563198,
      0.13654149834601517,
      0.13654149834601517,
      0.13117350478706238,
      0.13117350478706238,
      0.12325237681051242,
      0.12325237681051242,
      0.11293229608053922,
      0.11293229608053922,
      0.10041414444288096,
      0.10041414444288096,
      0.08594160621706773,
      0.08594160621706773,
      0.06979646842452049,
      0.06979646842452049,
      0.052293335152683286,
      0.052293335152683286,
      0.03377490158481415,
      0.03377490158481415,
      0.0146279952982722,
      0.0146279952982722
    ],
    [
      0.13365457218610619,
      0.1324620394046966,
      0.1324620394046966,
      0.12890572218808216,
      0.12890572218808216,
      0.12304908430672953,
      0.12304908430672953,
      0.11499664022241136,
      0.11499664022241136,
      0.10489209146454141,
      0.10489209146454141,
      0.09291576606003515,
      0.09291576606003515,
      0.07928141177671895,
      0.07928141177671895,
      0.06423242140852585,
      0.06423242140852585,
      0.04803767173108467,
      0.04803767173108467,
      0.030988005856979445,
      0.030988005856979445,
      0.013411859487141771,
      0.013411859487141771
    ],
    [
      0.12793819534675216,
      0.12793819534675216,
      0.1258374563468283,
      0.1258374563468283,
      0.12167047292780339,
      0.12167047292780339,
      0.1155056680537256,
      0.1155056680537256,
      0.10744427011596563,
      0.10744427011596563,
      0.09761865210411388,
      0.09761865210411388,
      0.08619016153195327,
      0.08619016153195327,
      0.0733464814110803,
      0.0733464814110803,
      0.05929858491543678,
      0.05929858491543678,
      0.04427743881741981,
      0.04427743881741981,
      0.028531388628933663,
      0.028531388628933663,
      0.0123412297999872,
      0.0123412297999872
    ]
  ];
  exports2.binomialCoefficients = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]];
  const getCubicArcLength = (xs, ys, t) => {
    let z;
    let sum2;
    let correctedT;
    const n = 20;
    z = t / 2;
    sum2 = 0;
    for (let i = 0; i < n; i++) {
      correctedT = z * exports2.tValues[n][i] + z;
      sum2 += exports2.cValues[n][i] * BFunc(xs, ys, correctedT);
    }
    return z * sum2;
  };
  exports2.getCubicArcLength = getCubicArcLength;
  const getQuadraticArcLength = (xs, ys, t) => {
    if (t === void 0) {
      t = 1;
    }
    const ax = xs[0] - 2 * xs[1] + xs[2];
    const ay = ys[0] - 2 * ys[1] + ys[2];
    const bx = 2 * xs[1] - 2 * xs[0];
    const by = 2 * ys[1] - 2 * ys[0];
    const A = 4 * (ax * ax + ay * ay);
    const B = 4 * (ax * bx + ay * by);
    const C = bx * bx + by * by;
    if (A === 0) {
      return t * Math.sqrt(Math.pow(xs[2] - xs[0], 2) + Math.pow(ys[2] - ys[0], 2));
    }
    const b = B / (2 * A);
    const c2 = C / A;
    const u = t + b;
    const k = c2 - b * b;
    const uuk = u * u + k > 0 ? Math.sqrt(u * u + k) : 0;
    const bbk = b * b + k > 0 ? Math.sqrt(b * b + k) : 0;
    const term = b + Math.sqrt(b * b + k) !== 0 ? k * Math.log(Math.abs((u + uuk) / (b + bbk))) : 0;
    return Math.sqrt(A) / 2 * (u * uuk - b * bbk + term);
  };
  exports2.getQuadraticArcLength = getQuadraticArcLength;
  function BFunc(xs, ys, t) {
    const xbase = getDerivative(1, t, xs);
    const ybase = getDerivative(1, t, ys);
    const combined = xbase * xbase + ybase * ybase;
    return Math.sqrt(combined);
  }
  const getDerivative = (derivative, t, vs) => {
    const n = vs.length - 1;
    let _vs;
    let value;
    if (n === 0) {
      return 0;
    }
    if (derivative === 0) {
      value = 0;
      for (let k = 0; k <= n; k++) {
        value += exports2.binomialCoefficients[n][k] * Math.pow(1 - t, n - k) * Math.pow(t, k) * vs[k];
      }
      return value;
    } else {
      _vs = new Array(n);
      for (let k = 0; k < n; k++) {
        _vs[k] = n * (vs[k + 1] - vs[k]);
      }
      return getDerivative(derivative - 1, t, _vs);
    }
  };
  const t2length = (length, totalLength, func2) => {
    let error = 1;
    let t = length / totalLength;
    let step = (length - func2(t)) / totalLength;
    let numIterations = 0;
    while (error > 1e-3) {
      const increasedTLength = func2(t + step);
      const increasedTError = Math.abs(length - increasedTLength) / totalLength;
      if (increasedTError < error) {
        error = increasedTError;
        t += step;
      } else {
        const decreasedTLength = func2(t - step);
        const decreasedTError = Math.abs(length - decreasedTLength) / totalLength;
        if (decreasedTError < error) {
          error = decreasedTError;
          t -= step;
        } else {
          step /= 2;
        }
      }
      numIterations++;
      if (numIterations > 500) {
        break;
      }
    }
    return t;
  };
  exports2.t2length = t2length;
})(BezierFunctions);
Object.defineProperty(Path$1, "__esModule", { value: true });
Path$1.Path = void 0;
const Factory_1$t = Factory;
const Shape_1$d = Shape;
const Global_1$e = Global;
const BezierFunctions_1 = BezierFunctions;
class Path extends Shape_1$d.Shape {
  constructor(config) {
    super(config);
    this.dataArray = [];
    this.pathLength = 0;
    this._readDataAttribute();
    this.on("dataChange.konva", function() {
      this._readDataAttribute();
    });
  }
  _readDataAttribute() {
    this.dataArray = Path.parsePathData(this.data());
    this.pathLength = Path.getPathLength(this.dataArray);
  }
  _sceneFunc(context) {
    var ca = this.dataArray;
    context.beginPath();
    var isClosed = false;
    for (var n = 0; n < ca.length; n++) {
      var c2 = ca[n].command;
      var p2 = ca[n].points;
      switch (c2) {
        case "L":
          context.lineTo(p2[0], p2[1]);
          break;
        case "M":
          context.moveTo(p2[0], p2[1]);
          break;
        case "C":
          context.bezierCurveTo(p2[0], p2[1], p2[2], p2[3], p2[4], p2[5]);
          break;
        case "Q":
          context.quadraticCurveTo(p2[0], p2[1], p2[2], p2[3]);
          break;
        case "A":
          var cx = p2[0], cy = p2[1], rx = p2[2], ry = p2[3], theta = p2[4], dTheta = p2[5], psi = p2[6], fs = p2[7];
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(psi);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-psi);
          context.translate(-cx, -cy);
          break;
        case "z":
          isClosed = true;
          context.closePath();
          break;
      }
    }
    if (!isClosed && !this.hasFill()) {
      context.strokeShape(this);
    } else {
      context.fillStrokeShape(this);
    }
  }
  getSelfRect() {
    var points = [];
    this.dataArray.forEach(function(data) {
      if (data.command === "A") {
        var start = data.points[4];
        var dTheta = data.points[5];
        var end = data.points[4] + dTheta;
        var inc = Math.PI / 180;
        if (Math.abs(start - end) < inc) {
          inc = Math.abs(start - end);
        }
        if (dTheta < 0) {
          for (let t = start - inc; t > end; t -= inc) {
            const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
            points.push(point.x, point.y);
          }
        } else {
          for (let t = start + inc; t < end; t += inc) {
            const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
            points.push(point.x, point.y);
          }
        }
      } else if (data.command === "C") {
        for (let t = 0; t <= 1; t += 0.01) {
          const point = Path.getPointOnCubicBezier(t, data.start.x, data.start.y, data.points[0], data.points[1], data.points[2], data.points[3], data.points[4], data.points[5]);
          points.push(point.x, point.y);
        }
      } else {
        points = points.concat(data.points);
      }
    });
    var minX = points[0];
    var maxX = points[0];
    var minY = points[1];
    var maxY = points[1];
    var x, y;
    for (var i = 0; i < points.length / 2; i++) {
      x = points[i * 2];
      y = points[i * 2 + 1];
      if (!isNaN(x)) {
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
      }
      if (!isNaN(y)) {
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  getLength() {
    return this.pathLength;
  }
  getPointAtLength(length) {
    return Path.getPointAtLengthOfDataArray(length, this.dataArray);
  }
  static getLineLength(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  static getPathLength(dataArray) {
    let pathLength = 0;
    for (var i = 0; i < dataArray.length; ++i) {
      pathLength += dataArray[i].pathLength;
    }
    return pathLength;
  }
  static getPointAtLengthOfDataArray(length, dataArray) {
    var point, i = 0, ii = dataArray.length;
    if (!ii) {
      return null;
    }
    while (i < ii && length > dataArray[i].pathLength) {
      length -= dataArray[i].pathLength;
      ++i;
    }
    if (i === ii) {
      point = dataArray[i - 1].points.slice(-2);
      return {
        x: point[0],
        y: point[1]
      };
    }
    if (length < 0.01) {
      point = dataArray[i].points.slice(0, 2);
      return {
        x: point[0],
        y: point[1]
      };
    }
    var cp = dataArray[i];
    var p2 = cp.points;
    switch (cp.command) {
      case "L":
        return Path.getPointOnLine(length, cp.start.x, cp.start.y, p2[0], p2[1]);
      case "C":
        return Path.getPointOnCubicBezier((0, BezierFunctions_1.t2length)(length, Path.getPathLength(dataArray), (i2) => {
          return (0, BezierFunctions_1.getCubicArcLength)([cp.start.x, p2[0], p2[2], p2[4]], [cp.start.y, p2[1], p2[3], p2[5]], i2);
        }), cp.start.x, cp.start.y, p2[0], p2[1], p2[2], p2[3], p2[4], p2[5]);
      case "Q":
        return Path.getPointOnQuadraticBezier((0, BezierFunctions_1.t2length)(length, Path.getPathLength(dataArray), (i2) => {
          return (0, BezierFunctions_1.getQuadraticArcLength)([cp.start.x, p2[0], p2[2]], [cp.start.y, p2[1], p2[3]], i2);
        }), cp.start.x, cp.start.y, p2[0], p2[1], p2[2], p2[3]);
      case "A":
        var cx = p2[0], cy = p2[1], rx = p2[2], ry = p2[3], theta = p2[4], dTheta = p2[5], psi = p2[6];
        theta += dTheta * length / cp.pathLength;
        return Path.getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi);
    }
    return null;
  }
  static getPointOnLine(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
    fromX = fromX !== null && fromX !== void 0 ? fromX : P1x;
    fromY = fromY !== null && fromY !== void 0 ? fromY : P1y;
    const len2 = this.getLineLength(P1x, P1y, P2x, P2y);
    if (len2 < 1e-10) {
      return { x: P1x, y: P1y };
    }
    if (P2x === P1x) {
      return { x: fromX, y: fromY + (P2y > P1y ? dist : -dist) };
    }
    const m = (P2y - P1y) / (P2x - P1x);
    const run = Math.sqrt(dist * dist / (1 + m * m)) * (P2x < P1x ? -1 : 1);
    const rise = m * run;
    if (Math.abs(fromY - P1y - m * (fromX - P1x)) < 1e-10) {
      return { x: fromX + run, y: fromY + rise };
    }
    const u = ((fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y)) / (len2 * len2);
    const ix = P1x + u * (P2x - P1x);
    const iy = P1y + u * (P2y - P1y);
    const pRise = this.getLineLength(fromX, fromY, ix, iy);
    const pRun = Math.sqrt(dist * dist - pRise * pRise);
    const adjustedRun = Math.sqrt(pRun * pRun / (1 + m * m)) * (P2x < P1x ? -1 : 1);
    const adjustedRise = m * adjustedRun;
    return { x: ix + adjustedRun, y: iy + adjustedRise };
  }
  static getPointOnCubicBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
    function CB1(t) {
      return t * t * t;
    }
    function CB2(t) {
      return 3 * t * t * (1 - t);
    }
    function CB3(t) {
      return 3 * t * (1 - t) * (1 - t);
    }
    function CB4(t) {
      return (1 - t) * (1 - t) * (1 - t);
    }
    var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
    var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);
    return {
      x,
      y
    };
  }
  static getPointOnQuadraticBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
    function QB1(t) {
      return t * t;
    }
    function QB2(t) {
      return 2 * t * (1 - t);
    }
    function QB3(t) {
      return (1 - t) * (1 - t);
    }
    var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
    var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);
    return {
      x,
      y
    };
  }
  static getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
    var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
    var pt = {
      x: rx * Math.cos(theta),
      y: ry * Math.sin(theta)
    };
    return {
      x: cx + (pt.x * cosPsi - pt.y * sinPsi),
      y: cy + (pt.x * sinPsi + pt.y * cosPsi)
    };
  }
  static parsePathData(data) {
    if (!data) {
      return [];
    }
    var cs = data;
    var cc = [
      "m",
      "M",
      "l",
      "L",
      "v",
      "V",
      "h",
      "H",
      "z",
      "Z",
      "c",
      "C",
      "q",
      "Q",
      "t",
      "T",
      "s",
      "S",
      "a",
      "A"
    ];
    cs = cs.replace(new RegExp(" ", "g"), ",");
    for (var n = 0; n < cc.length; n++) {
      cs = cs.replace(new RegExp(cc[n], "g"), "|" + cc[n]);
    }
    var arr = cs.split("|");
    var ca = [];
    var coords = [];
    var cpx = 0;
    var cpy = 0;
    var re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
    var match2;
    for (n = 1; n < arr.length; n++) {
      var str = arr[n];
      var c2 = str.charAt(0);
      str = str.slice(1);
      coords.length = 0;
      while (match2 = re.exec(str)) {
        coords.push(match2[0]);
      }
      var p2 = [];
      for (var j = 0, jlen = coords.length; j < jlen; j++) {
        if (coords[j] === "00") {
          p2.push(0, 0);
          continue;
        }
        var parsed = parseFloat(coords[j]);
        if (!isNaN(parsed)) {
          p2.push(parsed);
        } else {
          p2.push(0);
        }
      }
      while (p2.length > 0) {
        if (isNaN(p2[0])) {
          break;
        }
        var cmd = "";
        var points = [];
        var startX = cpx, startY = cpy;
        var prevCmd, ctlPtx, ctlPty;
        var rx, ry, psi, fa, fs, x1, y1;
        switch (c2) {
          case "l":
            cpx += p2.shift();
            cpy += p2.shift();
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "L":
            cpx = p2.shift();
            cpy = p2.shift();
            points.push(cpx, cpy);
            break;
          case "m":
            var dx = p2.shift();
            var dy = p2.shift();
            cpx += dx;
            cpy += dy;
            cmd = "M";
            if (ca.length > 2 && ca[ca.length - 1].command === "z") {
              for (var idx = ca.length - 2; idx >= 0; idx--) {
                if (ca[idx].command === "M") {
                  cpx = ca[idx].points[0] + dx;
                  cpy = ca[idx].points[1] + dy;
                  break;
                }
              }
            }
            points.push(cpx, cpy);
            c2 = "l";
            break;
          case "M":
            cpx = p2.shift();
            cpy = p2.shift();
            cmd = "M";
            points.push(cpx, cpy);
            c2 = "L";
            break;
          case "h":
            cpx += p2.shift();
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "H":
            cpx = p2.shift();
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "v":
            cpy += p2.shift();
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "V":
            cpy = p2.shift();
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "C":
            points.push(p2.shift(), p2.shift(), p2.shift(), p2.shift());
            cpx = p2.shift();
            cpy = p2.shift();
            points.push(cpx, cpy);
            break;
          case "c":
            points.push(cpx + p2.shift(), cpy + p2.shift(), cpx + p2.shift(), cpy + p2.shift());
            cpx += p2.shift();
            cpy += p2.shift();
            cmd = "C";
            points.push(cpx, cpy);
            break;
          case "S":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "C") {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, p2.shift(), p2.shift());
            cpx = p2.shift();
            cpy = p2.shift();
            cmd = "C";
            points.push(cpx, cpy);
            break;
          case "s":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "C") {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, cpx + p2.shift(), cpy + p2.shift());
            cpx += p2.shift();
            cpy += p2.shift();
            cmd = "C";
            points.push(cpx, cpy);
            break;
          case "Q":
            points.push(p2.shift(), p2.shift());
            cpx = p2.shift();
            cpy = p2.shift();
            points.push(cpx, cpy);
            break;
          case "q":
            points.push(cpx + p2.shift(), cpy + p2.shift());
            cpx += p2.shift();
            cpy += p2.shift();
            cmd = "Q";
            points.push(cpx, cpy);
            break;
          case "T":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "Q") {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx = p2.shift();
            cpy = p2.shift();
            cmd = "Q";
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case "t":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "Q") {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx += p2.shift();
            cpy += p2.shift();
            cmd = "Q";
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case "A":
            rx = p2.shift();
            ry = p2.shift();
            psi = p2.shift();
            fa = p2.shift();
            fs = p2.shift();
            x1 = cpx;
            y1 = cpy;
            cpx = p2.shift();
            cpy = p2.shift();
            cmd = "A";
            points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
            break;
          case "a":
            rx = p2.shift();
            ry = p2.shift();
            psi = p2.shift();
            fa = p2.shift();
            fs = p2.shift();
            x1 = cpx;
            y1 = cpy;
            cpx += p2.shift();
            cpy += p2.shift();
            cmd = "A";
            points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
            break;
        }
        ca.push({
          command: cmd || c2,
          points,
          start: {
            x: startX,
            y: startY
          },
          pathLength: this.calcLength(startX, startY, cmd || c2, points)
        });
      }
      if (c2 === "z" || c2 === "Z") {
        ca.push({
          command: "z",
          points: [],
          start: void 0,
          pathLength: 0
        });
      }
    }
    return ca;
  }
  static calcLength(x, y, cmd, points) {
    var len2, p1, p2, t;
    var path = Path;
    switch (cmd) {
      case "L":
        return path.getLineLength(x, y, points[0], points[1]);
      case "C":
        return (0, BezierFunctions_1.getCubicArcLength)([x, points[0], points[2], points[4]], [y, points[1], points[3], points[5]], 1);
      case "Q":
        return (0, BezierFunctions_1.getQuadraticArcLength)([x, points[0], points[2]], [y, points[1], points[3]], 1);
      case "A":
        len2 = 0;
        var start = points[4];
        var dTheta = points[5];
        var end = points[4] + dTheta;
        var inc = Math.PI / 180;
        if (Math.abs(start - end) < inc) {
          inc = Math.abs(start - end);
        }
        p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
        if (dTheta < 0) {
          for (t = start - inc; t > end; t -= inc) {
            p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
            len2 += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        } else {
          for (t = start + inc; t < end; t += inc) {
            p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
            len2 += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        }
        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
        len2 += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
        return len2;
    }
    return 0;
  }
  static convertEndpointToCenterParameterization(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
    var psi = psiDeg * (Math.PI / 180);
    var xp = Math.cos(psi) * (x1 - x2) / 2 + Math.sin(psi) * (y1 - y2) / 2;
    var yp = -1 * Math.sin(psi) * (x1 - x2) / 2 + Math.cos(psi) * (y1 - y2) / 2;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var f = Math.sqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp)));
    if (fa === fs) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }
    var cxp = f * rx * yp / ry;
    var cyp = f * -ry * xp / rx;
    var cx = (x1 + x2) / 2 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
    var cy = (y1 + y2) / 2 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;
    var vMag = function(v2) {
      return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
    };
    var vRatio = function(u2, v2) {
      return (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2));
    };
    var vAngle = function(u2, v2) {
      return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
    };
    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (fs === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * Math.PI;
    }
    if (fs === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * Math.PI;
    }
    return [cx, cy, rx, ry, theta, dTheta, psi, fs];
  }
}
Path$1.Path = Path;
Path.prototype.className = "Path";
Path.prototype._attrsAffectingSize = ["data"];
(0, Global_1$e._registerNode)(Path);
Factory_1$t.Factory.addGetterSetter(Path, "data");
Object.defineProperty(Arrow$1, "__esModule", { value: true });
Arrow$1.Arrow = void 0;
const Factory_1$s = Factory;
const Line_1$1 = Line$2;
const Validators_1$s = Validators;
const Global_1$d = Global;
const Path_1$2 = Path$1;
class Arrow extends Line_1$1.Line {
  _sceneFunc(ctx2) {
    super._sceneFunc(ctx2);
    var PI2 = Math.PI * 2;
    var points = this.points();
    var tp = points;
    var fromTension = this.tension() !== 0 && points.length > 4;
    if (fromTension) {
      tp = this.getTensionPoints();
    }
    var length = this.pointerLength();
    var n = points.length;
    var dx, dy;
    if (fromTension) {
      const lp = [
        tp[tp.length - 4],
        tp[tp.length - 3],
        tp[tp.length - 2],
        tp[tp.length - 1],
        points[n - 2],
        points[n - 1]
      ];
      const lastLength = Path_1$2.Path.calcLength(tp[tp.length - 4], tp[tp.length - 3], "C", lp);
      const previous = Path_1$2.Path.getPointOnQuadraticBezier(Math.min(1, 1 - length / lastLength), lp[0], lp[1], lp[2], lp[3], lp[4], lp[5]);
      dx = points[n - 2] - previous.x;
      dy = points[n - 1] - previous.y;
    } else {
      dx = points[n - 2] - points[n - 4];
      dy = points[n - 1] - points[n - 3];
    }
    var radians = (Math.atan2(dy, dx) + PI2) % PI2;
    var width = this.pointerWidth();
    if (this.pointerAtEnding()) {
      ctx2.save();
      ctx2.beginPath();
      ctx2.translate(points[n - 2], points[n - 1]);
      ctx2.rotate(radians);
      ctx2.moveTo(0, 0);
      ctx2.lineTo(-length, width / 2);
      ctx2.lineTo(-length, -width / 2);
      ctx2.closePath();
      ctx2.restore();
      this.__fillStroke(ctx2);
    }
    if (this.pointerAtBeginning()) {
      ctx2.save();
      ctx2.beginPath();
      ctx2.translate(points[0], points[1]);
      if (fromTension) {
        dx = (tp[0] + tp[2]) / 2 - points[0];
        dy = (tp[1] + tp[3]) / 2 - points[1];
      } else {
        dx = points[2] - points[0];
        dy = points[3] - points[1];
      }
      ctx2.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
      ctx2.moveTo(0, 0);
      ctx2.lineTo(-length, width / 2);
      ctx2.lineTo(-length, -width / 2);
      ctx2.closePath();
      ctx2.restore();
      this.__fillStroke(ctx2);
    }
  }
  __fillStroke(ctx2) {
    var isDashEnabled = this.dashEnabled();
    if (isDashEnabled) {
      this.attrs.dashEnabled = false;
      ctx2.setLineDash([]);
    }
    ctx2.fillStrokeShape(this);
    if (isDashEnabled) {
      this.attrs.dashEnabled = true;
    }
  }
  getSelfRect() {
    const lineRect = super.getSelfRect();
    const offset = this.pointerWidth() / 2;
    return {
      x: lineRect.x - offset,
      y: lineRect.y - offset,
      width: lineRect.width + offset * 2,
      height: lineRect.height + offset * 2
    };
  }
}
Arrow$1.Arrow = Arrow;
Arrow.prototype.className = "Arrow";
(0, Global_1$d._registerNode)(Arrow);
Factory_1$s.Factory.addGetterSetter(Arrow, "pointerLength", 10, (0, Validators_1$s.getNumberValidator)());
Factory_1$s.Factory.addGetterSetter(Arrow, "pointerWidth", 10, (0, Validators_1$s.getNumberValidator)());
Factory_1$s.Factory.addGetterSetter(Arrow, "pointerAtBeginning", false);
Factory_1$s.Factory.addGetterSetter(Arrow, "pointerAtEnding", true);
var Circle$2 = {};
Object.defineProperty(Circle$2, "__esModule", { value: true });
Circle$2.Circle = void 0;
const Factory_1$r = Factory;
const Shape_1$c = Shape;
const Validators_1$r = Validators;
const Global_1$c = Global;
let Circle$1 = class Circle extends Shape_1$c.Shape {
  _sceneFunc(context) {
    context.beginPath();
    context.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, false);
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.radius() * 2;
  }
  getHeight() {
    return this.radius() * 2;
  }
  setWidth(width) {
    if (this.radius() !== width / 2) {
      this.radius(width / 2);
    }
  }
  setHeight(height) {
    if (this.radius() !== height / 2) {
      this.radius(height / 2);
    }
  }
};
Circle$2.Circle = Circle$1;
Circle$1.prototype._centroid = true;
Circle$1.prototype.className = "Circle";
Circle$1.prototype._attrsAffectingSize = ["radius"];
(0, Global_1$c._registerNode)(Circle$1);
Factory_1$r.Factory.addGetterSetter(Circle$1, "radius", 0, (0, Validators_1$r.getNumberValidator)());
var Ellipse$1 = {};
Object.defineProperty(Ellipse$1, "__esModule", { value: true });
Ellipse$1.Ellipse = void 0;
const Factory_1$q = Factory;
const Shape_1$b = Shape;
const Validators_1$q = Validators;
const Global_1$b = Global;
class Ellipse extends Shape_1$b.Shape {
  _sceneFunc(context) {
    var rx = this.radiusX(), ry = this.radiusY();
    context.beginPath();
    context.save();
    if (rx !== ry) {
      context.scale(1, ry / rx);
    }
    context.arc(0, 0, rx, 0, Math.PI * 2, false);
    context.restore();
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.radiusX() * 2;
  }
  getHeight() {
    return this.radiusY() * 2;
  }
  setWidth(width) {
    this.radiusX(width / 2);
  }
  setHeight(height) {
    this.radiusY(height / 2);
  }
}
Ellipse$1.Ellipse = Ellipse;
Ellipse.prototype.className = "Ellipse";
Ellipse.prototype._centroid = true;
Ellipse.prototype._attrsAffectingSize = ["radiusX", "radiusY"];
(0, Global_1$b._registerNode)(Ellipse);
Factory_1$q.Factory.addComponentsGetterSetter(Ellipse, "radius", ["x", "y"]);
Factory_1$q.Factory.addGetterSetter(Ellipse, "radiusX", 0, (0, Validators_1$q.getNumberValidator)());
Factory_1$q.Factory.addGetterSetter(Ellipse, "radiusY", 0, (0, Validators_1$q.getNumberValidator)());
var Image$2 = {};
Object.defineProperty(Image$2, "__esModule", { value: true });
Image$2.Image = void 0;
const Util_1$7 = Util;
const Factory_1$p = Factory;
const Shape_1$a = Shape;
const Global_1$a = Global;
const Validators_1$p = Validators;
let Image$1 = class Image2 extends Shape_1$a.Shape {
  constructor(attrs) {
    super(attrs);
    this.on("imageChange.konva", () => {
      this._setImageLoad();
    });
    this._setImageLoad();
  }
  _setImageLoad() {
    const image = this.image();
    if (image && image.complete) {
      return;
    }
    if (image && image.readyState === 4) {
      return;
    }
    if (image && image["addEventListener"]) {
      image["addEventListener"]("load", () => {
        this._requestDraw();
      });
    }
  }
  _useBufferCanvas() {
    const hasCornerRadius = !!this.cornerRadius();
    const hasShadow = this.hasShadow();
    if (hasCornerRadius && hasShadow) {
      return true;
    }
    return super._useBufferCanvas(true);
  }
  _sceneFunc(context) {
    const width = this.getWidth();
    const height = this.getHeight();
    const cornerRadius = this.cornerRadius();
    const image = this.attrs.image;
    let params;
    if (image) {
      const cropWidth = this.attrs.cropWidth;
      const cropHeight = this.attrs.cropHeight;
      if (cropWidth && cropHeight) {
        params = [
          image,
          this.cropX(),
          this.cropY(),
          cropWidth,
          cropHeight,
          0,
          0,
          width,
          height
        ];
      } else {
        params = [image, 0, 0, width, height];
      }
    }
    if (this.hasFill() || this.hasStroke() || cornerRadius) {
      context.beginPath();
      cornerRadius ? Util_1$7.Util.drawRoundedRectPath(context, width, height, cornerRadius) : context.rect(0, 0, width, height);
      context.closePath();
      context.fillStrokeShape(this);
    }
    if (image) {
      if (cornerRadius) {
        context.clip();
      }
      context.drawImage.apply(context, params);
    }
  }
  _hitFunc(context) {
    var width = this.width(), height = this.height(), cornerRadius = this.cornerRadius();
    context.beginPath();
    if (!cornerRadius) {
      context.rect(0, 0, width, height);
    } else {
      Util_1$7.Util.drawRoundedRectPath(context, width, height, cornerRadius);
    }
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    var _a, _b;
    return (_a = this.attrs.width) !== null && _a !== void 0 ? _a : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.width;
  }
  getHeight() {
    var _a, _b;
    return (_a = this.attrs.height) !== null && _a !== void 0 ? _a : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.height;
  }
  static fromURL(url2, callback, onError = null) {
    var img = Util_1$7.Util.createImageElement();
    img.onload = function() {
      var image = new Image2({
        image: img
      });
      callback(image);
    };
    img.onerror = onError;
    img.crossOrigin = "Anonymous";
    img.src = url2;
  }
};
Image$2.Image = Image$1;
Image$1.prototype.className = "Image";
(0, Global_1$a._registerNode)(Image$1);
Factory_1$p.Factory.addGetterSetter(Image$1, "cornerRadius", 0, (0, Validators_1$p.getNumberOrArrayOfNumbersValidator)(4));
Factory_1$p.Factory.addGetterSetter(Image$1, "image");
Factory_1$p.Factory.addComponentsGetterSetter(Image$1, "crop", ["x", "y", "width", "height"]);
Factory_1$p.Factory.addGetterSetter(Image$1, "cropX", 0, (0, Validators_1$p.getNumberValidator)());
Factory_1$p.Factory.addGetterSetter(Image$1, "cropY", 0, (0, Validators_1$p.getNumberValidator)());
Factory_1$p.Factory.addGetterSetter(Image$1, "cropWidth", 0, (0, Validators_1$p.getNumberValidator)());
Factory_1$p.Factory.addGetterSetter(Image$1, "cropHeight", 0, (0, Validators_1$p.getNumberValidator)());
var Label$1 = {};
Object.defineProperty(Label$1, "__esModule", { value: true });
Label$1.Tag = Label$1.Label = void 0;
const Factory_1$o = Factory;
const Shape_1$9 = Shape;
const Group_1$1 = Group$1;
const Validators_1$o = Validators;
const Global_1$9 = Global;
var ATTR_CHANGE_LIST$2 = [
  "fontFamily",
  "fontSize",
  "fontStyle",
  "padding",
  "lineHeight",
  "text",
  "width",
  "height",
  "pointerDirection",
  "pointerWidth",
  "pointerHeight"
], CHANGE_KONVA$1 = "Change.konva", NONE$1 = "none", UP = "up", RIGHT$1 = "right", DOWN = "down", LEFT$1 = "left", attrChangeListLen$1 = ATTR_CHANGE_LIST$2.length;
class Label extends Group_1$1.Group {
  constructor(config) {
    super(config);
    this.on("add.konva", function(evt) {
      this._addListeners(evt.child);
      this._sync();
    });
  }
  getText() {
    return this.find("Text")[0];
  }
  getTag() {
    return this.find("Tag")[0];
  }
  _addListeners(text) {
    var that = this, n;
    var func2 = function() {
      that._sync();
    };
    for (n = 0; n < attrChangeListLen$1; n++) {
      text.on(ATTR_CHANGE_LIST$2[n] + CHANGE_KONVA$1, func2);
    }
  }
  getWidth() {
    return this.getText().width();
  }
  getHeight() {
    return this.getText().height();
  }
  _sync() {
    var text = this.getText(), tag2 = this.getTag(), width, height, pointerDirection, pointerWidth, x, y, pointerHeight;
    if (text && tag2) {
      width = text.width();
      height = text.height();
      pointerDirection = tag2.pointerDirection();
      pointerWidth = tag2.pointerWidth();
      pointerHeight = tag2.pointerHeight();
      x = 0;
      y = 0;
      switch (pointerDirection) {
        case UP:
          x = width / 2;
          y = -1 * pointerHeight;
          break;
        case RIGHT$1:
          x = width + pointerWidth;
          y = height / 2;
          break;
        case DOWN:
          x = width / 2;
          y = height + pointerHeight;
          break;
        case LEFT$1:
          x = -1 * pointerWidth;
          y = height / 2;
          break;
      }
      tag2.setAttrs({
        x: -1 * x,
        y: -1 * y,
        width,
        height
      });
      text.setAttrs({
        x: -1 * x,
        y: -1 * y
      });
    }
  }
}
Label$1.Label = Label;
Label.prototype.className = "Label";
(0, Global_1$9._registerNode)(Label);
class Tag extends Shape_1$9.Shape {
  _sceneFunc(context) {
    var width = this.width(), height = this.height(), pointerDirection = this.pointerDirection(), pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), cornerRadius = this.cornerRadius();
    let topLeft = 0;
    let topRight = 0;
    let bottomLeft = 0;
    let bottomRight = 0;
    if (typeof cornerRadius === "number") {
      topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
    } else {
      topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
      topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
      bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
      bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
    }
    context.beginPath();
    context.moveTo(topLeft, 0);
    if (pointerDirection === UP) {
      context.lineTo((width - pointerWidth) / 2, 0);
      context.lineTo(width / 2, -1 * pointerHeight);
      context.lineTo((width + pointerWidth) / 2, 0);
    }
    context.lineTo(width - topRight, 0);
    context.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, false);
    if (pointerDirection === RIGHT$1) {
      context.lineTo(width, (height - pointerHeight) / 2);
      context.lineTo(width + pointerWidth, height / 2);
      context.lineTo(width, (height + pointerHeight) / 2);
    }
    context.lineTo(width, height - bottomRight);
    context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
    if (pointerDirection === DOWN) {
      context.lineTo((width + pointerWidth) / 2, height);
      context.lineTo(width / 2, height + pointerHeight);
      context.lineTo((width - pointerWidth) / 2, height);
    }
    context.lineTo(bottomLeft, height);
    context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
    if (pointerDirection === LEFT$1) {
      context.lineTo(0, (height + pointerHeight) / 2);
      context.lineTo(-1 * pointerWidth, height / 2);
      context.lineTo(0, (height - pointerHeight) / 2);
    }
    context.lineTo(0, topLeft);
    context.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
    context.closePath();
    context.fillStrokeShape(this);
  }
  getSelfRect() {
    var x = 0, y = 0, pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), direction = this.pointerDirection(), width = this.width(), height = this.height();
    if (direction === UP) {
      y -= pointerHeight;
      height += pointerHeight;
    } else if (direction === DOWN) {
      height += pointerHeight;
    } else if (direction === LEFT$1) {
      x -= pointerWidth * 1.5;
      width += pointerWidth;
    } else if (direction === RIGHT$1) {
      width += pointerWidth * 1.5;
    }
    return {
      x,
      y,
      width,
      height
    };
  }
}
Label$1.Tag = Tag;
Tag.prototype.className = "Tag";
(0, Global_1$9._registerNode)(Tag);
Factory_1$o.Factory.addGetterSetter(Tag, "pointerDirection", NONE$1);
Factory_1$o.Factory.addGetterSetter(Tag, "pointerWidth", 0, (0, Validators_1$o.getNumberValidator)());
Factory_1$o.Factory.addGetterSetter(Tag, "pointerHeight", 0, (0, Validators_1$o.getNumberValidator)());
Factory_1$o.Factory.addGetterSetter(Tag, "cornerRadius", 0, (0, Validators_1$o.getNumberOrArrayOfNumbersValidator)(4));
var Rect$2 = {};
Object.defineProperty(Rect$2, "__esModule", { value: true });
Rect$2.Rect = void 0;
const Factory_1$n = Factory;
const Shape_1$8 = Shape;
const Global_1$8 = Global;
const Util_1$6 = Util;
const Validators_1$n = Validators;
let Rect$1 = class Rect extends Shape_1$8.Shape {
  _sceneFunc(context) {
    var cornerRadius = this.cornerRadius(), width = this.width(), height = this.height();
    context.beginPath();
    if (!cornerRadius) {
      context.rect(0, 0, width, height);
    } else {
      Util_1$6.Util.drawRoundedRectPath(context, width, height, cornerRadius);
    }
    context.closePath();
    context.fillStrokeShape(this);
  }
};
Rect$2.Rect = Rect$1;
Rect$1.prototype.className = "Rect";
(0, Global_1$8._registerNode)(Rect$1);
Factory_1$n.Factory.addGetterSetter(Rect$1, "cornerRadius", 0, (0, Validators_1$n.getNumberOrArrayOfNumbersValidator)(4));
var RegularPolygon$1 = {};
Object.defineProperty(RegularPolygon$1, "__esModule", { value: true });
RegularPolygon$1.RegularPolygon = void 0;
const Factory_1$m = Factory;
const Shape_1$7 = Shape;
const Validators_1$m = Validators;
const Global_1$7 = Global;
class RegularPolygon extends Shape_1$7.Shape {
  _sceneFunc(context) {
    const points = this._getPoints();
    context.beginPath();
    context.moveTo(points[0].x, points[0].y);
    for (var n = 1; n < points.length; n++) {
      context.lineTo(points[n].x, points[n].y);
    }
    context.closePath();
    context.fillStrokeShape(this);
  }
  _getPoints() {
    const sides = this.attrs.sides;
    const radius = this.attrs.radius || 0;
    const points = [];
    for (var n = 0; n < sides; n++) {
      points.push({
        x: radius * Math.sin(n * 2 * Math.PI / sides),
        y: -1 * radius * Math.cos(n * 2 * Math.PI / sides)
      });
    }
    return points;
  }
  getSelfRect() {
    const points = this._getPoints();
    var minX = points[0].x;
    var maxX = points[0].y;
    var minY = points[0].x;
    var maxY = points[0].y;
    points.forEach((point) => {
      minX = Math.min(minX, point.x);
      maxX = Math.max(maxX, point.x);
      minY = Math.min(minY, point.y);
      maxY = Math.max(maxY, point.y);
    });
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  getWidth() {
    return this.radius() * 2;
  }
  getHeight() {
    return this.radius() * 2;
  }
  setWidth(width) {
    this.radius(width / 2);
  }
  setHeight(height) {
    this.radius(height / 2);
  }
}
RegularPolygon$1.RegularPolygon = RegularPolygon;
RegularPolygon.prototype.className = "RegularPolygon";
RegularPolygon.prototype._centroid = true;
RegularPolygon.prototype._attrsAffectingSize = ["radius"];
(0, Global_1$7._registerNode)(RegularPolygon);
Factory_1$m.Factory.addGetterSetter(RegularPolygon, "radius", 0, (0, Validators_1$m.getNumberValidator)());
Factory_1$m.Factory.addGetterSetter(RegularPolygon, "sides", 0, (0, Validators_1$m.getNumberValidator)());
var Ring$1 = {};
Object.defineProperty(Ring$1, "__esModule", { value: true });
Ring$1.Ring = void 0;
const Factory_1$l = Factory;
const Shape_1$6 = Shape;
const Validators_1$l = Validators;
const Global_1$6 = Global;
var PIx2 = Math.PI * 2;
class Ring extends Shape_1$6.Shape {
  _sceneFunc(context) {
    context.beginPath();
    context.arc(0, 0, this.innerRadius(), 0, PIx2, false);
    context.moveTo(this.outerRadius(), 0);
    context.arc(0, 0, this.outerRadius(), PIx2, 0, true);
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.outerRadius() * 2;
  }
  getHeight() {
    return this.outerRadius() * 2;
  }
  setWidth(width) {
    this.outerRadius(width / 2);
  }
  setHeight(height) {
    this.outerRadius(height / 2);
  }
}
Ring$1.Ring = Ring;
Ring.prototype.className = "Ring";
Ring.prototype._centroid = true;
Ring.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
(0, Global_1$6._registerNode)(Ring);
Factory_1$l.Factory.addGetterSetter(Ring, "innerRadius", 0, (0, Validators_1$l.getNumberValidator)());
Factory_1$l.Factory.addGetterSetter(Ring, "outerRadius", 0, (0, Validators_1$l.getNumberValidator)());
var Sprite$1 = {};
Object.defineProperty(Sprite$1, "__esModule", { value: true });
Sprite$1.Sprite = void 0;
const Factory_1$k = Factory;
const Shape_1$5 = Shape;
const Animation_1 = Animation$1;
const Validators_1$k = Validators;
const Global_1$5 = Global;
class Sprite extends Shape_1$5.Shape {
  constructor(config) {
    super(config);
    this._updated = true;
    this.anim = new Animation_1.Animation(() => {
      var updated = this._updated;
      this._updated = false;
      return updated;
    });
    this.on("animationChange.konva", function() {
      this.frameIndex(0);
    });
    this.on("frameIndexChange.konva", function() {
      this._updated = true;
    });
    this.on("frameRateChange.konva", function() {
      if (!this.anim.isRunning()) {
        return;
      }
      clearInterval(this.interval);
      this._setInterval();
    });
  }
  _sceneFunc(context) {
    var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set2 = this.animations()[anim], offsets = this.frameOffsets(), x = set2[ix4 + 0], y = set2[ix4 + 1], width = set2[ix4 + 2], height = set2[ix4 + 3], image = this.image();
    if (this.hasFill() || this.hasStroke()) {
      context.beginPath();
      context.rect(0, 0, width, height);
      context.closePath();
      context.fillStrokeShape(this);
    }
    if (image) {
      if (offsets) {
        var offset = offsets[anim], ix2 = index * 2;
        context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
      } else {
        context.drawImage(image, x, y, width, height, 0, 0, width, height);
      }
    }
  }
  _hitFunc(context) {
    var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set2 = this.animations()[anim], offsets = this.frameOffsets(), width = set2[ix4 + 2], height = set2[ix4 + 3];
    context.beginPath();
    if (offsets) {
      var offset = offsets[anim];
      var ix2 = index * 2;
      context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
    } else {
      context.rect(0, 0, width, height);
    }
    context.closePath();
    context.fillShape(this);
  }
  _useBufferCanvas() {
    return super._useBufferCanvas(true);
  }
  _setInterval() {
    var that = this;
    this.interval = setInterval(function() {
      that._updateIndex();
    }, 1e3 / this.frameRate());
  }
  start() {
    if (this.isRunning()) {
      return;
    }
    var layer = this.getLayer();
    this.anim.setLayers(layer);
    this._setInterval();
    this.anim.start();
  }
  stop() {
    this.anim.stop();
    clearInterval(this.interval);
  }
  isRunning() {
    return this.anim.isRunning();
  }
  _updateIndex() {
    var index = this.frameIndex(), animation = this.animation(), animations = this.animations(), anim = animations[animation], len2 = anim.length / 4;
    if (index < len2 - 1) {
      this.frameIndex(index + 1);
    } else {
      this.frameIndex(0);
    }
  }
}
Sprite$1.Sprite = Sprite;
Sprite.prototype.className = "Sprite";
(0, Global_1$5._registerNode)(Sprite);
Factory_1$k.Factory.addGetterSetter(Sprite, "animation");
Factory_1$k.Factory.addGetterSetter(Sprite, "animations");
Factory_1$k.Factory.addGetterSetter(Sprite, "frameOffsets");
Factory_1$k.Factory.addGetterSetter(Sprite, "image");
Factory_1$k.Factory.addGetterSetter(Sprite, "frameIndex", 0, (0, Validators_1$k.getNumberValidator)());
Factory_1$k.Factory.addGetterSetter(Sprite, "frameRate", 17, (0, Validators_1$k.getNumberValidator)());
Factory_1$k.Factory.backCompat(Sprite, {
  index: "frameIndex",
  getIndex: "getFrameIndex",
  setIndex: "setFrameIndex"
});
var Star$1 = {};
Object.defineProperty(Star$1, "__esModule", { value: true });
Star$1.Star = void 0;
const Factory_1$j = Factory;
const Shape_1$4 = Shape;
const Validators_1$j = Validators;
const Global_1$4 = Global;
class Star extends Shape_1$4.Shape {
  _sceneFunc(context) {
    var innerRadius = this.innerRadius(), outerRadius = this.outerRadius(), numPoints = this.numPoints();
    context.beginPath();
    context.moveTo(0, 0 - outerRadius);
    for (var n = 1; n < numPoints * 2; n++) {
      var radius = n % 2 === 0 ? outerRadius : innerRadius;
      var x = radius * Math.sin(n * Math.PI / numPoints);
      var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
      context.lineTo(x, y);
    }
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.outerRadius() * 2;
  }
  getHeight() {
    return this.outerRadius() * 2;
  }
  setWidth(width) {
    this.outerRadius(width / 2);
  }
  setHeight(height) {
    this.outerRadius(height / 2);
  }
}
Star$1.Star = Star;
Star.prototype.className = "Star";
Star.prototype._centroid = true;
Star.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
(0, Global_1$4._registerNode)(Star);
Factory_1$j.Factory.addGetterSetter(Star, "numPoints", 5, (0, Validators_1$j.getNumberValidator)());
Factory_1$j.Factory.addGetterSetter(Star, "innerRadius", 0, (0, Validators_1$j.getNumberValidator)());
Factory_1$j.Factory.addGetterSetter(Star, "outerRadius", 0, (0, Validators_1$j.getNumberValidator)());
var Text$1 = {};
Object.defineProperty(Text$1, "__esModule", { value: true });
Text$1.Text = Text$1.stringToArray = void 0;
const Util_1$5 = Util;
const Factory_1$i = Factory;
const Shape_1$3 = Shape;
const Global_1$3 = Global;
const Validators_1$i = Validators;
const Global_2$2 = Global;
function stringToArray(string3) {
  return Array.from(string3);
}
Text$1.stringToArray = stringToArray;
var AUTO = "auto", CENTER = "center", INHERIT = "inherit", JUSTIFY = "justify", CHANGE_KONVA = "Change.konva", CONTEXT_2D = "2d", DASH = "-", LEFT = "left", TEXT = "text", TEXT_UPPER = "Text", TOP = "top", BOTTOM = "bottom", MIDDLE = "middle", NORMAL$1 = "normal", PX_SPACE = "px ", SPACE = " ", RIGHT = "right", RTL = "rtl", WORD = "word", CHAR = "char", NONE = "none", ELLIPSIS = "…", ATTR_CHANGE_LIST$1 = [
  "direction",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontVariant",
  "padding",
  "align",
  "verticalAlign",
  "lineHeight",
  "text",
  "width",
  "height",
  "wrap",
  "ellipsis",
  "letterSpacing"
], attrChangeListLen = ATTR_CHANGE_LIST$1.length;
function normalizeFontFamily(fontFamily2) {
  return fontFamily2.split(",").map((family) => {
    family = family.trim();
    const hasSpace = family.indexOf(" ") >= 0;
    const hasQuotes = family.indexOf('"') >= 0 || family.indexOf("'") >= 0;
    if (hasSpace && !hasQuotes) {
      family = `"${family}"`;
    }
    return family;
  }).join(", ");
}
var dummyContext;
function getDummyContext() {
  if (dummyContext) {
    return dummyContext;
  }
  dummyContext = Util_1$5.Util.createCanvasElement().getContext(CONTEXT_2D);
  return dummyContext;
}
function _fillFunc$1(context) {
  context.fillText(this._partialText, this._partialTextX, this._partialTextY);
}
function _strokeFunc$1(context) {
  context.setAttr("miterLimit", 2);
  context.strokeText(this._partialText, this._partialTextX, this._partialTextY);
}
function checkDefaultFill(config) {
  config = config || {};
  if (!config.fillLinearGradientColorStops && !config.fillRadialGradientColorStops && !config.fillPatternImage) {
    config.fill = config.fill || "black";
  }
  return config;
}
class Text extends Shape_1$3.Shape {
  constructor(config) {
    super(checkDefaultFill(config));
    this._partialTextX = 0;
    this._partialTextY = 0;
    for (var n = 0; n < attrChangeListLen; n++) {
      this.on(ATTR_CHANGE_LIST$1[n] + CHANGE_KONVA, this._setTextData);
    }
    this._setTextData();
  }
  _sceneFunc(context) {
    var textArr = this.textArr, textArrLen = textArr.length;
    if (!this.text()) {
      return;
    }
    var padding = this.padding(), fontSize2 = this.fontSize(), lineHeightPx = this.lineHeight() * fontSize2, verticalAlign = this.verticalAlign(), direction = this.direction(), alignY = 0, align = this.align(), totalWidth = this.getWidth(), letterSpacing = this.letterSpacing(), fill2 = this.fill(), textDecoration = this.textDecoration(), shouldUnderline = textDecoration.indexOf("underline") !== -1, shouldLineThrough = textDecoration.indexOf("line-through") !== -1, n;
    direction = direction === INHERIT ? context.direction : direction;
    var translateY = lineHeightPx / 2;
    var baseline = MIDDLE;
    if (Global_1$3.Konva._fixTextRendering) {
      var metrics = this.measureSize("M");
      baseline = "alphabetic";
      translateY = (metrics.fontBoundingBoxAscent - metrics.fontBoundingBoxDescent) / 2 + lineHeightPx / 2;
    }
    var lineTranslateX = 0;
    var lineTranslateY = 0;
    if (direction === RTL) {
      context.setAttr("direction", direction);
    }
    context.setAttr("font", this._getContextFont());
    context.setAttr("textBaseline", baseline);
    context.setAttr("textAlign", LEFT);
    if (verticalAlign === MIDDLE) {
      alignY = (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2;
    } else if (verticalAlign === BOTTOM) {
      alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2;
    }
    context.translate(padding, alignY + padding);
    for (n = 0; n < textArrLen; n++) {
      var lineTranslateX = 0;
      var lineTranslateY = 0;
      var obj = textArr[n], text = obj.text, width = obj.width, lastLine = obj.lastInParagraph, spacesNumber, oneWord, lineWidth;
      context.save();
      if (align === RIGHT) {
        lineTranslateX += totalWidth - width - padding * 2;
      } else if (align === CENTER) {
        lineTranslateX += (totalWidth - width - padding * 2) / 2;
      }
      if (shouldUnderline) {
        context.save();
        context.beginPath();
        let yOffset = Global_1$3.Konva._fixTextRendering ? Math.round(fontSize2 / 4) : Math.round(fontSize2 / 2);
        const x = lineTranslateX;
        const y = translateY + lineTranslateY + yOffset;
        context.moveTo(x, y);
        spacesNumber = text.split(" ").length - 1;
        oneWord = spacesNumber === 0;
        lineWidth = align === JUSTIFY && !lastLine ? totalWidth - padding * 2 : width;
        context.lineTo(x + Math.round(lineWidth), y);
        context.lineWidth = fontSize2 / 15;
        const gradient = this._getLinearGradient();
        context.strokeStyle = gradient || fill2;
        context.stroke();
        context.restore();
      }
      if (shouldLineThrough) {
        context.save();
        context.beginPath();
        let yOffset = Global_1$3.Konva._fixTextRendering ? -Math.round(fontSize2 / 4) : 0;
        context.moveTo(lineTranslateX, translateY + lineTranslateY + yOffset);
        spacesNumber = text.split(" ").length - 1;
        oneWord = spacesNumber === 0;
        lineWidth = align === JUSTIFY && lastLine && !oneWord ? totalWidth - padding * 2 : width;
        context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY + yOffset);
        context.lineWidth = fontSize2 / 15;
        const gradient = this._getLinearGradient();
        context.strokeStyle = gradient || fill2;
        context.stroke();
        context.restore();
      }
      if (direction !== RTL && (letterSpacing !== 0 || align === JUSTIFY)) {
        spacesNumber = text.split(" ").length - 1;
        var array4 = stringToArray(text);
        for (var li = 0; li < array4.length; li++) {
          var letter = array4[li];
          if (letter === " " && !lastLine && align === JUSTIFY) {
            lineTranslateX += (totalWidth - padding * 2 - width) / spacesNumber;
          }
          this._partialTextX = lineTranslateX;
          this._partialTextY = translateY + lineTranslateY;
          this._partialText = letter;
          context.fillStrokeShape(this);
          lineTranslateX += this.measureSize(letter).width + letterSpacing;
        }
      } else {
        if (letterSpacing !== 0) {
          context.setAttr("letterSpacing", `${letterSpacing}px`);
        }
        this._partialTextX = lineTranslateX;
        this._partialTextY = translateY + lineTranslateY;
        this._partialText = text;
        context.fillStrokeShape(this);
      }
      context.restore();
      if (textArrLen > 1) {
        translateY += lineHeightPx;
      }
    }
  }
  _hitFunc(context) {
    var width = this.getWidth(), height = this.getHeight();
    context.beginPath();
    context.rect(0, 0, width, height);
    context.closePath();
    context.fillStrokeShape(this);
  }
  setText(text) {
    var str = Util_1$5.Util._isString(text) ? text : text === null || text === void 0 ? "" : text + "";
    this._setAttr(TEXT, str);
    return this;
  }
  getWidth() {
    var isAuto = this.attrs.width === AUTO || this.attrs.width === void 0;
    return isAuto ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
  }
  getHeight() {
    var isAuto = this.attrs.height === AUTO || this.attrs.height === void 0;
    return isAuto ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height;
  }
  getTextWidth() {
    return this.textWidth;
  }
  getTextHeight() {
    Util_1$5.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.");
    return this.textHeight;
  }
  measureSize(text) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    var _context = getDummyContext(), fontSize2 = this.fontSize(), metrics;
    _context.save();
    _context.font = this._getContextFont();
    metrics = _context.measureText(text);
    _context.restore();
    const scaleFactor = fontSize2 / 100;
    return {
      actualBoundingBoxAscent: (_a = metrics.actualBoundingBoxAscent) !== null && _a !== void 0 ? _a : 71.58203125 * scaleFactor,
      actualBoundingBoxDescent: (_b = metrics.actualBoundingBoxDescent) !== null && _b !== void 0 ? _b : 0,
      actualBoundingBoxLeft: (_c = metrics.actualBoundingBoxLeft) !== null && _c !== void 0 ? _c : -7.421875 * scaleFactor,
      actualBoundingBoxRight: (_d = metrics.actualBoundingBoxRight) !== null && _d !== void 0 ? _d : 75.732421875 * scaleFactor,
      alphabeticBaseline: (_e = metrics.alphabeticBaseline) !== null && _e !== void 0 ? _e : 0,
      emHeightAscent: (_f = metrics.emHeightAscent) !== null && _f !== void 0 ? _f : 100 * scaleFactor,
      emHeightDescent: (_g = metrics.emHeightDescent) !== null && _g !== void 0 ? _g : -20 * scaleFactor,
      fontBoundingBoxAscent: (_h = metrics.fontBoundingBoxAscent) !== null && _h !== void 0 ? _h : 91 * scaleFactor,
      fontBoundingBoxDescent: (_j = metrics.fontBoundingBoxDescent) !== null && _j !== void 0 ? _j : 21 * scaleFactor,
      hangingBaseline: (_k = metrics.hangingBaseline) !== null && _k !== void 0 ? _k : 72.80000305175781 * scaleFactor,
      ideographicBaseline: (_l = metrics.ideographicBaseline) !== null && _l !== void 0 ? _l : -21 * scaleFactor,
      width: metrics.width,
      height: fontSize2
    };
  }
  _getContextFont() {
    return this.fontStyle() + SPACE + this.fontVariant() + SPACE + (this.fontSize() + PX_SPACE) + normalizeFontFamily(this.fontFamily());
  }
  _addTextLine(line) {
    const align = this.align();
    if (align === JUSTIFY) {
      line = line.trim();
    }
    var width = this._getTextWidth(line);
    return this.textArr.push({
      text: line,
      width,
      lastInParagraph: false
    });
  }
  _getTextWidth(text) {
    var letterSpacing = this.letterSpacing();
    var length = text.length;
    return getDummyContext().measureText(text).width + (length ? letterSpacing * (length - 1) : 0);
  }
  _setTextData() {
    var lines = this.text().split("\n"), fontSize2 = +this.fontSize(), textWidth = 0, lineHeightPx = this.lineHeight() * fontSize2, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO && width !== void 0, fixedHeight = height !== AUTO && height !== void 0, padding = this.padding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap2 = this.wrap(), shouldWrap = wrap2 !== NONE, wrapAtWord = wrap2 !== CHAR && shouldWrap, shouldAddEllipsis = this.ellipsis();
    this.textArr = [];
    getDummyContext().font = this._getContextFont();
    var additionalWidth = shouldAddEllipsis ? this._getTextWidth(ELLIPSIS) : 0;
    for (var i = 0, max2 = lines.length; i < max2; ++i) {
      var line = lines[i];
      var lineWidth = this._getTextWidth(line);
      if (fixedWidth && lineWidth > maxWidth) {
        while (line.length > 0) {
          var low = 0, high = line.length, match2 = "", matchWidth = 0;
          while (low < high) {
            var mid = low + high >>> 1, substr = line.slice(0, mid + 1), substrWidth = this._getTextWidth(substr) + additionalWidth;
            if (substrWidth <= maxWidth) {
              low = mid + 1;
              match2 = substr;
              matchWidth = substrWidth;
            } else {
              high = mid;
            }
          }
          if (match2) {
            if (wrapAtWord) {
              var wrapIndex;
              var nextChar = line[match2.length];
              var nextIsSpaceOrDash = nextChar === SPACE || nextChar === DASH;
              if (nextIsSpaceOrDash && matchWidth <= maxWidth) {
                wrapIndex = match2.length;
              } else {
                wrapIndex = Math.max(match2.lastIndexOf(SPACE), match2.lastIndexOf(DASH)) + 1;
              }
              if (wrapIndex > 0) {
                low = wrapIndex;
                match2 = match2.slice(0, low);
                matchWidth = this._getTextWidth(match2);
              }
            }
            match2 = match2.trimRight();
            this._addTextLine(match2);
            textWidth = Math.max(textWidth, matchWidth);
            currentHeightPx += lineHeightPx;
            var shouldHandleEllipsis = this._shouldHandleEllipsis(currentHeightPx);
            if (shouldHandleEllipsis) {
              this._tryToAddEllipsisToLastLine();
              break;
            }
            line = line.slice(low);
            line = line.trimLeft();
            if (line.length > 0) {
              lineWidth = this._getTextWidth(line);
              if (lineWidth <= maxWidth) {
                this._addTextLine(line);
                currentHeightPx += lineHeightPx;
                textWidth = Math.max(textWidth, lineWidth);
                break;
              }
            }
          } else {
            break;
          }
        }
      } else {
        this._addTextLine(line);
        currentHeightPx += lineHeightPx;
        textWidth = Math.max(textWidth, lineWidth);
        if (this._shouldHandleEllipsis(currentHeightPx) && i < max2 - 1) {
          this._tryToAddEllipsisToLastLine();
        }
      }
      if (this.textArr[this.textArr.length - 1]) {
        this.textArr[this.textArr.length - 1].lastInParagraph = true;
      }
      if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
        break;
      }
    }
    this.textHeight = fontSize2;
    this.textWidth = textWidth;
  }
  _shouldHandleEllipsis(currentHeightPx) {
    var fontSize2 = +this.fontSize(), lineHeightPx = this.lineHeight() * fontSize2, height = this.attrs.height, fixedHeight = height !== AUTO && height !== void 0, padding = this.padding(), maxHeightPx = height - padding * 2, wrap2 = this.wrap(), shouldWrap = wrap2 !== NONE;
    return !shouldWrap || fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx;
  }
  _tryToAddEllipsisToLastLine() {
    var width = this.attrs.width, fixedWidth = width !== AUTO && width !== void 0, padding = this.padding(), maxWidth = width - padding * 2, shouldAddEllipsis = this.ellipsis();
    var lastLine = this.textArr[this.textArr.length - 1];
    if (!lastLine || !shouldAddEllipsis) {
      return;
    }
    if (fixedWidth) {
      var haveSpace = this._getTextWidth(lastLine.text + ELLIPSIS) < maxWidth;
      if (!haveSpace) {
        lastLine.text = lastLine.text.slice(0, lastLine.text.length - 3);
      }
    }
    this.textArr.splice(this.textArr.length - 1, 1);
    this._addTextLine(lastLine.text + ELLIPSIS);
  }
  getStrokeScaleEnabled() {
    return true;
  }
  _useBufferCanvas() {
    const hasLine = this.textDecoration().indexOf("underline") !== -1 || this.textDecoration().indexOf("line-through") !== -1;
    const hasShadow = this.hasShadow();
    if (hasLine && hasShadow) {
      return true;
    }
    return super._useBufferCanvas();
  }
}
Text$1.Text = Text;
Text.prototype._fillFunc = _fillFunc$1;
Text.prototype._strokeFunc = _strokeFunc$1;
Text.prototype.className = TEXT_UPPER;
Text.prototype._attrsAffectingSize = [
  "text",
  "fontSize",
  "padding",
  "wrap",
  "lineHeight",
  "letterSpacing"
];
(0, Global_2$2._registerNode)(Text);
Factory_1$i.Factory.overWriteSetter(Text, "width", (0, Validators_1$i.getNumberOrAutoValidator)());
Factory_1$i.Factory.overWriteSetter(Text, "height", (0, Validators_1$i.getNumberOrAutoValidator)());
Factory_1$i.Factory.addGetterSetter(Text, "direction", INHERIT);
Factory_1$i.Factory.addGetterSetter(Text, "fontFamily", "Arial");
Factory_1$i.Factory.addGetterSetter(Text, "fontSize", 12, (0, Validators_1$i.getNumberValidator)());
Factory_1$i.Factory.addGetterSetter(Text, "fontStyle", NORMAL$1);
Factory_1$i.Factory.addGetterSetter(Text, "fontVariant", NORMAL$1);
Factory_1$i.Factory.addGetterSetter(Text, "padding", 0, (0, Validators_1$i.getNumberValidator)());
Factory_1$i.Factory.addGetterSetter(Text, "align", LEFT);
Factory_1$i.Factory.addGetterSetter(Text, "verticalAlign", TOP);
Factory_1$i.Factory.addGetterSetter(Text, "lineHeight", 1, (0, Validators_1$i.getNumberValidator)());
Factory_1$i.Factory.addGetterSetter(Text, "wrap", WORD);
Factory_1$i.Factory.addGetterSetter(Text, "ellipsis", false, (0, Validators_1$i.getBooleanValidator)());
Factory_1$i.Factory.addGetterSetter(Text, "letterSpacing", 0, (0, Validators_1$i.getNumberValidator)());
Factory_1$i.Factory.addGetterSetter(Text, "text", "", (0, Validators_1$i.getStringValidator)());
Factory_1$i.Factory.addGetterSetter(Text, "textDecoration", "");
var TextPath$1 = {};
Object.defineProperty(TextPath$1, "__esModule", { value: true });
TextPath$1.TextPath = void 0;
const Util_1$4 = Util;
const Factory_1$h = Factory;
const Shape_1$2 = Shape;
const Path_1$1 = Path$1;
const Text_1$1 = Text$1;
const Validators_1$h = Validators;
const Global_1$2 = Global;
var EMPTY_STRING = "", NORMAL = "normal";
function _fillFunc(context) {
  context.fillText(this.partialText, 0, 0);
}
function _strokeFunc(context) {
  context.strokeText(this.partialText, 0, 0);
}
class TextPath extends Shape_1$2.Shape {
  constructor(config) {
    super(config);
    this.dummyCanvas = Util_1$4.Util.createCanvasElement();
    this.dataArray = [];
    this._readDataAttribute();
    this.on("dataChange.konva", function() {
      this._readDataAttribute();
      this._setTextData();
    });
    this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData);
    this._setTextData();
  }
  _getTextPathLength() {
    return Path_1$1.Path.getPathLength(this.dataArray);
  }
  _getPointAtLength(length) {
    if (!this.attrs.data) {
      return null;
    }
    const totalLength = this.pathLength;
    if (length - 1 > totalLength) {
      return null;
    }
    return Path_1$1.Path.getPointAtLengthOfDataArray(length, this.dataArray);
  }
  _readDataAttribute() {
    this.dataArray = Path_1$1.Path.parsePathData(this.attrs.data);
    this.pathLength = this._getTextPathLength();
  }
  _sceneFunc(context) {
    context.setAttr("font", this._getContextFont());
    context.setAttr("textBaseline", this.textBaseline());
    context.setAttr("textAlign", "left");
    context.save();
    var textDecoration = this.textDecoration();
    var fill2 = this.fill();
    var fontSize2 = this.fontSize();
    var glyphInfo = this.glyphInfo;
    if (textDecoration === "underline") {
      context.beginPath();
    }
    for (var i = 0; i < glyphInfo.length; i++) {
      context.save();
      var p0 = glyphInfo[i].p0;
      context.translate(p0.x, p0.y);
      context.rotate(glyphInfo[i].rotation);
      this.partialText = glyphInfo[i].text;
      context.fillStrokeShape(this);
      if (textDecoration === "underline") {
        if (i === 0) {
          context.moveTo(0, fontSize2 / 2 + 1);
        }
        context.lineTo(fontSize2, fontSize2 / 2 + 1);
      }
      context.restore();
    }
    if (textDecoration === "underline") {
      context.strokeStyle = fill2;
      context.lineWidth = fontSize2 / 20;
      context.stroke();
    }
    context.restore();
  }
  _hitFunc(context) {
    context.beginPath();
    var glyphInfo = this.glyphInfo;
    if (glyphInfo.length >= 1) {
      var p0 = glyphInfo[0].p0;
      context.moveTo(p0.x, p0.y);
    }
    for (var i = 0; i < glyphInfo.length; i++) {
      var p1 = glyphInfo[i].p1;
      context.lineTo(p1.x, p1.y);
    }
    context.setAttr("lineWidth", this.fontSize());
    context.setAttr("strokeStyle", this.colorKey);
    context.stroke();
  }
  getTextWidth() {
    return this.textWidth;
  }
  getTextHeight() {
    Util_1$4.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.");
    return this.textHeight;
  }
  setText(text) {
    return Text_1$1.Text.prototype.setText.call(this, text);
  }
  _getContextFont() {
    return Text_1$1.Text.prototype._getContextFont.call(this);
  }
  _getTextSize(text) {
    var dummyCanvas = this.dummyCanvas;
    var _context = dummyCanvas.getContext("2d");
    _context.save();
    _context.font = this._getContextFont();
    var metrics = _context.measureText(text);
    _context.restore();
    return {
      width: metrics.width,
      height: parseInt(`${this.fontSize()}`, 10)
    };
  }
  _setTextData() {
    const { width, height } = this._getTextSize(this.attrs.text);
    this.textWidth = width;
    this.textHeight = height;
    this.glyphInfo = [];
    if (!this.attrs.data) {
      return null;
    }
    const letterSpacing = this.letterSpacing();
    const align = this.align();
    const kerningFunc = this.kerningFunc();
    const textWidth = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * letterSpacing, 0);
    let offset = 0;
    if (align === "center") {
      offset = Math.max(0, this.pathLength / 2 - textWidth / 2);
    }
    if (align === "right") {
      offset = Math.max(0, this.pathLength - textWidth);
    }
    const charArr = (0, Text_1$1.stringToArray)(this.text());
    let offsetToGlyph = offset;
    for (var i = 0; i < charArr.length; i++) {
      const charStartPoint = this._getPointAtLength(offsetToGlyph);
      if (!charStartPoint)
        return;
      let glyphWidth = this._getTextSize(charArr[i]).width + letterSpacing;
      if (charArr[i] === " " && align === "justify") {
        const numberOfSpaces = this.text().split(" ").length - 1;
        glyphWidth += (this.pathLength - textWidth) / numberOfSpaces;
      }
      const charEndPoint = this._getPointAtLength(offsetToGlyph + glyphWidth);
      if (!charEndPoint)
        return;
      const width2 = Path_1$1.Path.getLineLength(charStartPoint.x, charStartPoint.y, charEndPoint.x, charEndPoint.y);
      let kern = 0;
      if (kerningFunc) {
        try {
          kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();
        } catch (e) {
          kern = 0;
        }
      }
      charStartPoint.x += kern;
      charEndPoint.x += kern;
      this.textWidth += kern;
      const midpoint = Path_1$1.Path.getPointOnLine(kern + width2 / 2, charStartPoint.x, charStartPoint.y, charEndPoint.x, charEndPoint.y);
      const rotation = Math.atan2(charEndPoint.y - charStartPoint.y, charEndPoint.x - charStartPoint.x);
      this.glyphInfo.push({
        transposeX: midpoint.x,
        transposeY: midpoint.y,
        text: charArr[i],
        rotation,
        p0: charStartPoint,
        p1: charEndPoint
      });
      offsetToGlyph += glyphWidth;
    }
  }
  getSelfRect() {
    if (!this.glyphInfo.length) {
      return {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
    var points = [];
    this.glyphInfo.forEach(function(info) {
      points.push(info.p0.x);
      points.push(info.p0.y);
      points.push(info.p1.x);
      points.push(info.p1.y);
    });
    var minX = points[0] || 0;
    var maxX = points[0] || 0;
    var minY = points[1] || 0;
    var maxY = points[1] || 0;
    var x, y;
    for (var i = 0; i < points.length / 2; i++) {
      x = points[i * 2];
      y = points[i * 2 + 1];
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }
    var fontSize2 = this.fontSize();
    return {
      x: minX - fontSize2 / 2,
      y: minY - fontSize2 / 2,
      width: maxX - minX + fontSize2,
      height: maxY - minY + fontSize2
    };
  }
  destroy() {
    Util_1$4.Util.releaseCanvas(this.dummyCanvas);
    return super.destroy();
  }
}
TextPath$1.TextPath = TextPath;
TextPath.prototype._fillFunc = _fillFunc;
TextPath.prototype._strokeFunc = _strokeFunc;
TextPath.prototype._fillFuncHit = _fillFunc;
TextPath.prototype._strokeFuncHit = _strokeFunc;
TextPath.prototype.className = "TextPath";
TextPath.prototype._attrsAffectingSize = ["text", "fontSize", "data"];
(0, Global_1$2._registerNode)(TextPath);
Factory_1$h.Factory.addGetterSetter(TextPath, "data");
Factory_1$h.Factory.addGetterSetter(TextPath, "fontFamily", "Arial");
Factory_1$h.Factory.addGetterSetter(TextPath, "fontSize", 12, (0, Validators_1$h.getNumberValidator)());
Factory_1$h.Factory.addGetterSetter(TextPath, "fontStyle", NORMAL);
Factory_1$h.Factory.addGetterSetter(TextPath, "align", "left");
Factory_1$h.Factory.addGetterSetter(TextPath, "letterSpacing", 0, (0, Validators_1$h.getNumberValidator)());
Factory_1$h.Factory.addGetterSetter(TextPath, "textBaseline", "middle");
Factory_1$h.Factory.addGetterSetter(TextPath, "fontVariant", NORMAL);
Factory_1$h.Factory.addGetterSetter(TextPath, "text", EMPTY_STRING);
Factory_1$h.Factory.addGetterSetter(TextPath, "textDecoration", null);
Factory_1$h.Factory.addGetterSetter(TextPath, "kerningFunc", null);
var Transformer$1 = {};
Object.defineProperty(Transformer$1, "__esModule", { value: true });
Transformer$1.Transformer = void 0;
const Util_1$3 = Util;
const Factory_1$g = Factory;
const Node_1$f = Node$1;
const Shape_1$1 = Shape;
const Rect_1$1 = Rect$2;
const Group_1 = Group$1;
const Global_1$1 = Global;
const Validators_1$g = Validators;
const Global_2$1 = Global;
var EVENTS_NAME = "tr-konva";
var ATTR_CHANGE_LIST = [
  "resizeEnabledChange",
  "rotateAnchorOffsetChange",
  "rotateEnabledChange",
  "enabledAnchorsChange",
  "anchorSizeChange",
  "borderEnabledChange",
  "borderStrokeChange",
  "borderStrokeWidthChange",
  "borderDashChange",
  "anchorStrokeChange",
  "anchorStrokeWidthChange",
  "anchorFillChange",
  "anchorCornerRadiusChange",
  "ignoreStrokeChange",
  "anchorStyleFuncChange"
].map((e) => e + `.${EVENTS_NAME}`).join(" ");
var NODES_RECT = "nodesRect";
var TRANSFORM_CHANGE_STR = [
  "widthChange",
  "heightChange",
  "scaleXChange",
  "scaleYChange",
  "skewXChange",
  "skewYChange",
  "rotationChange",
  "offsetXChange",
  "offsetYChange",
  "transformsEnabledChange",
  "strokeWidthChange"
];
var ANGLES = {
  "top-left": -45,
  "top-center": 0,
  "top-right": 45,
  "middle-right": -90,
  "middle-left": 90,
  "bottom-left": -135,
  "bottom-center": 180,
  "bottom-right": 135
};
const TOUCH_DEVICE = "ontouchstart" in Global_1$1.Konva._global;
function getCursor(anchorName, rad, rotateCursor) {
  if (anchorName === "rotater") {
    return rotateCursor;
  }
  rad += Util_1$3.Util.degToRad(ANGLES[anchorName] || 0);
  var angle = (Util_1$3.Util.radToDeg(rad) % 360 + 360) % 360;
  if (Util_1$3.Util._inRange(angle, 315 + 22.5, 360) || Util_1$3.Util._inRange(angle, 0, 22.5)) {
    return "ns-resize";
  } else if (Util_1$3.Util._inRange(angle, 45 - 22.5, 45 + 22.5)) {
    return "nesw-resize";
  } else if (Util_1$3.Util._inRange(angle, 90 - 22.5, 90 + 22.5)) {
    return "ew-resize";
  } else if (Util_1$3.Util._inRange(angle, 135 - 22.5, 135 + 22.5)) {
    return "nwse-resize";
  } else if (Util_1$3.Util._inRange(angle, 180 - 22.5, 180 + 22.5)) {
    return "ns-resize";
  } else if (Util_1$3.Util._inRange(angle, 225 - 22.5, 225 + 22.5)) {
    return "nesw-resize";
  } else if (Util_1$3.Util._inRange(angle, 270 - 22.5, 270 + 22.5)) {
    return "ew-resize";
  } else if (Util_1$3.Util._inRange(angle, 315 - 22.5, 315 + 22.5)) {
    return "nwse-resize";
  } else {
    Util_1$3.Util.error("Transformer has unknown angle for cursor detection: " + angle);
    return "pointer";
  }
}
var ANCHORS_NAMES = [
  "top-left",
  "top-center",
  "top-right",
  "middle-right",
  "middle-left",
  "bottom-left",
  "bottom-center",
  "bottom-right"
];
var MAX_SAFE_INTEGER = 1e8;
function getCenter(shape) {
  return {
    x: shape.x + shape.width / 2 * Math.cos(shape.rotation) + shape.height / 2 * Math.sin(-shape.rotation),
    y: shape.y + shape.height / 2 * Math.cos(shape.rotation) + shape.width / 2 * Math.sin(shape.rotation)
  };
}
function rotateAroundPoint(shape, angleRad, point) {
  const x = point.x + (shape.x - point.x) * Math.cos(angleRad) - (shape.y - point.y) * Math.sin(angleRad);
  const y = point.y + (shape.x - point.x) * Math.sin(angleRad) + (shape.y - point.y) * Math.cos(angleRad);
  return {
    ...shape,
    rotation: shape.rotation + angleRad,
    x,
    y
  };
}
function rotateAroundCenter(shape, deltaRad) {
  const center = getCenter(shape);
  return rotateAroundPoint(shape, deltaRad, center);
}
function getSnap(snaps, newRotationRad, tol) {
  let snapped = newRotationRad;
  for (let i = 0; i < snaps.length; i++) {
    const angle = Global_1$1.Konva.getAngle(snaps[i]);
    const absDiff = Math.abs(angle - newRotationRad) % (Math.PI * 2);
    const dif = Math.min(absDiff, Math.PI * 2 - absDiff);
    if (dif < tol) {
      snapped = angle;
    }
  }
  return snapped;
}
let activeTransformersCount = 0;
class Transformer extends Group_1.Group {
  constructor(config) {
    super(config);
    this._movingAnchorName = null;
    this._transforming = false;
    this._createElements();
    this._handleMouseMove = this._handleMouseMove.bind(this);
    this._handleMouseUp = this._handleMouseUp.bind(this);
    this.update = this.update.bind(this);
    this.on(ATTR_CHANGE_LIST, this.update);
    if (this.getNode()) {
      this.update();
    }
  }
  attachTo(node) {
    this.setNode(node);
    return this;
  }
  setNode(node) {
    Util_1$3.Util.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead.");
    return this.setNodes([node]);
  }
  getNode() {
    return this._nodes && this._nodes[0];
  }
  _getEventNamespace() {
    return EVENTS_NAME + this._id;
  }
  setNodes(nodes = []) {
    if (this._nodes && this._nodes.length) {
      this.detach();
    }
    const filteredNodes = nodes.filter((node) => {
      if (node.isAncestorOf(this)) {
        Util_1$3.Util.error("Konva.Transformer cannot be an a child of the node you are trying to attach");
        return false;
      }
      return true;
    });
    this._nodes = nodes = filteredNodes;
    if (nodes.length === 1 && this.useSingleNodeRotation()) {
      this.rotation(nodes[0].getAbsoluteRotation());
    } else {
      this.rotation(0);
    }
    this._nodes.forEach((node) => {
      const onChange = () => {
        if (this.nodes().length === 1 && this.useSingleNodeRotation()) {
          this.rotation(this.nodes()[0].getAbsoluteRotation());
        }
        this._resetTransformCache();
        if (!this._transforming && !this.isDragging()) {
          this.update();
        }
      };
      const additionalEvents = node._attrsAffectingSize.map((prop) => prop + "Change." + this._getEventNamespace()).join(" ");
      node.on(additionalEvents, onChange);
      node.on(TRANSFORM_CHANGE_STR.map((e) => e + `.${this._getEventNamespace()}`).join(" "), onChange);
      node.on(`absoluteTransformChange.${this._getEventNamespace()}`, onChange);
      this._proxyDrag(node);
    });
    this._resetTransformCache();
    var elementsCreated = !!this.findOne(".top-left");
    if (elementsCreated) {
      this.update();
    }
    return this;
  }
  _proxyDrag(node) {
    let lastPos;
    node.on(`dragstart.${this._getEventNamespace()}`, (e) => {
      lastPos = node.getAbsolutePosition();
      if (!this.isDragging() && node !== this.findOne(".back")) {
        this.startDrag(e, false);
      }
    });
    node.on(`dragmove.${this._getEventNamespace()}`, (e) => {
      if (!lastPos) {
        return;
      }
      const abs = node.getAbsolutePosition();
      const dx = abs.x - lastPos.x;
      const dy = abs.y - lastPos.y;
      this.nodes().forEach((otherNode) => {
        if (otherNode === node) {
          return;
        }
        if (otherNode.isDragging()) {
          return;
        }
        const otherAbs = otherNode.getAbsolutePosition();
        otherNode.setAbsolutePosition({
          x: otherAbs.x + dx,
          y: otherAbs.y + dy
        });
        otherNode.startDrag(e);
      });
      lastPos = null;
    });
  }
  getNodes() {
    return this._nodes || [];
  }
  getActiveAnchor() {
    return this._movingAnchorName;
  }
  detach() {
    if (this._nodes) {
      this._nodes.forEach((node) => {
        node.off("." + this._getEventNamespace());
      });
    }
    this._nodes = [];
    this._resetTransformCache();
  }
  _resetTransformCache() {
    this._clearCache(NODES_RECT);
    this._clearCache("transform");
    this._clearSelfAndDescendantCache("absoluteTransform");
  }
  _getNodeRect() {
    return this._getCache(NODES_RECT, this.__getNodeRect);
  }
  __getNodeShape(node, rot = this.rotation(), relative) {
    var rect = node.getClientRect({
      skipTransform: true,
      skipShadow: true,
      skipStroke: this.ignoreStroke()
    });
    var absScale = node.getAbsoluteScale(relative);
    var absPos = node.getAbsolutePosition(relative);
    var dx = rect.x * absScale.x - node.offsetX() * absScale.x;
    var dy = rect.y * absScale.y - node.offsetY() * absScale.y;
    const rotation = (Global_1$1.Konva.getAngle(node.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2);
    const box = {
      x: absPos.x + dx * Math.cos(rotation) + dy * Math.sin(-rotation),
      y: absPos.y + dy * Math.cos(rotation) + dx * Math.sin(rotation),
      width: rect.width * absScale.x,
      height: rect.height * absScale.y,
      rotation
    };
    return rotateAroundPoint(box, -Global_1$1.Konva.getAngle(rot), {
      x: 0,
      y: 0
    });
  }
  __getNodeRect() {
    var node = this.getNode();
    if (!node) {
      return {
        x: -MAX_SAFE_INTEGER,
        y: -MAX_SAFE_INTEGER,
        width: 0,
        height: 0,
        rotation: 0
      };
    }
    const totalPoints = [];
    this.nodes().map((node2) => {
      const box = node2.getClientRect({
        skipTransform: true,
        skipShadow: true,
        skipStroke: this.ignoreStroke()
      });
      var points = [
        { x: box.x, y: box.y },
        { x: box.x + box.width, y: box.y },
        { x: box.x + box.width, y: box.y + box.height },
        { x: box.x, y: box.y + box.height }
      ];
      var trans = node2.getAbsoluteTransform();
      points.forEach(function(point) {
        var transformed = trans.point(point);
        totalPoints.push(transformed);
      });
    });
    const tr = new Util_1$3.Transform();
    tr.rotate(-Global_1$1.Konva.getAngle(this.rotation()));
    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    totalPoints.forEach(function(point) {
      var transformed = tr.point(point);
      if (minX === void 0) {
        minX = maxX = transformed.x;
        minY = maxY = transformed.y;
      }
      minX = Math.min(minX, transformed.x);
      minY = Math.min(minY, transformed.y);
      maxX = Math.max(maxX, transformed.x);
      maxY = Math.max(maxY, transformed.y);
    });
    tr.invert();
    const p2 = tr.point({ x: minX, y: minY });
    return {
      x: p2.x,
      y: p2.y,
      width: maxX - minX,
      height: maxY - minY,
      rotation: Global_1$1.Konva.getAngle(this.rotation())
    };
  }
  getX() {
    return this._getNodeRect().x;
  }
  getY() {
    return this._getNodeRect().y;
  }
  getWidth() {
    return this._getNodeRect().width;
  }
  getHeight() {
    return this._getNodeRect().height;
  }
  _createElements() {
    this._createBack();
    ANCHORS_NAMES.forEach((name) => {
      this._createAnchor(name);
    });
    this._createAnchor("rotater");
  }
  _createAnchor(name) {
    var anchor = new Rect_1$1.Rect({
      stroke: "rgb(0, 161, 255)",
      fill: "white",
      strokeWidth: 1,
      name: name + " _anchor",
      dragDistance: 0,
      draggable: true,
      hitStrokeWidth: TOUCH_DEVICE ? 10 : "auto"
    });
    var self2 = this;
    anchor.on("mousedown touchstart", function(e) {
      self2._handleMouseDown(e);
    });
    anchor.on("dragstart", (e) => {
      anchor.stopDrag();
      e.cancelBubble = true;
    });
    anchor.on("dragend", (e) => {
      e.cancelBubble = true;
    });
    anchor.on("mouseenter", () => {
      var rad = Global_1$1.Konva.getAngle(this.rotation());
      var rotateCursor = this.rotateAnchorCursor();
      var cursor = getCursor(name, rad, rotateCursor);
      anchor.getStage().content && (anchor.getStage().content.style.cursor = cursor);
      this._cursorChange = true;
    });
    anchor.on("mouseout", () => {
      anchor.getStage().content && (anchor.getStage().content.style.cursor = "");
      this._cursorChange = false;
    });
    this.add(anchor);
  }
  _createBack() {
    var back = new Shape_1$1.Shape({
      name: "back",
      width: 0,
      height: 0,
      draggable: true,
      sceneFunc(ctx2, shape) {
        var tr = shape.getParent();
        var padding = tr.padding();
        ctx2.beginPath();
        ctx2.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);
        ctx2.moveTo(shape.width() / 2, -padding);
        if (tr.rotateEnabled() && tr.rotateLineVisible()) {
          ctx2.lineTo(shape.width() / 2, -tr.rotateAnchorOffset() * Util_1$3.Util._sign(shape.height()) - padding);
        }
        ctx2.fillStrokeShape(shape);
      },
      hitFunc: (ctx2, shape) => {
        if (!this.shouldOverdrawWholeArea()) {
          return;
        }
        var padding = this.padding();
        ctx2.beginPath();
        ctx2.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);
        ctx2.fillStrokeShape(shape);
      }
    });
    this.add(back);
    this._proxyDrag(back);
    back.on("dragstart", (e) => {
      e.cancelBubble = true;
    });
    back.on("dragmove", (e) => {
      e.cancelBubble = true;
    });
    back.on("dragend", (e) => {
      e.cancelBubble = true;
    });
    this.on("dragmove", (e) => {
      this.update();
    });
  }
  _handleMouseDown(e) {
    if (this._transforming) {
      return;
    }
    this._movingAnchorName = e.target.name().split(" ")[0];
    var attrs = this._getNodeRect();
    var width = attrs.width;
    var height = attrs.height;
    var hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
    this.sin = Math.abs(height / hypotenuse);
    this.cos = Math.abs(width / hypotenuse);
    if (typeof window !== "undefined") {
      window.addEventListener("mousemove", this._handleMouseMove);
      window.addEventListener("touchmove", this._handleMouseMove);
      window.addEventListener("mouseup", this._handleMouseUp, true);
      window.addEventListener("touchend", this._handleMouseUp, true);
    }
    this._transforming = true;
    var ap = e.target.getAbsolutePosition();
    var pos = e.target.getStage().getPointerPosition();
    this._anchorDragOffset = {
      x: pos.x - ap.x,
      y: pos.y - ap.y
    };
    activeTransformersCount++;
    this._fire("transformstart", { evt: e.evt, target: this.getNode() });
    this._nodes.forEach((target) => {
      target._fire("transformstart", { evt: e.evt, target });
    });
  }
  _handleMouseMove(e) {
    var x, y, newHypotenuse;
    var anchorNode = this.findOne("." + this._movingAnchorName);
    var stage = anchorNode.getStage();
    stage.setPointersPositions(e);
    const pp = stage.getPointerPosition();
    let newNodePos = {
      x: pp.x - this._anchorDragOffset.x,
      y: pp.y - this._anchorDragOffset.y
    };
    const oldAbs = anchorNode.getAbsolutePosition();
    if (this.anchorDragBoundFunc()) {
      newNodePos = this.anchorDragBoundFunc()(oldAbs, newNodePos, e);
    }
    anchorNode.setAbsolutePosition(newNodePos);
    const newAbs = anchorNode.getAbsolutePosition();
    if (oldAbs.x === newAbs.x && oldAbs.y === newAbs.y) {
      return;
    }
    if (this._movingAnchorName === "rotater") {
      var attrs = this._getNodeRect();
      x = anchorNode.x() - attrs.width / 2;
      y = -anchorNode.y() + attrs.height / 2;
      let delta = Math.atan2(-y, x) + Math.PI / 2;
      if (attrs.height < 0) {
        delta -= Math.PI;
      }
      var oldRotation = Global_1$1.Konva.getAngle(this.rotation());
      const newRotation = oldRotation + delta;
      const tol = Global_1$1.Konva.getAngle(this.rotationSnapTolerance());
      const snappedRot = getSnap(this.rotationSnaps(), newRotation, tol);
      const diff = snappedRot - attrs.rotation;
      const shape = rotateAroundCenter(attrs, diff);
      this._fitNodesInto(shape, e);
      return;
    }
    var shiftBehavior = this.shiftBehavior();
    var keepProportion;
    if (shiftBehavior === "inverted") {
      keepProportion = this.keepRatio() && !e.shiftKey;
    } else if (shiftBehavior === "none") {
      keepProportion = this.keepRatio();
    } else {
      keepProportion = this.keepRatio() || e.shiftKey;
    }
    var centeredScaling = this.centeredScaling() || e.altKey;
    if (this._movingAnchorName === "top-left") {
      if (keepProportion) {
        var comparePoint = centeredScaling ? {
          x: this.width() / 2,
          y: this.height() / 2
        } : {
          x: this.findOne(".bottom-right").x(),
          y: this.findOne(".bottom-right").y()
        };
        newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));
        var reverseX = this.findOne(".top-left").x() > comparePoint.x ? -1 : 1;
        var reverseY = this.findOne(".top-left").y() > comparePoint.y ? -1 : 1;
        x = newHypotenuse * this.cos * reverseX;
        y = newHypotenuse * this.sin * reverseY;
        this.findOne(".top-left").x(comparePoint.x - x);
        this.findOne(".top-left").y(comparePoint.y - y);
      }
    } else if (this._movingAnchorName === "top-center") {
      this.findOne(".top-left").y(anchorNode.y());
    } else if (this._movingAnchorName === "top-right") {
      if (keepProportion) {
        var comparePoint = centeredScaling ? {
          x: this.width() / 2,
          y: this.height() / 2
        } : {
          x: this.findOne(".bottom-left").x(),
          y: this.findOne(".bottom-left").y()
        };
        newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));
        var reverseX = this.findOne(".top-right").x() < comparePoint.x ? -1 : 1;
        var reverseY = this.findOne(".top-right").y() > comparePoint.y ? -1 : 1;
        x = newHypotenuse * this.cos * reverseX;
        y = newHypotenuse * this.sin * reverseY;
        this.findOne(".top-right").x(comparePoint.x + x);
        this.findOne(".top-right").y(comparePoint.y - y);
      }
      var pos = anchorNode.position();
      this.findOne(".top-left").y(pos.y);
      this.findOne(".bottom-right").x(pos.x);
    } else if (this._movingAnchorName === "middle-left") {
      this.findOne(".top-left").x(anchorNode.x());
    } else if (this._movingAnchorName === "middle-right") {
      this.findOne(".bottom-right").x(anchorNode.x());
    } else if (this._movingAnchorName === "bottom-left") {
      if (keepProportion) {
        var comparePoint = centeredScaling ? {
          x: this.width() / 2,
          y: this.height() / 2
        } : {
          x: this.findOne(".top-right").x(),
          y: this.findOne(".top-right").y()
        };
        newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));
        var reverseX = comparePoint.x < anchorNode.x() ? -1 : 1;
        var reverseY = anchorNode.y() < comparePoint.y ? -1 : 1;
        x = newHypotenuse * this.cos * reverseX;
        y = newHypotenuse * this.sin * reverseY;
        anchorNode.x(comparePoint.x - x);
        anchorNode.y(comparePoint.y + y);
      }
      pos = anchorNode.position();
      this.findOne(".top-left").x(pos.x);
      this.findOne(".bottom-right").y(pos.y);
    } else if (this._movingAnchorName === "bottom-center") {
      this.findOne(".bottom-right").y(anchorNode.y());
    } else if (this._movingAnchorName === "bottom-right") {
      if (keepProportion) {
        var comparePoint = centeredScaling ? {
          x: this.width() / 2,
          y: this.height() / 2
        } : {
          x: this.findOne(".top-left").x(),
          y: this.findOne(".top-left").y()
        };
        newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));
        var reverseX = this.findOne(".bottom-right").x() < comparePoint.x ? -1 : 1;
        var reverseY = this.findOne(".bottom-right").y() < comparePoint.y ? -1 : 1;
        x = newHypotenuse * this.cos * reverseX;
        y = newHypotenuse * this.sin * reverseY;
        this.findOne(".bottom-right").x(comparePoint.x + x);
        this.findOne(".bottom-right").y(comparePoint.y + y);
      }
    } else {
      console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));
    }
    var centeredScaling = this.centeredScaling() || e.altKey;
    if (centeredScaling) {
      var topLeft = this.findOne(".top-left");
      var bottomRight = this.findOne(".bottom-right");
      var topOffsetX = topLeft.x();
      var topOffsetY = topLeft.y();
      var bottomOffsetX = this.getWidth() - bottomRight.x();
      var bottomOffsetY = this.getHeight() - bottomRight.y();
      bottomRight.move({
        x: -topOffsetX,
        y: -topOffsetY
      });
      topLeft.move({
        x: bottomOffsetX,
        y: bottomOffsetY
      });
    }
    var absPos = this.findOne(".top-left").getAbsolutePosition();
    x = absPos.x;
    y = absPos.y;
    var width = this.findOne(".bottom-right").x() - this.findOne(".top-left").x();
    var height = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
    this._fitNodesInto({
      x,
      y,
      width,
      height,
      rotation: Global_1$1.Konva.getAngle(this.rotation())
    }, e);
  }
  _handleMouseUp(e) {
    this._removeEvents(e);
  }
  getAbsoluteTransform() {
    return this.getTransform();
  }
  _removeEvents(e) {
    var _a;
    if (this._transforming) {
      this._transforming = false;
      if (typeof window !== "undefined") {
        window.removeEventListener("mousemove", this._handleMouseMove);
        window.removeEventListener("touchmove", this._handleMouseMove);
        window.removeEventListener("mouseup", this._handleMouseUp, true);
        window.removeEventListener("touchend", this._handleMouseUp, true);
      }
      var node = this.getNode();
      activeTransformersCount--;
      this._fire("transformend", { evt: e, target: node });
      (_a = this.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();
      if (node) {
        this._nodes.forEach((target) => {
          var _a2;
          target._fire("transformend", { evt: e, target });
          (_a2 = target.getLayer()) === null || _a2 === void 0 ? void 0 : _a2.batchDraw();
        });
      }
      this._movingAnchorName = null;
    }
  }
  _fitNodesInto(newAttrs, evt) {
    var oldAttrs = this._getNodeRect();
    const minSize = 1;
    if (Util_1$3.Util._inRange(newAttrs.width, -this.padding() * 2 - minSize, minSize)) {
      this.update();
      return;
    }
    if (Util_1$3.Util._inRange(newAttrs.height, -this.padding() * 2 - minSize, minSize)) {
      this.update();
      return;
    }
    var t = new Util_1$3.Transform();
    t.rotate(Global_1$1.Konva.getAngle(this.rotation()));
    if (this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
      const offset = t.point({
        x: -this.padding() * 2,
        y: 0
      });
      newAttrs.x += offset.x;
      newAttrs.y += offset.y;
      newAttrs.width += this.padding() * 2;
      this._movingAnchorName = this._movingAnchorName.replace("left", "right");
      this._anchorDragOffset.x -= offset.x;
      this._anchorDragOffset.y -= offset.y;
    } else if (this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
      const offset = t.point({
        x: this.padding() * 2,
        y: 0
      });
      this._movingAnchorName = this._movingAnchorName.replace("right", "left");
      this._anchorDragOffset.x -= offset.x;
      this._anchorDragOffset.y -= offset.y;
      newAttrs.width += this.padding() * 2;
    }
    if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
      const offset = t.point({
        x: 0,
        y: -this.padding() * 2
      });
      newAttrs.x += offset.x;
      newAttrs.y += offset.y;
      this._movingAnchorName = this._movingAnchorName.replace("top", "bottom");
      this._anchorDragOffset.x -= offset.x;
      this._anchorDragOffset.y -= offset.y;
      newAttrs.height += this.padding() * 2;
    } else if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
      const offset = t.point({
        x: 0,
        y: this.padding() * 2
      });
      this._movingAnchorName = this._movingAnchorName.replace("bottom", "top");
      this._anchorDragOffset.x -= offset.x;
      this._anchorDragOffset.y -= offset.y;
      newAttrs.height += this.padding() * 2;
    }
    if (this.boundBoxFunc()) {
      const bounded = this.boundBoxFunc()(oldAttrs, newAttrs);
      if (bounded) {
        newAttrs = bounded;
      } else {
        Util_1$3.Util.warn("boundBoxFunc returned falsy. You should return new bound rect from it!");
      }
    }
    const baseSize = 1e7;
    const oldTr = new Util_1$3.Transform();
    oldTr.translate(oldAttrs.x, oldAttrs.y);
    oldTr.rotate(oldAttrs.rotation);
    oldTr.scale(oldAttrs.width / baseSize, oldAttrs.height / baseSize);
    const newTr = new Util_1$3.Transform();
    const newScaleX = newAttrs.width / baseSize;
    const newScaleY = newAttrs.height / baseSize;
    if (this.flipEnabled() === false) {
      newTr.translate(newAttrs.x, newAttrs.y);
      newTr.rotate(newAttrs.rotation);
      newTr.translate(newAttrs.width < 0 ? newAttrs.width : 0, newAttrs.height < 0 ? newAttrs.height : 0);
      newTr.scale(Math.abs(newScaleX), Math.abs(newScaleY));
    } else {
      newTr.translate(newAttrs.x, newAttrs.y);
      newTr.rotate(newAttrs.rotation);
      newTr.scale(newScaleX, newScaleY);
    }
    const delta = newTr.multiply(oldTr.invert());
    this._nodes.forEach((node) => {
      var _a;
      const parentTransform = node.getParent().getAbsoluteTransform();
      const localTransform = node.getTransform().copy();
      localTransform.translate(node.offsetX(), node.offsetY());
      const newLocalTransform = new Util_1$3.Transform();
      newLocalTransform.multiply(parentTransform.copy().invert()).multiply(delta).multiply(parentTransform).multiply(localTransform);
      const attrs = newLocalTransform.decompose();
      node.setAttrs(attrs);
      (_a = node.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();
    });
    this.rotation(Util_1$3.Util._getRotation(newAttrs.rotation));
    this._nodes.forEach((node) => {
      this._fire("transform", { evt, target: node });
      node._fire("transform", { evt, target: node });
    });
    this._resetTransformCache();
    this.update();
    this.getLayer().batchDraw();
  }
  forceUpdate() {
    this._resetTransformCache();
    this.update();
  }
  _batchChangeChild(selector, attrs) {
    const anchor = this.findOne(selector);
    anchor.setAttrs(attrs);
  }
  update() {
    var _a;
    var attrs = this._getNodeRect();
    this.rotation(Util_1$3.Util._getRotation(attrs.rotation));
    var width = attrs.width;
    var height = attrs.height;
    var enabledAnchors = this.enabledAnchors();
    var resizeEnabled = this.resizeEnabled();
    var padding = this.padding();
    var anchorSize = this.anchorSize();
    const anchors = this.find("._anchor");
    anchors.forEach((node) => {
      node.setAttrs({
        width: anchorSize,
        height: anchorSize,
        offsetX: anchorSize / 2,
        offsetY: anchorSize / 2,
        stroke: this.anchorStroke(),
        strokeWidth: this.anchorStrokeWidth(),
        fill: this.anchorFill(),
        cornerRadius: this.anchorCornerRadius()
      });
    });
    this._batchChangeChild(".top-left", {
      x: 0,
      y: 0,
      offsetX: anchorSize / 2 + padding,
      offsetY: anchorSize / 2 + padding,
      visible: resizeEnabled && enabledAnchors.indexOf("top-left") >= 0
    });
    this._batchChangeChild(".top-center", {
      x: width / 2,
      y: 0,
      offsetY: anchorSize / 2 + padding,
      visible: resizeEnabled && enabledAnchors.indexOf("top-center") >= 0
    });
    this._batchChangeChild(".top-right", {
      x: width,
      y: 0,
      offsetX: anchorSize / 2 - padding,
      offsetY: anchorSize / 2 + padding,
      visible: resizeEnabled && enabledAnchors.indexOf("top-right") >= 0
    });
    this._batchChangeChild(".middle-left", {
      x: 0,
      y: height / 2,
      offsetX: anchorSize / 2 + padding,
      visible: resizeEnabled && enabledAnchors.indexOf("middle-left") >= 0
    });
    this._batchChangeChild(".middle-right", {
      x: width,
      y: height / 2,
      offsetX: anchorSize / 2 - padding,
      visible: resizeEnabled && enabledAnchors.indexOf("middle-right") >= 0
    });
    this._batchChangeChild(".bottom-left", {
      x: 0,
      y: height,
      offsetX: anchorSize / 2 + padding,
      offsetY: anchorSize / 2 - padding,
      visible: resizeEnabled && enabledAnchors.indexOf("bottom-left") >= 0
    });
    this._batchChangeChild(".bottom-center", {
      x: width / 2,
      y: height,
      offsetY: anchorSize / 2 - padding,
      visible: resizeEnabled && enabledAnchors.indexOf("bottom-center") >= 0
    });
    this._batchChangeChild(".bottom-right", {
      x: width,
      y: height,
      offsetX: anchorSize / 2 - padding,
      offsetY: anchorSize / 2 - padding,
      visible: resizeEnabled && enabledAnchors.indexOf("bottom-right") >= 0
    });
    this._batchChangeChild(".rotater", {
      x: width / 2,
      y: -this.rotateAnchorOffset() * Util_1$3.Util._sign(height) - padding,
      visible: this.rotateEnabled()
    });
    this._batchChangeChild(".back", {
      width,
      height,
      visible: this.borderEnabled(),
      stroke: this.borderStroke(),
      strokeWidth: this.borderStrokeWidth(),
      dash: this.borderDash(),
      x: 0,
      y: 0
    });
    const styleFunc = this.anchorStyleFunc();
    if (styleFunc) {
      anchors.forEach((node) => {
        styleFunc(node);
      });
    }
    (_a = this.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();
  }
  isTransforming() {
    return this._transforming;
  }
  stopTransform() {
    if (this._transforming) {
      this._removeEvents();
      var anchorNode = this.findOne("." + this._movingAnchorName);
      if (anchorNode) {
        anchorNode.stopDrag();
      }
    }
  }
  destroy() {
    if (this.getStage() && this._cursorChange) {
      this.getStage().content && (this.getStage().content.style.cursor = "");
    }
    Group_1.Group.prototype.destroy.call(this);
    this.detach();
    this._removeEvents();
    return this;
  }
  toObject() {
    return Node_1$f.Node.prototype.toObject.call(this);
  }
  clone(obj) {
    var node = Node_1$f.Node.prototype.clone.call(this, obj);
    return node;
  }
  getClientRect() {
    if (this.nodes().length > 0) {
      return super.getClientRect();
    } else {
      return { x: 0, y: 0, width: 0, height: 0 };
    }
  }
}
Transformer$1.Transformer = Transformer;
Transformer.isTransforming = () => {
  return activeTransformersCount > 0;
};
function validateAnchors(val) {
  if (!(val instanceof Array)) {
    Util_1$3.Util.warn("enabledAnchors value should be an array");
  }
  if (val instanceof Array) {
    val.forEach(function(name) {
      if (ANCHORS_NAMES.indexOf(name) === -1) {
        Util_1$3.Util.warn("Unknown anchor name: " + name + ". Available names are: " + ANCHORS_NAMES.join(", "));
      }
    });
  }
  return val || [];
}
Transformer.prototype.className = "Transformer";
(0, Global_2$1._registerNode)(Transformer);
Factory_1$g.Factory.addGetterSetter(Transformer, "enabledAnchors", ANCHORS_NAMES, validateAnchors);
Factory_1$g.Factory.addGetterSetter(Transformer, "flipEnabled", true, (0, Validators_1$g.getBooleanValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, "resizeEnabled", true);
Factory_1$g.Factory.addGetterSetter(Transformer, "anchorSize", 10, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, "rotateEnabled", true);
Factory_1$g.Factory.addGetterSetter(Transformer, "rotateLineVisible", true);
Factory_1$g.Factory.addGetterSetter(Transformer, "rotationSnaps", []);
Factory_1$g.Factory.addGetterSetter(Transformer, "rotateAnchorOffset", 50, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, "rotateAnchorCursor", "crosshair");
Factory_1$g.Factory.addGetterSetter(Transformer, "rotationSnapTolerance", 5, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, "borderEnabled", true);
Factory_1$g.Factory.addGetterSetter(Transformer, "anchorStroke", "rgb(0, 161, 255)");
Factory_1$g.Factory.addGetterSetter(Transformer, "anchorStrokeWidth", 1, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, "anchorFill", "white");
Factory_1$g.Factory.addGetterSetter(Transformer, "anchorCornerRadius", 0, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, "borderStroke", "rgb(0, 161, 255)");
Factory_1$g.Factory.addGetterSetter(Transformer, "borderStrokeWidth", 1, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, "borderDash");
Factory_1$g.Factory.addGetterSetter(Transformer, "keepRatio", true);
Factory_1$g.Factory.addGetterSetter(Transformer, "shiftBehavior", "default");
Factory_1$g.Factory.addGetterSetter(Transformer, "centeredScaling", false);
Factory_1$g.Factory.addGetterSetter(Transformer, "ignoreStroke", false);
Factory_1$g.Factory.addGetterSetter(Transformer, "padding", 0, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, "node");
Factory_1$g.Factory.addGetterSetter(Transformer, "nodes");
Factory_1$g.Factory.addGetterSetter(Transformer, "boundBoxFunc");
Factory_1$g.Factory.addGetterSetter(Transformer, "anchorDragBoundFunc");
Factory_1$g.Factory.addGetterSetter(Transformer, "anchorStyleFunc");
Factory_1$g.Factory.addGetterSetter(Transformer, "shouldOverdrawWholeArea", false);
Factory_1$g.Factory.addGetterSetter(Transformer, "useSingleNodeRotation", true);
Factory_1$g.Factory.backCompat(Transformer, {
  lineEnabled: "borderEnabled",
  rotateHandlerOffset: "rotateAnchorOffset",
  enabledHandlers: "enabledAnchors"
});
var Wedge$1 = {};
Object.defineProperty(Wedge$1, "__esModule", { value: true });
Wedge$1.Wedge = void 0;
const Factory_1$f = Factory;
const Shape_1 = Shape;
const Global_1 = Global;
const Validators_1$f = Validators;
const Global_2 = Global;
class Wedge extends Shape_1.Shape {
  _sceneFunc(context) {
    context.beginPath();
    context.arc(0, 0, this.radius(), 0, Global_1.Konva.getAngle(this.angle()), this.clockwise());
    context.lineTo(0, 0);
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.radius() * 2;
  }
  getHeight() {
    return this.radius() * 2;
  }
  setWidth(width) {
    this.radius(width / 2);
  }
  setHeight(height) {
    this.radius(height / 2);
  }
}
Wedge$1.Wedge = Wedge;
Wedge.prototype.className = "Wedge";
Wedge.prototype._centroid = true;
Wedge.prototype._attrsAffectingSize = ["radius"];
(0, Global_2._registerNode)(Wedge);
Factory_1$f.Factory.addGetterSetter(Wedge, "radius", 0, (0, Validators_1$f.getNumberValidator)());
Factory_1$f.Factory.addGetterSetter(Wedge, "angle", 0, (0, Validators_1$f.getNumberValidator)());
Factory_1$f.Factory.addGetterSetter(Wedge, "clockwise", false);
Factory_1$f.Factory.backCompat(Wedge, {
  angleDeg: "angle",
  getAngleDeg: "getAngle",
  setAngleDeg: "setAngle"
});
var Blur$1 = {};
Object.defineProperty(Blur$1, "__esModule", { value: true });
Blur$1.Blur = void 0;
const Factory_1$e = Factory;
const Node_1$e = Node$1;
const Validators_1$e = Validators;
function BlurStack() {
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
}
var mul_table = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
];
var shg_table = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function filterGaussBlurRGBA(imageData, radius) {
  var pixels = imageData.data, width = imageData.width, height = imageData.height;
  var x, y, i, p2, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
  var div = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2, stackStart = new BlurStack(), stackEnd = null, stack2 = stackStart, stackIn = null, stackOut = null, mul_sum = mul_table[radius], shg_sum = shg_table[radius];
  for (i = 1; i < div; i++) {
    stack2 = stack2.next = new BlurStack();
    if (i === radiusPlus1) {
      stackEnd = stack2;
    }
  }
  stack2.next = stackStart;
  yw = yi = 0;
  for (y = 0; y < height; y++) {
    r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;
    stack2 = stackStart;
    for (i = 0; i < radiusPlus1; i++) {
      stack2.r = pr;
      stack2.g = pg;
      stack2.b = pb;
      stack2.a = pa;
      stack2 = stack2.next;
    }
    for (i = 1; i < radiusPlus1; i++) {
      p2 = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
      r_sum += (stack2.r = pr = pixels[p2]) * (rbs = radiusPlus1 - i);
      g_sum += (stack2.g = pg = pixels[p2 + 1]) * rbs;
      b_sum += (stack2.b = pb = pixels[p2 + 2]) * rbs;
      a_sum += (stack2.a = pa = pixels[p2 + 3]) * rbs;
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;
      stack2 = stack2.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (x = 0; x < width; x++) {
      pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
      if (pa !== 0) {
        pa = 255 / pa;
        pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
        pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
        pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;
      p2 = yw + ((p2 = x + radius + 1) < widthMinus1 ? p2 : widthMinus1) << 2;
      r_in_sum += stackIn.r = pixels[p2];
      g_in_sum += stackIn.g = pixels[p2 + 1];
      b_in_sum += stackIn.b = pixels[p2 + 2];
      a_in_sum += stackIn.a = pixels[p2 + 3];
      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;
      a_sum += a_in_sum;
      stackIn = stackIn.next;
      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      a_out_sum += pa = stackOut.a;
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (x = 0; x < width; x++) {
    g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
    yi = x << 2;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;
    stack2 = stackStart;
    for (i = 0; i < radiusPlus1; i++) {
      stack2.r = pr;
      stack2.g = pg;
      stack2.b = pb;
      stack2.a = pa;
      stack2 = stack2.next;
    }
    yp = width;
    for (i = 1; i <= radius; i++) {
      yi = yp + x << 2;
      r_sum += (stack2.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
      g_sum += (stack2.g = pg = pixels[yi + 1]) * rbs;
      b_sum += (stack2.b = pb = pixels[yi + 2]) * rbs;
      a_sum += (stack2.a = pa = pixels[yi + 3]) * rbs;
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;
      stack2 = stack2.next;
      if (i < heightMinus1) {
        yp += width;
      }
    }
    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (y = 0; y < height; y++) {
      p2 = yi << 2;
      pixels[p2 + 3] = pa = a_sum * mul_sum >> shg_sum;
      if (pa > 0) {
        pa = 255 / pa;
        pixels[p2] = (r_sum * mul_sum >> shg_sum) * pa;
        pixels[p2 + 1] = (g_sum * mul_sum >> shg_sum) * pa;
        pixels[p2 + 2] = (b_sum * mul_sum >> shg_sum) * pa;
      } else {
        pixels[p2] = pixels[p2 + 1] = pixels[p2 + 2] = 0;
      }
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;
      p2 = x + ((p2 = y + radiusPlus1) < heightMinus1 ? p2 : heightMinus1) * width << 2;
      r_sum += r_in_sum += stackIn.r = pixels[p2];
      g_sum += g_in_sum += stackIn.g = pixels[p2 + 1];
      b_sum += b_in_sum += stackIn.b = pixels[p2 + 2];
      a_sum += a_in_sum += stackIn.a = pixels[p2 + 3];
      stackIn = stackIn.next;
      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      a_out_sum += pa = stackOut.a;
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }
}
const Blur = function Blur2(imageData) {
  var radius = Math.round(this.blurRadius());
  if (radius > 0) {
    filterGaussBlurRGBA(imageData, radius);
  }
};
Blur$1.Blur = Blur;
Factory_1$e.Factory.addGetterSetter(Node_1$e.Node, "blurRadius", 0, (0, Validators_1$e.getNumberValidator)(), Factory_1$e.Factory.afterSetFilter);
var Brighten$1 = {};
Object.defineProperty(Brighten$1, "__esModule", { value: true });
Brighten$1.Brighten = void 0;
const Factory_1$d = Factory;
const Node_1$d = Node$1;
const Validators_1$d = Validators;
const Brighten = function(imageData) {
  var brightness = this.brightness() * 255, data = imageData.data, len2 = data.length, i;
  for (i = 0; i < len2; i += 4) {
    data[i] += brightness;
    data[i + 1] += brightness;
    data[i + 2] += brightness;
  }
};
Brighten$1.Brighten = Brighten;
Factory_1$d.Factory.addGetterSetter(Node_1$d.Node, "brightness", 0, (0, Validators_1$d.getNumberValidator)(), Factory_1$d.Factory.afterSetFilter);
var Contrast$1 = {};
Object.defineProperty(Contrast$1, "__esModule", { value: true });
Contrast$1.Contrast = void 0;
const Factory_1$c = Factory;
const Node_1$c = Node$1;
const Validators_1$c = Validators;
const Contrast = function(imageData) {
  var adjust = Math.pow((this.contrast() + 100) / 100, 2);
  var data = imageData.data, nPixels = data.length, red = 150, green = 150, blue = 150, i;
  for (i = 0; i < nPixels; i += 4) {
    red = data[i];
    green = data[i + 1];
    blue = data[i + 2];
    red /= 255;
    red -= 0.5;
    red *= adjust;
    red += 0.5;
    red *= 255;
    green /= 255;
    green -= 0.5;
    green *= adjust;
    green += 0.5;
    green *= 255;
    blue /= 255;
    blue -= 0.5;
    blue *= adjust;
    blue += 0.5;
    blue *= 255;
    red = red < 0 ? 0 : red > 255 ? 255 : red;
    green = green < 0 ? 0 : green > 255 ? 255 : green;
    blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;
    data[i] = red;
    data[i + 1] = green;
    data[i + 2] = blue;
  }
};
Contrast$1.Contrast = Contrast;
Factory_1$c.Factory.addGetterSetter(Node_1$c.Node, "contrast", 0, (0, Validators_1$c.getNumberValidator)(), Factory_1$c.Factory.afterSetFilter);
var Emboss$1 = {};
Object.defineProperty(Emboss$1, "__esModule", { value: true });
Emboss$1.Emboss = void 0;
const Factory_1$b = Factory;
const Node_1$b = Node$1;
const Util_1$2 = Util;
const Validators_1$b = Validators;
const Emboss = function(imageData) {
  var strength = this.embossStrength() * 10, greyLevel = this.embossWhiteLevel() * 255, direction = this.embossDirection(), blend = this.embossBlend(), dirY = 0, dirX = 0, data = imageData.data, w = imageData.width, h2 = imageData.height, w4 = w * 4, y = h2;
  switch (direction) {
    case "top-left":
      dirY = -1;
      dirX = -1;
      break;
    case "top":
      dirY = -1;
      dirX = 0;
      break;
    case "top-right":
      dirY = -1;
      dirX = 1;
      break;
    case "right":
      dirY = 0;
      dirX = 1;
      break;
    case "bottom-right":
      dirY = 1;
      dirX = 1;
      break;
    case "bottom":
      dirY = 1;
      dirX = 0;
      break;
    case "bottom-left":
      dirY = 1;
      dirX = -1;
      break;
    case "left":
      dirY = 0;
      dirX = -1;
      break;
    default:
      Util_1$2.Util.error("Unknown emboss direction: " + direction);
  }
  do {
    var offsetY = (y - 1) * w4;
    var otherY = dirY;
    if (y + otherY < 1) {
      otherY = 0;
    }
    if (y + otherY > h2) {
      otherY = 0;
    }
    var offsetYOther = (y - 1 + otherY) * w * 4;
    var x = w;
    do {
      var offset = offsetY + (x - 1) * 4;
      var otherX = dirX;
      if (x + otherX < 1) {
        otherX = 0;
      }
      if (x + otherX > w) {
        otherX = 0;
      }
      var offsetOther = offsetYOther + (x - 1 + otherX) * 4;
      var dR = data[offset] - data[offsetOther];
      var dG = data[offset + 1] - data[offsetOther + 1];
      var dB = data[offset + 2] - data[offsetOther + 2];
      var dif = dR;
      var absDif = dif > 0 ? dif : -dif;
      var absG = dG > 0 ? dG : -dG;
      var absB = dB > 0 ? dB : -dB;
      if (absG > absDif) {
        dif = dG;
      }
      if (absB > absDif) {
        dif = dB;
      }
      dif *= strength;
      if (blend) {
        var r = data[offset] + dif;
        var g = data[offset + 1] + dif;
        var b = data[offset + 2] + dif;
        data[offset] = r > 255 ? 255 : r < 0 ? 0 : r;
        data[offset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
        data[offset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
      } else {
        var grey = greyLevel - dif;
        if (grey < 0) {
          grey = 0;
        } else if (grey > 255) {
          grey = 255;
        }
        data[offset] = data[offset + 1] = data[offset + 2] = grey;
      }
    } while (--x);
  } while (--y);
};
Emboss$1.Emboss = Emboss;
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, "embossStrength", 0.5, (0, Validators_1$b.getNumberValidator)(), Factory_1$b.Factory.afterSetFilter);
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, "embossWhiteLevel", 0.5, (0, Validators_1$b.getNumberValidator)(), Factory_1$b.Factory.afterSetFilter);
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, "embossDirection", "top-left", null, Factory_1$b.Factory.afterSetFilter);
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, "embossBlend", false, null, Factory_1$b.Factory.afterSetFilter);
var Enhance$1 = {};
Object.defineProperty(Enhance$1, "__esModule", { value: true });
Enhance$1.Enhance = void 0;
const Factory_1$a = Factory;
const Node_1$a = Node$1;
const Validators_1$a = Validators;
function remap(fromValue, fromMin, fromMax, toMin, toMax) {
  var fromRange = fromMax - fromMin, toRange = toMax - toMin, toValue;
  if (fromRange === 0) {
    return toMin + toRange / 2;
  }
  if (toRange === 0) {
    return toMin;
  }
  toValue = (fromValue - fromMin) / fromRange;
  toValue = toRange * toValue + toMin;
  return toValue;
}
const Enhance = function(imageData) {
  var data = imageData.data, nSubPixels = data.length, rMin = data[0], rMax = rMin, r, gMin = data[1], gMax = gMin, g, bMin = data[2], bMax = bMin, b, i;
  var enhanceAmount = this.enhance();
  if (enhanceAmount === 0) {
    return;
  }
  for (i = 0; i < nSubPixels; i += 4) {
    r = data[i + 0];
    if (r < rMin) {
      rMin = r;
    } else if (r > rMax) {
      rMax = r;
    }
    g = data[i + 1];
    if (g < gMin) {
      gMin = g;
    } else if (g > gMax) {
      gMax = g;
    }
    b = data[i + 2];
    if (b < bMin) {
      bMin = b;
    } else if (b > bMax) {
      bMax = b;
    }
  }
  if (rMax === rMin) {
    rMax = 255;
    rMin = 0;
  }
  if (gMax === gMin) {
    gMax = 255;
    gMin = 0;
  }
  if (bMax === bMin) {
    bMax = 255;
    bMin = 0;
  }
  var rMid, rGoalMax, rGoalMin, gMid, gGoalMax, gGoalMin, bMid, bGoalMax, bGoalMin;
  if (enhanceAmount > 0) {
    rGoalMax = rMax + enhanceAmount * (255 - rMax);
    rGoalMin = rMin - enhanceAmount * (rMin - 0);
    gGoalMax = gMax + enhanceAmount * (255 - gMax);
    gGoalMin = gMin - enhanceAmount * (gMin - 0);
    bGoalMax = bMax + enhanceAmount * (255 - bMax);
    bGoalMin = bMin - enhanceAmount * (bMin - 0);
  } else {
    rMid = (rMax + rMin) * 0.5;
    rGoalMax = rMax + enhanceAmount * (rMax - rMid);
    rGoalMin = rMin + enhanceAmount * (rMin - rMid);
    gMid = (gMax + gMin) * 0.5;
    gGoalMax = gMax + enhanceAmount * (gMax - gMid);
    gGoalMin = gMin + enhanceAmount * (gMin - gMid);
    bMid = (bMax + bMin) * 0.5;
    bGoalMax = bMax + enhanceAmount * (bMax - bMid);
    bGoalMin = bMin + enhanceAmount * (bMin - bMid);
  }
  for (i = 0; i < nSubPixels; i += 4) {
    data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
    data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
    data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
  }
};
Enhance$1.Enhance = Enhance;
Factory_1$a.Factory.addGetterSetter(Node_1$a.Node, "enhance", 0, (0, Validators_1$a.getNumberValidator)(), Factory_1$a.Factory.afterSetFilter);
var Grayscale$1 = {};
Object.defineProperty(Grayscale$1, "__esModule", { value: true });
Grayscale$1.Grayscale = void 0;
const Grayscale = function(imageData) {
  var data = imageData.data, len2 = data.length, i, brightness;
  for (i = 0; i < len2; i += 4) {
    brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
    data[i] = brightness;
    data[i + 1] = brightness;
    data[i + 2] = brightness;
  }
};
Grayscale$1.Grayscale = Grayscale;
var HSL$1 = {};
Object.defineProperty(HSL$1, "__esModule", { value: true });
HSL$1.HSL = void 0;
const Factory_1$9 = Factory;
const Node_1$9 = Node$1;
const Validators_1$9 = Validators;
Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, "hue", 0, (0, Validators_1$9.getNumberValidator)(), Factory_1$9.Factory.afterSetFilter);
Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, "saturation", 0, (0, Validators_1$9.getNumberValidator)(), Factory_1$9.Factory.afterSetFilter);
Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, "luminance", 0, (0, Validators_1$9.getNumberValidator)(), Factory_1$9.Factory.afterSetFilter);
const HSL = function(imageData) {
  var data = imageData.data, nPixels = data.length, v = 1, s = Math.pow(2, this.saturation()), h2 = Math.abs(this.hue() + 360) % 360, l = this.luminance() * 127, i;
  var vsu = v * s * Math.cos(h2 * Math.PI / 180), vsw = v * s * Math.sin(h2 * Math.PI / 180);
  var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
  var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
  var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
  var r, g, b, a;
  for (i = 0; i < nPixels; i += 4) {
    r = data[i + 0];
    g = data[i + 1];
    b = data[i + 2];
    a = data[i + 3];
    data[i + 0] = rr * r + rg * g + rb * b + l;
    data[i + 1] = gr * r + gg * g + gb * b + l;
    data[i + 2] = br * r + bg * g + bb * b + l;
    data[i + 3] = a;
  }
};
HSL$1.HSL = HSL;
var HSV$1 = {};
Object.defineProperty(HSV$1, "__esModule", { value: true });
HSV$1.HSV = void 0;
const Factory_1$8 = Factory;
const Node_1$8 = Node$1;
const Validators_1$8 = Validators;
const HSV = function(imageData) {
  var data = imageData.data, nPixels = data.length, v = Math.pow(2, this.value()), s = Math.pow(2, this.saturation()), h2 = Math.abs(this.hue() + 360) % 360, i;
  var vsu = v * s * Math.cos(h2 * Math.PI / 180), vsw = v * s * Math.sin(h2 * Math.PI / 180);
  var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
  var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
  var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
  var r, g, b, a;
  for (i = 0; i < nPixels; i += 4) {
    r = data[i + 0];
    g = data[i + 1];
    b = data[i + 2];
    a = data[i + 3];
    data[i + 0] = rr * r + rg * g + rb * b;
    data[i + 1] = gr * r + gg * g + gb * b;
    data[i + 2] = br * r + bg * g + bb * b;
    data[i + 3] = a;
  }
};
HSV$1.HSV = HSV;
Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, "hue", 0, (0, Validators_1$8.getNumberValidator)(), Factory_1$8.Factory.afterSetFilter);
Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, "saturation", 0, (0, Validators_1$8.getNumberValidator)(), Factory_1$8.Factory.afterSetFilter);
Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, "value", 0, (0, Validators_1$8.getNumberValidator)(), Factory_1$8.Factory.afterSetFilter);
var Invert$1 = {};
Object.defineProperty(Invert$1, "__esModule", { value: true });
Invert$1.Invert = void 0;
const Invert = function(imageData) {
  var data = imageData.data, len2 = data.length, i;
  for (i = 0; i < len2; i += 4) {
    data[i] = 255 - data[i];
    data[i + 1] = 255 - data[i + 1];
    data[i + 2] = 255 - data[i + 2];
  }
};
Invert$1.Invert = Invert;
var Kaleidoscope$1 = {};
Object.defineProperty(Kaleidoscope$1, "__esModule", { value: true });
Kaleidoscope$1.Kaleidoscope = void 0;
const Factory_1$7 = Factory;
const Node_1$7 = Node$1;
const Util_1$1 = Util;
const Validators_1$7 = Validators;
var ToPolar = function(src, dst, opt) {
  var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, r = 0, g = 0, b = 0, a = 0;
  var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
  x = xSize - xMid;
  y = ySize - yMid;
  rad = Math.sqrt(x * x + y * y);
  rMax = rad > rMax ? rad : rMax;
  var rSize = ySize, tSize = xSize, radius, theta;
  var conversion = 360 / tSize * Math.PI / 180, sin, cos;
  for (theta = 0; theta < tSize; theta += 1) {
    sin = Math.sin(theta * conversion);
    cos = Math.cos(theta * conversion);
    for (radius = 0; radius < rSize; radius += 1) {
      x = Math.floor(xMid + rMax * radius / rSize * cos);
      y = Math.floor(yMid + rMax * radius / rSize * sin);
      i = (y * xSize + x) * 4;
      r = srcPixels[i + 0];
      g = srcPixels[i + 1];
      b = srcPixels[i + 2];
      a = srcPixels[i + 3];
      i = (theta + radius * xSize) * 4;
      dstPixels[i + 0] = r;
      dstPixels[i + 1] = g;
      dstPixels[i + 2] = b;
      dstPixels[i + 3] = a;
    }
  }
};
var FromPolar = function(src, dst, opt) {
  var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0;
  var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
  x = xSize - xMid;
  y = ySize - yMid;
  rad = Math.sqrt(x * x + y * y);
  rMax = rad > rMax ? rad : rMax;
  var rSize = ySize, tSize = xSize, radius, theta, phaseShift = opt.polarRotation || 0;
  var x1, y1;
  for (x = 0; x < xSize; x += 1) {
    for (y = 0; y < ySize; y += 1) {
      dx = x - xMid;
      dy = y - yMid;
      radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
      theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
      theta = theta * tSize / 360;
      x1 = Math.floor(theta);
      y1 = Math.floor(radius);
      i = (y1 * xSize + x1) * 4;
      r = srcPixels[i + 0];
      g = srcPixels[i + 1];
      b = srcPixels[i + 2];
      a = srcPixels[i + 3];
      i = (y * xSize + x) * 4;
      dstPixels[i + 0] = r;
      dstPixels[i + 1] = g;
      dstPixels[i + 2] = b;
      dstPixels[i + 3] = a;
    }
  }
};
const Kaleidoscope = function(imageData) {
  var xSize = imageData.width, ySize = imageData.height;
  var x, y, xoff, i, r, g, b, a, srcPos, dstPos;
  var power = Math.round(this.kaleidoscopePower());
  var angle = Math.round(this.kaleidoscopeAngle());
  var offset = Math.floor(xSize * (angle % 360) / 360);
  if (power < 1) {
    return;
  }
  var tempCanvas = Util_1$1.Util.createCanvasElement();
  tempCanvas.width = xSize;
  tempCanvas.height = ySize;
  var scratchData = tempCanvas.getContext("2d").getImageData(0, 0, xSize, ySize);
  Util_1$1.Util.releaseCanvas(tempCanvas);
  ToPolar(imageData, scratchData, {
    polarCenterX: xSize / 2,
    polarCenterY: ySize / 2
  });
  var minSectionSize = xSize / Math.pow(2, power);
  while (minSectionSize <= 8) {
    minSectionSize = minSectionSize * 2;
    power -= 1;
  }
  minSectionSize = Math.ceil(minSectionSize);
  var sectionSize = minSectionSize;
  var xStart = 0, xEnd = sectionSize, xDelta = 1;
  if (offset + minSectionSize > xSize) {
    xStart = sectionSize;
    xEnd = 0;
    xDelta = -1;
  }
  for (y = 0; y < ySize; y += 1) {
    for (x = xStart; x !== xEnd; x += xDelta) {
      xoff = Math.round(x + offset) % xSize;
      srcPos = (xSize * y + xoff) * 4;
      r = scratchData.data[srcPos + 0];
      g = scratchData.data[srcPos + 1];
      b = scratchData.data[srcPos + 2];
      a = scratchData.data[srcPos + 3];
      dstPos = (xSize * y + x) * 4;
      scratchData.data[dstPos + 0] = r;
      scratchData.data[dstPos + 1] = g;
      scratchData.data[dstPos + 2] = b;
      scratchData.data[dstPos + 3] = a;
    }
  }
  for (y = 0; y < ySize; y += 1) {
    sectionSize = Math.floor(minSectionSize);
    for (i = 0; i < power; i += 1) {
      for (x = 0; x < sectionSize + 1; x += 1) {
        srcPos = (xSize * y + x) * 4;
        r = scratchData.data[srcPos + 0];
        g = scratchData.data[srcPos + 1];
        b = scratchData.data[srcPos + 2];
        a = scratchData.data[srcPos + 3];
        dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
        scratchData.data[dstPos + 0] = r;
        scratchData.data[dstPos + 1] = g;
        scratchData.data[dstPos + 2] = b;
        scratchData.data[dstPos + 3] = a;
      }
      sectionSize *= 2;
    }
  }
  FromPolar(scratchData, imageData, { polarRotation: 0 });
};
Kaleidoscope$1.Kaleidoscope = Kaleidoscope;
Factory_1$7.Factory.addGetterSetter(Node_1$7.Node, "kaleidoscopePower", 2, (0, Validators_1$7.getNumberValidator)(), Factory_1$7.Factory.afterSetFilter);
Factory_1$7.Factory.addGetterSetter(Node_1$7.Node, "kaleidoscopeAngle", 0, (0, Validators_1$7.getNumberValidator)(), Factory_1$7.Factory.afterSetFilter);
var Mask$1 = {};
Object.defineProperty(Mask$1, "__esModule", { value: true });
Mask$1.Mask = void 0;
const Factory_1$6 = Factory;
const Node_1$6 = Node$1;
const Validators_1$6 = Validators;
function pixelAt(idata, x, y) {
  var idx = (y * idata.width + x) * 4;
  var d = [];
  d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
  return d;
}
function rgbDistance(p1, p2) {
  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
}
function rgbMean(pTab) {
  var m = [0, 0, 0];
  for (var i = 0; i < pTab.length; i++) {
    m[0] += pTab[i][0];
    m[1] += pTab[i][1];
    m[2] += pTab[i][2];
  }
  m[0] /= pTab.length;
  m[1] /= pTab.length;
  m[2] /= pTab.length;
  return m;
}
function backgroundMask(idata, threshold) {
  var rgbv_no = pixelAt(idata, 0, 0);
  var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
  var rgbv_so = pixelAt(idata, 0, idata.height - 1);
  var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);
  var thres = threshold || 10;
  if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {
    var mean2 = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);
    var mask = [];
    for (var i = 0; i < idata.width * idata.height; i++) {
      var d = rgbDistance(mean2, [
        idata.data[i * 4],
        idata.data[i * 4 + 1],
        idata.data[i * 4 + 2]
      ]);
      mask[i] = d < thres ? 0 : 255;
    }
    return mask;
  }
}
function applyMask(idata, mask) {
  for (var i = 0; i < idata.width * idata.height; i++) {
    idata.data[4 * i + 3] = mask[i];
  }
}
function erodeMask(mask, sw, sh) {
  var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
  var side = Math.round(Math.sqrt(weights.length));
  var halfSide = Math.floor(side / 2);
  var maskResult = [];
  for (var y = 0; y < sh; y++) {
    for (var x = 0; x < sw; x++) {
      var so = y * sw + x;
      var a = 0;
      for (var cy = 0; cy < side; cy++) {
        for (var cx = 0; cx < side; cx++) {
          var scy = y + cy - halfSide;
          var scx = x + cx - halfSide;
          if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
            var srcOff = scy * sw + scx;
            var wt = weights[cy * side + cx];
            a += mask[srcOff] * wt;
          }
        }
      }
      maskResult[so] = a === 255 * 8 ? 255 : 0;
    }
  }
  return maskResult;
}
function dilateMask(mask, sw, sh) {
  var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
  var side = Math.round(Math.sqrt(weights.length));
  var halfSide = Math.floor(side / 2);
  var maskResult = [];
  for (var y = 0; y < sh; y++) {
    for (var x = 0; x < sw; x++) {
      var so = y * sw + x;
      var a = 0;
      for (var cy = 0; cy < side; cy++) {
        for (var cx = 0; cx < side; cx++) {
          var scy = y + cy - halfSide;
          var scx = x + cx - halfSide;
          if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
            var srcOff = scy * sw + scx;
            var wt = weights[cy * side + cx];
            a += mask[srcOff] * wt;
          }
        }
      }
      maskResult[so] = a >= 255 * 4 ? 255 : 0;
    }
  }
  return maskResult;
}
function smoothEdgeMask(mask, sw, sh) {
  var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
  var side = Math.round(Math.sqrt(weights.length));
  var halfSide = Math.floor(side / 2);
  var maskResult = [];
  for (var y = 0; y < sh; y++) {
    for (var x = 0; x < sw; x++) {
      var so = y * sw + x;
      var a = 0;
      for (var cy = 0; cy < side; cy++) {
        for (var cx = 0; cx < side; cx++) {
          var scy = y + cy - halfSide;
          var scx = x + cx - halfSide;
          if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
            var srcOff = scy * sw + scx;
            var wt = weights[cy * side + cx];
            a += mask[srcOff] * wt;
          }
        }
      }
      maskResult[so] = a;
    }
  }
  return maskResult;
}
const Mask = function(imageData) {
  var threshold = this.threshold(), mask = backgroundMask(imageData, threshold);
  if (mask) {
    mask = erodeMask(mask, imageData.width, imageData.height);
    mask = dilateMask(mask, imageData.width, imageData.height);
    mask = smoothEdgeMask(mask, imageData.width, imageData.height);
    applyMask(imageData, mask);
  }
  return imageData;
};
Mask$1.Mask = Mask;
Factory_1$6.Factory.addGetterSetter(Node_1$6.Node, "threshold", 0, (0, Validators_1$6.getNumberValidator)(), Factory_1$6.Factory.afterSetFilter);
var Noise$1 = {};
Object.defineProperty(Noise$1, "__esModule", { value: true });
Noise$1.Noise = void 0;
const Factory_1$5 = Factory;
const Node_1$5 = Node$1;
const Validators_1$5 = Validators;
const Noise = function(imageData) {
  var amount = this.noise() * 255, data = imageData.data, nPixels = data.length, half = amount / 2, i;
  for (i = 0; i < nPixels; i += 4) {
    data[i + 0] += half - 2 * half * Math.random();
    data[i + 1] += half - 2 * half * Math.random();
    data[i + 2] += half - 2 * half * Math.random();
  }
};
Noise$1.Noise = Noise;
Factory_1$5.Factory.addGetterSetter(Node_1$5.Node, "noise", 0.2, (0, Validators_1$5.getNumberValidator)(), Factory_1$5.Factory.afterSetFilter);
var Pixelate$1 = {};
Object.defineProperty(Pixelate$1, "__esModule", { value: true });
Pixelate$1.Pixelate = void 0;
const Factory_1$4 = Factory;
const Util_1 = Util;
const Node_1$4 = Node$1;
const Validators_1$4 = Validators;
const Pixelate = function(imageData) {
  var pixelSize = Math.ceil(this.pixelSize()), width = imageData.width, height = imageData.height, x, y, i, red, green, blue, alpha, nBinsX = Math.ceil(width / pixelSize), nBinsY = Math.ceil(height / pixelSize), xBinStart, xBinEnd, yBinStart, yBinEnd, xBin, yBin, pixelsInBin, data = imageData.data;
  if (pixelSize <= 0) {
    Util_1.Util.error("pixelSize value can not be <= 0");
    return;
  }
  for (xBin = 0; xBin < nBinsX; xBin += 1) {
    for (yBin = 0; yBin < nBinsY; yBin += 1) {
      red = 0;
      green = 0;
      blue = 0;
      alpha = 0;
      xBinStart = xBin * pixelSize;
      xBinEnd = xBinStart + pixelSize;
      yBinStart = yBin * pixelSize;
      yBinEnd = yBinStart + pixelSize;
      pixelsInBin = 0;
      for (x = xBinStart; x < xBinEnd; x += 1) {
        if (x >= width) {
          continue;
        }
        for (y = yBinStart; y < yBinEnd; y += 1) {
          if (y >= height) {
            continue;
          }
          i = (width * y + x) * 4;
          red += data[i + 0];
          green += data[i + 1];
          blue += data[i + 2];
          alpha += data[i + 3];
          pixelsInBin += 1;
        }
      }
      red = red / pixelsInBin;
      green = green / pixelsInBin;
      blue = blue / pixelsInBin;
      alpha = alpha / pixelsInBin;
      for (x = xBinStart; x < xBinEnd; x += 1) {
        if (x >= width) {
          continue;
        }
        for (y = yBinStart; y < yBinEnd; y += 1) {
          if (y >= height) {
            continue;
          }
          i = (width * y + x) * 4;
          data[i + 0] = red;
          data[i + 1] = green;
          data[i + 2] = blue;
          data[i + 3] = alpha;
        }
      }
    }
  }
};
Pixelate$1.Pixelate = Pixelate;
Factory_1$4.Factory.addGetterSetter(Node_1$4.Node, "pixelSize", 8, (0, Validators_1$4.getNumberValidator)(), Factory_1$4.Factory.afterSetFilter);
var Posterize$1 = {};
Object.defineProperty(Posterize$1, "__esModule", { value: true });
Posterize$1.Posterize = void 0;
const Factory_1$3 = Factory;
const Node_1$3 = Node$1;
const Validators_1$3 = Validators;
const Posterize = function(imageData) {
  var levels = Math.round(this.levels() * 254) + 1, data = imageData.data, len2 = data.length, scale = 255 / levels, i;
  for (i = 0; i < len2; i += 1) {
    data[i] = Math.floor(data[i] / scale) * scale;
  }
};
Posterize$1.Posterize = Posterize;
Factory_1$3.Factory.addGetterSetter(Node_1$3.Node, "levels", 0.5, (0, Validators_1$3.getNumberValidator)(), Factory_1$3.Factory.afterSetFilter);
var RGB$1 = {};
Object.defineProperty(RGB$1, "__esModule", { value: true });
RGB$1.RGB = void 0;
const Factory_1$2 = Factory;
const Node_1$2 = Node$1;
const Validators_1$2 = Validators;
const RGB = function(imageData) {
  var data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), i, brightness;
  for (i = 0; i < nPixels; i += 4) {
    brightness = (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
    data[i] = brightness * red;
    data[i + 1] = brightness * green;
    data[i + 2] = brightness * blue;
    data[i + 3] = data[i + 3];
  }
};
RGB$1.RGB = RGB;
Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, "red", 0, function(val) {
  this._filterUpToDate = false;
  if (val > 255) {
    return 255;
  } else if (val < 0) {
    return 0;
  } else {
    return Math.round(val);
  }
});
Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, "green", 0, function(val) {
  this._filterUpToDate = false;
  if (val > 255) {
    return 255;
  } else if (val < 0) {
    return 0;
  } else {
    return Math.round(val);
  }
});
Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, "blue", 0, Validators_1$2.RGBComponent, Factory_1$2.Factory.afterSetFilter);
var RGBA$1 = {};
Object.defineProperty(RGBA$1, "__esModule", { value: true });
RGBA$1.RGBA = void 0;
const Factory_1$1 = Factory;
const Node_1$1 = Node$1;
const Validators_1$1 = Validators;
const RGBA = function(imageData) {
  var data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), alpha = this.alpha(), i, ia;
  for (i = 0; i < nPixels; i += 4) {
    ia = 1 - alpha;
    data[i] = red * alpha + data[i] * ia;
    data[i + 1] = green * alpha + data[i + 1] * ia;
    data[i + 2] = blue * alpha + data[i + 2] * ia;
  }
};
RGBA$1.RGBA = RGBA;
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, "red", 0, function(val) {
  this._filterUpToDate = false;
  if (val > 255) {
    return 255;
  } else if (val < 0) {
    return 0;
  } else {
    return Math.round(val);
  }
});
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, "green", 0, function(val) {
  this._filterUpToDate = false;
  if (val > 255) {
    return 255;
  } else if (val < 0) {
    return 0;
  } else {
    return Math.round(val);
  }
});
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, "blue", 0, Validators_1$1.RGBComponent, Factory_1$1.Factory.afterSetFilter);
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, "alpha", 1, function(val) {
  this._filterUpToDate = false;
  if (val > 1) {
    return 1;
  } else if (val < 0) {
    return 0;
  } else {
    return val;
  }
});
var Sepia$1 = {};
Object.defineProperty(Sepia$1, "__esModule", { value: true });
Sepia$1.Sepia = void 0;
const Sepia = function(imageData) {
  var data = imageData.data, nPixels = data.length, i, r, g, b;
  for (i = 0; i < nPixels; i += 4) {
    r = data[i + 0];
    g = data[i + 1];
    b = data[i + 2];
    data[i + 0] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
    data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
    data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
  }
};
Sepia$1.Sepia = Sepia;
var Solarize$1 = {};
Object.defineProperty(Solarize$1, "__esModule", { value: true });
Solarize$1.Solarize = void 0;
const Solarize = function(imageData) {
  var data = imageData.data, w = imageData.width, h2 = imageData.height, w4 = w * 4, y = h2;
  do {
    var offsetY = (y - 1) * w4;
    var x = w;
    do {
      var offset = offsetY + (x - 1) * 4;
      var r = data[offset];
      var g = data[offset + 1];
      var b = data[offset + 2];
      if (r > 127) {
        r = 255 - r;
      }
      if (g > 127) {
        g = 255 - g;
      }
      if (b > 127) {
        b = 255 - b;
      }
      data[offset] = r;
      data[offset + 1] = g;
      data[offset + 2] = b;
    } while (--x);
  } while (--y);
};
Solarize$1.Solarize = Solarize;
var Threshold$1 = {};
Object.defineProperty(Threshold$1, "__esModule", { value: true });
Threshold$1.Threshold = void 0;
const Factory_1 = Factory;
const Node_1 = Node$1;
const Validators_1 = Validators;
const Threshold = function(imageData) {
  var level = this.threshold() * 255, data = imageData.data, len2 = data.length, i;
  for (i = 0; i < len2; i += 1) {
    data[i] = data[i] < level ? 0 : 255;
  }
};
Threshold$1.Threshold = Threshold;
Factory_1.Factory.addGetterSetter(Node_1.Node, "threshold", 0.5, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
Object.defineProperty(_FullInternals, "__esModule", { value: true });
_FullInternals.Konva = void 0;
const _CoreInternals_1 = _CoreInternals;
const Arc_1 = Arc$1;
const Arrow_1 = Arrow$1;
const Circle_1 = Circle$2;
const Ellipse_1 = Ellipse$1;
const Image_1 = Image$2;
const Label_1 = Label$1;
const Line_1 = Line$2;
const Path_1 = Path$1;
const Rect_1 = Rect$2;
const RegularPolygon_1 = RegularPolygon$1;
const Ring_1 = Ring$1;
const Sprite_1 = Sprite$1;
const Star_1 = Star$1;
const Text_1 = Text$1;
const TextPath_1 = TextPath$1;
const Transformer_1 = Transformer$1;
const Wedge_1 = Wedge$1;
const Blur_1 = Blur$1;
const Brighten_1 = Brighten$1;
const Contrast_1 = Contrast$1;
const Emboss_1 = Emboss$1;
const Enhance_1 = Enhance$1;
const Grayscale_1 = Grayscale$1;
const HSL_1 = HSL$1;
const HSV_1 = HSV$1;
const Invert_1 = Invert$1;
const Kaleidoscope_1 = Kaleidoscope$1;
const Mask_1 = Mask$1;
const Noise_1 = Noise$1;
const Pixelate_1 = Pixelate$1;
const Posterize_1 = Posterize$1;
const RGB_1 = RGB$1;
const RGBA_1 = RGBA$1;
const Sepia_1 = Sepia$1;
const Solarize_1 = Solarize$1;
const Threshold_1 = Threshold$1;
_FullInternals.Konva = _CoreInternals_1.Konva.Util._assign(_CoreInternals_1.Konva, {
  Arc: Arc_1.Arc,
  Arrow: Arrow_1.Arrow,
  Circle: Circle_1.Circle,
  Ellipse: Ellipse_1.Ellipse,
  Image: Image_1.Image,
  Label: Label_1.Label,
  Tag: Label_1.Tag,
  Line: Line_1.Line,
  Path: Path_1.Path,
  Rect: Rect_1.Rect,
  RegularPolygon: RegularPolygon_1.RegularPolygon,
  Ring: Ring_1.Ring,
  Sprite: Sprite_1.Sprite,
  Star: Star_1.Star,
  Text: Text_1.Text,
  TextPath: TextPath_1.TextPath,
  Transformer: Transformer_1.Transformer,
  Wedge: Wedge_1.Wedge,
  Filters: {
    Blur: Blur_1.Blur,
    Brighten: Brighten_1.Brighten,
    Contrast: Contrast_1.Contrast,
    Emboss: Emboss_1.Emboss,
    Enhance: Enhance_1.Enhance,
    Grayscale: Grayscale_1.Grayscale,
    HSL: HSL_1.HSL,
    HSV: HSV_1.HSV,
    Invert: Invert_1.Invert,
    Kaleidoscope: Kaleidoscope_1.Kaleidoscope,
    Mask: Mask_1.Mask,
    Noise: Noise_1.Noise,
    Pixelate: Pixelate_1.Pixelate,
    Posterize: Posterize_1.Posterize,
    RGB: RGB_1.RGB,
    RGBA: RGBA_1.RGBA,
    Sepia: Sepia_1.Sepia,
    Solarize: Solarize_1.Solarize,
    Threshold: Threshold_1.Threshold
  }
});
var lib = lib$1.exports;
Object.defineProperty(lib, "__esModule", { value: true });
const _FullInternals_1 = _FullInternals;
lib$1.exports = _FullInternals_1.Konva;
var libExports = lib$1.exports;
const Konva = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
var MouseButton = /* @__PURE__ */ ((MouseButton2) => {
  MouseButton2[MouseButton2["左键"] = 0] = "左键";
  MouseButton2[MouseButton2["右键"] = 2] = "右键";
  return MouseButton2;
})(MouseButton || {});
class BaseDraw {
  constructor(render22, layer) {
    __publicField(this, "render");
    __publicField(this, "layer");
    __publicField(this, "group");
    this.render = render22;
    this.layer = layer;
    this.group = new Konva.Group();
  }
  init() {
    this.layer.add(this.group);
    this.draw();
  }
  draw() {
  }
  clear() {
    this.group.destroy();
    const name = this.group.name();
    this.group = new Konva.Group({ name });
    this.layer.add(this.group);
  }
}
var MoveKey = /* @__PURE__ */ ((MoveKey2) => {
  MoveKey2["上"] = "ArrowUp";
  MoveKey2["左"] = "ArrowLeft";
  MoveKey2["右"] = "ArrowRight";
  MoveKey2["下"] = "ArrowDown";
  return MoveKey2;
})(MoveKey || {});
var ShutcutKey = /* @__PURE__ */ ((ShutcutKey2) => {
  ShutcutKey2["删除"] = "Delete";
  ShutcutKey2["C"] = "KeyC";
  ShutcutKey2["V"] = "KeyV";
  ShutcutKey2["Z"] = "KeyZ";
  ShutcutKey2["A"] = "KeyA";
  ShutcutKey2["R"] = "KeyR";
  ShutcutKey2["Esc"] = "Escape";
  ShutcutKey2["Backspace"] = "Backspace";
  ShutcutKey2["Enter"] = "Enter";
  return ShutcutKey2;
})(ShutcutKey || {});
var AlignType = /* @__PURE__ */ ((AlignType2) => {
  AlignType2["垂直居中"] = "Middle";
  AlignType2["左对齐"] = "Left";
  AlignType2["右对齐"] = "Right";
  AlignType2["水平居中"] = "Center";
  AlignType2["上对齐"] = "Top";
  AlignType2["下对齐"] = "Bottom";
  return AlignType2;
})(AlignType || {});
var LinkType = /* @__PURE__ */ ((LinkType2) => {
  LinkType2["auto"] = "auto";
  LinkType2["straight"] = "straight";
  LinkType2["manual"] = "manual";
  return LinkType2;
})(LinkType || {});
var GraphType = /* @__PURE__ */ ((GraphType2) => {
  GraphType2["Line"] = "Line";
  GraphType2["Curve"] = "Curve";
  GraphType2["Rect"] = "Rect";
  GraphType2["Circle"] = "Circle";
  return GraphType2;
})(GraphType || {});
var AssetType = /* @__PURE__ */ ((AssetType2) => {
  AssetType2["Image"] = "Image";
  AssetType2["Json"] = "Json";
  AssetType2["Graph"] = "Graph";
  AssetType2["Text"] = "Text";
  return AssetType2;
})(AssetType || {});
var ImageType = /* @__PURE__ */ ((ImageType2) => {
  ImageType2["svg"] = "svg";
  ImageType2["gif"] = "gif";
  ImageType2["other"] = "other";
  return ImageType2;
})(ImageType || {});
class BgDraw extends BaseDraw {
  constructor(render22, layer, option) {
    super(render22, layer);
    __publicField(this, "option");
    this.option = option;
    this.group.listening(false);
  }
  draw() {
    this.clear();
    const stageState = this.render.getStageState();
    const cellSize = this.option.size;
    const lenX = Math.ceil(
      this.render.toStageValue(stageState.width + this.render.rulerSize) / cellSize
    );
    const lenY = Math.ceil(
      this.render.toStageValue(stageState.height + this.render.rulerSize) / cellSize
    );
    const startX = -Math.ceil(this.render.toStageValue(stageState.x) / cellSize);
    const startY = -Math.ceil(this.render.toStageValue(stageState.y) / cellSize);
    const group = new Konva.Group();
    group.add(
      new Konva.Rect({
        name: `${this.constructor.name}__background`,
        x: this.render.toStageValue(-stageState.x + this.render.rulerSize),
        y: this.render.toStageValue(-stageState.y + this.render.rulerSize),
        width: this.render.toStageValue(stageState.width),
        height: this.render.toStageValue(stageState.height),
        listening: false,
        fill: this.render.getPageSettings().background
      })
    );
    group.add(
      new Konva.Rect({
        name: this.constructor.name,
        x: 0,
        y: 0,
        width: stageState.width,
        height: stageState.height,
        stroke: "rgba(255,0,0,0.2)",
        strokeWidth: this.render.toStageValue(2),
        listening: false,
        dash: [this.render.toStageValue(6), this.render.toStageValue(6)]
      })
    );
    for (let x = startX; x < lenX + startX + 2; x++) {
      group.add(
        new Konva.Line({
          name: this.constructor.name,
          points: lodash.flatten([
            [cellSize * x, this.render.toStageValue(-stageState.y + this.render.rulerSize)],
            [
              cellSize * x,
              this.render.toStageValue(stageState.height - stageState.y + this.render.rulerSize)
            ]
          ]),
          stroke: "#ddd",
          strokeWidth: this.render.toStageValue(1),
          listening: false
        })
      );
    }
    for (let y = startY; y < lenY + startY + 2; y++) {
      group.add(
        new Konva.Line({
          name: this.constructor.name,
          points: lodash.flatten([
            [this.render.toStageValue(-stageState.x + this.render.rulerSize), cellSize * y],
            [
              this.render.toStageValue(stageState.width - stageState.x + this.render.rulerSize),
              cellSize * y
            ]
          ]),
          stroke: "#ddd",
          strokeWidth: this.render.toStageValue(1),
          listening: false
        })
      );
    }
    this.group.add(group);
  }
}
__publicField(BgDraw, "name", "bg");
class RulerDraw extends BaseDraw {
  constructor(render22, layer, option) {
    super(render22, layer);
    __publicField(this, "option");
    this.option = option;
    this.group.listening(false);
  }
  draw() {
    this.clear();
    const stageState = this.render.getStageState();
    const cellSize = 20;
    const fontSizeMax = 12;
    const lenX = Math.ceil(this.render.toStageValue(stageState.width) / cellSize);
    const lenY = Math.ceil(this.render.toStageValue(stageState.height) / cellSize);
    const startX = -Math.ceil(this.render.toStageValue(stageState.x - this.option.size) / cellSize);
    const startY = -Math.ceil(this.render.toStageValue(stageState.y - this.option.size) / cellSize);
    const group = new Konva.Group();
    const groupTop = new Konva.Group({
      x: this.render.toStageValue(-stageState.x + this.option.size),
      y: this.render.toStageValue(-stageState.y),
      width: this.render.toStageValue(stageState.width - this.option.size + this.render.rulerSize),
      height: this.render.toStageValue(this.option.size)
    });
    const groupLeft = new Konva.Group({
      x: this.render.toStageValue(-stageState.x),
      y: this.render.toStageValue(-stageState.y + this.option.size),
      width: this.render.toStageValue(this.option.size),
      height: this.render.toStageValue(stageState.height - this.option.size + this.render.rulerSize)
    });
    {
      groupTop.add(
        // 上
        new Konva.Rect({
          name: this.constructor.name,
          x: 0,
          y: 0,
          width: groupTop.width(),
          height: groupTop.height(),
          fill: "#ddd"
        })
      );
      for (let x = lenX + startX - 1; x >= startX; x--) {
        const nx = -groupTop.x() + cellSize * x;
        const long = this.render.toStageValue(this.option.size) / 5 * 4;
        const short = this.render.toStageValue(this.option.size) / 5 * 3;
        if (nx >= 0) {
          groupTop.add(
            new Konva.Line({
              name: this.constructor.name,
              points: lodash.flatten([
                [nx, x % 5 ? long : short],
                [nx, this.render.toStageValue(this.option.size)]
              ]),
              stroke: "#999",
              strokeWidth: this.render.toStageValue(1),
              listening: false
            })
          );
          if (x % 5 === 0) {
            let fontSize2 = fontSizeMax;
            const text = new Konva.Text({
              name: this.constructor.name,
              y: this.render.toStageValue(this.option.size / 2 - fontSize2),
              text: (x * cellSize).toString(),
              fontSize: this.render.toStageValue(fontSize2),
              fill: "#999",
              align: "center",
              verticalAlign: "middle",
              lineHeight: 1.6
            });
            while (this.render.toStageValue(text.width()) > this.render.toStageValue(cellSize) * 4.6) {
              fontSize2 -= 1;
              text.fontSize(this.render.toStageValue(fontSize2));
              text.y(this.render.toStageValue(this.option.size / 2 - fontSize2));
            }
            text.x(nx - text.width() / 2);
            groupTop.add(text);
          }
        }
      }
    }
    {
      groupLeft.add(
        // 左
        new Konva.Rect({
          name: this.constructor.name,
          x: 0,
          y: 0,
          width: groupLeft.width(),
          height: groupLeft.height(),
          fill: "#ddd"
        })
      );
      for (let y = lenY + startY - 1; y >= startY; y--) {
        const ny = -groupLeft.y() + cellSize * y;
        const long = this.render.toStageValue(this.option.size) / 5 * 4;
        const short = this.render.toStageValue(this.option.size) / 5 * 3;
        if (ny >= 0) {
          groupLeft.add(
            new Konva.Line({
              name: this.constructor.name,
              points: lodash.flatten([
                [y % 5 ? long : short, ny],
                [this.render.toStageValue(this.option.size), ny]
              ]),
              stroke: "#999",
              strokeWidth: this.render.toStageValue(1),
              listening: false
            })
          );
          if (y % 5 === 0) {
            let fontSize2 = fontSizeMax;
            const text = new Konva.Text({
              name: this.constructor.name,
              x: 0,
              y: ny,
              text: (y * cellSize).toString(),
              fontSize: this.render.toStageValue(fontSize2),
              fill: "#999",
              align: "right",
              verticalAlign: "bottom",
              lineHeight: 1.6,
              wrap: "none"
            });
            while (text.width() > short * 0.8) {
              fontSize2 -= 1;
              text.fontSize(this.render.toStageValue(fontSize2));
            }
            text.y(ny - text.height() / 2);
            text.width(short - this.render.toStageValue(1));
            groupLeft.add(text);
          }
        }
      }
    }
    group.add(
      // 角
      new Konva.Rect({
        name: this.constructor.name,
        x: this.render.toStageValue(-stageState.x),
        y: this.render.toStageValue(-stageState.y),
        width: this.render.toStageValue(this.option.size),
        height: this.render.toStageValue(this.option.size),
        fill: "#ddd"
      })
    );
    group.add(groupTop);
    group.add(groupLeft);
    this.group.add(group);
  }
}
__publicField(RulerDraw, "name", "ruler");
class RefLineDraw extends BaseDraw {
  constructor(render22, layer, option) {
    super(render22, layer);
    __publicField(this, "option");
    __publicField(this, "handlers", {
      dom: {
        mousemove: () => {
          this.draw();
        },
        mouseout: () => {
          this.clear();
        }
      }
    });
    this.option = option;
    this.group.listening(false);
  }
  draw() {
    this.clear();
    const stageState = this.render.getStageState();
    const group = new Konva.Group();
    const pos = this.render.stage.getPointerPosition();
    if (pos) {
      if (pos.y >= this.option.padding) {
        group.add(
          new Konva.Line({
            name: this.constructor.name,
            points: lodash.flatten([
              [
                this.render.toStageValue(-stageState.x),
                this.render.toStageValue(pos.y - stageState.y)
              ],
              [
                this.render.toStageValue(stageState.width - stageState.x + this.render.rulerSize),
                this.render.toStageValue(pos.y - stageState.y)
              ]
            ]),
            stroke: "rgba(255,0,0,0.2)",
            strokeWidth: this.render.toStageValue(1),
            listening: false
          })
        );
      }
      if (pos.x >= this.option.padding) {
        group.add(
          new Konva.Line({
            name: this.constructor.name,
            points: lodash.flatten([
              [
                this.render.toStageValue(pos.x - stageState.x),
                this.render.toStageValue(-stageState.y)
              ],
              [
                this.render.toStageValue(pos.x - stageState.x),
                this.render.toStageValue(stageState.height - stageState.y + this.render.rulerSize)
              ]
            ]),
            stroke: "rgba(255,0,0,0.2)",
            strokeWidth: this.render.toStageValue(1),
            listening: false
          })
        );
      }
    }
    this.group.add(group);
  }
}
__publicField(RefLineDraw, "name", "refLine");
class ContextmenuDraw extends BaseDraw {
  constructor(render22, layer, option) {
    super(render22, layer);
    __publicField(this, "option");
    __publicField(this, "state");
    __publicField(this, "handlers", {
      stage: {
        mousedown: (e) => {
          this.state.lastPos = this.render.stage.getPointerPosition();
          if (e.evt.button === MouseButton.左键) {
            if (!this.state.menuIsMousedown) {
              this.state.target = null;
              this.draw();
            }
          } else if (e.evt.button === MouseButton.右键 && !e.evt.ctrlKey) {
            this.state.right = true;
          }
        },
        mousemove: () => {
          if (this.state.target && this.state.right) {
            this.state.target = null;
            this.draw();
          }
        },
        mouseup: () => {
          this.state.right = false;
        },
        contextmenu: (e) => {
          if (!e.evt.ctrlKey) {
            const pos = this.render.stage.getPointerPosition();
            if (pos && this.state.lastPos) {
              const linkGroup = this.render.layerCover.find(
                `.${LinkDraw.name}`
              )[0];
              let lineSelection = null;
              if (linkGroup) {
                const linkLines = linkGroup.find(".link-line");
                for (const line of linkLines) {
                  if (Konva.Util.haveIntersection({ ...pos, width: 1, height: 1 }, line.getClientRect())) {
                    lineSelection = line;
                    break;
                  }
                }
              }
              if (pos.x === this.state.lastPos.x || pos.y === this.state.lastPos.y) {
                this.state.target = lineSelection ?? e.target;
              } else {
                this.state.target = null;
              }
              this.draw();
            }
          }
        },
        wheel: () => {
          this.state.target = null;
          this.draw();
        }
      }
    });
    this.option = option;
    this.state = { target: null, menuIsMousedown: false, lastPos: null, right: false };
  }
  draw() {
    this.clear();
    if (this.state.target) {
      const menus = [];
      if (this.state.target === this.render.stage) {
        menus.push({
          name: "自适应大小",
          action: () => {
            this.render.positionTool.positionFit();
          }
        });
        menus.push({
          name: "恢复位置",
          action: () => {
            this.render.positionTool.positionReset();
          }
        });
        menus.push({
          name: "恢复大小位置",
          action: () => {
            this.render.positionTool.positionZoomReset();
          }
        });
      } else if (!this.render.config.readonly) {
        if (this.state.target.name() === "link-line") {
          menus.push({
            name: "删除",
            action: () => {
              this.render.linkTool.remove(this.state.target);
            }
          });
        } else {
          const target = this.state.target.parent;
          menus.push({
            name: "复制",
            action: () => {
              if (target) {
                this.render.copyTool.copy([target]);
              }
            }
          });
          menus.push({
            name: "删除",
            action: () => {
              if (target) {
                this.render.remove([target]);
              }
            }
          });
          menus.push({
            name: "上移",
            action: () => {
              if (target) {
                this.render.zIndexTool.up([target]);
              }
            }
          });
          menus.push({
            name: "下移",
            action: () => {
              if (target) {
                this.render.zIndexTool.down([target]);
              }
            }
          });
          menus.push({
            name: "置顶",
            action: () => {
              if (target) {
                this.render.zIndexTool.top([target]);
              }
            }
          });
          menus.push({
            name: "置底",
            action: () => {
              if (target) {
                this.render.zIndexTool.bottom([target]);
              }
            }
          });
          if (target instanceof Konva.Transformer) {
            const pos2 = this.render.stage.getPointerPosition();
            if (pos2) {
              const shapes = target.nodes();
              if (shapes.length > 1) {
                shapes.sort((a, b) => b.zIndex() - a.zIndex());
                const selected = shapes.find(
                  (shape) => (
                    // 关键 api
                    Konva.Util.haveIntersection(
                      { ...pos2, width: 1, height: 1 },
                      shape.getClientRect()
                    )
                  )
                );
                menus.push({
                  name: "垂直居中" + (selected ? "于目标" : ""),
                  action: () => {
                    this.render.alignTool.align(AlignType.垂直居中, selected);
                  }
                });
                menus.push({
                  name: "左对齐" + (selected ? "于目标" : ""),
                  action: () => {
                    this.render.alignTool.align(AlignType.左对齐, selected);
                  }
                });
                menus.push({
                  name: "右对齐" + (selected ? "于目标" : ""),
                  action: () => {
                    this.render.alignTool.align(AlignType.右对齐, selected);
                  }
                });
                menus.push({
                  name: "水平居中" + (selected ? "于目标" : ""),
                  action: () => {
                    this.render.alignTool.align(AlignType.水平居中, selected);
                  }
                });
                menus.push({
                  name: "上对齐" + (selected ? "于目标" : ""),
                  action: () => {
                    this.render.alignTool.align(AlignType.上对齐, selected);
                  }
                });
                menus.push({
                  name: "下对齐" + (selected ? "于目标" : ""),
                  action: () => {
                    this.render.alignTool.align(AlignType.下对齐, selected);
                  }
                });
              }
            }
          }
        }
      }
      const stageState = this.render.getStageState();
      const group = new Konva.Group({
        name: "contextmenu",
        width: stageState.width,
        height: stageState.height
      });
      let top = 0;
      const lineHeight2 = 30;
      const pos = this.render.stage.getPointerPosition();
      if (pos) {
        for (const menu of menus) {
          const rect = new Konva.Rect({
            x: this.render.toStageValue(pos.x - stageState.x),
            y: this.render.toStageValue(pos.y + top - stageState.y),
            width: this.render.toStageValue(150),
            height: this.render.toStageValue(lineHeight2),
            fill: "#fff",
            stroke: "#999",
            strokeWidth: this.render.toStageValue(1),
            name: "contextmenu"
          });
          const text = new Konva.Text({
            x: this.render.toStageValue(pos.x - stageState.x),
            y: this.render.toStageValue(pos.y + top - stageState.y),
            text: menu.name,
            name: "contextmenu",
            listening: false,
            fontSize: this.render.toStageValue(16),
            fill: "#333",
            width: this.render.toStageValue(150),
            height: this.render.toStageValue(lineHeight2),
            align: "center",
            verticalAlign: "middle"
          });
          group.add(rect);
          group.add(text);
          rect.on("pointerclick", (e) => {
            if (e.evt.button === MouseButton.左键) {
              menu.action(e);
              this.group.getChildren().forEach((o) => {
                o.destroy();
              });
              this.group.removeChildren();
              this.state.target = null;
            }
            e.evt.preventDefault();
            e.evt.stopPropagation();
          });
          rect.on("mousedown", (e) => {
            if (e.evt.button === MouseButton.左键) {
              this.state.menuIsMousedown = true;
              rect.fill("#dfdfdf");
            }
            e.evt.preventDefault();
            e.evt.stopPropagation();
          });
          rect.on("mouseup", (e) => {
            if (e.evt.button === MouseButton.左键) {
              this.state.menuIsMousedown = false;
            }
          });
          rect.on("mouseenter", (e) => {
            if (this.state.menuIsMousedown) {
              rect.fill("#dfdfdf");
            } else {
              rect.fill("#efefef");
            }
            e.evt.preventDefault();
            e.evt.stopPropagation();
          });
          rect.on("mouseout", () => {
            rect.fill("#fff");
          });
          rect.on("contextmenu", (e) => {
            e.evt.preventDefault();
            e.evt.stopPropagation();
          });
          top += lineHeight2 - 1;
        }
      }
      this.group.add(group);
    }
  }
}
__publicField(ContextmenuDraw, "name", "contextmenu");
class PreviewDraw extends BaseDraw {
  constructor(render22, layer, option) {
    super(render22, layer);
    __publicField(this, "option");
    __publicField(this, "state", {
      moving: false
      // 正在预览框内部拖动
    });
    this.option = option;
  }
  draw() {
    this.clear();
    const stageState = this.render.getStageState();
    const previewMargin = 20;
    const group = new Konva.Group({
      name: "preview",
      scale: {
        x: this.render.toStageValue(this.option.size),
        y: this.render.toStageValue(this.option.size)
      },
      width: stageState.width,
      height: stageState.height
    });
    const main = this.render.stage.find("#main")[0];
    const cover = this.render.stage.find("#cover")[0];
    const nodes = [
      ...main.getChildren((node) => {
        return !this.render.ignore(node);
      }),
      // 补充连线
      ...cover.getChildren((node) => {
        return node.name() === LinkDraw.name;
      })
    ];
    let minX = 0;
    let maxX = group.width();
    let minY = 0;
    let maxY = group.height();
    for (const node of nodes) {
      const { x, y, width, height } = ((rect) => ({
        x: this.render.toStageValue(rect.x - stageState.x),
        y: this.render.toStageValue(rect.y - stageState.y),
        width: this.render.toStageValue(rect.width),
        height: this.render.toStageValue(rect.height)
      }))(node.getClientRect());
      if (x < minX) {
        minX = x;
      }
      if (x + width > maxX) {
        maxX = x + width;
      }
      if (y < minY) {
        minY = y;
      }
      if (y + height > maxY) {
        maxY = y + height;
      }
    }
    group.setAttrs({
      x: this.render.toStageValue(
        -stageState.x + this.render.rulerSize + stageState.width - maxX * this.option.size - previewMargin
      ),
      y: this.render.toStageValue(
        -stageState.y + this.render.rulerSize + stageState.height - maxY * this.option.size - previewMargin
      ),
      width: maxX - minX,
      height: maxY - minY
    });
    const bg = new Konva.Rect({
      name: this.constructor.name,
      x: minX,
      y: minY,
      width: group.width(),
      height: group.height(),
      stroke: "#666",
      strokeWidth: this.render.toStageValue(1),
      fill: !this.render.getPageSettings().background || this.render.getPageSettings().background === "transparent" ? "#fff" : this.render.getPageSettings().background
    });
    const move2 = () => {
      this.state.moving = true;
      const pos = this.render.stage.getPointerPosition();
      if (pos) {
        const pWidth = group.width() * this.option.size;
        const pHeight = group.height() * this.option.size;
        const pOffsetX = pWidth - (stageState.width - pos.x - previewMargin);
        const pOffsetY = pHeight - (stageState.height - pos.y - previewMargin);
        const offsetX = pOffsetX / this.option.size;
        const offsetY = pOffsetY / this.option.size;
        this.render.positionTool.updateCenter(
          offsetX - this.render.rulerSize / this.option.size,
          offsetY - this.render.rulerSize / this.option.size
        );
      }
    };
    bg.on("mousedown", (e) => {
      if (e.evt.button === MouseButton.左键) {
        move2();
      }
      e.evt.preventDefault();
    });
    bg.on("mousemove", (e) => {
      if (this.state.moving) {
        move2();
      }
      e.evt.preventDefault();
    });
    bg.on("mouseup", () => {
      this.state.moving = false;
    });
    group.add(bg);
    group.add(
      new Konva.Rect({
        name: this.constructor.name,
        x: 0,
        y: 0,
        width: stageState.width,
        height: stageState.height,
        stroke: "rgba(255,0,0,0.2)",
        strokeWidth: 1 / this.option.size,
        listening: false
      })
    );
    for (const node of nodes) {
      const copy = node.clone();
      copy.find(".link-line").forEach((link) => {
        const dash = link.dash();
        if (dash && dash.length === 2 && dash.every((o) => o === 1)) {
          link.dash([]);
        }
      });
      copy.listening(false);
      copy.name(this.constructor.name);
      group.add(copy);
    }
    if (stageState.scale > 1) {
      let x1 = this.render.toStageValue(-stageState.x + this.render.rulerSize);
      let y1 = this.render.toStageValue(-stageState.y + this.render.rulerSize);
      x1 = x1 > minX ? x1 : minX;
      x1 = x1 < maxX ? x1 : maxX;
      y1 = y1 > minY ? y1 : minY;
      y1 = y1 < maxY ? y1 : maxY;
      let x2 = this.render.toStageValue(-stageState.x + this.render.rulerSize) + this.render.toStageValue(stageState.width);
      let y2 = this.render.toStageValue(-stageState.y + this.render.rulerSize) + this.render.toStageValue(stageState.height);
      x2 = x2 > minX ? x2 : minX;
      x2 = x2 < maxX ? x2 : maxX;
      y2 = y2 > minY ? y2 : minY;
      y2 = y2 < maxY ? y2 : maxY;
      let points = [];
      if (x1 > minX && x1 < maxX && x2 > minX && x2 < maxX && y1 > minY && y1 < maxY && y2 > minY && y2 < maxY) {
        points = [
          [x1, y1],
          [x2, y1],
          [x2, y2],
          [x1, y2],
          [x1, y1]
        ];
      }
      if (x1 > minX && x1 < maxX && x2 > minX && x2 < maxX && y1 === minY && y1 < maxY && y2 > minY && y2 < maxY) {
        points = [
          [x2, y1],
          [x2, y2],
          [x1, y2],
          [x1, y1]
        ];
      }
      if (x1 > minX && x1 < maxX && x2 > minX && x2 < maxX && y1 > minY && y1 < maxY && y2 > minY && y2 === maxY) {
        points = [
          [x1, y2],
          [x1, y1],
          [x2, y1],
          [x2, y2]
        ];
      }
      if (x1 === minX && x1 < maxX && x2 > minX && x2 < maxX && y1 > minY && y1 < maxY && y2 > minY && y2 < maxY) {
        points = [
          [x1, y1],
          [x2, y1],
          [x2, y2],
          [x1, y2]
        ];
      }
      if (x1 > minX && x1 < maxX && x2 > minX && x2 === maxX && y1 > minY && y1 < maxY && y2 > minY && y2 < maxY) {
        points = [
          [x2, y1],
          [x1, y1],
          [x1, y2],
          [x2, y2]
        ];
      }
      if (x1 === minX && x1 < maxX && x2 > minX && x2 < maxX && y1 === minY && y1 < maxY && y2 > minY && y2 < maxY) {
        points = [
          [x2, y1],
          [x2, y2],
          [x1, y2]
        ];
      }
      if (x1 > minX && x1 < maxX && x2 > minX && x2 === maxX && y1 === minY && y1 < maxY && y2 > minY && y2 < maxY) {
        points = [
          [x2, y2],
          [x1, y2],
          [x1, y1]
        ];
      }
      if (x1 === minX && x1 < maxX && x2 > minX && x2 < maxX && y1 > minY && y1 < maxY && y2 > minY && y2 === maxY) {
        points = [
          [x1, y1],
          [x2, y1],
          [x2, y2]
        ];
      }
      if (x1 > minX && x1 < maxX && x2 > minX && x2 === maxX && y1 > minY && y1 < maxY && y2 > minY && y2 === maxY) {
        points = [
          [x2, y1],
          [x1, y1],
          [x1, y2]
        ];
      }
      group.add(
        new Konva.Line({
          name: this.constructor.name,
          points: lodash.flatten(points),
          stroke: "blue",
          strokeWidth: 1 / this.option.size,
          listening: false
        })
      );
    }
    this.group.add(group);
  }
}
__publicField(PreviewDraw, "name", "preview");
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let nanoid = (size2 = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size2));
  while (size2--) {
    id += urlAlphabet[bytes[size2] & 63];
  }
  return id;
};
function aStar(config) {
  var _a, _b;
  const { from, to, matrix, maxCost = 1 } = config;
  const grid = matrixToGrid(matrix);
  const start = grid[from.y][from.x];
  const goal = grid[to.y][to.x];
  const open = [start];
  const closed = /* @__PURE__ */ new Set();
  const f = /* @__PURE__ */ new Map();
  const g = /* @__PURE__ */ new Map();
  const h2 = /* @__PURE__ */ new Map();
  g.set(start, 0);
  h2.set(start, manhattanDistance(start, goal));
  f.set(start, g.get(start) + h2.get(start));
  while (open.length > 0) {
    const current = open.reduce((a, b) => f.get(a) < f.get(b) ? a : b);
    if (current === goal) {
      return reconstructPath(goal);
    }
    open.splice(open.indexOf(current), 1);
    closed.add(current);
    for (const neighbor of getNeighbors(current, grid)) {
      if (closed.has(neighbor)) {
        continue;
      }
      const tentativeG = g.get(current) + // 累计距离
      (neighbor.cost ?? 1) + // 下一步距离
      (current.x === ((_a = current.parent) == null ? void 0 : _a.x) && current.x !== neighbor.x || current.y === ((_b = current.parent) == null ? void 0 : _b.y) && current.y !== neighbor.y ? grid.length + grid[0].length : 0);
      if (!open.includes(neighbor) || tentativeG < g.get(neighbor)) {
        g.set(neighbor, tentativeG);
        h2.set(neighbor, manhattanDistance(neighbor, goal));
        f.set(neighbor, g.get(neighbor) + h2.get(neighbor));
        neighbor.parent = current;
        if (!open.includes(neighbor)) {
          open.push(neighbor);
        }
      }
    }
  }
  return [];
  function matrixToGrid(matrix2) {
    const mt = [];
    for (let y = 0; y < matrix2.length; y++) {
      if (mt[y] === void 0) {
        mt[y] = [];
      }
      for (let x = 0; x < matrix2[y].length; x++) {
        mt[y].push({
          x,
          y,
          cost: matrix2[y][x]
        });
      }
    }
    return mt;
  }
  function reconstructPath(node) {
    const path = [node];
    while (node.parent) {
      path.push(node.parent);
      node = node.parent;
    }
    return path.reverse();
  }
  function manhattanDistance(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
  }
  function getNeighbors(node, grid2) {
    const neighbors = [];
    const { x, y } = node;
    if (x > 0 && (grid2[y][x - 1].cost ?? 0) < maxCost) {
      neighbors.push(grid2[y][x - 1]);
    }
    if (x < grid2[0].length - 1 && (grid2[y][x + 1].cost ?? 0) < maxCost) {
      neighbors.push(grid2[y][x + 1]);
    }
    if (y > 0 && (grid2[y - 1][x].cost ?? 0) < maxCost) {
      neighbors.push(grid2[y - 1][x]);
    }
    if (y < grid2.length - 1 && (grid2[y + 1][x].cost ?? 0) < maxCost) {
      neighbors.push(grid2[y + 1][x]);
    }
    return neighbors;
  }
}
const _LinkDraw = class _LinkDraw extends BaseDraw {
  constructor(render22, layer, option) {
    super(render22, layer);
    __publicField(this, "option");
    __publicField(this, "state", {
      linkingLine: null,
      linkType: LinkType.manual,
      linkManualing: false
    });
    this.option = option;
    this.group.name(this.constructor.name);
  }
  // 元素（连接点们）最小区域（绝对值）
  getGroupLinkArea(group) {
    let area = {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0
    };
    if (group) {
      const stageState = this.render.getStageState();
      const anchors = group.find(".link-anchor");
      const positions = anchors.map((o) => o.absolutePosition());
      area = {
        x1: Math.min(...positions.map((o) => o.x)) - stageState.x,
        y1: Math.min(...positions.map((o) => o.y)) - stageState.y,
        x2: Math.max(...positions.map((o) => o.x)) - stageState.x,
        y2: Math.max(...positions.map((o) => o.y)) - stageState.y
      };
      if (this.render.debug) {
        const shape = new Konva.Rect({
          x: this.render.toStageValue(area.x1),
          y: this.render.toStageValue(area.y1),
          width: this.render.toStageValue(area.x2 - area.x1),
          height: this.render.toStageValue(area.y2 - area.y1),
          stroke: "rgba(255,0,0,0.5)",
          strokeWidth: 1,
          listening: false
        });
        this.group.add(shape);
        shape.zIndex(0);
      }
    }
    return area;
  }
  // 连线不可通过区域
  getGroupForbiddenArea(groupArea, gap) {
    const area = {
      x1: groupArea.x1 - gap,
      y1: groupArea.y1 - gap,
      x2: groupArea.x2 + gap,
      y2: groupArea.y2 + gap
    };
    if (this.render.debug) {
      const shape = new Konva.Rect({
        x: this.render.toStageValue(area.x1),
        y: this.render.toStageValue(area.y1),
        width: this.render.toStageValue(area.x2 - area.x1),
        height: this.render.toStageValue(area.y2 - area.y1),
        stroke: "rgba(0,0,255,0.5)",
        strokeWidth: 1,
        listening: false
      });
      this.group.add(shape);
      shape.zIndex(0);
    }
    return area;
  }
  // 连线通过区域
  getGroupAccessArea(groupArea, gap) {
    const area = {
      x1: groupArea.x1 - gap,
      y1: groupArea.y1 - gap,
      x2: groupArea.x2 + gap,
      y2: groupArea.y2 + gap
    };
    if (this.render.debug) {
      const shape = new Konva.Rect({
        x: this.render.toStageValue(area.x1),
        y: this.render.toStageValue(area.y1),
        width: this.render.toStageValue(area.x2 - area.x1),
        height: this.render.toStageValue(area.y2 - area.y1),
        stroke: "rgba(255,0,255,0.5)",
        strokeWidth: 1,
        listening: false
      });
      this.group.add(shape);
      shape.zIndex(0);
    }
    return area;
  }
  // 两区域扩展
  getGroupPairArea(groupArea1, groupArea2) {
    const area = {
      x1: Math.min(groupArea1.x1, groupArea2.x1),
      y1: Math.min(groupArea1.y1, groupArea2.y1),
      x2: Math.max(groupArea1.x2, groupArea2.x2),
      y2: Math.max(groupArea1.y2, groupArea2.y2)
    };
    if (this.render.debug) {
      const shape = new Konva.Rect({
        x: this.render.toStageValue(area.x1),
        y: this.render.toStageValue(area.y1),
        width: this.render.toStageValue(area.x2 - area.x1),
        height: this.render.toStageValue(area.y2 - area.y1),
        stroke: "rgba(0,120,0,0.5)",
        strokeWidth: 1,
        listening: false
      });
      this.group.add(shape);
      shape.zIndex(1);
    }
    return area;
  }
  // 两区域最短距离
  getGroupPairDistance(groupArea1, groupArea2) {
    const xs = [groupArea1.x1, groupArea1.x2, groupArea2.x1, groupArea2.x2];
    const maxX = Math.max(...xs);
    const minX = Math.min(...xs);
    const dx = maxX - minX - (groupArea1.x2 - groupArea1.x1 + (groupArea2.x2 - groupArea2.x1));
    const ys = [groupArea1.y1, groupArea1.y2, groupArea2.y1, groupArea2.y2];
    const maxY = Math.max(...ys);
    const minY = Math.min(...ys);
    const dy = maxY - minY - (groupArea1.y2 - groupArea1.y1 + (groupArea2.y2 - groupArea2.y1));
    return this.render.toBoardValue(
      Math.min(this.render.bgSize * 0.5, Math.max(dx < 6 ? 6 : dx, dy < 6 ? 6 : dy) * 0.5)
    );
  }
  // 两区域空隙中点
  getGroupPairCenter(groupArea1, groupArea2) {
    return { x: (groupArea2.x1 + groupArea1.x2) * 0.5, y: (groupArea2.y1 + groupArea1.y2) * 0.5 };
  }
  // 连接出入口
  getEntry(anchor, groupForbiddenArea, gap) {
    const stageState = this.render.getStageState();
    const fromPos = anchor.absolutePosition();
    let x = fromPos.x - stageState.x, y = fromPos.y - stageState.y;
    const direction = anchor.attrs.direction;
    if (direction) {
      const rotate = Math.round(anchor.getAbsoluteRotation() * 10) / 10;
      if (rotate === -45) {
        if (direction === "top") {
          x = groupForbiddenArea.x1;
          y = groupForbiddenArea.y1;
        } else if (direction === "bottom") {
          x = groupForbiddenArea.x2;
          y = groupForbiddenArea.y2;
        } else if (direction === "left") {
          x = groupForbiddenArea.x1;
          y = groupForbiddenArea.y2;
        } else if (direction === "right") {
          x = groupForbiddenArea.x2;
          y = groupForbiddenArea.y1;
        }
      } else if (rotate === 45) {
        if (direction === "top") {
          x = groupForbiddenArea.x2;
          y = groupForbiddenArea.y1;
        } else if (direction === "bottom") {
          x = groupForbiddenArea.x1;
          y = groupForbiddenArea.y2;
        } else if (direction === "left") {
          x = groupForbiddenArea.x1;
          y = groupForbiddenArea.y1;
        } else if (direction === "right") {
          x = groupForbiddenArea.x2;
          y = groupForbiddenArea.y2;
        }
      } else if (rotate === 135) {
        if (direction === "top") {
          x = groupForbiddenArea.x2;
          y = groupForbiddenArea.y2;
        } else if (direction === "bottom") {
          x = groupForbiddenArea.x1;
          y = groupForbiddenArea.y1;
        } else if (direction === "left") {
          x = groupForbiddenArea.x2;
          y = groupForbiddenArea.y1;
        } else if (direction === "right") {
          x = groupForbiddenArea.x1;
          y = groupForbiddenArea.y2;
        }
      } else if (rotate === -135) {
        if (direction === "top") {
          x = groupForbiddenArea.x1;
          y = groupForbiddenArea.y2;
        } else if (direction === "bottom") {
          x = groupForbiddenArea.x2;
          y = groupForbiddenArea.y1;
        } else if (direction === "left") {
          x = groupForbiddenArea.x2;
          y = groupForbiddenArea.y2;
        } else if (direction === "right") {
          x = groupForbiddenArea.x1;
          y = groupForbiddenArea.y1;
        }
      } else if (rotate > -45 && rotate < 45) {
        const offset = gap * Math.tan(rotate * Math.PI / 180);
        if (direction === "top") {
          x = fromPos.x - stageState.x + offset;
          y = groupForbiddenArea.y1;
        } else if (direction === "bottom") {
          x = fromPos.x - stageState.x - offset;
          y = groupForbiddenArea.y2;
        } else if (direction === "left") {
          x = groupForbiddenArea.x1;
          y = fromPos.y - stageState.y - offset;
        } else if (direction === "right") {
          x = groupForbiddenArea.x2;
          y = fromPos.y - stageState.y + offset;
        }
      } else if (rotate > 45 && rotate < 135) {
        const offset = gap * Math.atan((90 - rotate) * Math.PI / 180);
        if (direction === "top") {
          x = groupForbiddenArea.x2;
          y = fromPos.y - stageState.y - offset;
        } else if (direction === "bottom") {
          x = groupForbiddenArea.x1;
          y = fromPos.y - stageState.y + offset;
        } else if (direction === "left") {
          x = fromPos.x - stageState.x - offset;
          y = groupForbiddenArea.y1;
        } else if (direction === "right") {
          x = fromPos.x - stageState.x + offset;
          y = groupForbiddenArea.y2;
        }
      } else if (rotate > 135 && rotate <= 180 || rotate >= -180 && rotate < -135) {
        const offset = gap * Math.tan(rotate * Math.PI / 180);
        if (direction === "top") {
          x = fromPos.x - stageState.x - offset;
          y = groupForbiddenArea.y2;
        } else if (direction === "bottom") {
          x = fromPos.x - stageState.x + offset;
          y = groupForbiddenArea.y1;
        } else if (direction === "left") {
          x = groupForbiddenArea.x2;
          y = fromPos.y - stageState.y + offset;
        } else if (direction === "right") {
          x = groupForbiddenArea.x1;
          y = fromPos.y - stageState.y - offset;
        }
      } else if (rotate > -135 && rotate < -45) {
        const offset = gap * Math.atan((90 + rotate) * Math.PI / 180);
        if (direction === "top") {
          x = groupForbiddenArea.x1;
          y = fromPos.y - stageState.y - offset;
        } else if (direction === "bottom") {
          x = groupForbiddenArea.x2;
          y = fromPos.y - stageState.y + offset;
        } else if (direction === "left") {
          x = fromPos.x - stageState.x - offset;
          y = groupForbiddenArea.y2;
        } else if (direction === "right") {
          x = fromPos.x - stageState.x + offset;
          y = groupForbiddenArea.y1;
        }
      }
    }
    return { x, y };
  }
  // 连接点信息
  getAnchorPos(anchor) {
    const stageState = this.render.getStageState();
    return anchor ? {
      x: anchor.absolutePosition().x - stageState.x,
      y: anchor.absolutePosition().y - stageState.y
    } : { x: 0, y: 0 };
  }
  /**
   * 修改当前连接线类型
   * @param linkType Types.LinkType
   */
  changeLinkType(linkType) {
    this.state.linkType = linkType;
    this.render.emit("link-type-change", this.state.linkType);
  }
  // TODO: 优化
  // *思路：此 draw 弃用“整体 redraw”的方式，改为“局部更新”的方式:
  // 循环 pair 的时候查找 link-line、manualing-line、link-manual-point 等实例是否存在
  // 不存在 -> 新建并事件绑定
  // 存在 -> 更新
  draw() {
    var _a, _b, _c;
    this.clear();
    const stageState = this.render.getStageState();
    const groups = [
      ...this.render.layer.find(".asset"),
      ...this.render.layer.find(".sub-asset")
    ];
    const points = groups.reduce((ps, group) => {
      return ps.concat(Array.isArray(group.getAttr("points")) ? group.getAttr("points") : []);
    }, []);
    const pairs = points.reduce((ps, point) => {
      return ps.concat(point.pairs ? point.pairs.filter((o) => !o.disabled) : []);
    }, []);
    if (this.render.debug && pairs.length > 0) {
      console.log("");
      console.log("link draw");
    }
    for (const pair of pairs) {
      if (pair.from.groupId !== pair.to.groupId && !pair.disabled) {
        const fromGroup = groups.find((o) => o.id() === pair.from.groupId);
        const fromPoint = points.find((o) => o.id === pair.from.pointId);
        const toGroup = groups.find((o) => o.id() === pair.to.groupId);
        const toPoint = points.find((o) => o.id === pair.to.pointId);
        if (pair.linkType === LinkType.manual) {
          if (fromGroup && toGroup && fromPoint && toPoint) {
            const fromAnchor = fromGroup.findOne(`#${fromPoint.id}`);
            const toAnchor = toGroup.findOne(`#${toPoint.id}`);
            const fromAnchorPos = this.getAnchorPos(fromAnchor);
            const toAnchorPos = this.getAnchorPos(toAnchor);
            const manualPointsMap = fromGroup.getAttr("manualPointsMap") ?? {};
            const manualPoints = manualPointsMap[pair.id] ?? [];
            const linkPoints = [
              [
                this.render.toStageValue(fromAnchorPos.x),
                this.render.toStageValue(fromAnchorPos.y)
              ],
              ...manualPoints.map((o) => [o.x, o.y]),
              [this.render.toStageValue(toAnchorPos.x), this.render.toStageValue(toAnchorPos.y)]
            ];
            const linkLine = new Konva.Arrow({
              name: "link-line",
              // 用于删除连接线
              groupId: fromGroup.id(),
              pointId: fromPoint.id,
              pairId: pair.id,
              linkType: pair.linkType,
              points: lodash.flatten(linkPoints),
              pointerAtBeginning: false,
              pointerAtEnding: false
            });
            linkLine.stroke(this.render.getLinkSettings(linkLine).stroke);
            linkLine.strokeWidth(this.render.getLinkSettings(linkLine).strokeWidth);
            linkLine.hitStrokeWidth(Math.max(this.render.getLinkSettings().strokeWidth, 10));
            linkLine.dash(((_a = this.render.linkTool.linkCurrent) == null ? void 0 : _a.attrs.pairId) === pair.id ? [1, 1] : []);
            linkLine.fill(this.render.getLinkSettings(linkLine).stroke);
            linkLine.pointerAtBeginning(this.render.getLinkSettings(linkLine).arrowStart);
            linkLine.pointerAtEnding(this.render.getLinkSettings(linkLine).arrowEnd);
            if (!this.render.config.readonly) {
              linkLine.on("pointerclick", () => {
                this.render.linkTool.select(linkLine);
              });
              linkLine.on("mouseenter", () => {
                linkLine.opacity(0.5);
                document.body.style.cursor = "pointer";
              });
              linkLine.on("mouseleave", () => {
                linkLine.opacity(1);
                document.body.style.cursor = "default";
              });
            }
            this.group.add(linkLine);
            if (!this.render.config.readonly) {
              const manualingLine = new Konva.Line({
                name: "manualing-line",
                //
                stroke: "#ff0000",
                strokeWidth: 2,
                points: [],
                dash: [4, 4]
              });
              this.group.add(manualingLine);
              for (let i = 0; i < linkPoints.length - 1; i++) {
                const circle = new Konva.Circle({
                  name: "link-manual-point",
                  //
                  id: nanoid(),
                  pairId: pair.id,
                  x: (linkPoints[i][0] + linkPoints[i + 1][0]) / 2,
                  y: (linkPoints[i][1] + linkPoints[i + 1][1]) / 2,
                  radius: this.render.toStageValue(this.render.bgSize / 2),
                  stroke: "rgba(0,0,255,0.1)",
                  strokeWidth: this.render.toStageValue(1),
                  // opacity: 0,
                  linkManualIndex: i
                  // 当前拐点位置
                });
                circle.on("mouseenter", () => {
                  circle.stroke("rgba(0,0,255,0.8)");
                  document.body.style.cursor = "pointer";
                });
                circle.on("mouseleave", () => {
                  if (!circle.attrs.dragStart) {
                    circle.stroke("rgba(0,0,255,0.1)");
                    document.body.style.cursor = "default";
                  }
                });
                circle.on("mousedown", () => {
                  const pos = circle.getAbsolutePosition();
                  circle.setAttrs({
                    // 开始坐标
                    dragStartX: pos.x,
                    dragStartY: pos.y,
                    // 正在操作
                    dragStart: true
                  });
                  this.state.linkManualing = true;
                });
                this.render.stage.on("mousemove", () => {
                  if (circle.attrs.dragStart) {
                    const pos = this.render.stage.getPointerPosition();
                    if (pos) {
                      const { pos: transformerPos } = this.render.attractTool.attractPoint(pos);
                      circle.setAbsolutePosition(transformerPos);
                      const tempPoints = [...linkPoints];
                      tempPoints.splice(circle.attrs.linkManualIndex + 1, 0, [
                        this.render.toStageValue(transformerPos.x - stageState.x),
                        this.render.toStageValue(transformerPos.y - stageState.y)
                      ]);
                      manualingLine.points(lodash.flatten(tempPoints));
                    }
                  }
                });
                circle.on("mouseup", () => {
                  const pos = circle.getAbsolutePosition();
                  if (Math.abs(pos.x - circle.attrs.dragStartX) > this.option.size || Math.abs(pos.y - circle.attrs.dragStartY) > this.option.size) {
                    const stageState2 = this.render.getStageState();
                    manualPoints.splice(circle.attrs.linkManualIndex, 0, {
                      x: this.render.toStageValue(pos.x - stageState2.x),
                      y: this.render.toStageValue(pos.y - stageState2.y)
                    });
                    manualPointsMap[pair.id] = manualPoints;
                    fromGroup.setAttr("manualPointsMap", manualPointsMap);
                  }
                  circle.setAttrs({
                    dragStart: false
                  });
                  this.state.linkManualing = false;
                  circle.destroy();
                  manualingLine.destroy();
                  this.render.updateHistory();
                  this.render.attractTool.alignLinesClear();
                  this.render.redraw([
                    _LinkDraw.name,
                    AttractDraw.name,
                    RulerDraw.name,
                    PreviewDraw.name
                  ]);
                });
                this.group.add(circle);
              }
              for (let i = 1; i < linkPoints.length - 1; i++) {
                const circle = new Konva.Circle({
                  name: "link-manual-point",
                  //
                  id: nanoid(),
                  pairId: pair.id,
                  x: linkPoints[i][0],
                  y: linkPoints[i][1],
                  radius: this.render.toStageValue(this.render.bgSize / 2),
                  stroke: "rgba(0,100,0,0.1)",
                  strokeWidth: this.render.toStageValue(1),
                  // opacity: 0,
                  linkManualIndex: i
                  // 当前拐点位置
                });
                circle.on("mouseenter", () => {
                  circle.stroke("rgba(0,100,0,1)");
                  document.body.style.cursor = "pointer";
                });
                circle.on("mouseleave", () => {
                  if (!circle.attrs.dragStart) {
                    circle.stroke("rgba(0,100,0,0.1)");
                    document.body.style.cursor = "default";
                  }
                });
                circle.on("mousedown", () => {
                  const pos = circle.getAbsolutePosition();
                  circle.setAttrs({
                    dragStartX: pos.x,
                    dragStartY: pos.y,
                    dragStart: true
                  });
                  this.state.linkManualing = true;
                });
                this.render.stage.on("mousemove", () => {
                  if (circle.attrs.dragStart) {
                    const pos = this.render.stage.getPointerPosition();
                    if (pos) {
                      const { pos: transformerPos } = this.render.attractTool.attractPoint(pos);
                      circle.setAbsolutePosition(transformerPos);
                      const tempPoints = [...linkPoints];
                      tempPoints[circle.attrs.linkManualIndex] = [
                        this.render.toStageValue(transformerPos.x - stageState.x),
                        this.render.toStageValue(transformerPos.y - stageState.y)
                      ];
                      manualingLine.points(lodash.flatten(tempPoints));
                    }
                  }
                });
                circle.on("mouseup", () => {
                  const pos = circle.getAbsolutePosition();
                  if (Math.abs(pos.x - circle.attrs.dragStartX) > this.option.size || Math.abs(pos.y - circle.attrs.dragStartY) > this.option.size) {
                    const stageState2 = this.render.getStageState();
                    manualPoints[circle.attrs.linkManualIndex - 1] = {
                      x: this.render.toStageValue(pos.x - stageState2.x),
                      y: this.render.toStageValue(pos.y - stageState2.y)
                    };
                    manualPointsMap[pair.id] = manualPoints;
                    fromGroup.setAttr("manualPointsMap", manualPointsMap);
                  }
                  circle.setAttrs({
                    dragStart: false
                  });
                  this.state.linkManualing = false;
                  circle.destroy();
                  manualingLine.destroy();
                  this.render.updateHistory();
                  this.render.attractTool.alignLinesClear();
                  this.render.redraw([
                    _LinkDraw.name,
                    AttractDraw.name,
                    RulerDraw.name,
                    PreviewDraw.name
                  ]);
                });
                this.group.add(circle);
              }
            }
          }
        } else if (pair.linkType === LinkType.straight) {
          if (fromGroup && toGroup && fromPoint && toPoint) {
            const fromAnchor = fromGroup.findOne(`#${fromPoint.id}`);
            const toAnchor = toGroup.findOne(`#${toPoint.id}`);
            const fromAnchorPos = this.getAnchorPos(fromAnchor);
            const toAnchorPos = this.getAnchorPos(toAnchor);
            const linkLine = new Konva.Arrow({
              name: "link-line",
              // 用于删除连接线
              groupId: fromGroup.id(),
              pointId: fromPoint.id,
              pairId: pair.id,
              linkType: pair.linkType,
              points: lodash.flatten([
                [
                  this.render.toStageValue(fromAnchorPos.x),
                  this.render.toStageValue(fromAnchorPos.y)
                ],
                [this.render.toStageValue(toAnchorPos.x), this.render.toStageValue(toAnchorPos.y)]
              ]),
              pointerAtBeginning: false,
              pointerAtEnding: false
            });
            linkLine.stroke(this.render.getLinkSettings(linkLine).stroke);
            linkLine.strokeWidth(this.render.getLinkSettings(linkLine).strokeWidth);
            linkLine.hitStrokeWidth(Math.max(this.render.getLinkSettings().strokeWidth, 10));
            linkLine.dash(((_b = this.render.linkTool.linkCurrent) == null ? void 0 : _b.attrs.pairId) === pair.id ? [1, 1] : []);
            linkLine.fill(this.render.getLinkSettings(linkLine).stroke);
            linkLine.pointerAtBeginning(this.render.getLinkSettings(linkLine).arrowStart);
            linkLine.pointerAtEnding(this.render.getLinkSettings(linkLine).arrowEnd);
            if (!this.render.config.readonly) {
              linkLine.on("pointerclick", () => {
                this.render.linkTool.select(linkLine);
              });
              linkLine.on("mouseenter", () => {
                linkLine.opacity(0.5);
                document.body.style.cursor = "pointer";
              });
              linkLine.on("mouseleave", () => {
                linkLine.opacity(1);
                document.body.style.cursor = "default";
              });
            }
            this.group.add(linkLine);
          }
        } else {
          const fromGroupLinkArea = this.getGroupLinkArea(fromGroup);
          const toGroupLinkArea = this.getGroupLinkArea(toGroup);
          const groupDistance = this.getGroupPairDistance(fromGroupLinkArea, toGroupLinkArea);
          const fromGroupForbiddenArea = this.getGroupForbiddenArea(
            fromGroupLinkArea,
            groupDistance - 2
          );
          const toGroupForbiddenArea = this.getGroupForbiddenArea(
            toGroupLinkArea,
            groupDistance - 2
          );
          const groupForbiddenArea = this.getGroupPairArea(
            fromGroupForbiddenArea,
            toGroupForbiddenArea
          );
          const groupAccessArea = this.getGroupPairArea(
            this.getGroupAccessArea(fromGroupForbiddenArea, groupDistance),
            this.getGroupAccessArea(toGroupForbiddenArea, groupDistance)
          );
          if (fromGroup && toGroup && fromPoint && toPoint) {
            const fromAnchor = fromGroup.findOne(`#${fromPoint.id}`);
            const toAnchor = toGroup.findOne(`#${toPoint.id}`);
            const fromAnchorPos = this.getAnchorPos(fromAnchor);
            const toAnchorPos = this.getAnchorPos(toAnchor);
            if (fromAnchor && toAnchor) {
              if (this.render.debug) {
                console.log("distance", groupDistance);
              }
              const fromEntry = this.getEntry(
                fromAnchor,
                fromGroupForbiddenArea,
                groupDistance
              );
              const toEntry = this.getEntry(
                toAnchor,
                toGroupForbiddenArea,
                groupDistance
              );
              let matrixPoints = [];
              matrixPoints.push({ x: groupAccessArea.x1, y: groupAccessArea.y1 });
              matrixPoints.push({ x: groupAccessArea.x2, y: groupAccessArea.y2 });
              matrixPoints.push({ x: groupAccessArea.x1, y: groupAccessArea.y2 });
              matrixPoints.push({ x: groupAccessArea.x2, y: groupAccessArea.y1 });
              matrixPoints.push({ x: groupForbiddenArea.x1, y: groupForbiddenArea.y1 });
              matrixPoints.push({ x: groupForbiddenArea.x2, y: groupForbiddenArea.y2 });
              matrixPoints.push({ x: groupForbiddenArea.x1, y: groupForbiddenArea.y2 });
              matrixPoints.push({ x: groupForbiddenArea.x2, y: groupForbiddenArea.y1 });
              matrixPoints.push({
                ...fromAnchorPos,
                type: "from"
              });
              matrixPoints.push({ ...fromEntry, type: "from-entry" });
              matrixPoints.push({
                ...toAnchorPos,
                type: "to"
              });
              matrixPoints.push({ ...toEntry, type: "to-entry" });
              matrixPoints.push(
                this.getGroupPairCenter(fromGroupForbiddenArea, toGroupForbiddenArea)
              );
              matrixPoints = matrixPoints.reduce(
                (arr, item) => {
                  if (item.type === void 0) {
                    if (arr.findIndex((o) => o.x === item.x && o.y === item.y) < 0) {
                      arr.push(item);
                    }
                  } else {
                    const idx = arr.findIndex((o) => o.x === item.x && o.y === item.y);
                    if (idx > -1) {
                      arr.splice(idx, 1);
                    }
                    arr.push(item);
                  }
                  return arr;
                },
                []
              );
              const columns = [
                ...matrixPoints.map((o) => o.x),
                // 增加列
                fromGroupForbiddenArea.x1,
                fromGroupForbiddenArea.x2,
                toGroupForbiddenArea.x1,
                toGroupForbiddenArea.x2
              ].sort((a, b) => a - b);
              for (let x = columns.length - 1; x > 0; x--) {
                if (columns[x] === columns[x - 1]) {
                  columns.splice(x, 1);
                }
              }
              if (this.render.debug) {
                console.log("columns", columns);
              }
              const rows = [
                ...matrixPoints.map((o) => o.y),
                // 增加行
                fromGroupForbiddenArea.y1,
                fromGroupForbiddenArea.y2,
                toGroupForbiddenArea.y1,
                toGroupForbiddenArea.y2
              ].sort((a, b) => a - b);
              for (let y = rows.length - 1; y > 0; y--) {
                if (rows[y] === rows[y - 1]) {
                  rows.splice(y, 1);
                }
              }
              if (this.render.debug) {
                console.log("rows", rows);
              }
              const columnFromStart = columns.findIndex((o) => o === fromGroupForbiddenArea.x1);
              const columnFromEnd = columns.findIndex((o) => o === fromGroupForbiddenArea.x2);
              const rowFromStart = rows.findIndex((o) => o === fromGroupForbiddenArea.y1);
              const rowFromEnd = rows.findIndex((o) => o === fromGroupForbiddenArea.y2);
              const columnToStart = columns.findIndex((o) => o === toGroupForbiddenArea.x1);
              const columnToEnd = columns.findIndex((o) => o === toGroupForbiddenArea.x2);
              const rowToStart = rows.findIndex((o) => o === toGroupForbiddenArea.y1);
              const rowToEnd = rows.findIndex((o) => o === toGroupForbiddenArea.y2);
              let matrixStart = null;
              let matrixEnd = null;
              const matrix = [];
              for (let y = 0; y < rows.length; y++) {
                if (matrix[y] === void 0) {
                  matrix[y] = [];
                }
                for (let x = 0; x < columns.length; x++) {
                  if (x >= columnFromStart && x <= columnFromEnd && y >= rowFromStart && y <= rowFromEnd) {
                    matrix[y][x] = 2;
                  } else if (x >= columnToStart && x <= columnToEnd && y >= rowToStart && y <= rowToEnd) {
                    matrix[y][x] = 2;
                  } else {
                    matrix[y][x] = 0;
                  }
                  if (columns[x] === fromEntry.x && rows[y] === fromEntry.y) {
                    matrix[y][x] = 1;
                    matrixStart = { x, y };
                  }
                  if (columns[x] === toEntry.x && rows[y] === toEntry.y) {
                    matrix[y][x] = 1;
                    matrixEnd = { x, y };
                  }
                  if (!fromAnchor.attrs.direction) {
                    if (columns[x] === fromEntry.x || rows[y] === fromEntry.y) {
                      if (x >= columnFromStart && x <= columnFromEnd && y >= rowFromStart && y <= rowFromEnd) {
                        matrix[y][x] = 1;
                      }
                    }
                  }
                  if (!toAnchor.attrs.direction) {
                    if (columns[x] === toEntry.x || rows[y] === toEntry.y) {
                      if (x >= columnToStart && x <= columnToEnd && y >= rowToStart && y <= rowToEnd) {
                        matrix[y][x] = 1;
                      }
                    }
                  }
                }
              }
              if (this.render.debug) {
                console.log("matrix", matrix);
              }
              if (this.render.debug) {
                for (const point of matrixPoints) {
                  this.group.add(
                    new Konva.Circle({
                      id: nanoid(),
                      x: this.render.toStageValue(point.x),
                      y: this.render.toStageValue(point.y),
                      radius: this.render.toStageValue(3),
                      stroke: point.type === void 0 ? "rgba(0,0,255,1)" : ["from", "to"].includes(point.type) ? "rgba(255,0,0,1)" : "rgba(0,120,0,1)",
                      strokeWidth: this.render.toStageValue(1),
                      listening: false
                    })
                  );
                }
              }
              if (matrixStart && matrixEnd) {
                if (this.render.debug) {
                  console.log("算法起点", matrixStart, "算法终点", matrixEnd);
                }
                const way = aStar({
                  from: matrixStart,
                  to: matrixEnd,
                  matrix,
                  maxCost: 2
                });
                const linkLine = new Konva.Arrow({
                  name: "link-line",
                  // 用于删除连接线
                  groupId: fromGroup.id(),
                  pointId: fromPoint.id,
                  pairId: pair.id,
                  linkType: pair.linkType,
                  // 记录 连接线 类型
                  //
                  points: lodash.flatten([
                    [
                      this.render.toStageValue(fromAnchorPos.x),
                      this.render.toStageValue(fromAnchorPos.y)
                    ],
                    // 补充 起点
                    ...way.map((o) => [
                      this.render.toStageValue(columns[o.x]),
                      this.render.toStageValue(rows[o.y])
                    ]),
                    [
                      this.render.toStageValue(toAnchorPos.x),
                      this.render.toStageValue(toAnchorPos.y)
                    ]
                    // 补充 终点
                  ]),
                  pointerAtBeginning: false,
                  pointerAtEnding: false
                });
                linkLine.stroke(this.render.getLinkSettings(linkLine).stroke);
                linkLine.strokeWidth(this.render.getLinkSettings(linkLine).strokeWidth);
                linkLine.hitStrokeWidth(Math.max(this.render.getLinkSettings().strokeWidth, 10));
                linkLine.dash(
                  ((_c = this.render.linkTool.linkCurrent) == null ? void 0 : _c.attrs.pairId) === pair.id ? [1, 1] : []
                );
                linkLine.fill(this.render.getLinkSettings(linkLine).stroke);
                linkLine.pointerAtBeginning(this.render.getLinkSettings(linkLine).arrowStart);
                linkLine.pointerAtEnding(this.render.getLinkSettings(linkLine).arrowEnd);
                if (!this.render.config.readonly) {
                  linkLine.on("pointerclick", () => {
                    this.render.linkTool.select(linkLine);
                  });
                  linkLine.on("mouseenter", () => {
                    linkLine.opacity(0.5);
                    document.body.style.cursor = "pointer";
                  });
                  linkLine.on("mouseleave", () => {
                    linkLine.opacity(1);
                    document.body.style.cursor = "default";
                  });
                }
                this.group.add(linkLine);
              }
            }
          }
        }
      }
    }
    if (!this.render.config.readonly) {
      for (const point of points) {
        const group = groups.find((o) => o.id() === point.groupId);
        if (group && !group.getAttr("selected")) {
          const anchor = this.render.layer.findOne(`#${point.id}`);
          if (anchor) {
            const circle = new Konva.Circle({
              name: "link-point",
              //
              id: point.id,
              groupId: group.id(),
              x: this.render.toStageValue(anchor.absolutePosition().x - stageState.x),
              y: this.render.toStageValue(anchor.absolutePosition().y - stageState.y),
              radius: this.render.toStageValue(this.option.size),
              stroke: "rgba(255,0,0,0.2)",
              strokeWidth: this.render.toStageValue(1),
              // 调整中，不显示连接点
              opacity: point.visible && !this.render.draws[GraphDraw.name].state.adjusting ? 1 : 0
            });
            circle.on("mouseenter", () => {
              circle.stroke("rgba(255,0,0,0.5)");
              circle.opacity(1);
              document.body.style.cursor = "pointer";
            });
            circle.on("mouseleave", () => {
              circle.stroke("rgba(255,0,0,0.2)");
              circle.opacity(0);
              document.body.style.cursor = "default";
            });
            circle.on("mousedown", () => {
              this.render.selectionTool.selectingClear();
              this.render.linkTool.selectingClear();
              const pos = this.render.stage.getPointerPosition();
              if (pos) {
                this.state.linkingLine = {
                  group,
                  circle,
                  line: new Konva.Line({
                    name: "linking-line",
                    points: lodash.flatten([
                      [circle.x(), circle.y()],
                      [
                        this.render.toStageValue(pos.x - stageState.x),
                        this.render.toStageValue(pos.y - stageState.y)
                      ]
                    ]),
                    stroke: "blue",
                    strokeWidth: 1
                  })
                };
                this.layer.add(this.state.linkingLine.line);
              }
            });
            circle.on("mouseup", () => {
              var _a2;
              if (this.state.linkingLine) {
                const line = this.state.linkingLine;
                if (line.circle.id() !== circle.id()) {
                  const toGroup = groups.find((o) => o.id() === circle.getAttr("groupId"));
                  if (toGroup) {
                    const fromPoint = points.find((o) => o.id === line.circle.id());
                    if (fromPoint) {
                      const toPoint = points.find((o) => o.id === line.circle.id());
                      if (toPoint) {
                        if (Array.isArray(fromPoint.pairs)) {
                          fromPoint.pairs = [
                            ...fromPoint.pairs,
                            {
                              id: nanoid(),
                              from: {
                                groupId: line.group.id(),
                                pointId: line.circle.id()
                              },
                              to: {
                                groupId: circle.getAttr("groupId"),
                                pointId: circle.id()
                              },
                              linkType: this.state.linkType
                              // 记录 连接线 类型
                            }
                          ];
                        }
                        this.render.updateHistory();
                        this.render.attractTool.alignLinesClear();
                        this.render.redraw([
                          _LinkDraw.name,
                          AttractDraw.name,
                          RulerDraw.name,
                          PreviewDraw.name
                        ]);
                      }
                    }
                  }
                }
                (_a2 = this.state.linkingLine) == null ? void 0 : _a2.line.destroy();
                this.state.linkingLine = null;
              }
            });
            this.group.add(circle);
          }
        }
      }
    }
  }
};
__publicField(_LinkDraw, "name", "Link");
let LinkDraw = _LinkDraw;
class AttractDraw extends BaseDraw {
  constructor(render22, layer, option) {
    super(render22, layer);
    __publicField(this, "option");
    __publicField(this, "on", {});
    this.option = option;
    this.group.name(this.constructor.name);
  }
  draw() {
    this.clear();
    if (this.render.debug) {
      const stageState = this.render.getStageState();
      const groups = this.render.layer.find(".asset");
      const lastGroup = groups.pop();
      if (lastGroup) {
        this.render.selectionTool.selectingNodes = [lastGroup];
        const rect = lastGroup.getClientRect();
        const { sortX, sortY } = this.render.attractTool.getSortItems(rect);
        for (const x of sortX) {
          this.group.add(
            new Konva.Line({
              name: this.constructor.name,
              points: lodash.flatten([
                [x.value, this.render.toStageValue(this.render.rulerSize - stageState.y)],
                [
                  x.value,
                  this.render.toStageValue(this.render.rulerSize - stageState.y + stageState.height)
                ]
              ]),
              stroke: "rgba(0,200,0,1)",
              strokeWidth: 1,
              dash: [4, 4],
              listening: false
            })
          );
        }
        for (const y of sortY) {
          this.group.add(
            new Konva.Line({
              name: this.constructor.name,
              points: lodash.flatten([
                [this.render.toStageValue(this.render.rulerSize - stageState.x), y.value],
                [
                  this.render.toStageValue(this.render.rulerSize - stageState.x + stageState.width),
                  y.value
                ]
              ]),
              stroke: "rgba(0,200,0,1)",
              strokeWidth: 1,
              dash: [4, 4],
              listening: false
            })
          );
        }
      }
    }
  }
}
__publicField(AttractDraw, "name", "Attract");
class BaseGraph {
  constructor(render22, dropPoint, config) {
    //
    __publicField(this, "render");
    __publicField(this, "group");
    // 占用区域，用于识别 hover 态
    __publicField(this, "hoverRect");
    __publicField(this, "id");
    // 就是 group 的id
    /**
     * 鼠标按下位置
     */
    __publicField(this, "dropPoint", { x: 0, y: 0 });
    /**
     * 调整点 定义
     */
    __publicField(this, "anchors", []);
    /**
     * 调整点 的 锚点
     */
    __publicField(this, "anchorShadows", []);
    /**
     * 调整点 定义
     */
    __publicField(this, "linkAnchors", []);
    /**
     * 连接点 的 锚点
     */
    __publicField(this, "linkAnchorShadows", []);
    this.render = render22;
    this.dropPoint = dropPoint;
    this.id = nanoid();
    this.group = new Konva.Group({
      id: this.id,
      name: "asset",
      assetType: AssetType.Graph,
      graphType: config.type,
      draggable: true
    });
    this.hoverRect = new Konva.Rect({
      name: "hoverRect",
      x: 0,
      y: 0,
      // fill: 'rgba(255,0,0,0.2)',
      hitStrokeWidth: this.render.toStageValue(this.render.bgSize * 2 + 2)
    });
    this.anchors = config.anchors.map((o) => ({
      ...o,
      // 补充信息
      name: "anchor",
      groupId: this.group.id(),
      type: config.type
    }));
    this.group.setAttr("anchors", this.anchors);
    for (const anchor of this.anchors) {
      const circle = new Konva.Circle({
        adjustType: anchor.adjustType,
        anchorType: anchor.type,
        name: anchor.name,
        radius: 0
        // radius: this.render.toStageValue(2),
        // fill: 'red'
      });
      this.anchorShadows.push(circle);
      this.group.add(circle);
    }
    this.linkAnchors = config.linkAnchors.map(
      (o) => ({
        ...o,
        id: nanoid(),
        groupId: this.group.id(),
        visible: false,
        pairs: [],
        direction: o.direction,
        alias: o.alias
      })
    );
    this.group.setAttrs({
      points: this.linkAnchors
    });
    for (const point of this.linkAnchors) {
      const circle = new Konva.Circle({
        name: "link-anchor",
        id: point.id,
        x: point.x,
        y: point.y,
        radius: this.render.toStageValue(1),
        stroke: "rgba(0,0,255,1)",
        strokeWidth: this.render.toStageValue(2),
        visible: false,
        direction: point.direction,
        alias: point.alias
      });
      this.linkAnchorShadows.push(circle);
      this.group.add(circle);
    }
    this.render.layer.add(this.group);
    this.render.redraw([GraphDraw.name]);
  }
  /**
   * 更新 图形 的 调整点 的 锚点位置
   * @param width 图形 的 宽度
   * @param height 图形 的 高度
   * @param rotate 图形 的 旋转角度
   * @param anchorShadows 图形 的 调整点 的 锚点
   */
  static updateAnchorShadows(graph, anchorShadows) {
    console.log("请实现 updateAnchorShadows");
  }
  /**
   * 更新 图形 的 连接点 的 锚点位置
   * @param width 图形 的 宽度
   * @param height 图形 的 高度
   * @param rotate 图形 的 旋转角度
   * @param anchors 图形 的 调整点 的 锚点
   */
  static updateLinkAnchorShadows(graph, linkAnchorShadows) {
    console.log("请实现 updateLinkAnchorShadows");
  }
  /**
   * 生成 调整点
   * @param render 渲染实例
   * @param graph 图形
   * @param anchorAndShadows 调整点 及其 锚点
   * @param adjustAnchor 正在操作的 调整点
   * @returns
   */
  static createAnchorShapes(render22, graph, anchorAndShadows, adjustAnchor) {
    console.log("请实现 createAnchorShapes");
    return;
  }
  /**
   * 调整 图形
   * @param render 渲染实例
   * @param graph 图形
   * @param graphSnap 图形 的 备份
   * @param rect 当前 调整点
   * @param rects 所有 调整点
   * @param startPoint 鼠标按下位置
   * @param endPoint 鼠标拖动位置
   */
  static adjust(render22, graph, graphSnap, adjustShape, anchorAndShadows, startPoint, endPoint, hoverRect, hoverSize, hoverPos) {
    hoverRect == null ? void 0 : hoverRect.position({
      x: (hoverPos == null ? void 0 : hoverPos.x) ?? 0,
      y: (hoverPos == null ? void 0 : hoverPos.y) ?? 0
    });
    hoverRect == null ? void 0 : hoverRect.size({
      width: (hoverSize == null ? void 0 : hoverSize.width) ?? graph.width(),
      height: (hoverSize == null ? void 0 : hoverSize.height) ?? graph.height()
    });
  }
  static draw(graph, render22, adjustAnchor) {
    const anchors = graph.attrs.anchors ?? [];
    const anchorShapes = graph.find(`.anchor`);
    const anchorAndShadows = anchors.map((anchor) => ({
      anchor,
      anchorShadow: anchorShapes.find(
        (shape) => shape.attrs.adjustType === anchor.adjustType
      )
    })).filter((o) => o.anchorShadow !== void 0);
    return { anchorAndShadows };
  }
  /**
   * 调整结束
   */
  drawEnd(size2, pos) {
    var _a;
    (_a = this.hoverRect) == null ? void 0 : _a.position({
      x: (pos == null ? void 0 : pos.x) ?? 0,
      y: (pos == null ? void 0 : pos.y) ?? 0
    });
    this.hoverRect.size({
      width: (size2 == null ? void 0 : size2.width) ?? this.group.width(),
      height: (size2 == null ? void 0 : size2.height) ?? this.group.height()
    });
    this.hoverRect.on("mouseenter", () => {
      if (!this.group.attrs.hoverAnchor) {
        this.group.setAttr("hover", true);
        this.render.redraw([GraphDraw.name]);
      }
      setTimeout(() => {
        this.group.setAttr("hoverAnchor", false);
      });
      this.render.linkTool.pointsVisible(true, this.group);
    });
    this.hoverRect.on("mouseleave", () => {
      var _a2;
      setTimeout(() => {
        if (!this.group.attrs.hoverAnchor) {
          this.group.setAttr("hover", false);
          this.group.setAttr("hoverAnchor", false);
          this.render.redraw([GraphDraw.name]);
        }
      });
      this.render.linkTool.pointsVisible(false, this.group);
      (_a2 = this.group.findOne("#hoverRect")) == null ? void 0 : _a2.visible(false);
    });
    this.group.add(this.hoverRect);
  }
}
const _Circle = class _Circle extends BaseGraph {
  constructor(render22, dropPoint) {
    super(render22, dropPoint, {
      type: GraphType.Circle,
      // 记录所属 图形
      // 定义了 8 个 调整点
      anchors: [
        { adjustType: "top" },
        { adjustType: "bottom" },
        { adjustType: "left" },
        { adjustType: "right" },
        { adjustType: "top-left" },
        { adjustType: "top-right" },
        { adjustType: "bottom-left" },
        { adjustType: "bottom-right" }
      ].map((o) => ({
        adjustType: o.adjustType
        // 调整点 类型定义
      })),
      linkAnchors: [
        { x: 0, y: 0, alias: "top", direction: "top" },
        { x: 0, y: 0, alias: "bottom", direction: "bottom" },
        { x: 0, y: 0, alias: "left", direction: "left" },
        { x: 0, y: 0, alias: "right", direction: "right" },
        { x: 0, y: 0, alias: "center" }
      ]
    });
    /**
     * 圆/椭圆 对应的 Konva 实例
     */
    __publicField(this, "circle");
    this.circle = new Konva.Ellipse({
      name: "graph",
      x: 0,
      y: 0,
      radiusX: 0,
      radiusY: 0,
      stroke: this.render.getPageSettings().stroke,
      strokeWidth: this.render.getPageSettings().strokeWidth
      // fill: this.render.getPageSettings().fill,
    });
    this.group.add(this.circle);
    this.group.position(this.dropPoint);
  }
  // 实现：更新 图形 的 调整点 的 锚点位置
  static updateAnchorShadows(graph, anchorShadows) {
    const { width, height } = graph.size();
    for (const shadow of anchorShadows) {
      switch (shadow.attrs.adjustType) {
        case "top":
          shadow.position({
            x: width / 2,
            y: 0
          });
          break;
        case "bottom":
          shadow.position({
            x: width / 2,
            y: height
          });
          break;
        case "left":
          shadow.position({
            x: 0,
            y: height / 2
          });
          break;
        case "right":
          shadow.position({
            x: width,
            y: height / 2
          });
          break;
        case "top-left":
          shadow.position({
            x: 0,
            y: 0
          });
          break;
        case "top-right":
          shadow.position({
            x: width,
            y: 0
          });
          break;
        case "bottom-left":
          shadow.position({
            x: 0,
            y: height
          });
          break;
        case "bottom-right":
          shadow.position({
            x: width,
            y: height
          });
          break;
      }
    }
  }
  // 实现：更新 图形 的 连接点 的 锚点位置
  static updateLinkAnchorShadows(graph, linkAnchorShadows) {
    const { width, height } = graph.size();
    for (const shadow of linkAnchorShadows) {
      switch (shadow.attrs.alias) {
        case "top":
          shadow.position({
            x: width / 2,
            y: 0
          });
          break;
        case "bottom":
          shadow.position({
            x: width / 2,
            y: height
          });
          break;
        case "left":
          shadow.position({
            x: 0,
            y: height / 2
          });
          break;
        case "right":
          shadow.position({
            x: width,
            y: height / 2
          });
          break;
        case "center":
          shadow.position({
            x: width / 2,
            y: height / 2
          });
          break;
      }
    }
  }
  // 实现：生成 调整点
  static createAnchorShapes(render22, graph, anchorAndShadows, adjustAnchor) {
    const stageState = render22.getStageState();
    for (const anchorAndShadow of anchorAndShadows) {
      const { anchor, anchorShadow } = anchorAndShadow;
      const x = render22.toStageValue(anchorShadow.getAbsolutePosition().x - stageState.x), y = render22.toStageValue(anchorShadow.getAbsolutePosition().y - stageState.y);
      const offset = render22.toStageValue(render22.pointSize + 5);
      const anchorShape = new Konva.Line({
        name: "anchor",
        anchor,
        //
        stroke: `rgba(0,0,255,0.4)`,
        strokeWidth: render22.toStageValue(2),
        hitStrokeWidth: render22.toStageValue(3),
        // 位置
        x,
        y,
        // 路径
        points: {
          "top-left": lodash.flatten([
            [-offset, offset / 2],
            [-offset, -offset],
            [offset / 2, -offset]
          ]),
          top: lodash.flatten([
            [-offset, -offset],
            [offset, -offset]
          ]),
          "top-right": lodash.flatten([
            [-offset / 2, -offset],
            [offset, -offset],
            [offset, offset / 2]
          ]),
          right: lodash.flatten([
            [offset, -offset],
            [offset, offset]
          ]),
          "bottom-right": lodash.flatten([
            [-offset / 2, offset],
            [offset, offset],
            [offset, -offset / 2]
          ]),
          bottom: lodash.flatten([
            [-offset, offset],
            [offset, offset]
          ]),
          "bottom-left": lodash.flatten([
            [-offset, -offset / 2],
            [-offset, offset],
            [offset / 2, offset]
          ]),
          left: lodash.flatten([
            [-offset, -offset],
            [-offset, offset]
          ])
        }[anchor.adjustType] ?? [],
        // 旋转角度
        rotation: graph.getAbsoluteRotation(),
        visible: graph.attrs.adjusting || graph.attrs.hover === true
      });
      anchorShape.on("mouseenter", () => {
        document.body.style.cursor = "move";
        graph.setAttr("hover", true);
        graph.setAttr("hoverAnchor", true);
      });
      anchorShape.on("mouseleave", () => {
        document.body.style.cursor = anchorShape.attrs.adjusting ? "move" : "default";
        graph.setAttr("hover", false);
        graph.setAttr("hoverAnchor", false);
        render22.redraw([GraphDraw.name]);
      });
      anchorAndShadow.shape = anchorShape;
    }
    return { anchorAndShadows };
  }
  // 实现：调整 图形
  static adjust(render22, graph, graphSnap, adjustShape, anchorAndShadows, startPoint, endPoint, hoverRect) {
    var _a, _b;
    const circle = graph.findOne(".graph");
    const circleSnap = graphSnap.findOne(".graph");
    const anchors = graph.find(".anchor") ?? [];
    const anchorsSnap = graphSnap.find(".anchor") ?? [];
    const linkAnchors = graph.find(".link-anchor") ?? [];
    if (circle && circleSnap) {
      const [graphRotation, adjustType, ex, ey] = [
        Math.round(graph.rotation()),
        (_a = adjustShape.attrs.anchor) == null ? void 0 : _a.adjustType,
        endPoint.x,
        endPoint.y
      ];
      let anchorShadow, anchorShadowAcross;
      switch (adjustType) {
        case "top":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "top");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "bottom");
          }
          break;
        case "bottom":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "bottom");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "top");
          }
          break;
        case "left":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "left");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "right");
          }
          break;
        case "right":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "right");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "left");
          }
          break;
        case "top-left":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "top-left");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "bottom-right");
          }
          break;
        case "top-right":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "top-right");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "bottom-left");
          }
          break;
        case "bottom-left":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "bottom-left");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "top-right");
          }
          break;
        case "bottom-right":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "bottom-right");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "top-left");
          }
          break;
      }
      if (anchorShadow && anchorShadowAcross) {
        const { x: sx, y: sy } = anchorShadow.getAbsolutePosition();
        const { x: ax, y: ay } = anchorShadowAcross.getAbsolutePosition();
        {
          const d1 = Math.sqrt(Math.pow(sx - ax, 2) + Math.pow(sy - ay, 2));
          const d2 = Math.sqrt(Math.pow(ex - ax, 2) + Math.pow(ey - ay, 2));
          const r1 = d2 / d1;
          let zeroWidth = 1, zeroHeight = 1;
          switch (adjustType) {
            case "top":
              {
                if (graphRotation >= 45 && graphRotation < 135) {
                  zeroHeight = ex <= ax ? 0 : 1;
                } else if (graphRotation >= -135 && graphRotation < -45) {
                  zeroHeight = ex >= ax ? 0 : 1;
                } else if (graphRotation >= -45 && graphRotation < 45) {
                  zeroHeight = ey >= ay ? 0 : 1;
                } else {
                  zeroHeight = ey <= ay ? 0 : 1;
                }
              }
              break;
            case "bottom":
              {
                if (graphRotation >= 45 && graphRotation < 135) {
                  zeroHeight = ex <= ax ? 1 : 0;
                } else if (graphRotation >= -135 && graphRotation < -45) {
                  zeroHeight = ex >= ax ? 1 : 0;
                } else if (graphRotation >= -45 && graphRotation < 45) {
                  zeroHeight = ey >= ay ? 1 : 0;
                } else {
                  zeroHeight = ey <= ay ? 1 : 0;
                }
              }
              break;
            case "left":
              {
                if (graphRotation >= 45 && graphRotation < 135) {
                  zeroWidth = ey >= ay ? 0 : 1;
                } else if (graphRotation >= -135 && graphRotation < -45) {
                  zeroWidth = ex <= ax ? 0 : 1;
                } else if (graphRotation >= -45 && graphRotation < 45) {
                  zeroWidth = ex >= ax ? 0 : 1;
                } else {
                  zeroWidth = ey <= ay ? 0 : 1;
                }
              }
              break;
            case "right":
              {
                if (graphRotation >= 45 && graphRotation < 135) {
                  zeroWidth = ey >= ay ? 1 : 0;
                } else if (graphRotation >= -135 && graphRotation < -45) {
                  zeroWidth = ex <= ax ? 1 : 0;
                } else if (graphRotation >= -45 && graphRotation < 45) {
                  zeroWidth = ex >= ax ? 1 : 0;
                } else {
                  zeroWidth = ey <= ay ? 1 : 0;
                }
              }
              break;
            case "top-left":
              {
                if (graphRotation > -45 && graphRotation < 45) {
                  if (ex >= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 45) {
                  if (ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 45 && graphRotation < 135) {
                  if (ex <= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 135) {
                  if (ex <= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 135 && graphRotation <= 180 || graphRotation >= -180 && graphRotation < -135) {
                  if (ex <= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -135) {
                  if (ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > -135 && graphRotation < -45) {
                  if (ex >= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -45) {
                  if (ex >= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                }
              }
              break;
            case "top-right":
              {
                if (graphRotation > -45 && graphRotation < 45) {
                  if (ex <= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 45) {
                  if (ex <= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 45 && graphRotation < 135) {
                  if (ex <= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 135) {
                  if (ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 135 && graphRotation <= 180 || graphRotation >= -180 && graphRotation < -135) {
                  if (ex >= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -135) {
                  if (ex >= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > -135 && graphRotation < -45) {
                  if (ex >= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -45) {
                  if (ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                }
              }
              break;
            case "bottom-left":
              {
                if (graphRotation > -45 && graphRotation < 45) {
                  if (ex >= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 45) {
                  if (ex >= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 45 && graphRotation < 135) {
                  if (ex >= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 135) {
                  if (ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 135 && graphRotation <= 180 || graphRotation >= -180 && graphRotation < -135) {
                  if (ex <= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -135) {
                  if (ex <= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > -135 && graphRotation < -45) {
                  if (ex <= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -45) {
                  if (ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                }
              }
              break;
            case "bottom-right":
              {
                if (graphRotation > -45 && graphRotation < 45) {
                  if (ex <= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 45) {
                  if (ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 45 && graphRotation < 135) {
                  if (ex >= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 135) {
                  if (ex >= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 135 && graphRotation <= 180 || graphRotation >= -180 && graphRotation < -135) {
                  if (ex >= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -135) {
                  if (ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > -135 && graphRotation < -45) {
                  if (ex <= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -45) {
                  if (ex <= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                }
              }
              break;
          }
          if (/-?(left|right)$/.test(adjustType)) {
            graph.width(Math.max(2, graphSnap.width() * r1 * zeroWidth));
          }
          if (/^(top|bottom)-?/.test(adjustType)) {
            graph.height(Math.max(2, graphSnap.height() * r1 * zeroHeight));
          }
        }
        {
          const [graphWidth2, graphHeight2] = [
            graph.width() * graph.scaleX(),
            graph.height() * graph.scaleY()
          ];
          const cos = Math.cos(graphRotation * Math.PI / 180);
          const sin = Math.sin(graphRotation * Math.PI / 180);
          const tan = Math.tan(graphRotation * Math.PI / 180);
          switch (adjustType) {
            case "top":
              {
                graph.x(ax - (graphWidth2 / 2 - graphHeight2 * tan) * cos);
                if (graphRotation !== 90 && graphRotation !== -90) {
                  graph.y(ay - (graphHeight2 / cos + (graphWidth2 / 2 - graphHeight2 * tan) * sin));
                }
              }
              break;
            case "bottom":
              break;
            case "left":
              {
                if ([90, -90].includes(graphRotation)) {
                  graph.y(ay - graphWidth2);
                } else if (Math.abs(graphRotation) === 180) {
                  graph.x(ax + graphWidth2);
                } else {
                  const v1 = graphHeight2 / 2 / cos;
                  const v2 = v1 * sin;
                  const v3 = graphWidth2 - v2;
                  const v4 = v3 * sin;
                  graph.x(ax - v3 * cos);
                  graph.y(ay - (v1 + v4));
                }
              }
              break;
            case "right":
              break;
            case "top-left":
              {
                graph.x(ax - (graphWidth2 - graphHeight2 * tan) * cos);
                graph.y(ay - (graphWidth2 * sin + graphHeight2 * cos));
              }
              break;
            case "top-right":
              {
                graph.x(ax + graphHeight2 * sin);
                graph.y(ay - graphHeight2 * cos);
              }
              break;
            case "bottom-left":
              {
                graph.x(ax - graphWidth2 * cos);
                graph.y(ay - graphWidth2 * sin);
              }
              break;
          }
        }
      }
      const [graphWidth, graphHeight] = [graph.width(), graph.height()];
      circle.x(graphWidth / 2);
      circle.radiusX(graphWidth / 2);
      circle.y(graphHeight / 2);
      circle.radiusY(graphHeight / 2);
      _Circle.updateAnchorShadows(graph, anchors);
      _Circle.updateLinkAnchorShadows(graph, linkAnchors);
      const stageState = render22.getStageState();
      for (const anchor of anchors) {
        for (const { shape } of anchorAndShadows) {
          if (shape) {
            if (((_b = shape.attrs.anchor) == null ? void 0 : _b.adjustType) === anchor.attrs.adjustType) {
              const anchorShadow2 = graph.find(`.anchor`).find((o) => o.attrs.adjustType === anchor.attrs.adjustType);
              if (anchorShadow2) {
                shape.position({
                  x: render22.toStageValue(anchorShadow2.getAbsolutePosition().x - stageState.x),
                  y: render22.toStageValue(anchorShadow2.getAbsolutePosition().y - stageState.y)
                });
                shape.rotation(graph.getAbsoluteRotation());
              }
            }
          }
        }
      }
      render22.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
    }
    BaseGraph.adjust(
      render22,
      graph,
      graphSnap,
      adjustShape,
      anchorAndShadows,
      startPoint,
      endPoint,
      hoverRect
    );
  }
  /**
   * 提供给 GraphDraw draw 使用
   */
  static draw(graph, render22, adjustAnchor) {
    const { anchorAndShadows } = super.draw(graph, render22, adjustAnchor);
    return _Circle.createAnchorShapes(render22, graph, anchorAndShadows, adjustAnchor);
  }
  // 实现：拖动进行时
  drawMove(point) {
    let offsetX = point.x - this.dropPoint.x, offsetY = point.y - this.dropPoint.y;
    if (offsetX < 1) {
      offsetX = 1;
    }
    if (offsetY < 1) {
      offsetY = 1;
    }
    const radiusX = offsetX / 2, radiusY = offsetY / 2;
    this.circle.x(radiusX);
    this.circle.y(radiusY);
    this.circle.radiusX(radiusX);
    this.circle.radiusY(radiusY);
    this.group.size({
      width: offsetX,
      height: offsetY
    });
    _Circle.updateAnchorShadows(this.group, this.anchorShadows);
    _Circle.updateLinkAnchorShadows(this.group, this.linkAnchorShadows);
    this.render.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
  }
  // 实现：拖动结束
  drawEnd() {
    if (this.circle.radiusX() <= 1 && this.circle.radiusY() <= 1) {
      const width = _Circle.size, height = width;
      const radiusX = _Circle.size / 2, radiusY = radiusX;
      this.circle.x(radiusX);
      this.circle.y(radiusY);
      this.circle.radiusX(radiusX - this.circle.strokeWidth());
      this.circle.radiusY(radiusY - this.circle.strokeWidth());
      this.group.size({
        width,
        height
      });
      _Circle.updateAnchorShadows(this.group, this.anchorShadows);
      _Circle.updateLinkAnchorShadows(this.group, this.linkAnchorShadows);
      this.render.attractTool.alignLinesClear();
      this.render.updateHistory();
      this.render.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
    }
    super.drawEnd();
  }
};
/**
 * 默认图形大小
 */
__publicField(_Circle, "size", 100);
let Circle2 = _Circle;
const _Rect = class _Rect extends BaseGraph {
  constructor(render22, dropPoint) {
    super(render22, dropPoint, {
      type: GraphType.Rect,
      // 记录所属 图形
      // 定义了 8 个 调整点
      anchors: [
        { adjustType: "top" },
        { adjustType: "bottom" },
        { adjustType: "left" },
        { adjustType: "right" },
        { adjustType: "top-left" },
        { adjustType: "top-right" },
        { adjustType: "bottom-left" },
        { adjustType: "bottom-right" }
      ].map((o) => ({
        adjustType: o.adjustType
        // 调整点 类型定义
      })),
      linkAnchors: [
        { x: 0, y: 0, alias: "top", direction: "top" },
        { x: 0, y: 0, alias: "bottom", direction: "bottom" },
        { x: 0, y: 0, alias: "left", direction: "left" },
        { x: 0, y: 0, alias: "right", direction: "right" },
        { x: 0, y: 0, alias: "center" }
      ]
    });
    /**
     * 矩形 对应的 Konva 实例
     */
    __publicField(this, "rect");
    this.rect = new Konva.Rect({
      name: "graph",
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      stroke: this.render.getPageSettings().stroke,
      strokeWidth: this.render.getPageSettings().strokeWidth
      // fill: this.render.getPageSettings().fill,
    });
    this.group.add(this.rect);
    this.group.position(this.dropPoint);
  }
  // 实现：更新 图形 的 调整点 的 锚点位置
  static updateAnchorShadows(graph, anchorShadows) {
    const { width, height } = graph.size();
    for (const shadow of anchorShadows) {
      switch (shadow.attrs.adjustType) {
        case "top":
          shadow.position({
            x: width / 2,
            y: 0
          });
          break;
        case "bottom":
          shadow.position({
            x: width / 2,
            y: height
          });
          break;
        case "left":
          shadow.position({
            x: 0,
            y: height / 2
          });
          break;
        case "right":
          shadow.position({
            x: width,
            y: height / 2
          });
          break;
        case "top-left":
          shadow.position({
            x: 0,
            y: 0
          });
          break;
        case "top-right":
          shadow.position({
            x: width,
            y: 0
          });
          break;
        case "bottom-left":
          shadow.position({
            x: 0,
            y: height
          });
          break;
        case "bottom-right":
          shadow.position({
            x: width,
            y: height
          });
          break;
      }
    }
  }
  // 实现：更新 图形 的 连接点 的 锚点位置
  static updateLinkAnchorShadows(graph, linkAnchorShadows) {
    const { width, height } = graph.size();
    for (const shadow of linkAnchorShadows) {
      switch (shadow.attrs.alias) {
        case "top":
          shadow.position({
            x: width / 2,
            y: 0
          });
          break;
        case "bottom":
          shadow.position({
            x: width / 2,
            y: height
          });
          break;
        case "left":
          shadow.position({
            x: 0,
            y: height / 2
          });
          break;
        case "right":
          shadow.position({
            x: width,
            y: height / 2
          });
          break;
        case "center":
          shadow.position({
            x: width / 2,
            y: height / 2
          });
          break;
      }
    }
  }
  // 实现：生成 调整点
  static createAnchorShapes(render22, graph, anchorAndShadows, adjustAnchor) {
    const stageState = render22.getStageState();
    for (const anchorAndShadow of anchorAndShadows) {
      const { anchor, anchorShadow } = anchorAndShadow;
      const x = render22.toStageValue(anchorShadow.getAbsolutePosition().x - stageState.x), y = render22.toStageValue(anchorShadow.getAbsolutePosition().y - stageState.y);
      const offset = render22.toStageValue(render22.pointSize + 5);
      const anchorShape = new Konva.Line({
        name: "anchor",
        anchor,
        //
        stroke: `rgba(0,0,255,0.4)`,
        strokeWidth: render22.toStageValue(2),
        hitStrokeWidth: render22.toStageValue(3),
        // 位置
        x,
        y,
        // 路径
        points: {
          "top-left": lodash.flatten([
            [-offset, offset / 2],
            [-offset, -offset],
            [offset / 2, -offset]
          ]),
          top: lodash.flatten([
            [-offset, -offset],
            [offset, -offset]
          ]),
          "top-right": lodash.flatten([
            [-offset / 2, -offset],
            [offset, -offset],
            [offset, offset / 2]
          ]),
          right: lodash.flatten([
            [offset, -offset],
            [offset, offset]
          ]),
          "bottom-right": lodash.flatten([
            [-offset / 2, offset],
            [offset, offset],
            [offset, -offset / 2]
          ]),
          bottom: lodash.flatten([
            [-offset, offset],
            [offset, offset]
          ]),
          "bottom-left": lodash.flatten([
            [-offset, -offset / 2],
            [-offset, offset],
            [offset / 2, offset]
          ]),
          left: lodash.flatten([
            [-offset, -offset],
            [-offset, offset]
          ])
        }[anchor.adjustType] ?? [],
        // 旋转角度
        rotation: graph.getAbsoluteRotation(),
        visible: graph.attrs.adjusting || graph.attrs.hover === true
      });
      anchorShape.on("mouseenter", () => {
        document.body.style.cursor = "move";
        graph.setAttr("hover", true);
        graph.setAttr("hoverAnchor", true);
      });
      anchorShape.on("mouseleave", () => {
        document.body.style.cursor = anchorShape.attrs.adjusting ? "move" : "default";
        graph.setAttr("hover", false);
        graph.setAttr("hoverAnchor", false);
        render22.redraw([GraphDraw.name]);
      });
      anchorAndShadow.shape = anchorShape;
    }
    return { anchorAndShadows };
  }
  // 实现：调整 图形
  static adjust(render22, graph, graphSnap, adjustShape, anchorAndShadows, startPoint, endPoint, hoverRect) {
    var _a, _b;
    const rect = graph.findOne(".graph");
    const rectSnap = graphSnap.findOne(".graph");
    const anchors = graph.find(".anchor") ?? [];
    const anchorsSnap = graphSnap.find(".anchor") ?? [];
    const linkAnchors = graph.find(".link-anchor") ?? [];
    if (rect && rectSnap) {
      const [graphRotation, adjustType, ex, ey] = [
        Math.round(graph.rotation()),
        (_a = adjustShape.attrs.anchor) == null ? void 0 : _a.adjustType,
        endPoint.x,
        endPoint.y
      ];
      let anchorShadow, anchorShadowAcross;
      switch (adjustType) {
        case "top":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "top");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "bottom");
          }
          break;
        case "bottom":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "bottom");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "top");
          }
          break;
        case "left":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "left");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "right");
          }
          break;
        case "right":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "right");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "left");
          }
          break;
        case "top-left":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "top-left");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "bottom-right");
          }
          break;
        case "top-right":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "top-right");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "bottom-left");
          }
          break;
        case "bottom-left":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "bottom-left");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "top-right");
          }
          break;
        case "bottom-right":
          {
            anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === "bottom-right");
            anchorShadowAcross = anchorsSnap.find((o) => o.attrs.adjustType === "top-left");
          }
          break;
      }
      if (anchorShadow && anchorShadowAcross) {
        const { x: sx, y: sy } = anchorShadow.getAbsolutePosition();
        const { x: ax, y: ay } = anchorShadowAcross.getAbsolutePosition();
        {
          const d1 = Math.sqrt(Math.pow(sx - ax, 2) + Math.pow(sy - ay, 2));
          const d2 = Math.sqrt(Math.pow(ex - ax, 2) + Math.pow(ey - ay, 2));
          const r1 = d2 / d1;
          let zeroWidth = 1, zeroHeight = 1;
          switch (adjustType) {
            case "top":
              {
                if (graphRotation >= 45 && graphRotation < 135) {
                  zeroHeight = ex <= ax ? 0 : 1;
                } else if (graphRotation >= -135 && graphRotation < -45) {
                  zeroHeight = ex >= ax ? 0 : 1;
                } else if (graphRotation >= -45 && graphRotation < 45) {
                  zeroHeight = ey >= ay ? 0 : 1;
                } else {
                  zeroHeight = ey <= ay ? 0 : 1;
                }
              }
              break;
            case "bottom":
              {
                if (graphRotation >= 45 && graphRotation < 135) {
                  zeroHeight = ex <= ax ? 1 : 0;
                } else if (graphRotation >= -135 && graphRotation < -45) {
                  zeroHeight = ex >= ax ? 1 : 0;
                } else if (graphRotation >= -45 && graphRotation < 45) {
                  zeroHeight = ey >= ay ? 1 : 0;
                } else {
                  zeroHeight = ey <= ay ? 1 : 0;
                }
              }
              break;
            case "left":
              {
                if (graphRotation >= 45 && graphRotation < 135) {
                  zeroWidth = ey >= ay ? 0 : 1;
                } else if (graphRotation >= -135 && graphRotation < -45) {
                  zeroWidth = ex <= ax ? 0 : 1;
                } else if (graphRotation >= -45 && graphRotation < 45) {
                  zeroWidth = ex >= ax ? 0 : 1;
                } else {
                  zeroWidth = ey <= ay ? 0 : 1;
                }
              }
              break;
            case "right":
              {
                if (graphRotation >= 45 && graphRotation < 135) {
                  zeroWidth = ey >= ay ? 1 : 0;
                } else if (graphRotation >= -135 && graphRotation < -45) {
                  zeroWidth = ex <= ax ? 1 : 0;
                } else if (graphRotation >= -45 && graphRotation < 45) {
                  zeroWidth = ex >= ax ? 1 : 0;
                } else {
                  zeroWidth = ey <= ay ? 1 : 0;
                }
              }
              break;
            case "top-left":
              {
                if (graphRotation > -45 && graphRotation < 45) {
                  if (ex >= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 45) {
                  if (ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 45 && graphRotation < 135) {
                  if (ex <= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 135) {
                  if (ex <= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 135 && graphRotation <= 180 || graphRotation >= -180 && graphRotation < -135) {
                  if (ex <= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -135) {
                  if (ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > -135 && graphRotation < -45) {
                  if (ex >= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -45) {
                  if (ex >= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                }
              }
              break;
            case "top-right":
              {
                if (graphRotation > -45 && graphRotation < 45) {
                  if (ex <= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 45) {
                  if (ex <= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 45 && graphRotation < 135) {
                  if (ex <= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 135) {
                  if (ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 135 && graphRotation <= 180 || graphRotation >= -180 && graphRotation < -135) {
                  if (ex >= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -135) {
                  if (ex >= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > -135 && graphRotation < -45) {
                  if (ex >= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -45) {
                  if (ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                }
              }
              break;
            case "bottom-left":
              {
                if (graphRotation > -45 && graphRotation < 45) {
                  if (ex >= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 45) {
                  if (ex >= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 45 && graphRotation < 135) {
                  if (ex >= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 135) {
                  if (ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 135 && graphRotation <= 180 || graphRotation >= -180 && graphRotation < -135) {
                  if (ex <= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -135) {
                  if (ex <= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > -135 && graphRotation < -45) {
                  if (ex <= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -45) {
                  if (ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                }
              }
              break;
            case "bottom-right":
              {
                if (graphRotation > -45 && graphRotation < 45) {
                  if (ex <= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 45) {
                  if (ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 45 && graphRotation < 135) {
                  if (ex >= ax && ey <= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === 135) {
                  if (ex >= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > 135 && graphRotation <= 180 || graphRotation >= -180 && graphRotation < -135) {
                  if (ex >= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -135) {
                  if (ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation > -135 && graphRotation < -45) {
                  if (ex <= ax && ey >= ay) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                } else if (graphRotation === -45) {
                  if (ex <= ax) {
                    zeroWidth = 0;
                    zeroHeight = 0;
                  } else {
                    zeroWidth = 1;
                    zeroHeight = 1;
                  }
                }
              }
              break;
          }
          if (/-?(left|right)$/.test(adjustType)) {
            graph.width(Math.max(2, graphSnap.width() * r1 * zeroWidth));
          }
          if (/^(top|bottom)-?/.test(adjustType)) {
            graph.height(Math.max(2, graphSnap.height() * r1 * zeroHeight));
          }
        }
        {
          const [graphWidth2, graphHeight2] = [
            graph.width() * graph.scaleX(),
            graph.height() * graph.scaleY()
          ];
          const cos = Math.cos(graphRotation * Math.PI / 180);
          const sin = Math.sin(graphRotation * Math.PI / 180);
          const tan = Math.tan(graphRotation * Math.PI / 180);
          switch (adjustType) {
            case "top":
              {
                graph.x(ax - (graphWidth2 / 2 - graphHeight2 * tan) * cos);
                if (graphRotation !== 90 && graphRotation !== -90) {
                  graph.y(ay - (graphHeight2 / cos + (graphWidth2 / 2 - graphHeight2 * tan) * sin));
                }
              }
              break;
            case "bottom":
              break;
            case "left":
              {
                if ([90, -90].includes(graphRotation)) {
                  graph.y(ay - graphWidth2);
                } else if (Math.abs(graphRotation) === 180) {
                  graph.x(ax + graphWidth2);
                } else {
                  const v1 = graphHeight2 / 2 / cos;
                  const v2 = v1 * sin;
                  const v3 = graphWidth2 - v2;
                  const v4 = v3 * sin;
                  graph.x(ax - v3 * cos);
                  graph.y(ay - (v1 + v4));
                }
              }
              break;
            case "right":
              break;
            case "top-left":
              {
                graph.x(ax - (graphWidth2 - graphHeight2 * tan) * cos);
                graph.y(ay - (graphWidth2 * sin + graphHeight2 * cos));
              }
              break;
            case "top-right":
              {
                graph.x(ax + graphHeight2 * sin);
                graph.y(ay - graphHeight2 * cos);
              }
              break;
            case "bottom-left":
              {
                graph.x(ax - graphWidth2 * cos);
                graph.y(ay - graphWidth2 * sin);
              }
              break;
          }
        }
      }
      const [graphWidth, graphHeight] = [graph.width(), graph.height()];
      rect.width(graphWidth);
      rect.height(graphHeight);
      _Rect.updateAnchorShadows(graph, anchors);
      _Rect.updateLinkAnchorShadows(graph, linkAnchors);
      const stageState = render22.getStageState();
      for (const anchor of anchors) {
        for (const { shape } of anchorAndShadows) {
          if (shape) {
            if (((_b = shape.attrs.anchor) == null ? void 0 : _b.adjustType) === anchor.attrs.adjustType) {
              const anchorShadow2 = graph.find(`.anchor`).find((o) => o.attrs.adjustType === anchor.attrs.adjustType);
              if (anchorShadow2) {
                shape.position({
                  x: render22.toStageValue(anchorShadow2.getAbsolutePosition().x - stageState.x),
                  y: render22.toStageValue(anchorShadow2.getAbsolutePosition().y - stageState.y)
                });
                shape.rotation(graph.getAbsoluteRotation());
              }
            }
          }
        }
      }
      render22.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
    }
    BaseGraph.adjust(
      render22,
      graph,
      graphSnap,
      adjustShape,
      anchorAndShadows,
      startPoint,
      endPoint,
      hoverRect
    );
  }
  /**
   * 提供给 GraphDraw draw 使用
   */
  static draw(graph, render22, adjustAnchor) {
    const { anchorAndShadows } = super.draw(graph, render22, adjustAnchor);
    return _Rect.createAnchorShapes(render22, graph, anchorAndShadows, adjustAnchor);
  }
  // 实现：拖动进行时
  drawMove(point) {
    let offsetX = point.x - this.dropPoint.x, offsetY = point.y - this.dropPoint.y;
    if (offsetX < 1) {
      offsetX = 1;
    }
    if (offsetY < 1) {
      offsetY = 1;
    }
    this.rect.width(offsetX);
    this.rect.height(offsetY);
    this.group.size({
      width: offsetX,
      height: offsetY
    });
    _Rect.updateAnchorShadows(this.group, this.anchorShadows);
    _Rect.updateLinkAnchorShadows(this.group, this.linkAnchorShadows);
    this.render.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
  }
  // 实现：拖动结束
  drawEnd() {
    if (this.rect.width() <= 1 && this.rect.height() <= 1) {
      const width = _Rect.size, height = width;
      this.rect.width(width - this.rect.strokeWidth());
      this.rect.height(height - this.rect.strokeWidth());
      this.group.size({
        width,
        height
      });
      _Rect.updateAnchorShadows(this.group, this.anchorShadows);
      _Rect.updateLinkAnchorShadows(this.group, this.linkAnchorShadows);
      this.render.attractTool.alignLinesClear();
      this.render.updateHistory();
      this.render.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
    }
    super.drawEnd();
  }
};
/**
 * 默认图形大小
 */
__publicField(_Rect, "size", 100);
let Rect2 = _Rect;
const _Line = class _Line extends BaseGraph {
  constructor(render22, dropPoint) {
    super(render22, dropPoint, {
      type: GraphType.Line,
      // 定义了 2 个 调整点
      anchors: [{ adjustType: "start" }, { adjustType: "end" }].map((o) => ({
        adjustType: o.adjustType
        // 调整点 类型定义
      })),
      linkAnchors: [
        { x: 0, y: 0, alias: "start" },
        { x: 0, y: 0, alias: "end" }
      ]
    });
    /**
     * 直线、折线 对应的 Konva 实例
     */
    __publicField(this, "line");
    this.line = new Konva.Arrow({
      name: "graph",
      x: 0,
      y: 0,
      stroke: this.render.getPageSettings().stroke,
      strokeWidth: this.render.getPageSettings().strokeWidth,
      fill: this.render.getPageSettings().stroke,
      points: [],
      pointerAtBeginning: false,
      pointerAtEnding: false
    });
    this.group.size({
      width: 1,
      height: 1
    });
    this.group.add(this.line);
    this.group.position(this.dropPoint);
  }
  // 实现：更新 图形 的 调整点 的 锚点位置
  static updateAnchorShadows(graph, anchorShadows, shape) {
    if (shape) {
      const points = shape.points();
      for (const shadow of anchorShadows) {
        switch (shadow.attrs.adjustType) {
          case "start":
            shadow.position({
              x: points[0],
              y: points[1]
            });
            break;
          case "end":
            shadow.position({
              x: points[points.length - 2],
              y: points[points.length - 1]
            });
            break;
        }
      }
    }
  }
  // 实现：更新 图形 的 连接点 的 锚点位置
  static updateLinkAnchorShadows(graph, linkAnchorShadows, shape) {
    if (shape) {
      const points = shape.points();
      for (const shadow of linkAnchorShadows) {
        switch (shadow.attrs.alias) {
          case "start":
            shadow.position({
              x: points[0],
              y: points[1]
            });
            break;
          case "end":
            shadow.position({
              x: points[points.length - 2],
              y: points[points.length - 1]
            });
            break;
        }
      }
    }
  }
  static calculateAngle(sideA, sideB) {
    const angleInRadians = Math.atan2(sideA, sideB);
    const angleInDegrees = angleInRadians * (180 / Math.PI);
    return angleInDegrees;
  }
  // 实现：生成 调整点
  static createAnchorShapes(render22, graph, anchorAndShadows, adjustAnchor) {
    const stageState = render22.getStageState();
    const graphShape = graph.findOne(".graph");
    if (graphShape) {
      const points = graphShape.points();
      for (const anchorAndShadow of anchorAndShadows) {
        let rotate = 0;
        const { anchor, anchorShadow } = anchorAndShadow;
        const x = render22.toStageValue(anchorShadow.getAbsolutePosition().x - stageState.x), y = render22.toStageValue(anchorShadow.getAbsolutePosition().y - stageState.y);
        if (anchor.adjustType === "manual") {
          const anchorShape = new Konva.Circle({
            name: "anchor",
            anchor,
            //
            fill: anchor.adjusted ? `rgba(0,0,0,0.4)` : `rgba(0,0,255,0.4)`,
            radius: render22.toStageValue(5),
            strokeWidth: 0,
            // 位置
            x,
            y,
            // 旋转角度
            rotation: graph.getAbsoluteRotation(),
            visible: graph.attrs.adjusting || graph.attrs.hover === true
          });
          anchorShape.on("mouseenter", () => {
            document.body.style.cursor = "move";
            graph.setAttr("hover", true);
            graph.setAttr("hoverAnchor", true);
          });
          anchorShape.on("mouseleave", () => {
            document.body.style.cursor = anchorShape.attrs.adjusting ? "move" : "default";
            graph.setAttr("hover", false);
            graph.setAttr("hoverAnchor", false);
            render22.redraw([GraphDraw.name]);
          });
          anchorAndShadow.shape = anchorShape;
        } else {
          if (anchor.adjustType === "start") {
            rotate = _Line.calculateAngle(points[2] - points[0], points[3] - points[1]);
          } else if (anchor.adjustType === "end") {
            rotate = _Line.calculateAngle(
              points[points.length - 2] - points[points.length - 4],
              points[points.length - 1] - points[points.length - 3]
            );
          }
          const cos = Math.cos(rotate * Math.PI / 180);
          const sin = Math.sin(rotate * Math.PI / 180);
          const offset = render22.toStageValue(render22.pointSize - 20);
          const offsetX = offset * sin;
          const offsetY = offset * cos;
          const anchorShape = new Konva.Circle({
            name: "anchor",
            anchor,
            //
            fill: `rgba(0,0,255,0.4)`,
            radius: render22.toStageValue(5),
            strokeWidth: 0,
            // 位置
            x,
            y,
            offsetX: anchor.adjustType === "start" ? offsetX : anchor.adjustType === "end" ? -offsetX : 0,
            offsetY: anchor.adjustType === "start" ? offsetY : anchor.adjustType === "end" ? -offsetY : 0,
            // 旋转角度
            rotation: graph.getAbsoluteRotation(),
            visible: graph.attrs.adjusting || graph.attrs.hover === true
          });
          anchorShape.on("mouseenter", () => {
            document.body.style.cursor = "move";
            graph.setAttr("hover", true);
            graph.setAttr("hoverAnchor", true);
          });
          anchorShape.on("mouseleave", () => {
            document.body.style.cursor = anchorShape.attrs.adjusting ? "move" : "default";
            graph.setAttr("hover", false);
            graph.setAttr("hoverAnchor", false);
            render22.redraw([GraphDraw.name]);
          });
          anchorAndShadow.shape = anchorShape;
        }
      }
    }
    return { anchorAndShadows };
  }
  /**
   * 矩阵变换：坐标系中的一个点，围绕着另外一个点进行旋转
   * -  -   -        - -   -   - -
   * |x`|   |cos -sin| |x-a|   |a|
   * |  | = |        | |   | +
   * |y`|   |sin  cos| |y-b|   |b|
   * -  -   -        - -   -   - -
   * @param x 目标节点坐标 x
   * @param y 目标节点坐标 y
   * @param centerX 围绕的点坐标 x
   * @param centerY 围绕的点坐标 y
   * @param angle 旋转角度
   * @returns
   */
  static rotatePoint(x, y, centerX, centerY, angle) {
    const radians = angle * Math.PI / 180;
    const newX = Math.cos(radians) * (x - centerX) - Math.sin(radians) * (y - centerY) + centerX;
    const newY = Math.sin(radians) * (x - centerX) + Math.cos(radians) * (y - centerY) + centerY;
    return { x: newX, y: newY };
  }
  // 实现：调整 图形
  static adjust(render22, graph, graphSnap, adjustShape, anchorAndShadows, startPoint, endPoint, hoverRect) {
    var _a, _b, _c, _d, _e, _f;
    const line = graph.findOne(".graph");
    const lineSnap = graphSnap.findOne(".graph");
    const anchors = graph.find(".anchor") ?? [];
    const anchorsSnap = graphSnap.find(".anchor") ?? [];
    const linkAnchors = graph.find(".link-anchor") ?? [];
    if (line && lineSnap) {
      const stageState = render22.getStageState();
      {
        const [graphRotation, adjustType, ex, ey] = [
          Math.round(graph.rotation()),
          (_a = adjustShape.attrs.anchor) == null ? void 0 : _a.adjustType,
          endPoint.x,
          endPoint.y
        ];
        const { x: cx, y: cy, width: cw, height: ch } = graphSnap.getClientRect();
        const { x, y } = graph.position();
        const [centerX, centerY] = [cx + cw / 2, cy + ch / 2];
        const { x: sx, y: sy } = _Line.rotatePoint(ex, ey, centerX, centerY, -graphRotation);
        const { x: rx, y: ry } = _Line.rotatePoint(x, y, centerX, centerY, -graphRotation);
        const points = line.points();
        const manualPoints = line.attrs.manualPoints ?? [];
        if (adjustType === "manual") {
          if (((_b = adjustShape.attrs.anchor) == null ? void 0 : _b.manualIndex) !== void 0) {
            const index = ((_c = adjustShape.attrs.anchor) == null ? void 0 : _c.adjusted) ? (_d = adjustShape.attrs.anchor) == null ? void 0 : _d.manualIndex : ((_e = adjustShape.attrs.anchor) == null ? void 0 : _e.manualIndex) + 1;
            const manualPointIndex = manualPoints.findIndex((o) => o.index === index);
            if (manualPointIndex > -1) {
              manualPoints[manualPointIndex].x = (sx - rx) / graph.scaleX();
              manualPoints[manualPointIndex].y = (sy - ry) / graph.scaleY();
            }
            const linkPoints = [
              [points[0], points[1]],
              ...manualPoints.sort((a, b) => a.index - b.index).map((o) => [o.x, o.y]),
              [points[points.length - 2], points[points.length - 1]]
            ];
            line.setAttr("manualPoints", manualPoints);
            line.points(lodash.flatten(linkPoints));
            const adjustAnchorShadow = anchors.find(
              (o) => o.attrs.adjustType === "manual" && o.attrs.manualIndex === index
            );
            if (adjustAnchorShadow) {
              adjustAnchorShadow.position({
                x: (sx - rx) / graph.scaleX(),
                y: (sy - ry) / graph.scaleY()
              });
            }
          }
        } else {
          const anchor = anchors.find((o) => o.attrs.adjustType === adjustType);
          const anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === adjustType);
          if (anchor && anchorShadow) {
            {
              const linkPoints = [
                [points[0], points[1]],
                ...manualPoints.sort((a, b) => a.index - b.index).map((o) => [o.x, o.y]),
                [points[points.length - 2], points[points.length - 1]]
              ];
              switch (adjustType) {
                case "start":
                  {
                    linkPoints[0] = [(sx - rx) / graph.scaleX(), (sy - ry) / graph.scaleY()];
                    line.points(lodash.flatten(linkPoints));
                  }
                  break;
                case "end":
                  {
                    linkPoints[linkPoints.length - 1] = [
                      (sx - rx) / graph.scaleX(),
                      (sy - ry) / graph.scaleY()
                    ];
                    line.points(lodash.flatten(linkPoints));
                  }
                  break;
              }
            }
          }
        }
      }
      _Line.updateAnchor(render22, graph);
      _Line.updateAnchorShadows(graph, anchors, line);
      _Line.updateLinkAnchorShadows(graph, linkAnchors, line);
      for (const anchor of anchors) {
        for (const { shape } of anchorAndShadows) {
          if (shape) {
            if (((_f = shape.attrs.anchor) == null ? void 0 : _f.adjustType) === anchor.attrs.adjustType) {
              const anchorShadow = graph.find(`.anchor`).find((o) => o.attrs.adjustType === anchor.attrs.adjustType);
              if (anchorShadow) {
                shape.position({
                  x: render22.toStageValue(anchorShadow.getAbsolutePosition().x - stageState.x),
                  y: render22.toStageValue(anchorShadow.getAbsolutePosition().y - stageState.y)
                });
                shape.rotation(graph.getAbsoluteRotation());
              }
            }
          }
        }
      }
      render22.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
    }
    BaseGraph.adjust(
      render22,
      graph,
      graphSnap,
      adjustShape,
      anchorAndShadows,
      startPoint,
      endPoint,
      hoverRect,
      line.size(),
      {
        x: Math.min(
          ...line.points().reduce((arr, item, idx) => {
            if (idx % 2 === 0) {
              arr.push(item);
            }
            return arr;
          }, [])
        ),
        y: Math.min(
          ...line.points().reduce((arr, item, idx) => {
            if (idx % 2 === 1) {
              arr.push(item);
            }
            return arr;
          }, [])
        )
      }
    );
  }
  /**
   * 提供给 GraphDraw draw 使用
   */
  static draw(graph, render22, adjustAnchor) {
    const anchors = graph.attrs.anchors ?? [];
    const anchorShapes = graph.find(`.anchor`);
    const anchorAndShadows = anchors.map((anchor) => ({
      anchor,
      anchorShadow: anchorShapes.find(
        (shape) => shape.attrs.adjustType === anchor.adjustType && shape.attrs.manualIndex === anchor.manualIndex
      )
    })).filter((o) => o.anchorShadow !== void 0);
    return _Line.createAnchorShapes(render22, graph, anchorAndShadows, adjustAnchor);
  }
  // 实现：拖动进行时
  drawMove(point) {
    const offsetX = point.x - this.dropPoint.x, offsetY = point.y - this.dropPoint.y;
    const linkPoints = [
      [this.line.x(), this.line.y()],
      [this.line.x() + offsetX, this.line.y() + offsetY]
    ];
    this.line.points(lodash.flatten(linkPoints));
    _Line.updateAnchorShadows(this.group, this.anchorShadows, this.line);
    _Line.updateLinkAnchorShadows(this.group, this.linkAnchorShadows, this.line);
    this.render.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
  }
  // 实现：拖动结束
  drawEnd() {
    if (this.line.width() <= 10 && this.line.height() <= 10) {
      const width = _Line.size, height = width;
      const linkPoints = [
        [this.line.x(), this.line.y()],
        [this.line.x() + width, this.line.y() + height]
      ];
      this.line.points(lodash.flatten(linkPoints));
    }
    _Line.updateAnchor(this.render, this.group);
    _Line.updateAnchorShadows(this.group, this.anchorShadows, this.line);
    _Line.updateLinkAnchorShadows(this.group, this.linkAnchorShadows, this.line);
    this.render.attractTool.alignLinesClear();
    this.render.updateHistory();
    this.render.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
    super.drawEnd(this.line.size(), {
      x: Math.min(
        ...this.line.points().reduce((arr, item, idx) => {
          if (idx % 2 === 0) {
            arr.push(item);
          }
          return arr;
        }, [])
      ),
      y: Math.min(
        ...this.line.points().reduce((arr, item, idx) => {
          if (idx % 2 === 1) {
            arr.push(item);
          }
          return arr;
        }, [])
      )
    });
  }
  /**
   * 更新 调整点（拐点）
   * @param render
   * @param graph
   */
  static updateAnchor(render22, graph) {
    const anchors = graph.attrs.anchors ?? [];
    const anchorShadows = graph.find(".anchor") ?? [];
    const shape = graph.findOne(".graph");
    if (shape) {
      let manualPoints = shape.attrs.manualPoints ?? [];
      const points = shape.points();
      const linkPoints = [
        [points[0], points[1]],
        ...manualPoints.sort((a, b) => a.index - b.index).map((o) => [o.x, o.y]),
        [points[points.length - 2], points[points.length - 1]]
      ];
      anchors.splice(2);
      const shadows = anchorShadows.splice(2);
      for (const shadow of shadows) {
        shadow.remove();
        shadow.destroy();
      }
      manualPoints = [];
      for (let i = linkPoints.length - 1; i > 0; i--) {
        linkPoints.splice(i, 0, []);
      }
      for (let i = 1; i < linkPoints.length - 1; i++) {
        const anchor = {
          type: graph.attrs.graphType,
          adjustType: "manual",
          //
          name: "anchor",
          groupId: graph.id(),
          //
          manualIndex: i,
          adjusted: false
        };
        if (linkPoints[i].length === 0) {
          anchor.adjusted = false;
          const prev = linkPoints[i - 1];
          const next = linkPoints[i + 1];
          const circle = new Konva.Circle({
            adjustType: anchor.adjustType,
            anchorType: anchor.type,
            name: anchor.name,
            manualIndex: anchor.manualIndex,
            radius: 0,
            // radius: render.toStageValue(2),
            // fill: 'red',
            //
            x: (prev[0] + next[0]) / 2,
            y: (prev[1] + next[1]) / 2,
            anchor
          });
          graph.add(circle);
        } else {
          anchor.adjusted = true;
          const circle = new Konva.Circle({
            adjustType: anchor.adjustType,
            anchorType: anchor.type,
            name: anchor.name,
            manualIndex: anchor.manualIndex,
            adjusted: true,
            radius: 0,
            // radius: render.toStageValue(2),
            // fill: 'red',
            //
            x: linkPoints[i][0],
            y: linkPoints[i][1],
            anchor
          });
          graph.add(circle);
          manualPoints.push({
            x: linkPoints[i][0],
            y: linkPoints[i][1],
            index: anchor.manualIndex
          });
        }
        anchors.push(anchor);
      }
      shape.setAttr("manualPoints", manualPoints);
      graph.setAttr("anchors", anchors);
    }
  }
  /**
   * 调整之前
   */
  static adjustStart(render22, graph, adjustAnchor, endPoint) {
    const { x: gx, y: gy } = graph.position();
    const shape = graph.findOne(".graph");
    if (shape && typeof adjustAnchor.manualIndex === "number") {
      const manualPoints = shape.attrs.manualPoints ?? [];
      if (adjustAnchor.adjusted)
        ;
      else {
        manualPoints.push({
          x: endPoint.x - gx,
          y: endPoint.y - gy,
          index: adjustAnchor.manualIndex
        });
        shape.setAttr("manualPoints", manualPoints);
      }
      _Line.updateAnchor(render22, graph);
    }
  }
};
/**
 * 默认图形大小
 */
__publicField(_Line, "size", 100);
let Line2 = _Line;
const _Curve = class _Curve extends BaseGraph {
  constructor(render22, dropPoint) {
    super(render22, dropPoint, {
      type: GraphType.Curve,
      // 定义了 2 个 调整点
      anchors: [{ adjustType: "start" }, { adjustType: "end" }].map((o) => ({
        adjustType: o.adjustType
        // 调整点 类型定义
      })),
      linkAnchors: [
        { x: 0, y: 0, alias: "start" },
        { x: 0, y: 0, alias: "end" }
      ]
    });
    /**
     * 曲线 对应的 Konva 实例
     */
    __publicField(this, "line");
    this.line = new Konva.Arrow({
      name: "graph",
      x: 0,
      y: 0,
      stroke: this.render.getPageSettings().stroke,
      strokeWidth: this.render.getPageSettings().strokeWidth,
      fill: this.render.getPageSettings().stroke,
      points: [],
      pointerAtBeginning: false,
      pointerAtEnding: false,
      tension: 0.5
    });
    this.group.size({
      width: 1,
      height: 1
    });
    this.group.add(this.line);
    this.group.position(this.dropPoint);
  }
  // 实现：更新 图形 的 调整点 的 锚点位置
  static updateAnchorShadows(graph, anchorShadows, shape) {
    if (shape) {
      const points = shape.points();
      for (const shadow of anchorShadows) {
        switch (shadow.attrs.adjustType) {
          case "start":
            shadow.position({
              x: points[0],
              y: points[1]
            });
            break;
          case "end":
            shadow.position({
              x: points[points.length - 2],
              y: points[points.length - 1]
            });
            break;
        }
      }
    }
  }
  // 实现：更新 图形 的 连接点 的 锚点位置
  static updateLinkAnchorShadows(graph, linkAnchorShadows, shape) {
    if (shape) {
      const points = shape.points();
      for (const shadow of linkAnchorShadows) {
        switch (shadow.attrs.alias) {
          case "start":
            shadow.position({
              x: points[0],
              y: points[1]
            });
            break;
          case "end":
            shadow.position({
              x: points[points.length - 2],
              y: points[points.length - 1]
            });
            break;
        }
      }
    }
  }
  static calculateAngle(sideA, sideB) {
    const angleInRadians = Math.atan2(sideA, sideB);
    const angleInDegrees = angleInRadians * (180 / Math.PI);
    return angleInDegrees;
  }
  // 实现：生成 调整点
  static createAnchorShapes(render22, graph, anchorAndShadows, adjustAnchor) {
    const stageState = render22.getStageState();
    const graphShape = graph.findOne(".graph");
    if (graphShape) {
      const points = graphShape.points();
      for (const anchorAndShadow of anchorAndShadows) {
        let rotate = 0;
        const { anchor, anchorShadow } = anchorAndShadow;
        const x = render22.toStageValue(anchorShadow.getAbsolutePosition().x - stageState.x), y = render22.toStageValue(anchorShadow.getAbsolutePosition().y - stageState.y);
        if (anchor.adjustType === "manual") {
          const anchorShape = new Konva.Circle({
            name: "anchor",
            anchor,
            //
            fill: anchor.adjusted ? `rgba(0,0,0,0.4)` : `rgba(0,0,255,0.4)`,
            radius: render22.toStageValue(5),
            strokeWidth: 0,
            // 位置
            x,
            y,
            // 旋转角度
            rotation: graph.getAbsoluteRotation(),
            visible: graph.attrs.adjusting || graph.attrs.hover === true
          });
          anchorShape.on("mouseenter", () => {
            document.body.style.cursor = "move";
            graph.setAttr("hover", true);
            graph.setAttr("hoverAnchor", true);
          });
          anchorShape.on("mouseleave", () => {
            document.body.style.cursor = anchorShape.attrs.adjusting ? "move" : "default";
            graph.setAttr("hover", false);
            graph.setAttr("hoverAnchor", false);
            render22.redraw([GraphDraw.name]);
          });
          anchorAndShadow.shape = anchorShape;
        } else {
          if (anchor.adjustType === "start") {
            rotate = _Curve.calculateAngle(points[2] - points[0], points[3] - points[1]);
          } else if (anchor.adjustType === "end") {
            rotate = _Curve.calculateAngle(
              points[points.length - 2] - points[points.length - 4],
              points[points.length - 1] - points[points.length - 3]
            );
          }
          const cos = Math.cos(rotate * Math.PI / 180);
          const sin = Math.sin(rotate * Math.PI / 180);
          const offset = render22.toStageValue(render22.pointSize - 20);
          const offsetX = offset * sin;
          const offsetY = offset * cos;
          const anchorShape = new Konva.Circle({
            name: "anchor",
            anchor,
            //
            fill: `rgba(0,0,255,0.4)`,
            radius: render22.toStageValue(5),
            strokeWidth: 0,
            // 位置
            x,
            y,
            offsetX: anchor.adjustType === "start" ? offsetX : anchor.adjustType === "end" ? -offsetX : 0,
            offsetY: anchor.adjustType === "start" ? offsetY : anchor.adjustType === "end" ? -offsetY : 0,
            // 旋转角度
            rotation: graph.getAbsoluteRotation(),
            visible: graph.attrs.adjusting || graph.attrs.hover === true
          });
          anchorShape.on("mouseenter", () => {
            document.body.style.cursor = "move";
            graph.setAttr("hover", true);
            graph.setAttr("hoverAnchor", true);
          });
          anchorShape.on("mouseleave", () => {
            document.body.style.cursor = anchorShape.attrs.adjusting ? "move" : "default";
            graph.setAttr("hover", false);
            graph.setAttr("hoverAnchor", false);
            render22.redraw([GraphDraw.name]);
          });
          anchorAndShadow.shape = anchorShape;
        }
      }
    }
    return { anchorAndShadows };
  }
  /**
   * 矩阵变换：坐标系中的一个点，围绕着另外一个点进行旋转
   * -  -   -        - -   -   - -
   * |x`|   |cos -sin| |x-a|   |a|
   * |  | = |        | |   | +
   * |y`|   |sin  cos| |y-b|   |b|
   * -  -   -        - -   -   - -
   * @param x 目标节点坐标 x
   * @param y 目标节点坐标 y
   * @param centerX 围绕的点坐标 x
   * @param centerY 围绕的点坐标 y
   * @param angle 旋转角度
   * @returns
   */
  static rotatePoint(x, y, centerX, centerY, angle) {
    const radians = angle * Math.PI / 180;
    const newX = Math.cos(radians) * (x - centerX) - Math.sin(radians) * (y - centerY) + centerX;
    const newY = Math.sin(radians) * (x - centerX) + Math.cos(radians) * (y - centerY) + centerY;
    return { x: newX, y: newY };
  }
  // 实现：调整 图形
  static adjust(render22, graph, graphSnap, adjustShape, anchorAndShadows, startPoint, endPoint, hoverRect) {
    var _a, _b, _c, _d, _e, _f;
    const line = graph.findOne(".graph");
    const lineSnap = graphSnap.findOne(".graph");
    const anchors = graph.find(".anchor") ?? [];
    const anchorsSnap = graphSnap.find(".anchor") ?? [];
    const linkAnchors = graph.find(".link-anchor") ?? [];
    if (line && lineSnap) {
      const stageState = render22.getStageState();
      {
        const [graphRotation, adjustType, ex, ey] = [
          Math.round(graph.rotation()),
          (_a = adjustShape.attrs.anchor) == null ? void 0 : _a.adjustType,
          endPoint.x,
          endPoint.y
        ];
        const { x: cx, y: cy, width: cw, height: ch } = graphSnap.getClientRect();
        const { x, y } = graph.position();
        const [centerX, centerY] = [cx + cw / 2, cy + ch / 2];
        const { x: sx, y: sy } = _Curve.rotatePoint(ex, ey, centerX, centerY, -graphRotation);
        const { x: rx, y: ry } = _Curve.rotatePoint(x, y, centerX, centerY, -graphRotation);
        const points = line.points();
        const manualPoints = line.attrs.manualPoints ?? [];
        if (adjustType === "manual") {
          if (((_b = adjustShape.attrs.anchor) == null ? void 0 : _b.manualIndex) !== void 0) {
            const index = ((_c = adjustShape.attrs.anchor) == null ? void 0 : _c.adjusted) ? (_d = adjustShape.attrs.anchor) == null ? void 0 : _d.manualIndex : ((_e = adjustShape.attrs.anchor) == null ? void 0 : _e.manualIndex) + 1;
            const manualPointIndex = manualPoints.findIndex((o) => o.index === index);
            if (manualPointIndex > -1) {
              manualPoints[manualPointIndex].x = (sx - rx) / graph.scaleX();
              manualPoints[manualPointIndex].y = (sy - ry) / graph.scaleY();
            }
            const linkPoints = [
              [points[0], points[1]],
              ...manualPoints.sort((a, b) => a.index - b.index).map((o) => [o.x, o.y]),
              [points[points.length - 2], points[points.length - 1]]
            ];
            line.setAttr("manualPoints", manualPoints);
            line.points(lodash.flatten(linkPoints));
            const adjustAnchorShadow = anchors.find(
              (o) => o.attrs.adjustType === "manual" && o.attrs.manualIndex === index
            );
            if (adjustAnchorShadow) {
              adjustAnchorShadow.position({
                x: (sx - rx) / graph.scaleX(),
                y: (sy - ry) / graph.scaleY()
              });
            }
          }
        } else {
          const anchor = anchors.find((o) => o.attrs.adjustType === adjustType);
          const anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === adjustType);
          if (anchor && anchorShadow) {
            {
              const linkPoints = [
                [points[0], points[1]],
                ...manualPoints.sort((a, b) => a.index - b.index).map((o) => [o.x, o.y]),
                [points[points.length - 2], points[points.length - 1]]
              ];
              switch (adjustType) {
                case "start":
                  {
                    linkPoints[0] = [(sx - rx) / graph.scaleX(), (sy - ry) / graph.scaleY()];
                    line.points(lodash.flatten(linkPoints));
                  }
                  break;
                case "end":
                  {
                    linkPoints[linkPoints.length - 1] = [
                      (sx - rx) / graph.scaleX(),
                      (sy - ry) / graph.scaleY()
                    ];
                    line.points(lodash.flatten(linkPoints));
                  }
                  break;
              }
            }
          }
        }
      }
      _Curve.updateAnchor(render22, graph);
      _Curve.updateAnchorShadows(graph, anchors, line);
      _Curve.updateLinkAnchorShadows(graph, linkAnchors, line);
      for (const anchor of anchors) {
        for (const { shape } of anchorAndShadows) {
          if (shape) {
            if (((_f = shape.attrs.anchor) == null ? void 0 : _f.adjustType) === anchor.attrs.adjustType) {
              const anchorShadow = graph.find(`.anchor`).find((o) => o.attrs.adjustType === anchor.attrs.adjustType);
              if (anchorShadow) {
                shape.position({
                  x: render22.toStageValue(anchorShadow.getAbsolutePosition().x - stageState.x),
                  y: render22.toStageValue(anchorShadow.getAbsolutePosition().y - stageState.y)
                });
                shape.rotation(graph.getAbsoluteRotation());
              }
            }
          }
        }
      }
      render22.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
    }
    const allXs = line.points().reduce((arr, item, idx) => {
      if (idx % 2 === 0) {
        arr.push(item);
      }
      return arr;
    }, []);
    const allYs = line.points().reduce((arr, item, idx) => {
      if (idx % 2 === 1) {
        arr.push(item);
      }
      return arr;
    }, []);
    const minX = Math.min(...allXs);
    const maxX = Math.max(...allXs);
    const minY = Math.min(...allYs);
    const maxY = Math.max(...allYs);
    BaseGraph.adjust(
      render22,
      graph,
      graphSnap,
      adjustShape,
      anchorAndShadows,
      startPoint,
      endPoint,
      hoverRect,
      {
        width: maxX - minX,
        height: maxY - minY
      },
      {
        x: minX,
        y: minY
      }
    );
  }
  /**
   * 提供给 GraphDraw draw 使用
   */
  static draw(graph, render22, adjustAnchor) {
    const anchors = graph.attrs.anchors ?? [];
    const anchorShapes = graph.find(`.anchor`);
    const anchorAndShadows = anchors.map((anchor) => ({
      anchor,
      anchorShadow: anchorShapes.find(
        (shape) => shape.attrs.adjustType === anchor.adjustType && shape.attrs.manualIndex === anchor.manualIndex
      )
    })).filter((o) => o.anchorShadow !== void 0);
    return _Curve.createAnchorShapes(render22, graph, anchorAndShadows, adjustAnchor);
  }
  // 实现：拖动进行时
  drawMove(point) {
    const offsetX = point.x - this.dropPoint.x, offsetY = point.y - this.dropPoint.y;
    const linkPoints = [
      [this.line.x(), this.line.y()],
      [this.line.x() + offsetX, this.line.y() + offsetY]
    ];
    this.line.points(lodash.flatten(linkPoints));
    _Curve.updateAnchorShadows(this.group, this.anchorShadows, this.line);
    _Curve.updateLinkAnchorShadows(this.group, this.linkAnchorShadows, this.line);
    this.render.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
  }
  // 实现：拖动结束
  drawEnd() {
    if (this.line.width() <= 10 && this.line.height() <= 10) {
      const width = _Curve.size, height = width;
      const linkPoints = [
        [this.line.x(), this.line.y()],
        [this.line.x() + width, this.line.y() + height]
      ];
      this.line.points(lodash.flatten(linkPoints));
    }
    _Curve.updateAnchor(this.render, this.group);
    _Curve.updateAnchorShadows(this.group, this.anchorShadows, this.line);
    _Curve.updateLinkAnchorShadows(this.group, this.linkAnchorShadows, this.line);
    this.render.attractTool.alignLinesClear();
    this.render.updateHistory();
    this.render.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
    super.drawEnd(this.line.size(), {
      x: Math.min(
        ...this.line.points().reduce((arr, item, idx) => {
          if (idx % 2 === 0) {
            arr.push(item);
          }
          return arr;
        }, [])
      ),
      y: Math.min(
        ...this.line.points().reduce((arr, item, idx) => {
          if (idx % 2 === 1) {
            arr.push(item);
          }
          return arr;
        }, [])
      )
    });
  }
  /**
   * 更新 调整点（拐点）
   * @param render
   * @param graph
   */
  static updateAnchor(render22, graph) {
    const anchors = graph.attrs.anchors ?? [];
    const anchorShadows = graph.find(".anchor") ?? [];
    const shape = graph.findOne(".graph");
    if (shape) {
      let manualPoints = shape.attrs.manualPoints ?? [];
      const points = shape.points();
      const linkPoints = [
        [points[0], points[1]],
        ...manualPoints.sort((a, b) => a.index - b.index).map((o) => [o.x, o.y]),
        [points[points.length - 2], points[points.length - 1]]
      ];
      anchors.splice(2);
      const shadows = anchorShadows.splice(2);
      for (const shadow of shadows) {
        shadow.remove();
        shadow.destroy();
      }
      manualPoints = [];
      for (let i = linkPoints.length - 1; i > 0; i--) {
        linkPoints.splice(i, 0, []);
      }
      for (let i = 1; i < linkPoints.length - 1; i++) {
        const anchor = {
          type: graph.attrs.graphType,
          adjustType: "manual",
          //
          name: "anchor",
          groupId: graph.id(),
          //
          manualIndex: i,
          adjusted: false
        };
        if (linkPoints[i].length === 0) {
          anchor.adjusted = false;
          const prev = linkPoints[i - 1];
          const next = linkPoints[i + 1];
          const circle = new Konva.Circle({
            adjustType: anchor.adjustType,
            anchorType: anchor.type,
            name: anchor.name,
            manualIndex: anchor.manualIndex,
            radius: 0,
            // radius: render.toStageValue(2),
            // fill: 'red',
            //
            x: (prev[0] + next[0]) / 2,
            y: (prev[1] + next[1]) / 2,
            anchor
          });
          graph.add(circle);
        } else {
          anchor.adjusted = true;
          const circle = new Konva.Circle({
            adjustType: anchor.adjustType,
            anchorType: anchor.type,
            name: anchor.name,
            manualIndex: anchor.manualIndex,
            adjusted: true,
            radius: 0,
            // radius: render.toStageValue(2),
            // fill: 'red',
            //
            x: linkPoints[i][0],
            y: linkPoints[i][1],
            anchor
          });
          graph.add(circle);
          manualPoints.push({
            x: linkPoints[i][0],
            y: linkPoints[i][1],
            index: anchor.manualIndex
          });
        }
        anchors.push(anchor);
      }
      shape.setAttr("manualPoints", manualPoints);
      graph.setAttr("anchors", anchors);
    }
  }
  /**
   * 调整之前
   */
  static adjustStart(render22, graph, adjustAnchor, endPoint) {
    const { x: gx, y: gy } = graph.position();
    const shape = graph.findOne(".graph");
    if (shape && typeof adjustAnchor.manualIndex === "number") {
      const manualPoints = shape.attrs.manualPoints ?? [];
      if (adjustAnchor.adjusted)
        ;
      else {
        manualPoints.push({
          x: endPoint.x - gx,
          y: endPoint.y - gy,
          index: adjustAnchor.manualIndex
        });
        shape.setAttr("manualPoints", manualPoints);
      }
      _Curve.updateAnchor(render22, graph);
    }
  }
};
/**
 * 默认图形大小
 */
__publicField(_Curve, "size", 100);
let Curve = _Curve;
const _GraphDraw = class _GraphDraw extends BaseDraw {
  constructor(render22, layer, option) {
    super(render22, layer);
    __publicField(this, "option");
    __publicField(this, "on", {});
    __publicField(this, "state", {
      adjusting: false,
      adjustGroupId: "",
      startPointCurrent: { x: 0, y: 0 }
    });
    this.option = option;
    this.group.name(this.constructor.name);
  }
  /**
   * 获取鼠标位置，并处理为 相对大小
   * @param attract 含磁贴计算
   * @returns
   */
  getStagePoint(attract = false) {
    const pos = this.render.stage.getPointerPosition();
    if (pos) {
      const stageState = this.render.getStageState();
      if (attract) {
        const { pos: transformerPos } = this.render.attractTool.attractPoint(pos);
        return {
          x: this.render.toStageValue(transformerPos.x - stageState.x),
          y: this.render.toStageValue(transformerPos.y - stageState.y)
        };
      } else {
        return {
          x: this.render.toStageValue(pos.x - stageState.x),
          y: this.render.toStageValue(pos.y - stageState.y)
        };
      }
    }
    return null;
  }
  draw() {
    this.clear();
    const graphs = this.render.layer.find(".asset").filter((o) => o.attrs.assetType === AssetType.Graph);
    for (const graph of graphs) {
      if (!graph.attrs.selected) {
        let anchorAndShadows = [];
        switch (graph.attrs.graphType) {
          case GraphType.Circle:
            {
              const res = Circle2.draw(graph, this.render, this.state.adjustAnchor);
              anchorAndShadows = res.anchorAndShadows;
            }
            break;
          case GraphType.Rect:
            {
              const res = Rect2.draw(graph, this.render, this.state.adjustAnchor);
              anchorAndShadows = res.anchorAndShadows;
            }
            break;
          case GraphType.Line:
            {
              const res = Line2.draw(graph, this.render, this.state.adjustAnchor);
              anchorAndShadows = res.anchorAndShadows;
            }
            break;
          case GraphType.Curve:
            {
              const res = Curve.draw(graph, this.render, this.state.adjustAnchor);
              anchorAndShadows = res.anchorAndShadows;
            }
            break;
        }
        for (const anchorAndShadow of anchorAndShadows) {
          const { shape } = anchorAndShadow;
          if (shape) {
            shape.on("mousedown", () => {
              var _a;
              const pos = this.getStagePoint();
              if (pos) {
                this.state.adjusting = true;
                this.state.adjustAnchor = shape.attrs.anchor;
                this.state.adjustGroupId = graph.id();
                this.state.startPointCurrent = pos;
                this.state.graphCurrent = graph;
                this.state.graphCurrentSnap = graph.clone();
                graph.setAttr("adjusting", true);
                shape.setAttr("adjusting", true);
                if (this.state.adjustAnchor) {
                  switch ((_a = shape.attrs.anchor) == null ? void 0 : _a.type) {
                    case GraphType.Line:
                      Line2.adjustStart(this.render, graph, this.state.adjustAnchor, pos);
                      break;
                    case GraphType.Curve:
                      Curve.adjustStart(this.render, graph, this.state.adjustAnchor, pos);
                      break;
                  }
                }
              }
            });
            this.render.stage.on("mousemove", () => {
              var _a;
              if (this.state.adjusting && this.state.graphCurrent && this.state.graphCurrentSnap) {
                if (shape.attrs.adjusting) {
                  const pos = this.getStagePoint(true);
                  if (pos) {
                    switch ((_a = shape.attrs.anchor) == null ? void 0 : _a.type) {
                      case GraphType.Circle:
                        Circle2.adjust(
                          this.render,
                          graph,
                          this.state.graphCurrentSnap,
                          shape,
                          anchorAndShadows,
                          this.state.startPointCurrent,
                          pos,
                          graph.findOne(".hoverRect")
                        );
                        break;
                      case GraphType.Rect:
                        Rect2.adjust(
                          this.render,
                          graph,
                          this.state.graphCurrentSnap,
                          shape,
                          anchorAndShadows,
                          this.state.startPointCurrent,
                          pos,
                          graph.findOne(".hoverRect")
                        );
                        break;
                      case GraphType.Line:
                        Line2.adjust(
                          this.render,
                          graph,
                          this.state.graphCurrentSnap,
                          shape,
                          anchorAndShadows,
                          this.state.startPointCurrent,
                          pos,
                          graph.findOne(".hoverRect")
                        );
                        break;
                      case GraphType.Curve:
                        Curve.adjust(
                          this.render,
                          graph,
                          this.state.graphCurrentSnap,
                          shape,
                          anchorAndShadows,
                          this.state.startPointCurrent,
                          pos,
                          graph.findOne(".hoverRect")
                        );
                        break;
                    }
                    this.render.redraw([
                      _GraphDraw.name,
                      LinkDraw.name,
                      PreviewDraw.name
                    ]);
                  }
                }
              }
            });
            this.render.stage.on("mouseup", () => {
              var _a;
              graph.setAttr("adjusting", false);
              graph.setAttr("hover", false);
              graph.setAttr("hoverAnchor", false);
              if (this.state.adjusting) {
                this.render.updateHistory();
                this.render.redraw([
                  _GraphDraw.name,
                  LinkDraw.name,
                  PreviewDraw.name
                ]);
              }
              this.state.adjusting = false;
              this.state.adjustAnchor = void 0;
              this.state.adjustGroupId = "";
              for (const { shape: shape2 } of anchorAndShadows) {
                if (shape2) {
                  shape2.setAttr("adjusting", false);
                }
              }
              document.body.style.cursor = "default";
              (_a = this.state.graphCurrentSnap) == null ? void 0 : _a.destroy();
              this.render.attractTool.alignLinesClear();
            });
            this.group.add(shape);
          }
        }
      }
    }
  }
};
__publicField(_GraphDraw, "name", "Graph");
let GraphDraw = _GraphDraw;
class DragHandlers {
  constructor(render22) {
    __publicField(this, "render");
    // 右键是否按下
    __publicField(this, "mousedownRight", false);
    // 右键按下 stage 位置
    __publicField(this, "mousedownStagePos", { x: 0, y: 0 });
    // 右键按下位置
    __publicField(this, "mousedownPointerPos", { x: 0, y: 0 });
    __publicField(this, "handlers", {
      stage: {
        mousedown: (e) => {
          var _a;
          if (!((_a = this.render.draws[LinkDraw.name]) == null ? void 0 : _a.state.linkManualing) && !this.render.graphType) {
            if (e.evt.button === MouseButton.右键 || e.evt.ctrlKey && e.evt.button === MouseButton.左键) {
              const stageState = this.render.getStageState();
              this.mousedownRight = true;
              this.render.changeDraggable(false);
              this.mousedownStagePos = { x: stageState.x, y: stageState.y };
              const pos = this.render.stage.getPointerPosition();
              if (pos) {
                this.mousedownPointerPos = { x: pos.x, y: pos.y };
              }
              document.body.style.cursor = "pointer";
            }
          }
        },
        mouseup: () => {
          this.mousedownRight = false;
          this.render.changeDraggable(!this.render.config.readonly);
          document.body.style.cursor = "default";
        },
        mousemove: () => {
          if (this.mousedownRight) {
            const pos = this.render.stage.getPointerPosition();
            if (pos) {
              const offsetX = pos.x - this.mousedownPointerPos.x;
              const offsetY = pos.y - this.mousedownPointerPos.y;
              this.render.stage.position({
                x: this.mousedownStagePos.x + offsetX,
                y: this.mousedownStagePos.y + offsetY
              });
              this.render.redraw([
                BgDraw.name,
                GraphDraw.name,
                LinkDraw.name,
                RulerDraw.name,
                PreviewDraw.name
              ]);
            }
          }
        }
      }
    });
    this.render = render22;
  }
}
__publicField(DragHandlers, "name", "Drag");
class ZoomHandlers {
  constructor(render22) {
    __publicField(this, "render");
    // zoom 速度
    __publicField(this, "scaleBy", 0.1);
    // zoom 范围
    __publicField(this, "scaleMin", 0.2);
    __publicField(this, "scaleMax", 5);
    __publicField(this, "handlers", {
      stage: {
        wheel: (e) => {
          const stageState = this.render.getStageState();
          const oldScale = stageState.scale;
          const pos = this.render.stage.getPointerPosition();
          if (pos) {
            const mousePointTo = {
              x: (pos.x - stageState.x) / oldScale,
              y: (pos.y - stageState.y) / oldScale
            };
            const direction = e.evt.deltaY > 0 ? -1 : 1;
            const newScale = direction > 0 ? oldScale + this.scaleBy : oldScale - this.scaleBy;
            if (newScale >= this.scaleMin && newScale < this.scaleMax) {
              this.render.stage.scale({ x: newScale, y: newScale });
              this.render.emit("scale-change", newScale);
              this.render.stage.position({
                x: pos.x - mousePointTo.x * newScale,
                y: pos.y - mousePointTo.y * newScale
              });
              this.render.redraw([
                BgDraw.name,
                GraphDraw.name,
                LinkDraw.name,
                RulerDraw.name,
                RefLineDraw.name,
                PreviewDraw.name
              ]);
            }
          }
        }
      }
    });
    this.render = render22;
  }
}
__publicField(ZoomHandlers, "name", "Zoom");
class DragOutsideHandlers {
  constructor(render22) {
    __publicField(this, "render");
    __publicField(this, "handlers", {
      dom: {
        dragenter: (e) => {
          this.render.stage.setPointersPositions(e);
          this.render.redraw([RefLineDraw.name]);
        },
        dragover: (e) => {
          this.render.stage.setPointersPositions(e);
          this.render.redraw([RefLineDraw.name]);
        },
        drop: (e) => {
          var _a, _b, _c;
          const src = (_a = e.dataTransfer) == null ? void 0 : _a.getData("src");
          let morePoints = [];
          const morePointsTxt = ((_b = e.dataTransfer) == null ? void 0 : _b.getData("points")) ?? "[]";
          try {
            morePoints = JSON.parse(morePointsTxt);
          } catch (e2) {
            console.error(e2);
          }
          const type4 = (_c = e.dataTransfer) == null ? void 0 : _c.getData("type");
          if (src && type4) {
            const stageState = this.render.getStageState();
            this.render.stage.setPointersPositions(e);
            const pos = this.render.stage.getPointerPosition();
            if (pos) {
              this.render.assetTool[type4 === ImageType.svg ? `loadSvg` : type4 === ImageType.gif ? "loadGif" : type4 === "json" ? "loadJson" : "loadImg"](src).then((target) => {
                let group = null;
                let points = [];
                if (target instanceof Konva.Image) {
                  group = new Konva.Group({
                    id: nanoid(),
                    width: target.width(),
                    height: target.height(),
                    name: "asset",
                    assetType: AssetType.Image,
                    draggable: true,
                    imageType: type4 !== "json" ? type4 === ImageType.svg ? ImageType.svg : type4 === ImageType.gif ? ImageType.gif : ImageType.other : void 0
                  });
                  this.render.setAssetSettings(group, this.render.getAssetSettings(), false);
                  group.add(target);
                  points = [
                    // 左
                    { x: 0, y: group.height() / 2, direction: "left" },
                    // 右
                    {
                      x: group.width(),
                      y: group.height() / 2,
                      direction: "right"
                    },
                    // 上
                    { x: group.width() / 2, y: 0, direction: "top" },
                    // 下
                    {
                      x: group.width() / 2,
                      y: group.height(),
                      direction: "bottom"
                    }
                  ];
                } else {
                  target.id(nanoid());
                  target.setAttrs({
                    name: "asset",
                    assetType: AssetType.Json,
                    draggable: true
                  });
                  group = target;
                  this.render.linkTool.groupIdCover(group);
                }
                target.setAttrs({
                  x: 0,
                  y: 0
                });
                this.render.layer.add(group);
                const x = this.render.toStageValue(pos.x - stageState.x) - group.width() / 2;
                const y = this.render.toStageValue(pos.y - stageState.y) - group.height() / 2;
                group.setAttrs({
                  x,
                  y
                });
                this.render.setAssetSettings(group, this.render.getAssetSettings(group), false);
                if (Array.isArray(morePoints) && morePoints.length > 0) {
                  points = morePoints;
                }
                group.setAttrs({
                  points: points.map(
                    (o) => ({
                      ...o,
                      id: nanoid(),
                      groupId: group.id(),
                      visible: false,
                      pairs: [],
                      direction: o.direction
                    })
                  )
                });
                for (const point of group.getAttr("points") ?? []) {
                  group.add(
                    new Konva.Circle({
                      name: "link-anchor",
                      id: point.id,
                      x: point.x,
                      y: point.y,
                      radius: this.render.toStageValue(1),
                      stroke: "rgba(0,0,255,1)",
                      strokeWidth: this.render.toStageValue(2),
                      visible: false,
                      direction: point.direction
                    })
                  );
                }
                group.on("mouseenter", () => {
                  this.render.linkTool.pointsVisible(true, group);
                });
                group.add(
                  new Konva.Rect({
                    id: "hoverRect",
                    width: target.width(),
                    height: target.height(),
                    fill: "rgba(0,255,0,0.3)",
                    visible: false
                  })
                );
                group.on("mouseleave", () => {
                  var _a2;
                  this.render.linkTool.pointsVisible(false, group);
                  (_a2 = group.findOne("#hoverRect")) == null ? void 0 : _a2.visible(false);
                });
                this.render.updateHistory();
                this.render.redraw([PreviewDraw.name]);
              });
            }
          }
        }
      }
    });
    this.render = render22;
  }
}
__publicField(DragOutsideHandlers, "name", "DragOutside");
class SelectionHandlers {
  constructor(render22) {
    __publicField(this, "render");
    // selectRect 拉动的开始和结束坐标
    __publicField(this, "selectRectStartX", 0);
    __publicField(this, "selectRectStartY", 0);
    __publicField(this, "selectRectEndX", 0);
    __publicField(this, "selectRectEndY", 0);
    // 是否正在使用 selectRect
    __publicField(this, "selecting", false);
    // 拖动前的位置
    __publicField(this, "transformerMousedownPos", { x: 0, y: 0 });
    // 对齐线
    __publicField(this, "alignLines", []);
    __publicField(this, "lastRotation", 0);
    __publicField(this, "handlers", {
      // 选择相关
      stage: {
        mousedown: (e) => {
          if (!this.render.graphType) {
            const parent2 = e.target.getParent();
            if (e.target === this.render.stage) {
              this.render.selectionTool.selectingClear();
              this.render.linkTool.selectingClear();
              if (e.evt.button === MouseButton.左键 && !e.evt.ctrlKey) {
                const pos = this.render.stage.getPointerPosition();
                if (pos) {
                  this.selectRectStartX = pos.x;
                  this.selectRectStartY = pos.y;
                  this.selectRectEndX = pos.x;
                  this.selectRectEndY = pos.y;
                }
                this.render.selectRect.width(0);
                this.render.selectRect.height(0);
                this.selecting = true;
              }
              this.render.linkTool.pointsVisible(false);
            } else if (parent2 instanceof Konva.Transformer)
              ;
            else if (parent2 instanceof Konva.Group) {
              if (e.evt.button === MouseButton.左键 && !e.evt.ctrlKey) {
                if (!this.render.ignore(parent2) && !this.render.ignoreDraw(e.target)) {
                  if (e.evt.ctrlKey || e.evt.metaKey) {
                    this.render.selectionTool.select([
                      ...this.render.selectionTool.selectingNodes,
                      parent2
                    ]);
                  } else {
                    this.render.selectionTool.select([parent2]);
                    const rect = parent2.getClientRect();
                    this.transformerMousedownPos = { x: rect.x, y: rect.y };
                  }
                }
              } else {
                this.render.selectionTool.selectingClear();
              }
            }
          }
        },
        mousemove: () => {
          const stageState = this.render.getStageState();
          if (this.selecting) {
            const pos = this.render.stage.getPointerPosition();
            if (pos) {
              this.selectRectEndX = pos.x;
              this.selectRectEndY = pos.y;
            }
            this.render.selectRect.setAttrs({
              visible: true,
              // 显示
              x: this.render.toStageValue(
                Math.min(this.selectRectStartX, this.selectRectEndX) - stageState.x
              ),
              y: this.render.toStageValue(
                Math.min(this.selectRectStartY, this.selectRectEndY) - stageState.y
              ),
              width: this.render.toStageValue(Math.abs(this.selectRectEndX - this.selectRectStartX)),
              height: this.render.toStageValue(Math.abs(this.selectRectEndY - this.selectRectStartY))
            });
          }
        },
        mouseup: () => {
          const box = this.render.selectRect.getClientRect();
          if (box.width > 0 && box.height > 0) {
            const shapes = this.render.layer.getChildren((node) => {
              return !this.render.ignore(node);
            });
            const selected = shapes.filter(
              (shape) => (
                // 关键 api
                Konva.Util.haveIntersection(box, shape.getClientRect())
              )
            );
            this.render.selectionTool.select(selected);
          }
          this.render.selectRect.setAttrs({
            visible: false,
            // 隐藏
            x: 0,
            y: 0,
            width: 0,
            height: 0
          });
          this.selecting = false;
        }
      },
      transformer: {
        // 记录初始状态
        mousedown: (e) => {
          const anchor = this.render.transformer.getActiveAnchor();
          if (!anchor) {
            if (e.evt.ctrlKey || e.evt.metaKey) {
              if (this.render.selectionTool.selectingNodes.length > 0) {
                const pos = this.render.stage.getPointerPosition();
                if (pos) {
                  const keeps = [];
                  const removes = [];
                  let finded = false;
                  for (const node of this.render.selectionTool.selectingNodes.sort(
                    (a, b) => b.zIndex() - a.zIndex()
                  )) {
                    if (!finded && Konva.Util.haveIntersection(node.getClientRect(), {
                      ...pos,
                      width: 1,
                      height: 1
                    })) {
                      removes.unshift(node);
                      finded = true;
                    } else {
                      keeps.unshift(node);
                    }
                  }
                  if (removes.length > 0) {
                    this.render.selectionTool.select(keeps);
                  } else {
                    let finded2 = false;
                    const adds = [];
                    for (const node of this.render.layer.getChildren().filter((node2) => !this.render.ignore(node2)).sort((a, b) => b.zIndex() - a.zIndex())) {
                      if (!finded2 && Konva.Util.haveIntersection(node.getClientRect(), {
                        ...pos,
                        width: 1,
                        height: 1
                      })) {
                        adds.unshift(node);
                        finded2 = true;
                      }
                    }
                    if (adds.length > 0) {
                      this.render.selectionTool.select([
                        ...this.render.selectionTool.selectingNodes,
                        ...adds
                      ]);
                    }
                  }
                }
              }
            } else {
              if (this.render.selectionTool.selectingNodes.length > 0) {
                this.reset();
              }
            }
          } else {
            this.reset();
          }
        },
        transformstart: () => {
          const back = this.render.transformer.findOne(".back");
          if (back) {
            this.lastRotation = back.getAbsoluteRotation();
          }
        },
        transform: () => {
          const back = this.render.transformer.findOne(".back");
          if (back) {
            const stageState = this.render.getStageState();
            const { x, y, width, height } = back.getClientRect();
            const rotation = back.getAbsoluteRotation() - this.lastRotation;
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            const groups = this.render.transformer.nodes();
            const points = groups.reduce((ps, group) => {
              return ps.concat(Array.isArray(group.getAttr("points")) ? group.getAttr("points") : []);
            }, []);
            const pairs = points.reduce((ps, point) => {
              return ps.concat(point.pairs ? point.pairs.filter((o) => !o.disabled) : []);
            }, []);
            for (const pair of pairs) {
              const fromGroup = groups.find((o) => o.id() === pair.from.groupId);
              const toGroup = groups.find((o) => o.id() === pair.to.groupId);
              if (fromGroup && toGroup) {
                if (fromGroup.attrs.manualPointsMap && fromGroup.attrs.manualPointsMapBefore) {
                  let manualPoints = fromGroup.attrs.manualPointsMap[pair.id];
                  const manualPointsBefore = fromGroup.attrs.manualPointsMapBefore[pair.id];
                  if (Array.isArray(manualPoints) && Array.isArray(manualPointsBefore)) {
                    manualPoints = manualPointsBefore.map((o) => {
                      const { x: x2, y: y2 } = this.rotatePoint(
                        this.render.toBoardValue(o.x) + stageState.x,
                        this.render.toBoardValue(o.y) + stageState.y,
                        centerX,
                        centerY,
                        rotation
                      );
                      return {
                        x: this.render.toStageValue(x2 - stageState.x),
                        y: this.render.toStageValue(y2 - stageState.y)
                      };
                    });
                    fromGroup.setAttr("manualPointsMap", {
                      ...fromGroup.attrs.manualPointsMap,
                      [pair.id]: manualPoints
                    });
                  }
                }
              }
            }
            for (const group of groups) {
              this.render.setAssetSettings(group, this.render.getAssetSettings(group), false);
            }
            this.render.emit("asset-position-change", groups);
            this.render.emit("asset-rotation-change", groups);
          }
          this.render.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
        },
        transformend: () => {
          this.reset();
          this.render.updateHistory();
          this.render.redraw([GraphDraw.name, LinkDraw.name, PreviewDraw.name]);
        },
        //
        dragstart: () => {
        },
        // 拖动
        dragmove: () => {
          const rect = this.render.transformer.findOne(".back").getClientRect();
          const { pos: transformerPos, isAttract } = this.render.attractTool.attractTransformer(rect);
          if (isAttract) {
            this.selectingNodesPositionByOffset({
              x: this.render.toStageValue(transformerPos.x - this.transformerMousedownPos.x),
              y: this.render.toStageValue(transformerPos.y - this.transformerMousedownPos.y)
            });
          }
          const groups = this.render.transformer.nodes();
          const points = groups.reduce((ps, group) => {
            return ps.concat(Array.isArray(group.getAttr("points")) ? group.getAttr("points") : []);
          }, []);
          const pairs = points.reduce((ps, point) => {
            return ps.concat(point.pairs ? point.pairs.filter((o) => !o.disabled) : []);
          }, []);
          for (const pair of pairs) {
            const fromGroup = groups.find((o) => o.id() === pair.from.groupId);
            const toGroup = groups.find((o) => o.id() === pair.to.groupId);
            if (fromGroup && toGroup) {
              if (fromGroup.attrs.manualPointsMap && fromGroup.attrs.manualPointsMapBefore) {
                let manualPoints = fromGroup.attrs.manualPointsMap[pair.id];
                const manualPointsBefore = fromGroup.attrs.manualPointsMapBefore[pair.id];
                if (Array.isArray(manualPoints) && Array.isArray(manualPointsBefore)) {
                  manualPoints = isAttract ? manualPointsBefore.map(
                    (o) => ({
                      x: o.x + this.render.toStageValue(
                        transformerPos.x - this.transformerMousedownPos.x
                      ),
                      y: o.y + this.render.toStageValue(
                        transformerPos.y - this.transformerMousedownPos.y
                      )
                    })
                  ) : manualPointsBefore.map(
                    (o) => ({
                      x: o.x + this.render.toStageValue(rect.x - this.transformerMousedownPos.x),
                      y: o.y + this.render.toStageValue(rect.y - this.transformerMousedownPos.y)
                    })
                  );
                  fromGroup.setAttr("manualPointsMap", {
                    ...fromGroup.attrs.manualPointsMap,
                    [pair.id]: manualPoints
                  });
                }
              }
            }
          }
          for (const group of groups) {
            this.render.setAssetSettings(group, this.render.getAssetSettings(group), false);
          }
          this.render.emit("asset-position-change", groups);
          this.render.redraw([
            GraphDraw.name,
            LinkDraw.name,
            RulerDraw.name,
            PreviewDraw.name
          ]);
        },
        dragend: () => {
          this.reset();
          this.render.updateHistory();
          this.render.redraw([
            GraphDraw.name,
            LinkDraw.name,
            RulerDraw.name,
            PreviewDraw.name
          ]);
        },
        // 子节点 hover
        mousemove: () => {
          var _a, _b;
          const pos = this.render.stage.getPointerPosition();
          if (pos) {
            const shapes = this.render.transformer.nodes();
            for (const shape of shapes) {
              if (shape instanceof Konva.Group) {
                (_a = shape.findOne("#hoverRect")) == null ? void 0 : _a.visible(false);
              }
            }
            if (shapes.length > 1) {
              shapes.sort((a, b) => b.zIndex() - a.zIndex());
              const selected = shapes.find(
                (shape) => (
                  // 关键 api
                  Konva.Util.haveIntersection({ ...pos, width: 1, height: 1 }, shape.getClientRect())
                )
              );
              if (selected) {
                if (selected instanceof Konva.Group) {
                  (_b = selected.findOne("#hoverRect")) == null ? void 0 : _b.visible(true);
                }
              }
            }
          }
        },
        mouseleave: () => {
          var _a;
          for (const shape of this.render.transformer.nodes()) {
            if (shape instanceof Konva.Group) {
              (_a = shape.findOne("#hoverRect")) == null ? void 0 : _a.visible(false);
            }
          }
        }
      }
    });
    // transformer config
    __publicField(this, "transformerConfig", {
      // 变换中
      anchorDragBoundFunc: (oldPos, newPos) => {
        if (!this.render.config.readonly && this.render.config.attractResize) {
          const anchor = this.render.transformer.getActiveAnchor();
          if (anchor && anchor !== "rotater") {
            const stageState = this.render.getStageState();
            const logicX = this.render.toStageValue(newPos.x - stageState.x);
            const logicNumX = Math.round(logicX / this.render.bgSize);
            const logicClosestX = logicNumX * this.render.bgSize;
            const logicDiffX = Math.abs(logicX - logicClosestX);
            const snappedX = /-(left|right)$/.test(anchor) && logicDiffX < 5;
            const logicY = this.render.toStageValue(newPos.y - stageState.y);
            const logicNumY = Math.round(logicY / this.render.bgSize);
            const logicClosestY = logicNumY * this.render.bgSize;
            const logicDiffY = Math.abs(logicY - logicClosestY);
            const snappedY = /^(top|bottom)-/.test(anchor) && logicDiffY < 5;
            if (snappedX && !snappedY) {
              return {
                x: this.render.toBoardValue(logicClosestX) + stageState.x,
                y: oldPos.y
              };
            } else if (snappedY && !snappedX) {
              return {
                x: oldPos.x,
                y: this.render.toBoardValue(logicClosestY) + stageState.y
              };
            } else if (snappedX && snappedY) {
              return {
                x: this.render.toBoardValue(logicClosestX) + stageState.x,
                y: this.render.toBoardValue(logicClosestY) + stageState.y
              };
            }
          }
        }
        return newPos;
      }
    });
    this.render = render22;
  }
  // 对齐线清除
  alignLinesClear() {
    for (const line of this.alignLines) {
      line.destroy();
    }
    this.alignLines = [];
  }
  // 通过偏移量移动【目标节点】
  selectingNodesPositionByOffset(offset) {
    for (const node of this.render.selectionTool.selectingNodes) {
      if (node.attrs.nodeMousedownPos) {
        const x = node.attrs.nodeMousedownPos.x + offset.x;
        const y = node.attrs.nodeMousedownPos.y + offset.y;
        node.x(x);
        node.y(y);
      }
    }
  }
  // 重置【目标节点】的 nodeMousedownPos
  selectingNodesPositionReset() {
    for (const node of this.render.selectionTool.selectingNodes) {
      if (node.attrs.nodeMousedownPos) {
        node.attrs.nodeMousedownPos.x = node.x();
        node.attrs.nodeMousedownPos.y = node.y();
      }
    }
  }
  // 重置 transformer 状态
  transformerStateReset() {
    const rect = this.render.transformer.findOne(".back").getClientRect();
    this.transformerMousedownPos = { x: rect.x, y: rect.y };
    const groups = this.render.transformer.nodes();
    const points = groups.reduce((ps, group) => {
      return ps.concat(Array.isArray(group.getAttr("points")) ? group.getAttr("points") : []);
    }, []);
    const pairs = points.reduce((ps, point) => {
      return ps.concat(point.pairs ? point.pairs.filter((o) => !o.disabled) : []);
    }, []);
    for (const pair of pairs) {
      const fromGroup = groups.find((o) => o.id() === pair.from.groupId);
      const toGroup = groups.find((o) => o.id() === pair.to.groupId);
      if (fromGroup && toGroup) {
        fromGroup.setAttr(
          "manualPointsMapBefore",
          fromGroup.getAttr("manualPointsMap") ?? {}
        );
      }
    }
  }
  // 重置
  reset() {
    this.render.attractTool.alignLinesClear();
    this.transformerStateReset();
    this.selectingNodesPositionReset();
  }
  /**
   * 矩阵变换：坐标系中的一个点，围绕着另外一个点进行旋转
   * -  -   -        - -   -   - -
   * |x`|   |cos -sin| |x-a|   |a|
   * |  | = |        | |   | +
   * |y`|   |sin  cos| |y-b|   |b|
   * -  -   -        - -   -   - -
   * @param x 目标节点坐标 x
   * @param y 目标节点坐标 y
   * @param centerX 围绕的点坐标 x
   * @param centerY 围绕的点坐标 y
   * @param angle 旋转角度
   * @returns
   */
  rotatePoint(x, y, centerX, centerY, angle) {
    const radians = angle * Math.PI / 180;
    const newX = Math.cos(radians) * (x - centerX) - Math.sin(radians) * (y - centerY) + centerX;
    const newY = Math.sin(radians) * (x - centerX) + Math.cos(radians) * (y - centerY) + centerY;
    return { x: newX, y: newY };
  }
}
__publicField(SelectionHandlers, "name", "Selection");
class KeyMoveHandlers {
  constructor(render22) {
    __publicField(this, "render");
    __publicField(this, "speed", 1);
    __publicField(this, "speedMax", 20);
    __publicField(this, "change", lodash.debounce(() => {
      this.render.updateHistory();
    }, 200));
    __publicField(this, "handlers", {
      dom: {
        keydown: (e) => {
          if (!e.ctrlKey) {
            if (Object.values(MoveKey).map((o) => o.toString()).includes(e.code)) {
              if (e.code === MoveKey.上) {
                this.render.selectionTool.selectingNodesMove({ x: 0, y: -this.speed });
              } else if (e.code === MoveKey.左) {
                this.render.selectionTool.selectingNodesMove({ x: -this.speed, y: 0 });
              } else if (e.code === MoveKey.右) {
                this.render.selectionTool.selectingNodesMove({ x: this.speed, y: 0 });
              } else if (e.code === MoveKey.下) {
                this.render.selectionTool.selectingNodesMove({ x: 0, y: this.speed });
              }
              if (this.speed < this.speedMax) {
                this.speed++;
              }
              this.change();
              this.render.redraw([
                GraphDraw.name,
                LinkDraw.name,
                AttractDraw.name,
                RulerDraw.name,
                PreviewDraw.name
              ]);
            }
          }
        },
        keyup: () => {
          this.speed = 1;
        }
      }
    });
    this.render = render22;
  }
}
__publicField(KeyMoveHandlers, "name", "KeyMove");
class ShutcutHandlers {
  constructor(render22) {
    __publicField(this, "render");
    __publicField(this, "handlers", {
      dom: {
        keydown: (e) => {
          if (!this.render.config.readonly) {
            if (e.ctrlKey || e.metaKey) {
              if (e.code === ShutcutKey.C) {
                this.render.copyTool.pasteStart();
              } else if (e.code === ShutcutKey.V) {
                this.render.copyTool.pasteEnd();
              } else if (e.code === ShutcutKey.Z) {
                if (e.shiftKey) {
                  this.render.nextHistory();
                } else {
                  this.render.prevHistory();
                }
              } else if (e.code === ShutcutKey.A) {
                this.render.selectionTool.selectAll();
              }
            } else if (e.code === ShutcutKey.删除 || e.code === ShutcutKey.Backspace) {
              this.render.remove(this.render.selectionTool.selectingNodes);
              this.render.linkTool.remove();
            } else if (e.code === ShutcutKey.Esc) {
              this.render.selectionTool.selectingClear();
              this.render.linkTool.selectingClear();
            }
          }
          if (e.code === ShutcutKey.R) {
            if (e.ctrlKey || e.metaKey) {
              window.location.reload();
            }
          }
        }
      }
    });
    this.render = render22;
  }
}
__publicField(ShutcutHandlers, "name", "Shutcut");
class LinkHandlers {
  constructor(render22) {
    __publicField(this, "render");
    __publicField(this, "handlers", {
      stage: {
        mouseup: () => {
          var _a, _b;
          const linkDrawState = (_a = this.render.draws[LinkDraw.name]) == null ? void 0 : _a.state;
          if (linkDrawState) {
            (_b = linkDrawState.linkingLine) == null ? void 0 : _b.line.destroy();
            linkDrawState.linkingLine = null;
          }
        },
        mousemove: () => {
          var _a;
          const linkDrawState = (_a = this.render.draws[LinkDraw.name]) == null ? void 0 : _a.state;
          if (linkDrawState) {
            const pos = this.render.stage.getPointerPosition();
            if (pos) {
              const stageState = this.render.getStageState();
              if (linkDrawState.linkingLine) {
                const { circle, line } = linkDrawState.linkingLine;
                line.points(
                  lodash.flatten([
                    [circle.x(), circle.y()],
                    [
                      this.render.toStageValue(pos.x - stageState.x),
                      this.render.toStageValue(pos.y - stageState.y)
                    ]
                  ])
                );
              }
            }
          }
        }
      }
    });
    this.render = render22;
  }
}
__publicField(LinkHandlers, "name", "Link");
class GraphHandlers {
  constructor(render22) {
    __publicField(this, "render");
    /**
     * 新建图形中
     */
    __publicField(this, "graphing", false);
    /**
     * 当前新建图形类型
     */
    __publicField(this, "currentGraph");
    __publicField(this, "handlers", {
      stage: {
        mousedown: (e) => {
          if (this.render.graphType) {
            if (e.target === this.render.stage) {
              this.graphing = true;
              this.render.selectionTool.selectingClear();
              this.render.linkTool.selectingClear();
              const point = this.getStagePoint();
              if (point) {
                if (this.render.graphType === GraphType.Circle) {
                  this.currentGraph = new Circle2(this.render, point);
                } else if (this.render.graphType === GraphType.Rect) {
                  this.currentGraph = new Rect2(this.render, point);
                } else if (this.render.graphType === GraphType.Line) {
                  this.currentGraph = new Line2(this.render, point);
                } else if (this.render.graphType === GraphType.Curve) {
                  this.currentGraph = new Curve(this.render, point);
                }
                if (this.currentGraph) {
                  this.render.setAssetSettings(
                    this.currentGraph.group,
                    this.render.getAssetSettings(this.currentGraph.group),
                    false
                  );
                }
              }
            }
          }
        },
        mousemove: () => {
          if (this.graphing) {
            if (this.currentGraph) {
              const pos = this.getStagePoint(true);
              if (pos) {
                this.currentGraph.drawMove(pos);
              }
            }
          }
        },
        mouseup: () => {
          if (this.graphing) {
            if (this.currentGraph) {
              this.currentGraph.drawEnd();
            }
            this.graphing = false;
            this.render.changeGraphType();
            this.render.attractTool.alignLinesClear();
            this.render.redraw([GraphDraw.name]);
          }
        }
      }
    });
    this.render = render22;
  }
  /**
   * 获取鼠标位置，并处理为 相对大小
   * @param attract 含磁贴计算
   * @returns
   */
  getStagePoint(attract = false) {
    const pos = this.render.stage.getPointerPosition();
    if (pos) {
      const stageState = this.render.getStageState();
      if (attract) {
        const { pos: transformerPos } = this.render.attractTool.attractPoint(pos);
        return {
          x: this.render.toStageValue(transformerPos.x - stageState.x),
          y: this.render.toStageValue(transformerPos.y - stageState.y)
        };
      } else {
        return {
          x: this.render.toStageValue(pos.x - stageState.x),
          y: this.render.toStageValue(pos.y - stageState.y)
        };
      }
    }
    return null;
  }
}
__publicField(GraphHandlers, "name", "Graph");
class TextHandlers {
  constructor(render22) {
    __publicField(this, "render");
    __publicField(this, "group", null);
    __publicField(this, "handlers", {
      stage: {
        mousedown: (e) => {
          if (this.render.texting) {
            if (e.target === this.render.stage) {
              this.render.selectionTool.selectingClear();
              this.render.linkTool.selectingClear();
              const point = this.getStagePoint();
              if (point) {
                this.group = new Konva.Group({
                  id: nanoid(),
                  name: "asset",
                  assetType: AssetType.Text,
                  draggable: false,
                  position: point
                });
                const assetSettings = this.render.getAssetSettings();
                this.group.setAttr("assetSettings", assetSettings);
                const text = new Konva.Text({
                  text: assetSettings.text,
                  fill: assetSettings.textFill,
                  fontSize: assetSettings.fontSize,
                  draggable: false
                });
                const bg = new Konva.Rect({
                  width: text.width(),
                  height: text.height()
                });
                this.group.add(bg);
                this.group.add(text);
                this.render.layer.add(this.group);
              }
            }
          }
        },
        mouseup: () => {
          if (this.group && this.render.texting) {
            this.render.selectionTool.select([this.group]);
          }
          this.render.changeTexting(false);
        }
      },
      transformer: {
        dblclick: () => {
        }
      }
    });
    this.render = render22;
  }
  /**
   * 获取鼠标位置，并处理为 相对大小
   * @param attract 含磁贴计算
   * @returns
   */
  getStagePoint(attract = false) {
    const pos = this.render.stage.getPointerPosition();
    if (pos) {
      const stageState = this.render.getStageState();
      if (attract) {
        const { pos: transformerPos } = this.render.attractTool.attractPoint(pos);
        return {
          x: this.render.toStageValue(transformerPos.x - stageState.x),
          y: this.render.toStageValue(transformerPos.y - stageState.y)
        };
      } else {
        return {
          x: this.render.toStageValue(pos.x - stageState.x),
          y: this.render.toStageValue(pos.y - stageState.y)
        };
      }
    }
    return null;
  }
}
__publicField(TextHandlers, "name", "Text");
const gifler = window.gifler;
class AssetTool {
  constructor(render22) {
    __publicField(this, "render");
    this.render = render22;
  }
  // 加载 svg xml
  async loadSvgXML(svgXML) {
    const blob = new Blob([svgXML], { type: "image/svg+xml" });
    const url2 = URL.createObjectURL(blob);
    return new Promise((resolve) => {
      Konva.Image.fromURL(url2, (imageNode) => {
        imageNode.setAttrs({
          svgXML
        });
        resolve(imageNode);
      });
    });
  }
  // 加载 svg
  async loadSvg(src) {
    const svgXML = await (await fetch(src)).text();
    return this.loadSvgXML(this.render.setSvgXMLSettings(svgXML, this.render.getAssetSettings()));
  }
  // 加载 gif
  async loadGif(src) {
    return new Promise((resolve) => {
      const img = document.createElement("img");
      img.onload = () => {
        const canvas = document.createElement("canvas");
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalWidth;
        img.remove();
        const gif = gifler(src);
        gif.frames(canvas, (ctx2, frame) => {
          var _a;
          ctx2.drawImage(frame.buffer, 0, 0);
          this.render.layer.draw();
          (_a = this.render.draws[PreviewDraw.name]) == null ? void 0 : _a.layer.draw();
        });
        resolve(
          new Konva.Image({
            image: canvas,
            // TODO: 拖动 gif 素材产生大量 JS event listeners
            gif: src
          })
        );
      };
      img.src = src;
    });
  }
  // 加载图片
  async loadImg(src) {
    return new Promise((resolve) => {
      Konva.Image.fromURL(src, (imageNode) => {
        imageNode.setAttrs({ src });
        resolve(imageNode);
      });
    });
  }
  // 加载节点 json
  async loadJson(src) {
    var _a, _b, _c;
    try {
      const json = JSON.parse(await (await fetch(src)).text());
      const assets = json.children;
      this.render.linkTool.jsonIdCover(assets);
      const stageEmpty = new Konva.Stage({
        container: document.createElement("div")
      });
      const layerEmpty = new Konva.Layer();
      stageEmpty.add(layerEmpty);
      const jsonRoot = JSON.parse(stageEmpty.toJSON());
      jsonRoot.children[0].children = [json];
      const stageReload = Konva.Node.create(JSON.stringify(jsonRoot), document.createElement("div"));
      const groupTarget = stageReload.children[0].children[0];
      stageEmpty.destroy();
      groupTarget.remove();
      stageReload.destroy();
      const nodes = [{ target: groupTarget }];
      while (nodes.length > 0) {
        const item = nodes.shift();
        if (item) {
          const node = item.target;
          if (node instanceof Konva.Image) {
            if (node.attrs.svgXML) {
              const n = await this.loadSvgXML(node.attrs.svgXML);
              n.listening(false);
              (_a = node.parent) == null ? void 0 : _a.add(n);
              node.remove();
            } else if (node.attrs.gif) {
              const n = await this.loadGif(node.attrs.gif);
              n.listening(false);
              (_b = node.parent) == null ? void 0 : _b.add(n);
              node.remove();
            } else if (node.attrs.src) {
              const n = await this.loadImg(node.attrs.src);
              n.listening(false);
              (_c = node.parent) == null ? void 0 : _c.add(n);
              node.remove();
            }
          }
          if (node instanceof Konva.Stage || node instanceof Konva.Layer || node instanceof Konva.Group) {
            nodes.push(
              ...node.getChildren().map((o) => ({
                target: o,
                parent: node
              }))
            );
          }
        }
      }
      const clickMask = new Konva.Rect({
        id: "click-mask",
        width: groupTarget.width(),
        height: groupTarget.height()
      });
      groupTarget.add(clickMask);
      clickMask.zIndex(1);
      return groupTarget;
    } catch (e) {
      console.error(e);
      return new Konva.Group();
    }
  }
}
__publicField(AssetTool, "name", "AssetTool");
class SelectionTool {
  constructor(render22) {
    __publicField(this, "render");
    // 【被选中的】
    __publicField(this, "selectingNodes", []);
    this.render = render22;
  }
  // 清空已选
  selectingClear(slient = false) {
    if (this.selectingNodes.length > 0) {
      !slient && this.render.emit("selection-change", []);
    }
    this.render.transformer.nodes([]);
    for (const node of [...this.selectingNodes].sort(
      (a, b) => a.attrs.lastZIndex - b.attrs.lastZIndex
    )) {
      node.setAttrs({
        listening: true,
        opacity: node.attrs.lastOpacity ?? 1,
        zIndex: node.attrs.lastZIndex
      });
    }
    for (const node of this.selectingNodes) {
      node.setAttrs({
        nodeMousedownPos: void 0,
        lastOpacity: void 0,
        lastZIndex: void 0,
        selectingZIndex: void 0,
        selected: false
      });
    }
    this.selectingNodes = [];
    this.render.linkTool.pointsVisible(false);
    this.render.redraw([GraphDraw.name, LinkDraw.name]);
  }
  // 选择节点
  select(nodes) {
    this.render.linkTool.selectingClear();
    this.render.emit("selection-change", nodes);
    this.selectingClear(true);
    if (nodes.length > 0) {
      const maxZIndex = Math.max(
        ...this.render.layer.getChildren((node) => {
          return !this.render.ignore(node);
        }).map((o) => o.zIndex())
      );
      for (const node of nodes) {
        node.setAttrs({
          nodeMousedownPos: node.position(),
          // 后面用于移动所选
          lastOpacity: node.opacity(),
          // 选中时，下面会使其变透明，记录原有的透明度
          lastZIndex: node.zIndex(),
          // 记录原有的层次，后面暂时提升所选节点的层次
          selectingZIndex: void 0,
          selected: true,
          // 选择中
          listening: false,
          // 不可交互
          opacity: node.opacity() * 0.8
          // 设置透明度
        });
      }
      for (const node of nodes.sort((a, b) => a.zIndex() - b.zIndex())) {
        node.setAttrs({
          zIndex: maxZIndex
          // 提升层次
        });
      }
      this.selectingNodes = nodes;
      this.render.transformer.nodes(this.selectingNodes);
    }
    this.render.redraw([GraphDraw.name, LinkDraw.name]);
  }
  // 更新节点位置
  selectingNodesMove(offset) {
    for (const node of this.render.selectionTool.selectingNodes) {
      node.x(node.x() + offset.x);
      node.y(node.y() + offset.y);
    }
  }
  // 选择所有节点
  selectAll() {
    const nodes = this.render.layer.find(".asset");
    this.select(nodes);
  }
}
__publicField(SelectionTool, "name", "SelectionTool");
class CopyTool {
  constructor(render22) {
    __publicField(this, "render");
    // 复制暂存
    __publicField(this, "pasteCache", []);
    // 粘贴次数（用于定义新节点的偏移距离）
    __publicField(this, "pasteCount", 1);
    this.render = render22;
  }
  // 复制
  pasteStart() {
    this.pasteCache = this.render.selectionTool.selectingNodes.map((o) => {
      const copy = o.clone();
      copy.setAttrs({
        listening: true,
        opacity: copy.attrs.lastOpacity ?? 1
      });
      copy.setAttrs({
        nodeMousedownPos: void 0,
        lastOpacity: void 0,
        lastZIndex: void 0,
        selectingZIndex: void 0,
        selected: false
      });
      return copy;
    });
    this.pasteCount = 1;
  }
  // 粘贴
  pasteEnd() {
    if (this.pasteCache.length > 0) {
      this.render.selectionTool.selectingClear();
      this.render.linkTool.selectingClear();
      this.copy(this.pasteCache);
      this.pasteCount++;
    }
  }
  // 刷新 id、事件
  nodesIdCover(nodes) {
    let deepAssets = [...nodes];
    const idMap = /* @__PURE__ */ new Map();
    while (deepAssets.length > 0) {
      const asset = deepAssets.shift();
      if (asset) {
        if (Array.isArray(asset.attrs.points)) {
          for (const point of asset.attrs.points) {
            if (Array.isArray(point.pairs)) {
              for (const pair of point.pairs) {
                if (!idMap.has(pair.id)) {
                  idMap.set(pair.id, "pr:" + nanoid());
                }
                if (pair.from.groupId && !idMap.has(pair.from.groupId)) {
                  idMap.set(pair.from.groupId, "g:" + nanoid());
                }
                if (pair.to.groupId && !idMap.has(pair.to.groupId)) {
                  idMap.set(pair.to.groupId, "g:" + nanoid());
                }
                if (pair.from.pointId && !idMap.has(pair.from.pointId)) {
                  idMap.set(pair.from.pointId, "p:" + nanoid());
                }
                if (pair.to.pointId && !idMap.has(pair.to.pointId)) {
                  idMap.set(pair.to.pointId, "p:" + nanoid());
                }
              }
            }
            if (point.id) {
              if (!idMap.has(point.id)) {
                idMap.set(point.id, "p:" + nanoid());
              }
            }
            if (point.groupId) {
              if (!idMap.has(point.groupId)) {
                idMap.set(point.groupId, "g:" + nanoid());
              }
            }
          }
        }
        if (Array.isArray(asset.attrs.anchors)) {
          for (const anchor of asset.attrs.anchors) {
            if (anchor.groupId && !idMap.has(anchor.groupId)) {
              idMap.set(anchor.groupId, "g:" + nanoid());
            }
          }
        }
        if (asset.id()) {
          if (!idMap.has(asset.id())) {
            idMap.set(asset.id(), "n:" + nanoid());
          }
        }
        if (asset instanceof Konva.Group && Array.isArray(asset.children)) {
          deepAssets.push(...asset.children);
        }
      }
    }
    deepAssets = [...nodes];
    while (deepAssets.length > 0) {
      const asset = deepAssets.shift();
      if (asset) {
        if (idMap.has(asset.id())) {
          asset.id(idMap.get(asset.id()));
        }
        if (Array.isArray(asset.attrs.points)) {
          asset.attrs.points = lodash.cloneDeep(asset.attrs.points ?? []);
          for (const point of asset.attrs.points) {
            if (Array.isArray(point.pairs)) {
              for (const pair of point.pairs) {
                pair.id = idMap.get(pair.id);
                if (idMap.has(pair.from.groupId)) {
                  pair.from.groupId = idMap.get(pair.from.groupId);
                }
                if (idMap.has(pair.to.groupId)) {
                  pair.to.groupId = idMap.get(pair.to.groupId);
                }
                if (idMap.has(pair.from.pointId)) {
                  pair.from.pointId = idMap.get(pair.from.pointId);
                }
                if (idMap.has(pair.to.pointId)) {
                  pair.to.pointId = idMap.get(pair.to.pointId);
                }
              }
            }
            if (idMap.has(point.id)) {
              if (asset instanceof Konva.Group) {
                const anchor = asset.findOne(`#${point.id}`);
                anchor == null ? void 0 : anchor.id(idMap.get(point.id));
              }
              point.id = idMap.get(point.id);
              point.visible = false;
            }
            if (idMap.has(point.groupId)) {
              point.groupId = idMap.get(point.groupId);
            }
          }
        }
        if (Array.isArray(asset.attrs.anchors)) {
          asset.attrs.anchors = lodash.cloneDeep(asset.attrs.anchors ?? []);
          for (const anchor of asset.attrs.anchors) {
            if (idMap.has(anchor.groupId)) {
              anchor.groupId = idMap.get(anchor.groupId);
            }
          }
        }
        if (asset instanceof Konva.Group && Array.isArray(asset.children)) {
          deepAssets.push(...asset.children);
        }
      }
    }
    for (const node of nodes) {
      if (node instanceof Konva.Group) {
        node.off("mouseenter");
        node.on("mouseenter", () => {
          this.render.linkTool.pointsVisible(true, node);
        });
        node.off("mouseleave");
        node.on("mouseleave", () => {
          var _a;
          this.render.linkTool.pointsVisible(false, node);
          (_a = node.findOne("#hoverRect")) == null ? void 0 : _a.visible(false);
        });
        node.setAttrs({
          x: node.x() + this.render.toStageValue(this.render.bgSize) * this.pasteCount,
          y: node.y() + this.render.toStageValue(this.render.bgSize) * this.pasteCount
        });
        if (node.attrs.manualPointsMap) {
          const manualPointsMap = {};
          for (const pairId in node.attrs.manualPointsMap) {
            manualPointsMap[idMap.get(pairId)] = node.attrs.manualPointsMap[pairId];
          }
          for (const pairId in manualPointsMap) {
            const manualPoints = manualPointsMap[pairId];
            if (Array.isArray(manualPoints)) {
              manualPointsMap[pairId] = manualPoints.map((o) => ({
                x: o.x + this.render.toStageValue(this.render.bgSize) * this.pasteCount,
                y: o.y + this.render.toStageValue(this.render.bgSize) * this.pasteCount
              }));
            }
          }
          node.setAttr("manualPointsMap", manualPointsMap);
        }
      }
    }
  }
  /**
   * 复制粘贴
   * @param nodes 节点数组
   * @param skip 跳过检查
   * @returns 复制的元素
   */
  copy(nodes) {
    const clones = [];
    for (const node of nodes) {
      if (node instanceof Konva.Transformer) {
        const backup = [...this.render.selectionTool.selectingNodes];
        this.render.selectionTool.selectingClear();
        this.render.linkTool.selectingClear();
        this.copy(backup);
        return;
      } else {
        clones.push(node.clone());
      }
    }
    this.nodesIdCover(clones);
    this.render.layer.add(...clones);
    this.render.selectionTool.select(clones);
    this.render.updateHistory();
    this.render.redraw([
      GraphDraw.name,
      LinkDraw.name,
      RulerDraw.name,
      PreviewDraw.name
    ]);
  }
}
__publicField(CopyTool, "name", "CopyTool");
class PositionTool {
  constructor(render22) {
    __publicField(this, "render");
    this.render = render22;
  }
  // 自适应大小
  positionFit() {
    const children = [
      ...this.render.layer.getChildren(),
      ...this.render.layerCover.find(".link-line")
    ];
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    const stageState = this.render.getStageState();
    for (const node of children) {
      if (node instanceof Konva.Group) {
        const { x, y, width, height } = ((rect) => ({
          x: this.render.toStageValue(rect.x - stageState.x),
          y: this.render.toStageValue(rect.y - stageState.y),
          width: this.render.toStageValue(rect.width),
          height: this.render.toStageValue(rect.height)
        }))(node.getClientRect());
        if (x < minX) {
          minX = x;
        }
        if (x + width > maxX) {
          maxX = x + width;
        }
        if (y < minY) {
          minY = y;
        }
        if (y + height > maxY) {
          maxY = y + height;
        }
      } else if (node instanceof Konva.Line && node.name() === "link-line") {
        const points = node.points();
        for (let i = 0; i < points.length; i += 2) {
          const [x, y] = [points[i], points[i + 1]];
          if (x < minX) {
            minX = x - 1;
          }
          if (x > maxX) {
            maxX = x + 1;
          }
          if (y < minY) {
            minY = y - 1;
          }
          if (y > maxY) {
            maxY = y + 1;
          }
        }
      }
    }
    minX === Infinity && (minX = (this.render.stage.width() - this.render.rulerSize) / 2);
    maxX === -Infinity && (maxX = minX);
    minY === Infinity && (minY = (this.render.stage.height() - this.render.rulerSize) / 2);
    maxY === -Infinity && (maxY = minY);
    const assetSize = {
      width: maxX - minX,
      height: maxY - minY
    };
    const assetRate = assetSize.width / assetSize.height;
    const viewSize = {
      width: this.render.stage.width() - (this.render.config.readonly ? 0 : this.render.rulerSize),
      height: this.render.stage.height() - (this.render.config.readonly ? 0 : this.render.rulerSize)
    };
    const viewRate = viewSize.width / viewSize.height;
    let scale = 1;
    if (viewRate > assetRate) {
      scale = viewSize.height / assetSize.height;
    } else if (viewRate < assetRate) {
      scale = viewSize.width / assetSize.width;
    }
    scale = Math.max(0.2, scale);
    scale = Math.floor(scale * 100) / 100;
    this.render.stage.setAttrs({
      scale: { x: scale, y: scale },
      position: {
        x: (this.render.config.readonly ? 0 : this.render.rulerSize) - minX * scale + (viewSize.width - assetSize.width * scale) / 2,
        y: (this.render.config.readonly ? 0 : this.render.rulerSize) - minY * scale + (viewSize.height - assetSize.height * scale) / 2
      }
    });
    this.render.emit("scale-change", scale);
    this.render.redraw([
      BgDraw.name,
      GraphDraw.name,
      LinkDraw.name,
      RulerDraw.name,
      RefLineDraw.name,
      PreviewDraw.name
    ]);
  }
  // 恢复位置大小
  positionZoomReset() {
    this.render.stage.setAttrs({
      scale: { x: 1, y: 1 }
    });
    this.render.emit("scale-change", 1);
    this.positionReset();
  }
  // 恢复位置
  positionReset() {
    this.render.stage.setAttrs({
      x: this.render.rulerSize,
      y: this.render.rulerSize
    });
    this.render.redraw([
      BgDraw.name,
      GraphDraw.name,
      LinkDraw.name,
      RulerDraw.name,
      RefLineDraw.name,
      PreviewDraw.name
    ]);
  }
  // 更新中心位置
  updateCenter(x = 0, y = 0) {
    const stageState = this.render.getStageState();
    const nodes = this.render.layer.getChildren((node) => {
      return !this.render.ignore(node);
    });
    let minX = 0;
    let minY = 0;
    for (const node of nodes) {
      const x2 = node.x();
      const y2 = node.y();
      if (x2 < minX) {
        minX = x2;
      }
      if (y2 < minY) {
        minY = y2;
      }
    }
    this.render.stage.setAttrs({
      x: stageState.width / 2 - this.render.toBoardValue(minX) - this.render.toBoardValue(x) + this.render.rulerSize,
      y: stageState.height / 2 - this.render.toBoardValue(minY) - this.render.toBoardValue(y) + this.render.rulerSize
    });
    this.render.redraw([
      BgDraw.name,
      GraphDraw.name,
      LinkDraw.name,
      RulerDraw.name,
      RefLineDraw.name,
      PreviewDraw.name
    ]);
  }
}
__publicField(PositionTool, "name", "PositionTool");
class ZIndexTool {
  constructor(render22) {
    __publicField(this, "render");
    this.render = render22;
  }
  // 获取移动节点
  getNodes(nodes) {
    const targets = [];
    for (const node of nodes) {
      if (node instanceof Konva.Transformer) {
        targets.push(...this.render.selectionTool.selectingNodes);
      } else {
        targets.push(node);
      }
    }
    return targets;
  }
  // 最大 zIndex
  getMaxZIndex() {
    return Math.max(
      ...this.render.layer.getChildren((node) => {
        return !this.render.ignore(node);
      }).map((o) => o.zIndex())
    );
  }
  // 最小 zIndex
  getMinZIndex() {
    return Math.min(
      ...this.render.layer.getChildren((node) => {
        return !this.render.ignore(node);
      }).map((o) => o.zIndex())
    );
  }
  // 记录选择期间的 zIndex
  updateSelectingZIndex(nodes) {
    for (const node of nodes) {
      node.setAttrs({
        selectingZIndex: node.zIndex()
      });
    }
  }
  // 恢复选择期间的 zIndex
  resetSelectingZIndex(nodes) {
    nodes.sort((a, b) => a.zIndex() - b.zIndex());
    for (const node of nodes) {
      node.zIndex(node.attrs.selectingZIndex);
    }
  }
  // 更新 zIndex 缓存
  updateLastZindex(nodes) {
    for (const node of nodes) {
      node.setAttrs({
        lastZIndex: node.zIndex()
      });
    }
  }
  // 上移
  up(nodes) {
    const maxZIndex = this.getMaxZIndex();
    const sorted = this.getNodes(nodes).sort((a, b) => b.zIndex() - a.zIndex());
    let lastNode = null;
    if (this.render.selectionTool.selectingNodes.length > 0) {
      this.updateSelectingZIndex(sorted);
      for (const node of sorted) {
        if (node.attrs.lastZIndex < maxZIndex && (lastNode === null || node.attrs.lastZIndex < lastNode.attrs.lastZIndex - 1)) {
          node.setAttrs({
            lastZIndex: node.attrs.lastZIndex + 1
          });
        }
        lastNode = node;
      }
      this.resetSelectingZIndex(sorted);
    } else {
      for (const node of sorted) {
        if (node.zIndex() < maxZIndex && (lastNode === null || node.zIndex() < lastNode.zIndex() - 1)) {
          node.zIndex(node.zIndex() + 1);
        }
        lastNode = node;
      }
      this.updateLastZindex(sorted);
      this.render.updateHistory();
      this.render.redraw([
        GraphDraw.name,
        LinkDraw.name,
        RulerDraw.name,
        PreviewDraw.name
      ]);
    }
  }
  // 下移
  down(nodes) {
    const minZIndex = this.getMinZIndex();
    const sorted = this.getNodes(nodes).sort((a, b) => a.zIndex() - b.zIndex());
    let lastNode = null;
    if (this.render.selectionTool.selectingNodes.length > 0) {
      this.updateSelectingZIndex(sorted);
      for (const node of sorted) {
        if (node.attrs.lastZIndex > minZIndex && (lastNode === null || node.attrs.lastZIndex > lastNode.attrs.lastZIndex + 1)) {
          node.setAttrs({
            lastZIndex: node.attrs.lastZIndex - 1
          });
        }
        lastNode = node;
      }
      this.resetSelectingZIndex(sorted);
    } else {
      for (const node of sorted) {
        if (node.zIndex() > minZIndex && (lastNode === null || node.zIndex() > lastNode.zIndex() + 1)) {
          node.zIndex(node.zIndex() - 1);
        }
        lastNode = node;
      }
      this.updateLastZindex(sorted);
      this.render.updateHistory();
      this.render.redraw([
        GraphDraw.name,
        LinkDraw.name,
        RulerDraw.name,
        PreviewDraw.name
      ]);
    }
  }
  // 置顶
  top(nodes) {
    let maxZIndex = this.getMaxZIndex();
    const sorted = this.getNodes(nodes).sort((a, b) => b.zIndex() - a.zIndex());
    if (this.render.selectionTool.selectingNodes.length > 0) {
      this.updateSelectingZIndex(sorted);
      for (const node of sorted) {
        node.setAttrs({
          lastZIndex: maxZIndex--
        });
      }
      this.resetSelectingZIndex(sorted);
    } else {
      for (const node of sorted) {
        node.zIndex(maxZIndex);
      }
      this.updateLastZindex(sorted);
      this.render.updateHistory();
      this.render.redraw([
        GraphDraw.name,
        LinkDraw.name,
        RulerDraw.name,
        PreviewDraw.name
      ]);
    }
  }
  // 置底
  bottom(nodes) {
    let minZIndex = this.getMinZIndex();
    const sorted = this.getNodes(nodes).sort((a, b) => a.zIndex() - b.zIndex());
    if (this.render.selectionTool.selectingNodes.length > 0) {
      this.updateSelectingZIndex(sorted);
      for (const node of sorted) {
        node.setAttrs({
          lastZIndex: minZIndex++
        });
      }
      this.resetSelectingZIndex(sorted);
    } else {
      for (const node of sorted) {
        node.zIndex(minZIndex);
      }
      this.updateLastZindex(sorted);
      this.render.updateHistory();
      this.render.redraw([
        GraphDraw.name,
        LinkDraw.name,
        RulerDraw.name,
        PreviewDraw.name
      ]);
    }
  }
}
__publicField(ZIndexTool, "name", "ZIndexTool");
var canvas2svg = { exports: {} };
/*!!
 *  Canvas 2 Svg v1.0.15
 *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.
 *
 *  Licensed under the MIT license:
 *  http://www.opensource.org/licenses/mit-license.php
 *
 *  Author:
 *  Kerry Liu
 *
 *  Copyright (c) 2014 Gliffy Inc.
 */
(function(module2) {
  (function() {
    var STYLES, ctx2, CanvasGradient, CanvasPattern, namedEntities;
    function format2(str, args) {
      var keys2 = Object.keys(args), i;
      for (i = 0; i < keys2.length; i++) {
        str = str.replace(new RegExp("\\{" + keys2[i] + "\\}", "gi"), args[keys2[i]]);
      }
      return str;
    }
    function randomString(holder) {
      var chars, randomstring, i;
      if (!holder) {
        throw new Error("cannot create a random attribute name for an undefined object");
      }
      chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
      randomstring = "";
      do {
        randomstring = "";
        for (i = 0; i < 12; i++) {
          randomstring += chars[Math.floor(Math.random() * chars.length)];
        }
      } while (holder[randomstring]);
      return randomstring;
    }
    function createNamedToNumberedLookup(items, radix) {
      var i, entity, lookup = {}, base10;
      items = items.split(",");
      radix = radix || 10;
      for (i = 0; i < items.length; i += 2) {
        entity = "&" + items[i + 1] + ";";
        base10 = parseInt(items[i], radix);
        lookup[entity] = "&#" + base10 + ";";
      }
      lookup["\\xa0"] = "&#160;";
      return lookup;
    }
    function getTextAnchor(textAlign) {
      var mapping = { "left": "start", "right": "end", "center": "middle", "start": "start", "end": "end" };
      return mapping[textAlign] || mapping.start;
    }
    function getDominantBaseline(textBaseline) {
      var mapping = { "alphabetic": "alphabetic", "hanging": "hanging", "top": "text-before-edge", "bottom": "text-after-edge", "middle": "central" };
      return mapping[textBaseline] || mapping.alphabetic;
    }
    namedEntities = createNamedToNumberedLookup(
      "50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro",
      32
    );
    STYLES = {
      "strokeStyle": {
        svgAttr: "stroke",
        //corresponding svg attribute
        canvas: "#000000",
        //canvas default
        svg: "none",
        //svg default
        apply: "stroke"
        //apply on stroke() or fill()
      },
      "fillStyle": {
        svgAttr: "fill",
        canvas: "#000000",
        svg: null,
        //svg default is black, but we need to special case this to handle canvas stroke without fill
        apply: "fill"
      },
      "lineCap": {
        svgAttr: "stroke-linecap",
        canvas: "butt",
        svg: "butt",
        apply: "stroke"
      },
      "lineJoin": {
        svgAttr: "stroke-linejoin",
        canvas: "miter",
        svg: "miter",
        apply: "stroke"
      },
      "miterLimit": {
        svgAttr: "stroke-miterlimit",
        canvas: 10,
        svg: 4,
        apply: "stroke"
      },
      "lineWidth": {
        svgAttr: "stroke-width",
        canvas: 1,
        svg: 1,
        apply: "stroke"
      },
      "globalAlpha": {
        svgAttr: "opacity",
        canvas: 1,
        svg: 1,
        apply: "fill stroke"
      },
      "font": {
        //font converts to multiple svg attributes, there is custom logic for this
        canvas: "10px sans-serif"
      },
      "shadowColor": {
        canvas: "#000000"
      },
      "shadowOffsetX": {
        canvas: 0
      },
      "shadowOffsetY": {
        canvas: 0
      },
      "shadowBlur": {
        canvas: 0
      },
      "textAlign": {
        canvas: "start"
      },
      "textBaseline": {
        canvas: "alphabetic"
      }
    };
    CanvasGradient = function(gradientNode, ctx3) {
      this.__root = gradientNode;
      this.__ctx = ctx3;
    };
    CanvasGradient.prototype.addColorStop = function(offset, color) {
      var stop = this.__ctx.__createElement("stop"), regex, matches2;
      stop.setAttribute("offset", offset);
      if (color.indexOf("rgba") !== -1) {
        regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
        matches2 = regex.exec(color);
        stop.setAttribute("stop-color", format2("rgb({r},{g},{b})", { r: matches2[1], g: matches2[2], b: matches2[3] }));
        stop.setAttribute("stop-opacity", matches2[4]);
      } else {
        stop.setAttribute("stop-color", color);
      }
      this.__root.appendChild(stop);
    };
    CanvasPattern = function(pattern4, ctx3) {
      this.__root = pattern4;
      this.__ctx = ctx3;
    };
    ctx2 = function(o) {
      var defaultOptions = { width: 500, height: 500, enableMirroring: false }, options;
      if (arguments.length > 1) {
        options = defaultOptions;
        options.width = arguments[0];
        options.height = arguments[1];
      } else if (!o) {
        options = defaultOptions;
      } else {
        options = o;
      }
      if (!(this instanceof ctx2)) {
        return new ctx2(options);
      }
      this.width = options.width || defaultOptions.width;
      this.height = options.height || defaultOptions.height;
      this.enableMirroring = options.enableMirroring !== void 0 ? options.enableMirroring : defaultOptions.enableMirroring;
      this.canvas = this;
      this.__document = options.document || document;
      this.__canvas = this.__document.createElement("canvas");
      this.__ctx = this.__canvas.getContext("2d");
      this.__setDefaultStyles();
      this.__stack = [this.__getStyleState()];
      this.__groupStack = [];
      this.__root = this.__document.createElementNS("http://www.w3.org/2000/svg", "svg");
      this.__root.setAttribute("version", 1.1);
      this.__root.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      this.__root.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
      this.__root.setAttribute("width", this.width);
      this.__root.setAttribute("height", this.height);
      this.__ids = {};
      this.__defs = this.__document.createElementNS("http://www.w3.org/2000/svg", "defs");
      this.__root.appendChild(this.__defs);
      this.__currentElement = this.__document.createElementNS("http://www.w3.org/2000/svg", "g");
      this.__root.appendChild(this.__currentElement);
    };
    ctx2.prototype.__createElement = function(elementName, properties, resetFill) {
      if (typeof properties === "undefined") {
        properties = {};
      }
      var element = this.__document.createElementNS("http://www.w3.org/2000/svg", elementName), keys2 = Object.keys(properties), i, key;
      if (resetFill) {
        element.setAttribute("fill", "none");
        element.setAttribute("stroke", "none");
      }
      for (i = 0; i < keys2.length; i++) {
        key = keys2[i];
        element.setAttribute(key, properties[key]);
      }
      return element;
    };
    ctx2.prototype.__setDefaultStyles = function() {
      var keys2 = Object.keys(STYLES), i, key;
      for (i = 0; i < keys2.length; i++) {
        key = keys2[i];
        this[key] = STYLES[key].canvas;
      }
    };
    ctx2.prototype.__applyStyleState = function(styleState) {
      var keys2 = Object.keys(styleState), i, key;
      for (i = 0; i < keys2.length; i++) {
        key = keys2[i];
        this[key] = styleState[key];
      }
    };
    ctx2.prototype.__getStyleState = function() {
      var i, styleState = {}, keys2 = Object.keys(STYLES), key;
      for (i = 0; i < keys2.length; i++) {
        key = keys2[i];
        styleState[key] = this[key];
      }
      return styleState;
    };
    ctx2.prototype.__applyStyleToCurrentElement = function(type4) {
      var keys2 = Object.keys(STYLES), i, style2, value, id, regex, matches2;
      for (i = 0; i < keys2.length; i++) {
        style2 = STYLES[keys2[i]];
        value = this[keys2[i]];
        if (style2.apply) {
          if (style2.apply.indexOf("fill") !== -1 && value instanceof CanvasPattern) {
            if (value.__ctx) {
              while (value.__ctx.__defs.childNodes.length) {
                id = value.__ctx.__defs.childNodes[0].getAttribute("id");
                this.__ids[id] = id;
                this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);
              }
            }
            this.__currentElement.setAttribute("fill", format2("url(#{id})", { id: value.__root.getAttribute("id") }));
          } else if (style2.apply.indexOf("fill") !== -1 && value instanceof CanvasGradient) {
            this.__currentElement.setAttribute("fill", format2("url(#{id})", { id: value.__root.getAttribute("id") }));
          } else if (style2.apply.indexOf(type4) !== -1 && style2.svg !== value) {
            if ((style2.svgAttr === "stroke" || style2.svgAttr === "fill") && value.indexOf("rgba") !== -1) {
              regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
              matches2 = regex.exec(value);
              this.__currentElement.setAttribute(style2.svgAttr, format2("rgb({r},{g},{b})", { r: matches2[1], g: matches2[2], b: matches2[3] }));
              this.__currentElement.setAttribute(style2.svgAttr + "-opacity", matches2[4]);
            } else {
              this.__currentElement.setAttribute(style2.svgAttr, value);
            }
          }
        }
      }
    };
    ctx2.prototype.__closestGroupOrSvg = function(node) {
      node = node || this.__currentElement;
      if (node.nodeName === "g" || node.nodeName === "svg") {
        return node;
      } else {
        return this.__closestGroupOrSvg(node.parentNode);
      }
    };
    ctx2.prototype.getSerializedSvg = function(fixNamedEntities) {
      var serialized = new XMLSerializer().serializeToString(this.__root), keys2, i, key, value, regexp4, xmlns;
      xmlns = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
      if (xmlns.test(serialized)) {
        serialized = serialized.replace('xmlns="http://www.w3.org/2000/svg', 'xmlns:xlink="http://www.w3.org/1999/xlink');
      }
      if (fixNamedEntities) {
        keys2 = Object.keys(namedEntities);
        for (i = 0; i < keys2.length; i++) {
          key = keys2[i];
          value = namedEntities[key];
          regexp4 = new RegExp(key, "gi");
          if (regexp4.test(serialized)) {
            serialized = serialized.replace(regexp4, value);
          }
        }
      }
      return serialized;
    };
    ctx2.prototype.getSvg = function() {
      return this.__root;
    };
    ctx2.prototype.save = function() {
      var group = this.__createElement("g"), parent2 = this.__closestGroupOrSvg();
      this.__groupStack.push(parent2);
      parent2.appendChild(group);
      this.__currentElement = group;
      this.__stack.push(this.__getStyleState());
    };
    ctx2.prototype.restore = function() {
      this.__currentElement = this.__groupStack.pop();
      var state = this.__stack.pop();
      this.__applyStyleState(state);
    };
    ctx2.prototype.__addTransform = function(t) {
      var parent2 = this.__closestGroupOrSvg();
      if (parent2.childNodes.length > 0) {
        var group = this.__createElement("g");
        parent2.appendChild(group);
        this.__currentElement = group;
      }
      var transform2 = this.__currentElement.getAttribute("transform");
      if (transform2) {
        transform2 += " ";
      } else {
        transform2 = "";
      }
      transform2 += t;
      this.__currentElement.setAttribute("transform", transform2);
    };
    ctx2.prototype.scale = function(x, y) {
      if (y === void 0) {
        y = x;
      }
      this.__addTransform(format2("scale({x},{y})", { x, y }));
    };
    ctx2.prototype.rotate = function(angle) {
      var degrees = angle * 180 / Math.PI;
      this.__addTransform(format2("rotate({angle},{cx},{cy})", { angle: degrees, cx: 0, cy: 0 }));
    };
    ctx2.prototype.translate = function(x, y) {
      this.__addTransform(format2("translate({x},{y})", { x, y }));
    };
    ctx2.prototype.transform = function(a, b, c2, d, e, f) {
      this.__addTransform(format2("matrix({a},{b},{c},{d},{e},{f})", { a, b, c: c2, d, e, f }));
    };
    ctx2.prototype.beginPath = function() {
      var path, parent2;
      this.__currentDefaultPath = "";
      this.__currentPosition = {};
      path = this.__createElement("path", {}, true);
      parent2 = this.__closestGroupOrSvg();
      parent2.appendChild(path);
      this.__currentElement = path;
    };
    ctx2.prototype.__applyCurrentDefaultPath = function() {
      if (this.__currentElement.nodeName === "path") {
        var d = this.__currentDefaultPath;
        this.__currentElement.setAttribute("d", d);
      } else {
        throw new Error("Attempted to apply path command to node " + this.__currentElement.nodeName);
      }
    };
    ctx2.prototype.__addPathCommand = function(command) {
      this.__currentDefaultPath += " ";
      this.__currentDefaultPath += command;
    };
    ctx2.prototype.moveTo = function(x, y) {
      if (this.__currentElement.nodeName !== "path") {
        this.beginPath();
      }
      this.__currentPosition = { x, y };
      this.__addPathCommand(format2("M {x} {y}", { x, y }));
    };
    ctx2.prototype.closePath = function() {
      this.__addPathCommand("Z");
    };
    ctx2.prototype.lineTo = function(x, y) {
      this.__currentPosition = { x, y };
      if (this.__currentDefaultPath.indexOf("M") > -1) {
        this.__addPathCommand(format2("L {x} {y}", { x, y }));
      } else {
        this.__addPathCommand(format2("M {x} {y}", { x, y }));
      }
    };
    ctx2.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
      this.__currentPosition = { x, y };
      this.__addPathCommand(format2(
        "C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}",
        { cp1x, cp1y, cp2x, cp2y, x, y }
      ));
    };
    ctx2.prototype.quadraticCurveTo = function(cpx, cpy, x, y) {
      this.__currentPosition = { x, y };
      this.__addPathCommand(format2("Q {cpx} {cpy} {x} {y}", { cpx, cpy, x, y }));
    };
    var normalize = function(vector) {
      var len2 = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
      return [vector[0] / len2, vector[1] / len2];
    };
    ctx2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
      var x0 = this.__currentPosition && this.__currentPosition.x;
      var y0 = this.__currentPosition && this.__currentPosition.y;
      if (typeof x0 == "undefined" || typeof y0 == "undefined") {
        return;
      }
      if (radius < 0) {
        throw new Error("IndexSizeError: The radius provided (" + radius + ") is negative.");
      }
      if (x0 === x1 && y0 === y1 || x1 === x2 && y1 === y2 || radius === 0) {
        this.lineTo(x1, y1);
        return;
      }
      var unit_vec_p1_p0 = normalize([x0 - x1, y0 - y1]);
      var unit_vec_p1_p2 = normalize([x2 - x1, y2 - y1]);
      if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {
        this.lineTo(x1, y1);
        return;
      }
      var cos = unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1];
      var theta = Math.acos(Math.abs(cos));
      var unit_vec_p1_origin = normalize([
        unit_vec_p1_p0[0] + unit_vec_p1_p2[0],
        unit_vec_p1_p0[1] + unit_vec_p1_p2[1]
      ]);
      var len_p1_origin = radius / Math.sin(theta / 2);
      var x = x1 + len_p1_origin * unit_vec_p1_origin[0];
      var y = y1 + len_p1_origin * unit_vec_p1_origin[1];
      var unit_vec_origin_start_tangent = [
        -unit_vec_p1_p0[1],
        unit_vec_p1_p0[0]
      ];
      var unit_vec_origin_end_tangent = [
        unit_vec_p1_p2[1],
        -unit_vec_p1_p2[0]
      ];
      var getAngle = function(vector) {
        var x3 = vector[0];
        var y3 = vector[1];
        if (y3 >= 0) {
          return Math.acos(x3);
        } else {
          return -Math.acos(x3);
        }
      };
      var startAngle = getAngle(unit_vec_origin_start_tangent);
      var endAngle = getAngle(unit_vec_origin_end_tangent);
      this.lineTo(
        x + unit_vec_origin_start_tangent[0] * radius,
        y + unit_vec_origin_start_tangent[1] * radius
      );
      this.arc(x, y, radius, startAngle, endAngle);
    };
    ctx2.prototype.stroke = function() {
      if (this.__currentElement.nodeName === "path") {
        this.__currentElement.setAttribute("paint-order", "fill stroke markers");
      }
      this.__applyCurrentDefaultPath();
      this.__applyStyleToCurrentElement("stroke");
    };
    ctx2.prototype.fill = function() {
      if (this.__currentElement.nodeName === "path") {
        this.__currentElement.setAttribute("paint-order", "stroke fill markers");
      }
      this.__applyCurrentDefaultPath();
      this.__applyStyleToCurrentElement("fill");
    };
    ctx2.prototype.rect = function(x, y, width, height) {
      if (this.__currentElement.nodeName !== "path") {
        this.beginPath();
      }
      this.moveTo(x, y);
      this.lineTo(x + width, y);
      this.lineTo(x + width, y + height);
      this.lineTo(x, y + height);
      this.lineTo(x, y);
      this.closePath();
    };
    ctx2.prototype.fillRect = function(x, y, width, height) {
      var rect, parent2;
      rect = this.__createElement("rect", {
        x,
        y,
        width,
        height
      }, true);
      parent2 = this.__closestGroupOrSvg();
      parent2.appendChild(rect);
      this.__currentElement = rect;
      this.__applyStyleToCurrentElement("fill");
    };
    ctx2.prototype.strokeRect = function(x, y, width, height) {
      var rect, parent2;
      rect = this.__createElement("rect", {
        x,
        y,
        width,
        height
      }, true);
      parent2 = this.__closestGroupOrSvg();
      parent2.appendChild(rect);
      this.__currentElement = rect;
      this.__applyStyleToCurrentElement("stroke");
    };
    ctx2.prototype.clearRect = function(x, y, width, height) {
      var rect, parent2 = this.__closestGroupOrSvg();
      rect = this.__createElement("rect", {
        x,
        y,
        width,
        height,
        fill: "#FFFFFF"
      }, true);
      parent2.appendChild(rect);
    };
    ctx2.prototype.createLinearGradient = function(x1, y1, x2, y2) {
      var grad = this.__createElement("linearGradient", {
        id: randomString(this.__ids),
        x1: x1 + "px",
        x2: x2 + "px",
        y1: y1 + "px",
        y2: y2 + "px",
        "gradientUnits": "userSpaceOnUse"
      }, false);
      this.__defs.appendChild(grad);
      return new CanvasGradient(grad, this);
    };
    ctx2.prototype.createRadialGradient = function(x0, y0, r0, x1, y1, r1) {
      var grad = this.__createElement("radialGradient", {
        id: randomString(this.__ids),
        cx: x1 + "px",
        cy: y1 + "px",
        r: r1 + "px",
        fx: x0 + "px",
        fy: y0 + "px",
        "gradientUnits": "userSpaceOnUse"
      }, false);
      this.__defs.appendChild(grad);
      return new CanvasGradient(grad, this);
    };
    ctx2.prototype.__parseFont = function() {
      var regex = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\"\sa-z]+?)\s*$/i;
      var fontPart = regex.exec(this.font);
      var data = {
        style: fontPart[1] || "normal",
        size: fontPart[4] || "10px",
        family: fontPart[6] || "sans-serif",
        weight: fontPart[3] || "normal",
        decoration: fontPart[2] || "normal",
        href: null
      };
      if (this.__fontUnderline === "underline") {
        data.decoration = "underline";
      }
      if (this.__fontHref) {
        data.href = this.__fontHref;
      }
      return data;
    };
    ctx2.prototype.__wrapTextLink = function(font, element) {
      if (font.href) {
        var a = this.__createElement("a");
        a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", font.href);
        a.appendChild(element);
        return a;
      }
      return element;
    };
    ctx2.prototype.__applyText = function(text, x, y, action) {
      var font = this.__parseFont(), parent2 = this.__closestGroupOrSvg(), textElement = this.__createElement("text", {
        "font-family": font.family,
        "font-size": font.size,
        "font-style": font.style,
        "font-weight": font.weight,
        "text-decoration": font.decoration,
        "x": x,
        "y": y,
        "text-anchor": getTextAnchor(this.textAlign),
        "dominant-baseline": getDominantBaseline(this.textBaseline)
      }, true);
      textElement.appendChild(this.__document.createTextNode(text));
      this.__currentElement = textElement;
      this.__applyStyleToCurrentElement(action);
      parent2.appendChild(this.__wrapTextLink(font, textElement));
    };
    ctx2.prototype.fillText = function(text, x, y) {
      this.__applyText(text, x, y, "fill");
    };
    ctx2.prototype.strokeText = function(text, x, y) {
      this.__applyText(text, x, y, "stroke");
    };
    ctx2.prototype.measureText = function(text) {
      this.__ctx.font = this.font;
      return this.__ctx.measureText(text);
    };
    ctx2.prototype.arc = function(x, y, radius, startAngle, endAngle, counterClockwise) {
      if (startAngle === endAngle) {
        return;
      }
      startAngle = startAngle % (2 * Math.PI);
      endAngle = endAngle % (2 * Math.PI);
      if (startAngle === endAngle) {
        endAngle = (endAngle + 2 * Math.PI - 1e-3 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);
      }
      var endX = x + radius * Math.cos(endAngle), endY = y + radius * Math.sin(endAngle), startX = x + radius * Math.cos(startAngle), startY = y + radius * Math.sin(startAngle), sweepFlag = counterClockwise ? 0 : 1, largeArcFlag = 0, diff = endAngle - startAngle;
      if (diff < 0) {
        diff += 2 * Math.PI;
      }
      if (counterClockwise) {
        largeArcFlag = diff > Math.PI ? 0 : 1;
      } else {
        largeArcFlag = diff > Math.PI ? 1 : 0;
      }
      this.lineTo(startX, startY);
      this.__addPathCommand(format2(
        "A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}",
        { rx: radius, ry: radius, xAxisRotation: 0, largeArcFlag, sweepFlag, endX, endY }
      ));
      this.__currentPosition = { x: endX, y: endY };
    };
    ctx2.prototype.clip = function() {
      var group = this.__closestGroupOrSvg(), clipPath = this.__createElement("clipPath"), id = randomString(this.__ids), newGroup = this.__createElement("g");
      group.removeChild(this.__currentElement);
      clipPath.setAttribute("id", id);
      clipPath.appendChild(this.__currentElement);
      this.__defs.appendChild(clipPath);
      group.setAttribute("clip-path", format2("url(#{id})", { id }));
      group.appendChild(newGroup);
      this.__currentElement = newGroup;
    };
    ctx2.prototype.drawImage = function() {
      var args = Array.prototype.slice.call(arguments), image = args[0], dx, dy, dw, dh, sx = 0, sy = 0, sw, sh, parent2, svg, defs, group, currentElement, svgImage, canvas, context, id;
      if (args.length === 3) {
        dx = args[1];
        dy = args[2];
        sw = image.width;
        sh = image.height;
        dw = sw;
        dh = sh;
      } else if (args.length === 5) {
        dx = args[1];
        dy = args[2];
        dw = args[3];
        dh = args[4];
        sw = image.width;
        sh = image.height;
      } else if (args.length === 9) {
        sx = args[1];
        sy = args[2];
        sw = args[3];
        sh = args[4];
        dx = args[5];
        dy = args[6];
        dw = args[7];
        dh = args[8];
      } else {
        throw new Error("Inavlid number of arguments passed to drawImage: " + arguments.length);
      }
      parent2 = this.__closestGroupOrSvg();
      currentElement = this.__currentElement;
      if (image instanceof ctx2) {
        svg = image.getSvg();
        defs = svg.childNodes[0];
        while (defs.childNodes.length) {
          id = defs.childNodes[0].getAttribute("id");
          this.__ids[id] = id;
          this.__defs.appendChild(defs.childNodes[0]);
        }
        group = svg.childNodes[1];
        parent2.appendChild(group);
        this.__currentElement = group;
        this.translate(dx, dy);
        this.__currentElement = currentElement;
      } else if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
        svgImage = this.__createElement("image");
        svgImage.setAttribute("width", dw);
        svgImage.setAttribute("height", dh);
        svgImage.setAttribute("preserveAspectRatio", "none");
        if (sx || sy || sw !== image.width || sh !== image.height) {
          canvas = this.__document.createElement("canvas");
          canvas.width = dw;
          canvas.height = dh;
          context = canvas.getContext("2d");
          context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
          image = canvas;
        }
        svgImage.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
        );
        parent2.appendChild(svgImage);
        this.__currentElement = svgImage;
        this.translate(dx, dy);
        this.__currentElement = currentElement;
      }
    };
    ctx2.prototype.createPattern = function(image, repetition) {
      var pattern4 = this.__document.createElementNS("http://www.w3.org/2000/svg", "pattern"), id = randomString(this.__ids), img;
      pattern4.setAttribute("id", id);
      pattern4.setAttribute("width", image.width);
      pattern4.setAttribute("height", image.height);
      if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
        img = this.__document.createElementNS("http://www.w3.org/2000/svg", "image");
        img.setAttribute("width", image.width);
        img.setAttribute("height", image.height);
        img.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
        );
        pattern4.appendChild(img);
        this.__defs.appendChild(pattern4);
      } else if (image instanceof ctx2) {
        pattern4.appendChild(image.__root.childNodes[1]);
        this.__defs.appendChild(pattern4);
      }
      return new CanvasPattern(pattern4, this);
    };
    ctx2.prototype.drawFocusRing = function() {
    };
    ctx2.prototype.createImageData = function() {
    };
    ctx2.prototype.getImageData = function() {
    };
    ctx2.prototype.putImageData = function() {
    };
    ctx2.prototype.globalCompositeOperation = function() {
    };
    ctx2.prototype.setTransform = function() {
    };
    if (typeof window === "object") {
      window.C2S = ctx2;
    }
    {
      module2.exports = ctx2;
    }
  })();
})(canvas2svg);
var canvas2svgExports = canvas2svg.exports;
const C2S = /* @__PURE__ */ getDefaultExportFromCjs(canvas2svgExports);
C2S.prototype.__applyCurrentDefaultPath = function() {
  if (this.__currentElement.nodeName === "g") {
    const g = this.__currentElement.querySelector("g");
    if (g) {
      const scale = g.getAttribute("transform");
      if (scale) {
        const match2 = scale.match(/scale\(([^),]+),([^)]+)\)/);
        if (match2) {
          const [sx, sy] = [parseFloat(match2[1]), parseFloat(match2[2])];
          let d = this.__currentDefaultPath;
          const reg = /A ([^ ]+) ([^ ]+) /;
          const match22 = d.match(reg);
          if (match22) {
            const [rx, ry] = [parseFloat(match22[1]), parseFloat(match22[2])];
            d = d.replace(reg, `A ${rx * sx} ${ry * sy} `);
            const path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            path.setAttribute("d", d);
            path.setAttribute("fill", "none");
            this.__currentElement.append(path);
          }
        }
      } else {
        const d = this.__currentDefaultPath;
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", d);
        path.setAttribute("fill", "none");
        this.__currentElement.append(path);
      }
    }
    console.warn(
      "[Hacked] Attempted to apply path command to node " + this.__currentElement.nodeName
    );
    return;
  }
  if (this.__currentElement.nodeName === "path") {
    const d = this.__currentDefaultPath;
    this.__currentElement.setAttribute("d", d);
  } else {
    throw new Error("Attempted to apply path command to node " + this.__currentElement.nodeName);
  }
};
class ImportExportTool {
  constructor(render22) {
    __publicField(this, "render");
    this.render = render22;
  }
  /**
   * 获得显示内容
   * @param withLink 是否包含线条
   * @returns
   */
  getView(withLink = false) {
    const copy = this.render.stage.clone();
    const main = copy.find("#main")[0];
    const cover = copy.find("#cover")[0];
    const copyChildren = copy.getChildren();
    copy.removeChildren();
    if (main && cover) {
      let nodes = main.getChildren((node) => {
        return !this.render.ignore(node);
      });
      for (const node of nodes) {
        node.listening(true);
        node.draggable(!this.render.config.readonly);
        for (const child of node.children) {
          if (this.render.ignoreSelect(child)) {
            child.remove();
          }
        }
      }
      if (withLink) {
        const linkDraw = cover.children.find(
          (o) => o.attrs.name === LinkDraw.name
        );
        if (linkDraw) {
          nodes = nodes.concat(linkDraw.children.filter((o) => o.attrs.name === "link-line"));
        }
      }
      const layer = new Konva.Layer();
      layer.add(...nodes);
      nodes = layer.getChildren();
      for (const node of nodes) {
        if (node.attrs.nodeMousedownPos) {
          node.setAttrs({
            opacity: copy.attrs.lastOpacity ?? 1
          });
        }
      }
      copy.add(layer);
      main.removeChildren();
      cover.removeChildren();
    }
    copyChildren.forEach((o) => o.destroy());
    return copy;
  }
  // 保存
  save() {
    const copy = this.getView();
    const json = copy.toJSON();
    copy.destroy();
    return json;
  }
  // 加载 image（用于导入）
  loadImage(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        resolve(img);
      };
      img.onerror = () => {
        resolve(null);
      };
      img.src = src;
    });
  }
  // 恢复图片（用于导入）
  async restoreImage(nodes = []) {
    for (const node of nodes) {
      if (node instanceof Konva.Group) {
        await this.restoreImage(node.getChildren());
      } else if (node instanceof Konva.Image) {
        if (node.attrs.svgXML) {
          const blob = new Blob([node.attrs.svgXML], { type: "image/svg+xml" });
          const url2 = URL.createObjectURL(blob);
          const image = await this.loadImage(url2);
          if (image) {
            node.image(image);
          }
        } else if (node.attrs.gif) {
          const imageNode = await this.render.assetTool.loadGif(node.attrs.gif);
          if (imageNode) {
            node.image(imageNode.image());
          }
        } else if (node.attrs.src) {
          const image = await this.loadImage(node.attrs.src);
          if (image) {
            node.image(image);
          }
        }
      }
    }
  }
  // 恢复
  async restore(json, silent = false) {
    console.group("restore");
    console.time("restore");
    try {
      this.render.emit("loading", true);
      this.render.selectionTool.selectingClear();
      this.render.linkTool.selectingClear();
      this.render.layer.getChildren().forEach((o) => {
        o.destroy();
      });
      this.render.layer.removeChildren();
      const container = document.createElement("div");
      const stage = Konva.Node.create(json, container);
      const main = stage.getChildren()[0];
      const nodes = main.getChildren();
      await this.restoreImage(nodes);
      for (const node of nodes) {
        node.draggable(!this.render.config.readonly);
        node.off("mouseenter");
        node.on("mouseenter", () => {
          this.render.linkTool.pointsVisible(true, node);
        });
        node.add(
          new Konva.Rect({
            id: "hoverRect",
            width: node.width(),
            height: node.height(),
            fill: "rgba(0,255,0,0.3)",
            visible: false
          })
        );
        node.off("mouseleave");
        node.on("mouseleave", () => {
          var _a;
          this.render.linkTool.pointsVisible(false, node);
          (_a = node.findOne("#hoverRect")) == null ? void 0 : _a.visible(false);
        });
      }
      this.render.layer.add(...nodes);
      this.render.stage.setAttr("pageSettings", stage.attrs.pageSettings);
      this.render.emit("page-settings-change", this.render.getPageSettings());
      this.render.updateBackground();
      if (!silent) {
        this.render.updateHistory();
      }
      this.render.linkTool.pointsVisible(false);
      this.render.redraw([
        GraphDraw.name,
        LinkDraw.name,
        RulerDraw.name,
        PreviewDraw.name
      ]);
      stage.destroy();
    } catch (e) {
      console.error(e);
    } finally {
      this.render.emit("loading", false);
    }
    console.timeEnd("restore");
    console.groupEnd();
  }
  // 获取图片
  getImage(pixelRatio = 1, bgColor) {
    const copy = this.getAssetView();
    const bgLayer = new Konva.Layer();
    const bg = new Konva.Rect({
      listening: false
    });
    bg.setAttrs({
      x: 0,
      y: 0,
      width: copy.width(),
      height: copy.height(),
      fill: bgColor ?? this.render.getPageSettings().background
    });
    bgLayer.add(bg);
    const children = copy.getChildren();
    copy.removeChildren();
    copy.add(bgLayer);
    copy.add(children[0], ...children.slice(1));
    const url2 = copy.toDataURL({ pixelRatio });
    copy.destroy();
    return url2;
  }
  // 获取元素图片
  getAssetImage(pixelRatio = 1, bgColor) {
    const copy = this.getAssetView();
    const bgLayer = new Konva.Layer();
    const bg = new Konva.Rect({
      listening: false
    });
    bg.setAttrs({
      x: -copy.x(),
      y: -copy.y(),
      width: copy.width(),
      height: copy.height(),
      fill: bgColor ?? this.render.getPageSettings().background
    });
    bgLayer.add(bg);
    const children = copy.getChildren();
    copy.removeChildren();
    copy.add(bgLayer);
    copy.add(children[0], ...children.slice(1));
    const url2 = copy.toDataURL({ pixelRatio });
    copy.destroy();
    return url2;
  }
  // blob to base64 url
  blobToBase64(blob, type4) {
    return new Promise((resolve) => {
      const file = new File([blob], "image", { type: type4 });
      const fileReader = new FileReader();
      fileReader.readAsDataURL(file);
      fileReader.onload = function() {
        resolve(this.result ?? "");
      };
    });
  }
  // 替换 svg blob: 链接
  parseSvgImage(urls) {
    return new Promise((resolve) => {
      if (urls.length > 0) {
        Promise.all(urls.map((o) => fetch(o))).then((rs) => {
          Promise.all(rs.map((o) => o.text())).then((xmls) => {
            resolve(xmls);
          });
        });
      } else {
        resolve([]);
      }
    });
  }
  // 替换其他 image 链接
  parseOtherImage(urls) {
    return new Promise((resolve) => {
      if (urls.length > 0) {
        Promise.all(urls.map((o) => fetch(o))).then((rs) => {
          Promise.all(rs.map((o) => o.blob())).then((bs) => {
            Promise.all(bs.map((o) => this.blobToBase64(o, "image/*"))).then((urls2) => {
              resolve(urls2);
            });
          });
        });
      } else {
        resolve([]);
      }
    });
  }
  // 替换 image 链接
  parseImage(xml) {
    return new Promise((resolve) => {
      const svgs = xml.match(new RegExp('(?<=xlink:href=")blob:https?:\\/\\/[^"]+(?=")', "g")) ?? [];
      const imgs = xml.match(new RegExp('(?<=xlink:href=")(?<!blob:)[^"]+(?=")', "g")) ?? [];
      Promise.all([this.parseSvgImage(svgs), this.parseOtherImage(imgs)]).then(
        ([svgXmls, imgUrls]) => {
          svgs.forEach((svg, idx) => {
            var _a;
            xml = xml.replace(
              new RegExp(`<image[^><]* xlink:href="${svg}"[^><]*/>`),
              ((_a = svgXmls[idx].match(/<svg[^><]*>.*<\/svg>/)) == null ? void 0 : _a[0]) ?? ""
              // 仅保留 svg 结构
            );
          });
          imgs.forEach((img, idx) => {
            xml = xml.replace(`"${img}"`, `"${imgUrls[idx]}"`);
          });
          resolve(xml);
        }
      );
    });
  }
  // 获取Svg
  async getSvg() {
    const copy = this.getAssetView();
    const main = copy.children[0];
    const ctx2 = main.canvas.context._context;
    if (ctx2) {
      const c2s = new C2S({ ctx: ctx2, ...main.size() });
      main.canvas.context._context = c2s;
      main.draw();
      let rawSvg = c2s.getSerializedSvg();
      console.log(rawSvg);
      rawSvg = rawSvg.replace(
        /(<defs\/><g><rect fill=")([^"]+)(")/,
        `$1${this.render.getPageSettings().background}$3`
      );
      const svg = await this.parseImage(rawSvg);
      console.log(svg);
      copy.destroy();
      return svg;
    }
    return Promise.resolve(
      `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0"></svg>`
    );
  }
  /**
   * 获得显示内容（用于另存为元素）
   * @returns Konva.Stage
   */
  getAssetView() {
    const copy = this.getView(true);
    const children = copy.getChildren()[0].getChildren();
    const nodes = [...children];
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minStartX = Infinity, minStartY = Infinity;
    const stageState = this.render.getStageState();
    for (const node of nodes) {
      if (node instanceof Konva.Group) {
        const { x, y, width, height } = ((rect) => ({
          x: this.render.toStageValue(rect.x - stageState.x),
          y: this.render.toStageValue(rect.y - stageState.y),
          width: this.render.toStageValue(rect.width),
          height: this.render.toStageValue(rect.height)
        }))(node.getClientRect());
        if (x < minX) {
          minX = x;
        }
        if (x + width > maxX) {
          maxX = x + width;
        }
        if (y < minY) {
          minY = y;
        }
        if (y + height > maxY) {
          maxY = y + height;
        }
        if (x < minStartX) {
          minStartX = x;
        }
        if (y < minStartY) {
          minStartY = y;
        }
        if (node instanceof Konva.Group) {
          const clickMask = node.findOne("#click-mask");
          if (clickMask) {
            clickMask.destroy();
          }
        }
      } else if (node instanceof Konva.Line && node.name() === "link-line") {
        const points = node.points();
        for (let i = 0; i < points.length; i += 2) {
          const [x, y] = [points[i], points[i + 1]];
          if (x < minX) {
            minX = x - 1;
          }
          if (x > maxX) {
            maxX = x + 1;
          }
          if (y < minY) {
            minY = y - 1;
          }
          if (y > maxY) {
            maxY = y + 1;
          }
          if (x < minStartX) {
            minStartX = x - 1;
          }
          if (y < minStartY) {
            minStartY = y - 1;
          }
        }
      }
    }
    for (const node of nodes) {
      if (node instanceof Konva.Group) {
        node.x(node.x() - minStartX);
        node.y(node.y() - minStartY);
      } else if (node instanceof Konva.Line && node.name() === "link-line") {
        const points = node.points();
        for (let i = 0; i < points.length; i += 2) {
          points[i] = points[i] - minStartX;
          points[i + 1] = points[i + 1] - minStartY;
        }
        node.points(points);
      }
    }
    copy.x(0);
    copy.y(0);
    copy.width(maxX - minX);
    copy.height(maxY - minY);
    copy.scale({ x: 1, y: 1 });
    return copy;
  }
  /**
   * 获得元素（用于另存为元素）
   * @returns Konva.Stage
   */
  getAsset() {
    const copy = this.getAssetView();
    const background = this.render.getBackground();
    background.width(copy.width());
    background.height(copy.height());
    copy.children[0].add(background);
    background.moveToBottom();
    const json = copy.toJSON();
    const obj = JSON.parse(json);
    const assets = obj.children[0].children;
    for (const asset of assets) {
      if (asset.attrs.name === "asset") {
        asset.attrs.name = "sub-asset";
      }
      if (asset.attrs.selected) {
        asset.attrs.selected = false;
      }
    }
    this.render.linkTool.jsonIdCover(assets);
    const result2 = JSON.stringify({
      ...obj.children[0],
      className: "Group",
      attrs: {
        width: copy.width(),
        height: copy.height(),
        x: 0,
        y: 0
      }
    });
    copy.destroy();
    return result2;
  }
}
__publicField(ImportExportTool, "name", "ImportExportTool");
class AlignTool {
  constructor(render22) {
    __publicField(this, "render");
    this.render = render22;
  }
  // 对齐参考点
  getAlignPoints(node) {
    let width = 0, height = 0, x = 0, y = 0;
    if (node instanceof Konva.Transformer) {
      const stageState = this.render.getStageState();
      const result2 = node.getClientRect();
      [width, height] = [
        this.render.toStageValue(result2.width),
        this.render.toStageValue(result2.height)
      ];
      [x, y] = [
        this.render.toStageValue(result2.x - stageState.x),
        this.render.toStageValue(result2.y - stageState.y)
      ];
    } else if (node !== void 0) {
      const result2 = node.getClientRect();
      [width, height] = [result2.width, result2.height];
      [x, y] = [result2.x, result2.y];
    } else {
      return this.getAlignPoints(this.render.transformer);
    }
    return {
      [AlignType.垂直居中]: x + width / 2,
      [AlignType.左对齐]: x,
      [AlignType.右对齐]: x + width,
      [AlignType.水平居中]: y + height / 2,
      [AlignType.上对齐]: y,
      [AlignType.下对齐]: y + height
    };
  }
  align(type4, target) {
    const points = this.getAlignPoints(target);
    const point = points[type4];
    const nodes = this.render.transformer.nodes().filter((node) => node !== target);
    for (const node of nodes) {
      const { width, height, x, y } = node.getClientRect();
      switch (type4) {
        case AlignType.垂直居中:
          {
            const cx = x + width / 2;
            node.x(node.x() + (point - cx));
          }
          break;
        case AlignType.水平居中:
          {
            const cy = y + height / 2;
            node.y(node.y() + (point - cy));
          }
          break;
        case AlignType.左对齐:
          {
            const cx = x;
            node.x(node.x() + (point - cx));
          }
          break;
        case AlignType.右对齐:
          {
            const cx = x + width;
            node.x(node.x() + (point - cx));
          }
          break;
        case AlignType.上对齐:
          {
            const cy = y;
            node.y(node.y() + (point - cy));
          }
          break;
        case AlignType.下对齐:
          {
            const cy = y + height;
            node.y(node.y() + (point - cy));
          }
          break;
      }
    }
    this.render.updateHistory();
    this.render.redraw([
      GraphDraw.name,
      LinkDraw.name,
      RulerDraw.name,
      PreviewDraw.name
    ]);
  }
}
__publicField(AlignTool, "name", "AlignTool");
class LinkTool {
  constructor(render22) {
    __publicField(this, "render");
    // 选中连接线
    __publicField(this, "linkCurrent");
    this.render = render22;
  }
  pointsVisible(visible, group) {
    var _a;
    if (!this.render.config.readonly) {
      const start = group ?? this.render.layer;
      for (const asset of [
        ...["asset", "sub-asset"].includes(start.name()) ? [start] : [],
        ...start.find(".asset"),
        ...start.find(".sub-asset")
      ]) {
        const points = asset.getAttr("points") ?? [];
        asset.setAttrs({
          points: points.map((o) => ({ ...o, visible }))
        });
      }
      if (!((_a = this.render.draws[LinkDraw.name]) == null ? void 0 : _a.state.linkManualing)) {
        this.render.redraw([LinkDraw.name, RulerDraw.name, PreviewDraw.name]);
      }
    }
  }
  remove(target) {
    const line = target ?? this.linkCurrent;
    if (line) {
      const { groupId, pointId, pairId } = line.getAttrs();
      if (groupId && pointId && pairId) {
        const group = this.render.layer.findOne(`#${groupId}`);
        if (group) {
          const points = group.getAttr("points") ?? [];
          const point = points.find((o) => o.id === pointId);
          if (point) {
            const pairIndex = (point.pairs ?? []).findIndex(
              (o) => o.id === pairId
            );
            if (pairIndex > -1) {
              const pair = point.pairs.splice(pairIndex, 1)[0];
              if (group.attrs.manualPointsMap && group.attrs.manualPointsMap[pair.id]) {
                group.setAttr("manualPointsMap", {
                  ...group.attrs.manualPointsMap,
                  [pair.id]: void 0
                });
              }
              this.render.redraw([
                LinkDraw.name,
                RulerDraw.name,
                PreviewDraw.name
              ]);
            }
          }
        }
      }
    }
  }
  // 刷新 json 的 id、事件
  jsonIdCover(assets) {
    let deepAssets = [...assets];
    const idMap = /* @__PURE__ */ new Map();
    while (deepAssets.length > 0) {
      const asset = deepAssets.shift();
      if (asset) {
        if (Array.isArray(asset.attrs.points)) {
          for (const point of asset.attrs.points) {
            if (Array.isArray(point.pairs)) {
              for (const pair of point.pairs) {
                if (pair.from.groupId && !idMap.has(pair.from.groupId)) {
                  idMap.set(pair.from.groupId, "g:" + nanoid());
                }
                if (pair.to.groupId && !idMap.has(pair.to.groupId)) {
                  idMap.set(pair.to.groupId, "g:" + nanoid());
                }
                if (pair.from.pointId && !idMap.has(pair.from.pointId)) {
                  idMap.set(pair.from.pointId, "p:" + nanoid());
                }
                if (pair.to.pointId && !idMap.has(pair.to.pointId)) {
                  idMap.set(pair.to.pointId, "p:" + nanoid());
                }
              }
            }
            if (point.id) {
              if (!idMap.has(point.id)) {
                idMap.set(point.id, "p:" + nanoid());
              }
            }
            if (point.groupId) {
              if (!idMap.has(point.groupId)) {
                idMap.set(point.groupId, "g:" + nanoid());
              }
            }
          }
        }
        if (asset.attrs.id) {
          if (!idMap.has(asset.attrs.id)) {
            idMap.set(asset.attrs.id, "n:" + nanoid());
          }
        }
        if (Array.isArray(asset.children)) {
          deepAssets.push(...asset.children);
        }
      }
    }
    deepAssets = [...assets];
    while (deepAssets.length > 0) {
      const asset = deepAssets.shift();
      if (asset) {
        if (idMap.has(asset.attrs.id)) {
          asset.attrs.id = idMap.get(asset.attrs.id);
        }
        if (Array.isArray(asset.attrs.points)) {
          for (const point of asset.attrs.points) {
            if (Array.isArray(point.pairs)) {
              for (const pair of point.pairs) {
                pair.disabled = true;
                if (pair.id) {
                  pair.id = "pr:" + nanoid();
                }
                if (idMap.has(pair.from.groupId)) {
                  pair.from.groupId = idMap.get(pair.from.groupId);
                }
                if (idMap.has(pair.to.groupId)) {
                  pair.to.groupId = idMap.get(pair.to.groupId);
                }
                if (idMap.has(pair.from.pointId)) {
                  pair.from.pointId = idMap.get(pair.from.pointId);
                }
                if (idMap.has(pair.to.pointId)) {
                  pair.to.pointId = idMap.get(pair.to.pointId);
                }
              }
            }
            if (idMap.has(point.id)) {
              const anchor = asset.children.find((o) => o.attrs.id === point.id);
              point.id = idMap.get(point.id);
              if (anchor) {
                anchor.attrs.id = point.id;
              }
            }
            if (idMap.has(point.groupId)) {
              point.groupId = idMap.get(point.groupId);
            }
          }
        }
        if (Array.isArray(asset.children)) {
          deepAssets.push(...asset.children);
        }
      }
    }
  }
  // 把深层 group 的 id 统一为顶层 group 的 id
  groupIdCover(group) {
    const groupId = group.id();
    const subGroups = group.find(".sub-asset");
    while (subGroups.length > 0) {
      const subGroup = subGroups.shift();
      if (subGroup) {
        const points = subGroup.attrs.points;
        if (Array.isArray(points)) {
          for (const point of points) {
            point.rawGroupId = point.groupId;
            point.groupId = groupId;
            for (const pair of point.pairs) {
              pair.from.rawGroupId = pair.from.groupId;
              pair.from.groupId = groupId;
              pair.to.rawGroupId = pair.to.groupId;
              pair.to.groupId = groupId;
            }
          }
        }
        subGroups.push(...subGroup.find(".sub-asset"));
      }
    }
  }
  // 选中
  select(link) {
    this.render.selectionTool.selectingClear();
    this.linkCurrent = link;
    this.render.emit("link-selection-change", this.linkCurrent);
    this.render.redraw([
      LinkDraw.name,
      // 更新连线
      RulerDraw.name
      // 更新比例尺
    ]);
  }
  // 清空选中
  selectingClear() {
    this.linkCurrent = void 0;
    this.render.emit("link-selection-change", void 0);
    this.render.redraw([
      LinkDraw.name,
      // 更新连线
      RulerDraw.name
    ]);
  }
}
__publicField(LinkTool, "name", "LinkTool");
class AttractTool {
  constructor(render22) {
    __publicField(this, "render");
    // 对齐线
    __publicField(this, "alignLines", []);
    __publicField(this, "attractPoint", (pos) => {
      this.alignLinesClear();
      const stageState = this.render.getStageState();
      let newPosX = pos.x;
      let newPosY = pos.y;
      let isAttract = false;
      let pairX = null;
      let pairY = null;
      if (!this.render.config.readonly && this.render.config.attractNode) {
        const sortX = [
          {
            value: this.render.toStageValue(newPosX - stageState.x)
            // 左
          }
        ], sortY = [
          {
            value: this.render.toStageValue(newPosY - stageState.y)
            // 上
          }
        ];
        let XMin = Infinity;
        let pairXMin = [];
        let YMin = Infinity;
        let pairYMin = [];
        for (let i = 0; i < sortX.length - 1; i++) {
          if (sortX[i].id === void 0 && sortX[i + 1].id !== void 0 || sortX[i].id !== void 0 && sortX[i + 1].id === void 0) {
            const offset = Math.abs(sortX[i].value - sortX[i + 1].value);
            if (offset < XMin) {
              XMin = offset;
              pairXMin = [[sortX[i], sortX[i + 1]]];
            } else if (offset === XMin) {
              pairXMin.push([sortX[i], sortX[i + 1]]);
            }
          }
        }
        for (let i = 0; i < sortY.length - 1; i++) {
          if (sortY[i].id === void 0 && sortY[i + 1].id !== void 0 || sortY[i].id !== void 0 && sortY[i + 1].id === void 0) {
            const offset = Math.abs(sortY[i].value - sortY[i + 1].value);
            if (offset < YMin) {
              YMin = offset;
              pairYMin = [[sortY[i], sortY[i + 1]]];
            } else if (offset === YMin) {
              pairYMin.push([sortY[i], sortY[i + 1]]);
            }
          }
        }
        if (pairXMin[0]) {
          if (Math.abs(pairXMin[0][0].value - pairXMin[0][1].value) < this.render.bgSize / 2) {
            pairX = pairXMin[0];
          }
        }
        if (pairYMin[0]) {
          if (Math.abs(pairYMin[0][0].value - pairYMin[0][1].value) < this.render.bgSize / 2) {
            pairY = pairYMin[0];
          }
        }
        if ((pairX == null ? void 0 : pairX.length) === 2) {
          for (const pair of pairXMin) {
            const other2 = pair.find((o) => o.id !== void 0);
            if (other2) {
              const line = new Konva.Line({
                points: lodash.flatten([
                  [other2.value, this.render.toStageValue(-stageState.y)],
                  [other2.value, this.render.toStageValue(this.render.stage.height() - stageState.y)]
                ]),
                stroke: "blue",
                strokeWidth: this.render.toStageValue(1),
                dash: [4, 4],
                listening: false
              });
              this.alignLines.push(line);
              this.render.layerCover.add(line);
            }
          }
          const target = pairX.find((o) => o.id === void 0);
          const other = pairX.find((o) => o.id !== void 0);
          if (target && other) {
            newPosX = newPosX - this.render.toBoardValue(target.value - other.value);
            isAttract = true;
          }
        }
        if ((pairY == null ? void 0 : pairY.length) === 2) {
          for (const pair of pairYMin) {
            const other2 = pair.find((o) => o.id !== void 0);
            if (other2) {
              const line = new Konva.Line({
                points: lodash.flatten([
                  [this.render.toStageValue(-stageState.x), other2.value],
                  [this.render.toStageValue(this.render.stage.width() - stageState.x), other2.value]
                ]),
                stroke: "blue",
                strokeWidth: this.render.toStageValue(1),
                dash: [4, 4],
                listening: false
              });
              this.alignLines.push(line);
              this.render.layerCover.add(line);
            }
          }
          const target = pairY.find((o) => o.id === void 0);
          const other = pairY.find((o) => o.id !== void 0);
          if (target && other) {
            newPosY = newPosY - this.render.toBoardValue(target.value - other.value);
            isAttract = true;
          }
        }
      }
      if (!this.render.config.readonly && this.render.config.attractBg) {
        if (pairX === null) {
          const logicLeftX = this.render.toStageValue(newPosX - stageState.x);
          const logicNumLeftX = Math.round(logicLeftX / this.render.bgSize);
          const logicClosestLeftX = logicNumLeftX * this.render.bgSize;
          const logicDiffLeftX = Math.abs(logicLeftX - logicClosestLeftX);
          const logicRightX = this.render.toStageValue(newPosX - stageState.x);
          const logicNumRightX = Math.round(logicRightX / this.render.bgSize);
          const logicClosestRightX = logicNumRightX * this.render.bgSize;
          const logicDiffRightX = Math.abs(logicRightX - logicClosestRightX);
          const logicStageRightX = stageState.width;
          const logicDiffStageRightX = Math.abs(logicRightX - logicStageRightX);
          for (const diff of [
            { type: "leftX", value: logicDiffLeftX },
            { type: "rightX", value: logicDiffRightX },
            { type: "stageRightX", value: logicDiffStageRightX }
          ].sort((a, b) => a.value - b.value)) {
            if (diff.value < 5) {
              if (diff.type === "stageRightX") {
                newPosX = this.render.toBoardValue(logicStageRightX) + stageState.x;
              } else if (diff.type === "leftX") {
                newPosX = this.render.toBoardValue(logicClosestLeftX) + stageState.x;
              } else if (diff.type === "rightX") {
                newPosX = this.render.toBoardValue(logicClosestRightX) + stageState.x;
              }
              isAttract = true;
              break;
            }
          }
        }
        if (pairY === null) {
          const logicTopY = this.render.toStageValue(newPosY - stageState.y);
          const logicNumTopY = Math.round(logicTopY / this.render.bgSize);
          const logicClosestTopY = logicNumTopY * this.render.bgSize;
          const logicDiffTopY = Math.abs(logicTopY - logicClosestTopY);
          const logicBottomY = this.render.toStageValue(newPosY - stageState.y);
          const logicNumBottomY = Math.round(logicBottomY / this.render.bgSize);
          const logicClosestBottomY = logicNumBottomY * this.render.bgSize;
          const logicDiffBottomY = Math.abs(logicBottomY - logicClosestBottomY);
          const logicStageBottomY = stageState.height;
          const logicDiffStageBottomY = Math.abs(logicBottomY - logicStageBottomY);
          for (const diff of [
            { type: "topY", value: logicDiffTopY },
            { type: "bottomY", value: logicDiffBottomY },
            { type: "stageBottomY", value: logicDiffStageBottomY }
          ].sort((a, b) => a.value - b.value)) {
            if (diff.value < 5) {
              if (diff.type === "stageBottomY") {
                newPosY = this.render.toBoardValue(logicStageBottomY) + stageState.y;
              } else if (diff.type === "topY") {
                newPosY = this.render.toBoardValue(logicClosestTopY) + stageState.y;
              } else if (diff.type === "bottomY") {
                newPosY = this.render.toBoardValue(logicClosestBottomY) + stageState.y;
              }
              isAttract = true;
              break;
            }
          }
        }
      }
      return {
        pos: {
          x: newPosX,
          y: newPosY
        },
        isAttract
      };
    });
    // 磁吸逻辑
    __publicField(this, "attractTransformer", (rect) => {
      this.alignLinesClear();
      const stageState = this.render.getStageState();
      const width = this.render.transformer.width();
      const height = this.render.transformer.height();
      let newPosX = rect.x;
      let newPosY = rect.y;
      let isAttract = false;
      let pairX = null;
      let pairY = null;
      if (!this.render.config.readonly && this.render.config.attractNode) {
        const { sortX, sortY } = this.getSortItems(rect);
        let XMin = Infinity;
        let pairXMin = [];
        let YMin = Infinity;
        let pairYMin = [];
        for (let i = 0; i < sortX.length - 1; i++) {
          if (sortX[i].id === void 0 && sortX[i + 1].id !== void 0 || sortX[i].id !== void 0 && sortX[i + 1].id === void 0) {
            const offset = Math.abs(sortX[i].value - sortX[i + 1].value);
            if (offset < XMin) {
              XMin = offset;
              pairXMin = [[sortX[i], sortX[i + 1]]];
            } else if (offset === XMin) {
              pairXMin.push([sortX[i], sortX[i + 1]]);
            }
          }
        }
        for (let i = 0; i < sortY.length - 1; i++) {
          if (sortY[i].id === void 0 && sortY[i + 1].id !== void 0 || sortY[i].id !== void 0 && sortY[i + 1].id === void 0) {
            const offset = Math.abs(sortY[i].value - sortY[i + 1].value);
            if (offset < YMin) {
              YMin = offset;
              pairYMin = [[sortY[i], sortY[i + 1]]];
            } else if (offset === YMin) {
              pairYMin.push([sortY[i], sortY[i + 1]]);
            }
          }
        }
        if (pairXMin[0]) {
          if (Math.abs(pairXMin[0][0].value - pairXMin[0][1].value) < this.render.bgSize / 2) {
            pairX = pairXMin[0];
          }
        }
        if (pairYMin[0]) {
          if (Math.abs(pairYMin[0][0].value - pairYMin[0][1].value) < this.render.bgSize / 2) {
            pairY = pairYMin[0];
          }
        }
        if ((pairX == null ? void 0 : pairX.length) === 2) {
          for (const pair of pairXMin) {
            const other2 = pair.find((o) => o.id !== void 0);
            if (other2) {
              const line = new Konva.Line({
                points: lodash.flatten([
                  [other2.value, this.render.toStageValue(-stageState.y)],
                  [other2.value, this.render.toStageValue(this.render.stage.height() - stageState.y)]
                ]),
                stroke: "blue",
                strokeWidth: this.render.toStageValue(1),
                dash: [4, 4],
                listening: false
              });
              this.alignLines.push(line);
              this.render.layerCover.add(line);
            }
          }
          const target = pairX.find((o) => o.id === void 0);
          const other = pairX.find((o) => o.id !== void 0);
          if (target && other) {
            newPosX = newPosX - this.render.toBoardValue(target.value - other.value);
            isAttract = true;
          }
        }
        if ((pairY == null ? void 0 : pairY.length) === 2) {
          for (const pair of pairYMin) {
            const other2 = pair.find((o) => o.id !== void 0);
            if (other2) {
              const line = new Konva.Line({
                points: lodash.flatten([
                  [this.render.toStageValue(-stageState.x), other2.value],
                  [this.render.toStageValue(this.render.stage.width() - stageState.x), other2.value]
                ]),
                stroke: "blue",
                strokeWidth: this.render.toStageValue(1),
                dash: [4, 4],
                listening: false
              });
              this.alignLines.push(line);
              this.render.layerCover.add(line);
            }
          }
          const target = pairY.find((o) => o.id === void 0);
          const other = pairY.find((o) => o.id !== void 0);
          if (target && other) {
            newPosY = newPosY - this.render.toBoardValue(target.value - other.value);
            isAttract = true;
          }
        }
      }
      if (!this.render.config.readonly && this.render.config.attractBg) {
        if (pairX === null) {
          const logicLeftX = this.render.toStageValue(newPosX - stageState.x);
          const logicNumLeftX = Math.round(logicLeftX / this.render.bgSize);
          const logicClosestLeftX = logicNumLeftX * this.render.bgSize;
          const logicDiffLeftX = Math.abs(logicLeftX - logicClosestLeftX);
          const logicRightX = this.render.toStageValue(newPosX + width - stageState.x);
          const logicNumRightX = Math.round(logicRightX / this.render.bgSize);
          const logicClosestRightX = logicNumRightX * this.render.bgSize;
          const logicDiffRightX = Math.abs(logicRightX - logicClosestRightX);
          const logicStageRightX = stageState.width;
          const logicDiffStageRightX = Math.abs(logicRightX - logicStageRightX);
          for (const diff of [
            { type: "leftX", value: logicDiffLeftX },
            { type: "rightX", value: logicDiffRightX },
            { type: "stageRightX", value: logicDiffStageRightX }
          ].sort((a, b) => a.value - b.value)) {
            if (diff.value < 5) {
              if (diff.type === "stageRightX") {
                newPosX = this.render.toBoardValue(logicStageRightX) + stageState.x - width;
              } else if (diff.type === "leftX") {
                newPosX = this.render.toBoardValue(logicClosestLeftX) + stageState.x;
              } else if (diff.type === "rightX") {
                newPosX = this.render.toBoardValue(logicClosestRightX) + stageState.x - width;
              }
              isAttract = true;
              break;
            }
          }
        }
        if (pairY === null) {
          const logicTopY = this.render.toStageValue(newPosY - stageState.y);
          const logicNumTopY = Math.round(logicTopY / this.render.bgSize);
          const logicClosestTopY = logicNumTopY * this.render.bgSize;
          const logicDiffTopY = Math.abs(logicTopY - logicClosestTopY);
          const logicBottomY = this.render.toStageValue(newPosY + height - stageState.y);
          const logicNumBottomY = Math.round(logicBottomY / this.render.bgSize);
          const logicClosestBottomY = logicNumBottomY * this.render.bgSize;
          const logicDiffBottomY = Math.abs(logicBottomY - logicClosestBottomY);
          const logicStageBottomY = stageState.height;
          const logicDiffStageBottomY = Math.abs(logicBottomY - logicStageBottomY);
          for (const diff of [
            { type: "topY", value: logicDiffTopY },
            { type: "bottomY", value: logicDiffBottomY },
            { type: "stageBottomY", value: logicDiffStageBottomY }
          ].sort((a, b) => a.value - b.value)) {
            if (diff.value < 5) {
              if (diff.type === "stageBottomY") {
                newPosY = this.render.toBoardValue(logicStageBottomY) + stageState.y - height;
              } else if (diff.type === "topY") {
                newPosY = this.render.toBoardValue(logicClosestTopY) + stageState.y;
              } else if (diff.type === "bottomY") {
                newPosY = this.render.toBoardValue(logicClosestBottomY) + stageState.y - height;
              }
              isAttract = true;
              break;
            }
          }
        }
      }
      return {
        pos: {
          x: newPosX,
          y: newPosY
        },
        isAttract
      };
    });
    this.render = render22;
  }
  // 对齐线清除
  alignLinesClear() {
    for (const line of this.alignLines) {
      line.destroy();
    }
    this.alignLines = [];
  }
  getSortItems(rect) {
    const stageState = this.render.getStageState();
    const sortX = [];
    const sortY = [];
    sortX.push(
      {
        value: this.render.toStageValue(rect.x - stageState.x)
        // 左
      },
      {
        value: this.render.toStageValue(rect.x - stageState.x + rect.width / 2)
        // 垂直中
      },
      {
        value: this.render.toStageValue(rect.x - stageState.x + rect.width)
        // 右
      }
    );
    sortY.push(
      {
        value: this.render.toStageValue(rect.y - stageState.y)
        // 上
      },
      {
        value: this.render.toStageValue(rect.y - stageState.y + rect.height / 2)
        // 水平中
      },
      {
        value: this.render.toStageValue(rect.y - stageState.y + rect.height)
        // 下
      }
    );
    const targetIds = this.render.selectionTool.selectingNodes.map((o) => o._id);
    const otherNodes = this.render.layer.find(".asset").filter((node) => !targetIds.includes(node._id));
    for (const node of otherNodes) {
      const nodeRect = node.getClientRect();
      sortX.push(
        {
          id: node._id,
          value: this.render.toStageValue(nodeRect.x - stageState.x)
          // 左
        },
        {
          id: node._id,
          value: this.render.toStageValue(nodeRect.x - stageState.x + nodeRect.width / 2)
          // 垂直中
        },
        {
          id: node._id,
          value: this.render.toStageValue(nodeRect.x - stageState.x + nodeRect.width)
          // 右
        }
      );
      sortY.push(
        {
          id: node._id,
          value: this.render.toStageValue(nodeRect.y - stageState.y)
          // 上
        },
        {
          id: node._id,
          value: this.render.toStageValue(nodeRect.y - stageState.y + nodeRect.height / 2)
          // 水平中
        },
        {
          id: node._id,
          value: this.render.toStageValue(nodeRect.y - stageState.y + nodeRect.height)
          // 下
        }
      );
    }
    sortX.sort((a, b) => a.value - b.value);
    sortY.sort((a, b) => a.value - b.value);
    return { sortX, sortY };
  }
}
__publicField(AttractTool, "name", "AttractTool");
const _Render = class _Render {
  constructor(stageEle, config) {
    __publicField(this, "stage");
    // 主要层
    __publicField(this, "layer", new Konva.Layer({ id: "main" }));
    // 辅助层 - 底层
    __publicField(this, "layerFloor", new Konva.Layer());
    // 辅助层 - 顶层
    __publicField(this, "layerCover", new Konva.Layer({ id: "cover" }));
    // 配置
    __publicField(this, "config");
    // 附加工具
    __publicField(this, "draws", {});
    // 素材工具
    __publicField(this, "assetTool");
    // 选择工具
    __publicField(this, "selectionTool");
    // 复制工具
    __publicField(this, "copyTool");
    // 定位工具
    __publicField(this, "positionTool");
    // 层级工具
    __publicField(this, "zIndexTool");
    // 导入导出
    __publicField(this, "importExportTool");
    // 对齐工具
    __publicField(this, "alignTool");
    // 连线工具
    __publicField(this, "linkTool");
    // 磁贴工具
    __publicField(this, "attractTool");
    // 多选器层
    __publicField(this, "groupTransformer", new Konva.Group());
    // 多选器
    __publicField(this, "transformer", new Konva.Transformer({
      shouldOverdrawWholeArea: true,
      borderDash: [4, 4],
      padding: 1,
      rotationSnaps: [0, 45, 90, 135, 180, 225, 270, 315, 360],
      flipEnabled: false
    }));
    // 选择框
    __publicField(this, "selectRect", new Konva.Rect({
      id: "selectRect",
      fill: "rgba(0,0,255,0.1)",
      visible: false
    }));
    // 事件处理
    __publicField(this, "handlers", {});
    // 参数
    __publicField(this, "bgSize", 20);
    __publicField(this, "rulerSize", 0);
    __publicField(this, "previewSize", 0.2);
    // 预览框大小（比例）
    __publicField(this, "pointSize", 6);
    __publicField(this, "history", []);
    __publicField(this, "historyIndex", -1);
    // 调试模式
    __publicField(this, "debug", false);
    // 画图类型
    __publicField(this, "graphType");
    // 添加文字中
    __publicField(this, "texting", false);
    __publicField(this, "emitter", mitt());
    __publicField(this, "on");
    __publicField(this, "off");
    __publicField(this, "emit");
    this.config = config;
    this.on = this.emitter.on.bind(this.emitter);
    this.off = this.emitter.off.bind(this.emitter);
    this.emit = this.emitter.emit.bind(this.emitter);
    if (this.config.showRuler) {
      this.rulerSize = 40;
    }
    this.stage = new Konva.Stage({
      container: stageEle,
      x: this.rulerSize,
      y: this.rulerSize,
      width: config.width,
      height: config.height
    });
    this.groupTransformer.add(this.transformer);
    this.groupTransformer.add(this.selectRect);
    this.layerCover.add(this.groupTransformer);
    if (!this.config.readonly && this.config.showBg) {
      this.draws[BgDraw.name] = new BgDraw(this, this.layerFloor, {
        size: this.bgSize
      });
    }
    this.draws[LinkDraw.name] = new LinkDraw(this, this.layerCover, {
      size: this.pointSize
    });
    this.draws[AttractDraw.name] = new AttractDraw(this, this.layerCover, {
      size: this.pointSize
    });
    if (!this.config.readonly && this.config.showRuler) {
      this.draws[RulerDraw.name] = new RulerDraw(this, this.layerCover, {
        size: this.rulerSize
      });
    }
    if (!this.config.readonly && this.config.showRefLine) {
      this.draws[RefLineDraw.name] = new RefLineDraw(this, this.layerCover, {
        padding: this.rulerSize
      });
    }
    if (this.config.showContextmenu) {
      this.draws[ContextmenuDraw.name] = new ContextmenuDraw(this, this.layerCover, {
        //
      });
    }
    if (!this.config.readonly && this.config.showPreview) {
      this.draws[PreviewDraw.name] = new PreviewDraw(this, this.layerCover, {
        size: this.previewSize
      });
    }
    this.draws[GraphDraw.name] = new GraphDraw(this, this.layerCover, {
      //
    });
    this.assetTool = new AssetTool(this);
    this.selectionTool = new SelectionTool(this);
    this.copyTool = new CopyTool(this);
    this.positionTool = new PositionTool(this);
    this.zIndexTool = new ZIndexTool(this);
    this.importExportTool = new ImportExportTool(this);
    this.alignTool = new AlignTool(this);
    this.linkTool = new LinkTool(this);
    this.attractTool = new AttractTool(this);
    this.handlers[DragHandlers.name] = new DragHandlers(this);
    this.handlers[ZoomHandlers.name] = new ZoomHandlers(this);
    if (!this.config.readonly) {
      this.handlers[DragOutsideHandlers.name] = new DragOutsideHandlers(this);
      this.handlers[SelectionHandlers.name] = new SelectionHandlers(this);
      this.handlers[KeyMoveHandlers.name] = new KeyMoveHandlers(this);
      this.handlers[LinkHandlers.name] = new LinkHandlers(this);
      this.handlers[GraphHandlers.name] = new GraphHandlers(this);
      this.handlers[TextHandlers.name] = new TextHandlers(this);
    }
    if (!this.config.readonly && this.config.showRefLine) {
      if (this.draws[RefLineDraw.name] !== void 0) {
        this.handlers[RefLineDraw.name] = this.draws[RefLineDraw.name];
      }
    }
    this.handlers[ShutcutHandlers.name] = new ShutcutHandlers(this);
    this.init();
  }
  changeDebug(v) {
    var _a, _b, _c, _d, _e, _f;
    this.debug = v;
    this.emit("debug-change", this.debug);
    (_a = this.draws[LinkDraw.name]) == null ? void 0 : _a.init();
    (_b = this.draws[AttractDraw.name]) == null ? void 0 : _b.init();
    (_c = this.draws[RulerDraw.name]) == null ? void 0 : _c.init();
    (_d = this.draws[RefLineDraw.name]) == null ? void 0 : _d.init();
    (_e = this.draws[ContextmenuDraw.name]) == null ? void 0 : _e.init();
    (_f = this.draws[PreviewDraw.name]) == null ? void 0 : _f.init();
    return this.debug;
  }
  // 初始化
  init() {
    var _a, _b, _c, _d, _e, _f, _g;
    this.stage.add(this.layerFloor);
    (_a = this.draws[BgDraw.name]) == null ? void 0 : _a.init();
    this.stage.add(this.layer);
    this.stage.add(this.layerCover);
    (_b = this.draws[LinkDraw.name]) == null ? void 0 : _b.init();
    (_c = this.draws[AttractDraw.name]) == null ? void 0 : _c.init();
    (_d = this.draws[RulerDraw.name]) == null ? void 0 : _d.init();
    (_e = this.draws[RefLineDraw.name]) == null ? void 0 : _e.init();
    (_f = this.draws[ContextmenuDraw.name]) == null ? void 0 : _f.init();
    (_g = this.draws[PreviewDraw.name]) == null ? void 0 : _g.init();
    this.eventBind();
    this.updateHistory();
  }
  // 更新 stage 尺寸
  resize(width, height) {
    this.stage.setAttrs({
      width,
      height
    });
    this.redraw();
  }
  // 移除元素
  remove(nodes) {
    for (const node of nodes) {
      if (node instanceof Konva.Transformer) {
        this.remove(this.selectionTool.selectingNodes);
      } else {
        const groupId = node.id();
        for (const rn of this.layer.getChildren()) {
          if (rn.id() !== groupId && Array.isArray(rn.attrs.points)) {
            for (const point of rn.attrs.points) {
              if (Array.isArray(point.pairs)) {
                if (rn.attrs.manualPointsMap) {
                  point.pairs.filter(
                    (pair) => pair.from.groupId === groupId || pair.to.groupId === groupId
                  ).forEach((pair) => {
                    rn.attrs.manualPointsMap[pair.id] = void 0;
                  });
                }
                point.pairs = point.pairs.filter(
                  (pair) => pair.from.groupId !== groupId && pair.to.groupId !== groupId
                );
              }
            }
            rn.setAttr("points", rn.attrs.points);
          }
        }
        node.destroy();
      }
    }
    if (nodes.length > 0) {
      this.selectionTool.selectingClear();
      this.linkTool.selectingClear();
      this.updateHistory();
      this.redraw();
    }
  }
  prevHistory() {
    const record = this.history[this.historyIndex - 1];
    if (record) {
      this.importExportTool.restore(record, true);
      this.historyIndex--;
      this.emit("history-change", {
        records: lodash.clone(this.history),
        index: this.historyIndex
      });
    }
  }
  nextHistory() {
    const record = this.history[this.historyIndex + 1];
    if (record) {
      this.importExportTool.restore(record, true);
      this.historyIndex++;
      this.emit("history-change", {
        records: lodash.clone(this.history),
        index: this.historyIndex
      });
    }
  }
  updateHistory() {
    this.history.splice(this.historyIndex + 1);
    this.history.push(this.importExportTool.save());
    this.historyIndex = this.history.length - 1;
    this.emit("history-change", {
      records: lodash.clone(this.history),
      index: this.historyIndex
    });
  }
  // 事件绑定
  eventBind() {
    var _a, _b;
    for (const event of [
      "mousedown",
      "mouseup",
      "mousemove",
      "wheel",
      "contextmenu",
      "pointerclick"
    ]) {
      this.stage.on(event, (e) => {
        var _a2, _b2, _c, _d, _e, _f, _g, _h, _i;
        (_a2 = e == null ? void 0 : e.evt) == null ? void 0 : _a2.preventDefault();
        for (const k in this.draws) {
          (_e = (_d = (_c = (_b2 = this.draws[k]) == null ? void 0 : _b2.handlers) == null ? void 0 : _c.stage) == null ? void 0 : _d[event]) == null ? void 0 : _e.call(_d, e);
        }
        for (const k in this.handlers) {
          (_i = (_h = (_g = (_f = this.handlers[k]) == null ? void 0 : _f.handlers) == null ? void 0 : _g.stage) == null ? void 0 : _h[event]) == null ? void 0 : _i.call(_h, e);
        }
      });
    }
    const container = this.stage.container();
    container.tabIndex = 1;
    container.focus();
    for (const event of [
      "mouseenter",
      "dragenter",
      "mousemove",
      "mouseout",
      "dragenter",
      "dragover",
      "drop",
      "keydown",
      "keyup"
    ]) {
      container.addEventListener(event, (e) => {
        var _a2, _b2, _c, _d, _e, _f, _g, _h;
        e == null ? void 0 : e.preventDefault();
        if (["mouseenter", "dragenter"].includes(event)) {
          this.stage.container().focus();
        }
        for (const k in this.draws) {
          (_d = (_c = (_b2 = (_a2 = this.draws[k]) == null ? void 0 : _a2.handlers) == null ? void 0 : _b2.dom) == null ? void 0 : _c[event]) == null ? void 0 : _d.call(_c, e);
        }
        for (const k in this.handlers) {
          (_h = (_g = (_f = (_e = this.handlers[k]) == null ? void 0 : _e.handlers) == null ? void 0 : _f.dom) == null ? void 0 : _g[event]) == null ? void 0 : _h.call(_g, e);
        }
      });
    }
    for (const event of [
      "mousedown",
      "transformstart",
      "transform",
      "transformend",
      "dragstart",
      "dragmove",
      "dragend",
      "mousemove",
      "mouseleave",
      "dblclick"
    ]) {
      this.transformer.on(event, (e) => {
        var _a2, _b2, _c, _d, _e, _f, _g, _h, _i;
        (_a2 = e == null ? void 0 : e.evt) == null ? void 0 : _a2.preventDefault();
        for (const k in this.draws) {
          (_e = (_d = (_c = (_b2 = this.draws[k]) == null ? void 0 : _b2.handlers) == null ? void 0 : _c.transformer) == null ? void 0 : _d[event]) == null ? void 0 : _e.call(_d, e);
        }
        for (const k in this.handlers) {
          (_i = (_h = (_g = (_f = this.handlers[k]) == null ? void 0 : _f.handlers) == null ? void 0 : _g.transformer) == null ? void 0 : _h[event]) == null ? void 0 : _i.call(_h, e);
        }
      });
    }
    ((_b = (_a = this.handlers[SelectionHandlers.name]) == null ? void 0 : _a.transformerConfig) == null ? void 0 : _b.anchorDragBoundFunc) && this.transformer.anchorDragBoundFunc(
      this.handlers[SelectionHandlers.name].transformerConfig.anchorDragBoundFunc
    );
  }
  // 获取 stage 状态
  getStageState() {
    return {
      width: this.stage.width() - this.rulerSize,
      height: this.stage.height() - this.rulerSize,
      scale: this.stage.scaleX(),
      x: this.stage.x(),
      y: this.stage.y()
    };
  }
  // 相对大小（基于 stage，且无视 scale）
  toStageValue(boardPos) {
    return boardPos / this.stage.scaleX();
  }
  // 绝对大小（基于可视区域像素）
  toBoardValue(stagePos) {
    return stagePos * this.stage.scaleX();
  }
  // 忽略非素材
  ignore(node) {
    const isGroup2 = node instanceof Konva.Group;
    return !isGroup2 || this.ignoreSelect(node) || this.ignoreDraw(node) || this.ignoreLink(node);
  }
  // 忽略 选择时 辅助元素
  ignoreSelect(node) {
    return node.id() === "selectRect" || node.id() === "hoverRect";
  }
  // 忽略各 draw 的根 group
  ignoreDraw(node) {
    return node.name() === BgDraw.name || node.name() === RulerDraw.name || node.name() === RefLineDraw.name || node.name() === ContextmenuDraw.name || node.name() === PreviewDraw.name || node.name() === LinkDraw.name || node.name() === AttractDraw.name || node.name() === GraphDraw.name;
  }
  // 忽略各 draw 的根 group
  ignoreLink(node) {
    return node.name() === "link-anchor" || node.name() === "linking-line" || node.name() === "link-point" || node.name() === "link-line" || node.name() === "link-manual-point";
  }
  // 重绘（可选择）
  redraw(drawNames) {
    var _a, _b;
    const all = [
      // layerFloor
      BgDraw.name,
      // 更新背景
      // layerCover（按先后顺序）
      GraphDraw.name,
      // 更新图形调整点
      LinkDraw.name,
      // 更新连线
      AttractDraw.name,
      // 更新磁贴
      RulerDraw.name,
      // 更新比例尺
      RefLineDraw.name,
      // 更新参考线
      PreviewDraw.name,
      // 更新预览
      ContextmenuDraw.name
      // 更新右键菜单
    ];
    if (Array.isArray(drawNames) && !this.debug) {
      for (const name of all) {
        if (drawNames.includes(name)) {
          (_a = this.draws[name]) == null ? void 0 : _a.draw();
        }
      }
    } else {
      for (const name of all) {
        (_b = this.draws[name]) == null ? void 0 : _b.draw();
      }
    }
  }
  changeDraggable(disabled) {
    this.layer.children.forEach((asset) => {
      asset.draggable(disabled);
    });
  }
  // 改变画图类型
  changeGraphType(type4) {
    if (type4) {
      this.texting = false;
      this.emit("texting-change", this.texting);
    }
    this.graphType = type4;
    this.emit("graph-type-change", this.graphType);
    this.changeDraggable(!this.config.readonly && this.graphType === void 0);
  }
  // 添加文字状态
  changeTexting(texting) {
    if (texting) {
      this.graphType = void 0;
      this.emit("graph-type-change", this.graphType);
    }
    this.texting = texting;
    this.emit("texting-change", this.texting);
    document.body.style.cursor = this.texting ? "text" : "default";
  }
  // 获取页面设置
  getPageSettings() {
    return this.stage.attrs.pageSettings ?? { ..._Render.PageSettingsDefault };
  }
  // 更新页面设置
  setPageSettings(settings, update2 = false) {
    this.stage.setAttr("pageSettings", settings);
    this.updateBackground();
    if (update2) {
      this.updateHistory();
    }
  }
  // 获取背景
  getBackground() {
    var _a;
    return (_a = this.draws[BgDraw.name]) == null ? void 0 : _a.layer.findOne(
      `.${BgDraw.name}__background`
    );
  }
  // 更新背景
  updateBackground() {
    var _a, _b, _c, _d;
    const background = this.getBackground();
    if (background) {
      background.fill(this.getPageSettings().background ?? "transparent");
    }
    (_a = this.draws[BgDraw.name]) == null ? void 0 : _a.draw();
    (_b = this.draws[GraphDraw.name]) == null ? void 0 : _b.draw();
    (_c = this.draws[LinkDraw.name]) == null ? void 0 : _c.draw();
    (_d = this.draws[PreviewDraw.name]) == null ? void 0 : _d.draw();
  }
  // 获取素材设置
  getAssetSettings(asset) {
    const base2 = (asset == null ? void 0 : asset.attrs.assetSettings) ?? { ..._Render.AssetSettingsDefault };
    return {
      // 特定
      ...base2,
      // 继承全局
      stroke: base2.stroke || this.getPageSettings().stroke,
      strokeWidth: base2.strokeWidth || this.getPageSettings().strokeWidth,
      fontSize: base2.fontSize || this.getPageSettings().fontSize,
      textFill: base2.textFill || this.getPageSettings().textFill,
      // 绘制图形，默认不填充
      fill: base2.fill || ((asset == null ? void 0 : asset.attrs.assetType) === AssetType.Graph ? "transparent" : this.getPageSettings().fill),
      x: parseFloat(((asset == null ? void 0 : asset.position().x) ?? 0).toFixed(1)),
      y: parseFloat(((asset == null ? void 0 : asset.position().y) ?? 0).toFixed(1)),
      rotation: parseFloat(((asset == null ? void 0 : asset.rotation()) ?? 0).toFixed(1))
    };
  }
  // 设置 svgXML 样式（部分）
  setSvgXMLSettings(xml, settings) {
    const reg = /<(circle|ellipse|line|path|polygon|rect|text|textPath|tref|tspan)[^>/]*\/?>/g;
    const shapes = xml.match(reg);
    const regStroke = / stroke="([^"]*)"/;
    const regFill = / fill="([^"]*)"/;
    for (const shape of shapes ?? []) {
      let result2 = shape;
      if (settings.stroke) {
        if (regStroke.test(shape)) {
          result2 = result2.replace(regStroke, ` stroke="${settings.stroke}"`);
        } else {
          result2 = result2.replace(/(<[^>/]*)(\/?>)/, `$1 stroke="${settings.stroke}" $2`);
        }
      }
      if (settings.fill) {
        if (regFill.test(shape)) {
          result2 = result2.replace(regFill, ` fill="${settings.fill}"`);
        } else {
          result2 = result2.replace(/(<[^>/]*)(\/?>)/, `$1 fill="${settings.fill}" $2`);
        }
      }
      xml = xml.replace(shape, result2);
    }
    return xml;
  }
  rotatePoint({ x, y }, rad) {
    const rCos = Math.cos(rad);
    const rSin = Math.sin(rad);
    return { x: x * rCos - y * rSin, y: y * rCos + x * rSin };
  }
  rotateAroundCenter(node, rotation) {
    const topLeft = { x: -node.width() / 2, y: -node.height() / 2 };
    const current = this.rotatePoint(topLeft, Konva.getAngle(node.rotation()));
    const rotated = this.rotatePoint(topLeft, Konva.getAngle(rotation));
    const dx = rotated.x - current.x, dy = rotated.y - current.y;
    node.rotation(rotation);
    node.x(node.x() + dx);
    node.y(node.y() + dy);
  }
  // 更新素材设置
  async setAssetSettings(asset, settings, update2 = false) {
    var _a, _b, _c, _d, _e;
    asset.setAttr("assetSettings", settings);
    if (asset instanceof Konva.Group) {
      if (asset.attrs.imageType === ImageType.svg) {
        const node = asset.children[0];
        if (node instanceof Konva.Image) {
          if (node.attrs.svgXML) {
            const n = await this.assetTool.loadSvgXML(
              this.setSvgXMLSettings(node.attrs.svgXML, settings)
            );
            (_a = node.parent) == null ? void 0 : _a.add(n);
            node.remove();
            node.destroy();
            n.zIndex(0);
          }
        }
      } else if (asset.attrs.assetType === AssetType.Graph) {
        const node = asset.findOne(".graph");
        if (node instanceof Konva.Shape) {
          node.strokeWidth(settings.strokeWidth);
          node.stroke(settings.stroke);
          if (node instanceof Konva.Arrow) {
            node.fill(settings.stroke);
          } else {
            node.fill(settings.fill);
          }
          if (node instanceof Konva.Arrow) {
            node.pointerAtBeginning(settings.arrowStart);
            node.pointerAtEnding(settings.arrowEnd);
          }
        }
      } else if (asset.attrs.assetType === AssetType.Text) {
        const node = asset.findOne("Text");
        const rect = asset.findOne("Rect");
        if (node instanceof Konva.Text && rect instanceof Konva.Rect) {
          let sizeChanged = false;
          if (node.fontSize() !== settings.fontSize || node.text() !== settings.text) {
            sizeChanged = true;
          }
          node.fill(settings.textFill);
          node.fontSize(settings.fontSize);
          node.text(settings.text);
          rect.fill(node.text().trim() ? "" : "rgba(0,0,0,0.1)");
          rect.width(Math.max(node.width(), settings.fontSize));
          rect.height(Math.max(node.height(), settings.fontSize));
          if (sizeChanged) {
            this.selectionTool.select([asset]);
          }
        }
      }
      if (Math.abs(settings.rotation - asset.rotation()) >= 0.1) {
        this.rotateAroundCenter(asset, settings.rotation);
        this.emit("asset-position-change", [asset]);
      } else {
        const prevSettings = this.getAssetSettings(asset);
        asset.position({
          x: parseFloat(settings.x.toFixed(1)),
          y: parseFloat(settings.y.toFixed(1))
        });
        if (settings.x !== prevSettings.x || settings.y !== prevSettings.y) {
          this.emit("asset-position-change", [asset]);
        }
      }
    }
    if (update2) {
      this.updateHistory();
    }
    (_b = this.draws[BgDraw.name]) == null ? void 0 : _b.draw();
    (_c = this.draws[GraphDraw.name]) == null ? void 0 : _c.draw();
    (_d = this.draws[LinkDraw.name]) == null ? void 0 : _d.draw();
    (_e = this.draws[PreviewDraw.name]) == null ? void 0 : _e.draw();
  }
  // 连接线设置
  async setLinkSettings(link, settings, update2 = false) {
    var _a, _b, _c, _d;
    const group = this.layer.findOne(`#${link.attrs.groupId}`);
    if (Array.isArray(group == null ? void 0 : group.attrs.points)) {
      const point = (group == null ? void 0 : group.attrs.points).find(
        (o) => o.id === link.attrs.pointId
      );
      if (point) {
        const pair = point.pairs.find((o) => o.id === link.attrs.pairId);
        if (pair) {
          pair.style = {
            ...pair.style,
            ...settings
          };
          group.setAttr("points", group == null ? void 0 : group.attrs.points);
        }
      }
    }
    if (update2) {
      this.updateHistory();
    }
    (_a = this.draws[BgDraw.name]) == null ? void 0 : _a.draw();
    (_b = this.draws[GraphDraw.name]) == null ? void 0 : _b.draw();
    (_c = this.draws[LinkDraw.name]) == null ? void 0 : _c.draw();
    (_d = this.draws[PreviewDraw.name]) == null ? void 0 : _d.draw();
  }
  // 获取连接线设置
  getLinkSettings(link) {
    let settings = void 0;
    if (link) {
      const group = this.layer.findOne(`#${link.attrs.groupId}`);
      if (Array.isArray(group == null ? void 0 : group.attrs.points)) {
        const point = (group == null ? void 0 : group.attrs.points).find(
          (o) => o.id === link.attrs.pointId
        );
        if (point) {
          const pair = point.pairs.find((o) => o.id === link.attrs.pairId);
          if (pair) {
            settings = pair.style;
          }
        }
      }
    }
    const base2 = settings ?? { ..._Render.LinkSettingsDefault };
    return {
      // 特定
      ...base2,
      // 继承全局
      stroke: base2.stroke || this.getPageSettings().linkStroke,
      strokeWidth: base2.strokeWidth || this.getPageSettings().linkStrokeWidth
    };
  }
};
// 页面设置 默认值
__publicField(_Render, "PageSettingsDefault", {
  background: "transparent",
  stroke: "rgb(0,0,0)",
  strokeWidth: 1,
  fill: "rgb(0,0,0)",
  linkStroke: "rgb(0,0,0)",
  linkStrokeWidth: 1,
  fontSize: 24,
  textFill: "rgb(0,0,0)"
});
// 素材设置 默认值
__publicField(_Render, "AssetSettingsDefault", {
  stroke: "",
  strokeWidth: 0,
  fill: "",
  arrowStart: false,
  arrowEnd: false,
  fontSize: 0,
  textFill: "",
  text: "Text",
  x: 0,
  y: 0,
  rotation: 0
});
// 连接线设置 默认值
__publicField(_Render, "LinkSettingsDefault", {
  stroke: "",
  strokeWidth: 0,
  arrowStart: false,
  arrowEnd: false
});
let Render = _Render;
let onceCbs = [];
const paramsMap = /* @__PURE__ */ new WeakMap();
function flushOnceCallbacks() {
  onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));
  onceCbs = [];
}
function beforeNextFrameOnce(cb, ...params) {
  paramsMap.set(cb, params);
  if (onceCbs.includes(cb))
    return;
  onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
}
function happensIn(e, dataSetPropName) {
  let { target } = e;
  while (target) {
    if (target.dataset) {
      if (target.dataset[dataSetPropName] !== void 0)
        return true;
    }
    target = target.parentElement;
  }
  return false;
}
function getPreciseEventTarget(event) {
  return event.composedPath()[0] || null;
}
function depx(value) {
  if (typeof value === "string") {
    if (value.endsWith("px")) {
      return Number(value.slice(0, value.length - 2));
    }
    return Number(value);
  }
  return value;
}
function pxfy(value) {
  if (value === void 0 || value === null)
    return void 0;
  if (typeof value === "number")
    return `${value}px`;
  if (value.endsWith("px"))
    return value;
  return `${value}px`;
}
function getMargin(value, position) {
  const parts = value.trim().split(/\s+/g);
  const margin = {
    top: parts[0]
  };
  switch (parts.length) {
    case 1:
      margin.right = parts[0];
      margin.bottom = parts[0];
      margin.left = parts[0];
      break;
    case 2:
      margin.right = parts[1];
      margin.left = parts[1];
      margin.bottom = parts[0];
      break;
    case 3:
      margin.right = parts[1];
      margin.bottom = parts[2];
      margin.left = parts[1];
      break;
    case 4:
      margin.right = parts[1];
      margin.bottom = parts[2];
      margin.left = parts[3];
      break;
    default:
      throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
  }
  if (position === void 0)
    return margin;
  return margin[position];
}
const colors = {
  black: "#000",
  silver: "#C0C0C0",
  gray: "#808080",
  white: "#FFF",
  maroon: "#800000",
  red: "#F00",
  purple: "#800080",
  fuchsia: "#F0F",
  green: "#008000",
  lime: "#0F0",
  olive: "#808000",
  yellow: "#FF0",
  navy: "#000080",
  blue: "#00F",
  teal: "#008080",
  aqua: "#0FF",
  transparent: "#0000"
};
function hsl2hsv(h2, s, l) {
  s /= 100;
  l /= 100;
  const v = s * Math.min(l, 1 - l) + l;
  return [h2, v ? (2 - 2 * l / v) * 100 : 0, v * 100];
}
function hsv2hsl(h2, s, v) {
  s /= 100;
  v /= 100;
  const l = v - v * s / 2;
  const m = Math.min(l, 1 - l);
  return [h2, m ? (v - l) / m * 100 : 0, l * 100];
}
function hsv2rgb(h2, s, v) {
  s /= 100;
  v /= 100;
  let f = (n, k = (n + h2 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5) * 255, f(3) * 255, f(1) * 255];
}
function rgb2hsv(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  let v = Math.max(r, g, b), c2 = v - Math.min(r, g, b);
  let h2 = c2 && (v == r ? (g - b) / c2 : v == g ? 2 + (b - r) / c2 : 4 + (r - g) / c2);
  return [60 * (h2 < 0 ? h2 + 6 : h2), v && c2 / v * 100, v * 100];
}
function rgb2hsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  let v = Math.max(r, g, b), c2 = v - Math.min(r, g, b), f = 1 - Math.abs(v + v - c2 - 1);
  let h2 = c2 && (v == r ? (g - b) / c2 : v == g ? 2 + (b - r) / c2 : 4 + (r - g) / c2);
  return [60 * (h2 < 0 ? h2 + 6 : h2), f ? c2 / f * 100 : 0, (v + v - c2) * 50];
}
function hsl2rgb(h2, s, l) {
  s /= 100;
  l /= 100;
  let a = s * Math.min(l, 1 - l);
  let f = (n, k = (n + h2 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0) * 255, f(8) * 255, f(4) * 255];
}
const prefix$1 = "^\\s*";
const suffix = "\\s*$";
const percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
const hex = "([0-9A-Fa-f])";
const dhex = "([0-9A-Fa-f]{2})";
const hslRegex = new RegExp(`${prefix$1}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
const hsvRegex = new RegExp(`${prefix$1}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
const hslaRegex = new RegExp(`${prefix$1}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
const hsvaRegex = new RegExp(`${prefix$1}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
const rgbRegex = new RegExp(`${prefix$1}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
const rgbaRegex = new RegExp(`${prefix$1}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
const sHexRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${suffix}`);
const hexRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${suffix}`);
const sHexaRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${hex}${suffix}`);
const hexaRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
function parseHex(value) {
  return parseInt(value, 16);
}
function hsla(color) {
  try {
    let i;
    if (i = hslaRegex.exec(color)) {
      return [
        roundDeg(i[1]),
        roundPercent(i[5]),
        roundPercent(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = hslRegex.exec(color)) {
      return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
    }
    throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function hsva(color) {
  try {
    let i;
    if (i = hsvaRegex.exec(color)) {
      return [
        roundDeg(i[1]),
        roundPercent(i[5]),
        roundPercent(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = hsvRegex.exec(color)) {
      return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
    }
    throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function rgba(color) {
  try {
    let i;
    if (i = hexRegex.exec(color)) {
      return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
    } else if (i = rgbRegex.exec(color)) {
      return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
    } else if (i = rgbaRegex.exec(color)) {
      return [
        roundChannel(i[1]),
        roundChannel(i[5]),
        roundChannel(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = sHexRegex.exec(color)) {
      return [
        parseHex(i[1] + i[1]),
        parseHex(i[2] + i[2]),
        parseHex(i[3] + i[3]),
        1
      ];
    } else if (i = hexaRegex.exec(color)) {
      return [
        parseHex(i[1]),
        parseHex(i[2]),
        parseHex(i[3]),
        roundAlpha(parseHex(i[4]) / 255)
      ];
    } else if (i = sHexaRegex.exec(color)) {
      return [
        parseHex(i[1] + i[1]),
        parseHex(i[2] + i[2]),
        parseHex(i[3] + i[3]),
        roundAlpha(parseHex(i[4] + i[4]) / 255)
      ];
    } else if (color in colors) {
      return rgba(colors[color]);
    }
    throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function normalizeAlpha$1(alphaValue) {
  return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
}
function stringifyRgb(r, g, b) {
  return `rgb(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)})`;
}
function stringifyRgba(r, g, b, a) {
  return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha$1(a)})`;
}
function compositeChannel(v1, a1, v2, a2, a) {
  return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a);
}
function composite(background, overlay2) {
  if (!Array.isArray(background))
    background = rgba(background);
  if (!Array.isArray(overlay2))
    overlay2 = rgba(overlay2);
  const a1 = background[3];
  const a2 = overlay2[3];
  const alpha = roundAlpha(a1 + a2 - a1 * a2);
  return stringifyRgba(compositeChannel(background[0], a1, overlay2[0], a2, alpha), compositeChannel(background[1], a1, overlay2[1], a2, alpha), compositeChannel(background[2], a1, overlay2[2], a2, alpha), alpha);
}
function changeColor(base2, options) {
  const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
  if (options.alpha) {
    return stringifyRgba(r, g, b, options.alpha);
  }
  return stringifyRgba(r, g, b, a);
}
function scaleColor(base2, options) {
  const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
  const { lightness = 1, alpha = 1 } = options;
  return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
}
function roundAlpha(value) {
  const v = Math.round(Number(value) * 100) / 100;
  if (v > 1)
    return 1;
  if (v < 0)
    return 0;
  return v;
}
function roundDeg(value) {
  const v = Math.round(Number(value));
  if (v >= 360)
    return 0;
  if (v < 0)
    return 0;
  return v;
}
function roundChannel(value) {
  const v = Math.round(Number(value));
  if (v > 255)
    return 255;
  if (v < 0)
    return 0;
  return v;
}
function roundPercent(value) {
  const v = Math.round(Number(value));
  if (v > 100)
    return 100;
  if (v < 0)
    return 0;
  return v;
}
function toRgbString(base2) {
  const [r, g, b] = Array.isArray(base2) ? base2 : rgba(base2);
  return stringifyRgb(r, g, b);
}
function toRgbaString(base2) {
  const [r, g, b] = base2;
  if (3 in base2) {
    return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base2[3])})`;
  }
  return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
}
function toHsvString(base2) {
  return `hsv(${roundDeg(base2[0])}, ${roundPercent(base2[1])}%, ${roundPercent(base2[2])}%)`;
}
function toHsvaString(base2) {
  const [h2, s, v] = base2;
  if (3 in base2) {
    return `hsva(${roundDeg(h2)}, ${roundPercent(s)}%, ${roundPercent(v)}%, ${roundAlpha(base2[3])})`;
  }
  return `hsva(${roundDeg(h2)}, ${roundPercent(s)}%, ${roundPercent(v)}%, 1)`;
}
function toHslString(base2) {
  return `hsl(${roundDeg(base2[0])}, ${roundPercent(base2[1])}%, ${roundPercent(base2[2])}%)`;
}
function toHslaString(base2) {
  const [h2, s, l] = base2;
  if (3 in base2) {
    return `hsla(${roundDeg(h2)}, ${roundPercent(s)}%, ${roundPercent(l)}%, ${roundAlpha(base2[3])})`;
  }
  return `hsla(${roundDeg(h2)}, ${roundPercent(s)}%, ${roundPercent(l)}%, 1)`;
}
function toHexaString(base2) {
  if (typeof base2 === "string") {
    let i;
    if (i = hexRegex.exec(base2)) {
      return `${i[0]}FF`;
    } else if (i = hexaRegex.exec(base2)) {
      return i[0];
    } else if (i = sHexRegex.exec(base2)) {
      return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}FF`;
    } else if (i = sHexaRegex.exec(base2)) {
      return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}${i[4]}${i[4]}`;
    }
    throw new Error(`[seemly/toHexString]: Invalid hex value ${base2}.`);
  }
  const hex3 = `#${base2.slice(0, 3).map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, "0")).join("")}`;
  const a = base2.length === 3 ? "FF" : roundChannel(base2[3] * 255).toString(16).padStart(2, "0").toUpperCase();
  return hex3 + a;
}
function toHexString(base2) {
  if (typeof base2 === "string") {
    let i;
    if (i = hexRegex.exec(base2)) {
      return i[0];
    } else if (i = hexaRegex.exec(base2)) {
      return i[0].slice(0, 7);
    } else if (i = sHexRegex.exec(base2) || sHexaRegex.exec(base2)) {
      return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}`;
    }
    throw new Error(`[seemly/toHexString]: Invalid hex value ${base2}.`);
  }
  return `#${base2.slice(0, 3).map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, "0")).join("")}`;
}
function createId(length = 8) {
  return Math.random().toString(16).slice(2, 2 + length);
}
function keep(object4, keys2 = [], rest2) {
  const keepedObject = {};
  keys2.forEach((key) => {
    keepedObject[key] = object4[key];
  });
  return Object.assign(keepedObject, rest2);
}
function omit(object4, keys2 = [], rest2) {
  const omitedObject = {};
  const originalKeys = Object.getOwnPropertyNames(object4);
  originalKeys.forEach((originalKey) => {
    if (!keys2.includes(originalKey)) {
      omitedObject[originalKey] = object4[originalKey];
    }
  });
  return Object.assign(omitedObject, rest2);
}
function flatten$2(vNodes, filterCommentNode = true, result2 = []) {
  vNodes.forEach((vNode) => {
    if (vNode === null)
      return;
    if (typeof vNode !== "object") {
      if (typeof vNode === "string" || typeof vNode === "number") {
        result2.push(createTextVNode(String(vNode)));
      }
      return;
    }
    if (Array.isArray(vNode)) {
      flatten$2(vNode, filterCommentNode, result2);
      return;
    }
    if (vNode.type === Fragment) {
      if (vNode.children === null)
        return;
      if (Array.isArray(vNode.children)) {
        flatten$2(vNode.children, filterCommentNode, result2);
      }
    } else {
      if (vNode.type === Comment && filterCommentNode)
        return;
      result2.push(vNode);
    }
  });
  return result2;
}
function call(funcs, ...args) {
  if (Array.isArray(funcs)) {
    funcs.forEach((func2) => call(func2, ...args));
  } else {
    return funcs(...args);
  }
}
function keysOf(obj) {
  return Object.keys(obj);
}
function render$1(r, ...args) {
  if (typeof r === "function") {
    return r(...args);
  } else if (typeof r === "string") {
    return createTextVNode(r);
  } else if (typeof r === "number") {
    return createTextVNode(String(r));
  } else {
    return null;
  }
}
function warn$2(location, message) {
  console.error(`[naive/${location}]: ${message}`);
}
function throwError(location, message) {
  throw new Error(`[naive/${location}]: ${message}`);
}
function getFirstSlotVNode(slots, slotName = "default", props = void 0) {
  const slot = slots[slotName];
  if (!slot) {
    warn$2("getFirstSlotVNode", `slot[${slotName}] is empty`);
    return null;
  }
  const slotContent = flatten$2(slot(props));
  if (slotContent.length === 1) {
    return slotContent[0];
  } else {
    warn$2("getFirstSlotVNode", `slot[${slotName}] should have exactly one child`);
    return null;
  }
}
function createRefSetter(ref2) {
  return (inst) => {
    if (inst) {
      ref2.value = inst.$el;
    } else {
      ref2.value = null;
    }
  };
}
function createInjectionKey(key) {
  return key;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) {
      return true;
    }
    if (child.type === Comment) {
      return false;
    }
    if (child.type === Fragment && !ensureValidVNode(child.children)) {
      return false;
    }
    return true;
  }) ? vnodes : null;
}
function resolveSlot(slot, fallback) {
  return slot && ensureValidVNode(slot()) || fallback();
}
function resolveSlotWithProps(slot, props, fallback) {
  return slot && ensureValidVNode(slot(props)) || fallback(props);
}
function resolveWrappedSlot(slot, wrapper) {
  const children = slot && ensureValidVNode(slot());
  return wrapper(children || null);
}
function resolveWrappedSlotWithProps(slot, props, wrapper) {
  const children = slot && ensureValidVNode(slot(props));
  return wrapper(children || null);
}
function isSlotEmpty(slot) {
  return !(slot && ensureValidVNode(slot()));
}
const Wrapper = /* @__PURE__ */ defineComponent({
  render() {
    var _a, _b;
    return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
});
const pureNumberRegex = /^(\d|\.)+$/;
const numberRegex = /(\d|\.)+/;
function formatLength(length, {
  c: c2 = 1,
  offset = 0,
  attachPx = true
} = {}) {
  if (typeof length === "number") {
    const result2 = (length + offset) * c2;
    if (result2 === 0)
      return "0";
    return `${result2}px`;
  } else if (typeof length === "string") {
    if (pureNumberRegex.test(length)) {
      const result2 = (Number(length) + offset) * c2;
      if (attachPx) {
        if (result2 === 0)
          return "0";
        return `${result2}px`;
      } else {
        return `${result2}`;
      }
    } else {
      const result2 = numberRegex.exec(length);
      if (!result2)
        return length;
      return length.replace(numberRegex, String((Number(result2[0]) + offset) * c2));
    }
  }
  return length;
}
function color2Class(color) {
  return color.replace(/#|\(|\)|,|\s|\./g, "_");
}
function rtlInset(inset) {
  const {
    left,
    right,
    top,
    bottom
  } = getMargin(inset);
  return `${top} ${right} ${bottom} ${left}`;
}
function ampCount(selector) {
  let cnt = 0;
  for (let i = 0; i < selector.length; ++i) {
    if (selector[i] === "&")
      ++cnt;
  }
  return cnt;
}
const separatorRegex = /\s*,(?![^(]*\))\s*/g;
const extraSpaceRegex = /\s+/g;
function resolveSelectorWithAmp(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    let round2 = ampCount(partialSelector);
    if (!round2) {
      amp.forEach((partialAmp) => {
        nextAmp.push(
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          (partialAmp && partialAmp + " ") + partialSelector
        );
      });
      return;
    } else if (round2 === 1) {
      amp.forEach((partialAmp) => {
        nextAmp.push(partialSelector.replace("&", partialAmp));
      });
      return;
    }
    let partialNextAmp = [
      partialSelector
    ];
    while (round2--) {
      const nextPartialNextAmp = [];
      partialNextAmp.forEach((selectorItr) => {
        amp.forEach((partialAmp) => {
          nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
        });
      });
      partialNextAmp = nextPartialNextAmp;
    }
    partialNextAmp.forEach((part) => nextAmp.push(part));
  });
  return nextAmp;
}
function resolveSelector(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    amp.forEach((partialAmp) => {
      nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
    });
  });
  return nextAmp;
}
function parseSelectorPath(selectorPaths) {
  let amp = [""];
  selectorPaths.forEach((selector) => {
    selector = selector && selector.trim();
    if (
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      !selector
    ) {
      return;
    }
    if (selector.includes("&")) {
      amp = resolveSelectorWithAmp(amp, selector);
    } else {
      amp = resolveSelector(amp, selector);
    }
  });
  return amp.join(", ").replace(extraSpaceRegex, " ");
}
function removeElement(el) {
  if (!el)
    return;
  const parentElement = el.parentElement;
  if (parentElement)
    parentElement.removeChild(el);
}
function queryElement(id, parent2) {
  return (parent2 !== null && parent2 !== void 0 ? parent2 : document.head).querySelector(`style[cssr-id="${id}"]`);
}
function createElement(id) {
  const el = document.createElement("style");
  el.setAttribute("cssr-id", id);
  return el;
}
function isMediaOrSupports(selector) {
  if (!selector)
    return false;
  return /^\s*@(s|m)/.test(selector);
}
const kebabRegex = /[A-Z]/g;
function kebabCase(pattern4) {
  return pattern4.replace(kebabRegex, (match2) => "-" + match2.toLowerCase());
}
function unwrapProperty(prop, indent = "  ") {
  if (typeof prop === "object" && prop !== null) {
    return " {\n" + Object.entries(prop).map((v) => {
      return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
    }).join("\n") + "\n" + indent + "}";
  }
  return `: ${prop};`;
}
function unwrapProperties(props, instance, params) {
  if (typeof props === "function") {
    return props({
      context: instance.context,
      props: params
    });
  }
  return props;
}
function createStyle(selector, props, instance, params) {
  if (!props)
    return "";
  const unwrappedProps = unwrapProperties(props, instance, params);
  if (!unwrappedProps)
    return "";
  if (typeof unwrappedProps === "string") {
    return `${selector} {
${unwrappedProps}
}`;
  }
  const propertyNames = Object.keys(unwrappedProps);
  if (propertyNames.length === 0) {
    if (instance.config.keepEmptyBlock)
      return selector + " {\n}";
    return "";
  }
  const statements = selector ? [
    selector + " {"
  ] : [];
  propertyNames.forEach((propertyName) => {
    const property2 = unwrappedProps[propertyName];
    if (propertyName === "raw") {
      statements.push("\n" + property2 + "\n");
      return;
    }
    propertyName = kebabCase(propertyName);
    if (property2 !== null && property2 !== void 0) {
      statements.push(`  ${propertyName}${unwrapProperty(property2)}`);
    }
  });
  if (selector) {
    statements.push("}");
  }
  return statements.join("\n");
}
function loopCNodeListWithCallback(children, options, callback) {
  if (!children)
    return;
  children.forEach((child) => {
    if (Array.isArray(child)) {
      loopCNodeListWithCallback(child, options, callback);
    } else if (typeof child === "function") {
      const grandChildren = child(options);
      if (Array.isArray(grandChildren)) {
        loopCNodeListWithCallback(grandChildren, options, callback);
      } else if (grandChildren) {
        callback(grandChildren);
      }
    } else if (child) {
      callback(child);
    }
  });
}
function traverseCNode(node, selectorPaths, styles2, instance, params) {
  const $ = node.$;
  let blockSelector = "";
  if (!$ || typeof $ === "string") {
    if (isMediaOrSupports($)) {
      blockSelector = $;
    } else {
      selectorPaths.push($);
    }
  } else if (typeof $ === "function") {
    const selector2 = $({
      context: instance.context,
      props: params
    });
    if (isMediaOrSupports(selector2)) {
      blockSelector = selector2;
    } else {
      selectorPaths.push(selector2);
    }
  } else {
    if ($.before)
      $.before(instance.context);
    if (!$.$ || typeof $.$ === "string") {
      if (isMediaOrSupports($.$)) {
        blockSelector = $.$;
      } else {
        selectorPaths.push($.$);
      }
    } else if ($.$) {
      const selector2 = $.$({
        context: instance.context,
        props: params
      });
      if (isMediaOrSupports(selector2)) {
        blockSelector = selector2;
      } else {
        selectorPaths.push(selector2);
      }
    }
  }
  const selector = parseSelectorPath(selectorPaths);
  const style2 = createStyle(selector, node.props, instance, params);
  if (blockSelector) {
    styles2.push(`${blockSelector} {`);
  } else if (style2.length) {
    styles2.push(style2);
  }
  if (node.children) {
    loopCNodeListWithCallback(node.children, {
      context: instance.context,
      props: params
    }, (childNode) => {
      if (typeof childNode === "string") {
        const style3 = createStyle(selector, { raw: childNode }, instance, params);
        styles2.push(style3);
      } else {
        traverseCNode(childNode, selectorPaths, styles2, instance, params);
      }
    });
  }
  selectorPaths.pop();
  if (blockSelector) {
    styles2.push("}");
  }
  if ($ && $.after)
    $.after(instance.context);
}
function render(node, instance, props) {
  const styles2 = [];
  traverseCNode(node, [], styles2, instance, props);
  return styles2.join("\n\n");
}
function murmur2(str) {
  var h2 = 0;
  var k, i = 0, len2 = str.length;
  for (; len2 >= 4; ++i, len2 -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h2 = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len2) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
if (typeof window !== "undefined") {
  window.__cssrContext = {};
}
function unmount(instance, node, id, parent2) {
  const { els } = node;
  if (id === void 0) {
    els.forEach(removeElement);
    node.els = [];
  } else {
    const target = queryElement(id, parent2);
    if (target && els.includes(target)) {
      removeElement(target);
      node.els = els.filter((el) => el !== target);
    }
  }
}
function addElementToList(els, target) {
  els.push(target);
}
function mount(instance, node, id, props, head2, force, anchorMetaName, parent2, ssrAdapter2) {
  let style2;
  if (id === void 0) {
    style2 = node.render(props);
    id = murmur2(style2);
  }
  if (ssrAdapter2) {
    ssrAdapter2.adapter(id, style2 !== null && style2 !== void 0 ? style2 : node.render(props));
    return;
  }
  if (parent2 === void 0) {
    parent2 = document.head;
  }
  const queriedTarget = queryElement(id, parent2);
  if (queriedTarget !== null && !force) {
    return queriedTarget;
  }
  const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
  if (style2 === void 0)
    style2 = node.render(props);
  target.textContent = style2;
  if (queriedTarget !== null)
    return queriedTarget;
  if (anchorMetaName) {
    const anchorMetaEl = parent2.querySelector(`meta[name="${anchorMetaName}"]`);
    if (anchorMetaEl) {
      parent2.insertBefore(target, anchorMetaEl);
      addElementToList(node.els, target);
      return target;
    }
  }
  if (head2) {
    parent2.insertBefore(target, parent2.querySelector("style, link"));
  } else {
    parent2.appendChild(target);
  }
  addElementToList(node.els, target);
  return target;
}
function wrappedRender(props) {
  return render(this, this.instance, props);
}
function wrappedMount(options = {}) {
  const { id, ssr, props, head: head2 = false, force = false, anchorMetaName, parent: parent2 } = options;
  const targetElement = mount(this.instance, this, id, props, head2, force, anchorMetaName, parent2, ssr);
  return targetElement;
}
function wrappedUnmount(options = {}) {
  const { id, parent: parent2 } = options;
  unmount(this.instance, this, id, parent2);
}
const createCNode = function(instance, $, props, children) {
  return {
    instance,
    $,
    props,
    children,
    els: [],
    render: wrappedRender,
    mount: wrappedMount,
    unmount: wrappedUnmount
  };
};
const c$2 = function(instance, $, props, children) {
  if (Array.isArray($)) {
    return createCNode(instance, { $: null }, null, $);
  } else if (Array.isArray(props)) {
    return createCNode(instance, $, null, props);
  } else if (Array.isArray(children)) {
    return createCNode(instance, $, props, children);
  } else {
    return createCNode(instance, $, props, null);
  }
};
function CssRender(config = {}) {
  const cssr2 = {
    c: (...args) => c$2(cssr2, ...args),
    use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
    find: queryElement,
    context: {},
    config
  };
  return cssr2;
}
function exists(id, ssr) {
  if (id === void 0)
    return false;
  if (ssr) {
    const { context: { ids } } = ssr;
    return ids.has(id);
  }
  return queryElement(id) !== null;
}
function plugin$1(options) {
  let _bPrefix = ".";
  let _ePrefix = "__";
  let _mPrefix = "--";
  let c2;
  if (options) {
    let t = options.blockPrefix;
    if (t) {
      _bPrefix = t;
    }
    t = options.elementPrefix;
    if (t) {
      _ePrefix = t;
    }
    t = options.modifierPrefix;
    if (t) {
      _mPrefix = t;
    }
  }
  const _plugin = {
    install(instance) {
      c2 = instance.c;
      const ctx2 = instance.context;
      ctx2.bem = {};
      ctx2.bem.b = null;
      ctx2.bem.els = null;
    }
  };
  function b(arg) {
    let memorizedB;
    let memorizedE;
    return {
      before(ctx2) {
        memorizedB = ctx2.bem.b;
        memorizedE = ctx2.bem.els;
        ctx2.bem.els = null;
      },
      after(ctx2) {
        ctx2.bem.b = memorizedB;
        ctx2.bem.els = memorizedE;
      },
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        context.bem.b = arg;
        return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
      }
    };
  }
  function e(arg) {
    let memorizedE;
    return {
      before(ctx2) {
        memorizedE = ctx2.bem.els;
      },
      after(ctx2) {
        ctx2.bem.els = memorizedE;
      },
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        context.bem.els = arg.split(",").map((v) => v.trim());
        return context.bem.els.map((el) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el}`).join(", ");
      }
    };
  }
  function m(arg) {
    return {
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        const modifiers = arg.split(",").map((v) => v.trim());
        function elementToSelector(el) {
          return modifiers.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== void 0 ? `${_ePrefix}${el}` : ""}${_mPrefix}${modifier}`).join(", ");
        }
        const els = context.bem.els;
        if (els !== null) {
          return elementToSelector(els[0]);
        } else {
          return elementToSelector();
        }
      }
    };
  }
  function notM(arg) {
    return {
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        const els = context.bem.els;
        return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
      }
    };
  }
  const cB2 = (...args) => c2(b(args[0]), args[1], args[2]);
  const cE2 = (...args) => c2(e(args[0]), args[1], args[2]);
  const cM2 = (...args) => c2(m(args[0]), args[1], args[2]);
  const cNotM2 = (...args) => c2(notM(args[0]), args[1], args[2]);
  Object.assign(_plugin, {
    cB: cB2,
    cE: cE2,
    cM: cM2,
    cNotM: cNotM2
  });
  return _plugin;
}
const namespace = "n";
const prefix = `.${namespace}-`;
const elementPrefix = "__";
const modifierPrefix = "--";
const cssr = CssRender();
const plugin = plugin$1({
  blockPrefix: prefix,
  elementPrefix,
  modifierPrefix
});
cssr.use(plugin);
const {
  c: c$1,
  find
} = cssr;
const {
  cB,
  cE,
  cM,
  cNotM
} = plugin;
function insideModal(style2) {
  return c$1(({
    props: {
      bPrefix
    }
  }) => `${bPrefix || prefix}modal, ${bPrefix || prefix}drawer`, [style2]);
}
function insidePopover(style2) {
  return c$1(({
    props: {
      bPrefix
    }
  }) => `${bPrefix || prefix}popover`, [style2]);
}
function asModal(style2) {
  return c$1(({
    props: {
      bPrefix
    }
  }) => `&${bPrefix || prefix}modal`, style2);
}
const cCB = (...args) => {
  return c$1(">", [cB(...args)]);
};
function createKey(prefix2, suffix2) {
  return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
}
let _isJsdom;
function isJsdom() {
  if (_isJsdom === void 0) {
    _isJsdom = navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
  }
  return _isJsdom;
}
const isBrowser$2 = typeof document !== "undefined" && typeof window !== "undefined";
const eventSet = /* @__PURE__ */ new WeakSet();
function eventEffectNotPerformed(event) {
  return !eventSet.has(event);
}
function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
  var _a;
  const injection = inject(injectionName, null);
  if (injection === null)
    return;
  const vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;
  watch(registerKeyRef, registerInstance);
  registerInstance(registerKeyRef.value);
  onBeforeUnmount(() => {
    registerInstance(void 0, registerKeyRef.value);
  });
  function registerInstance(key, oldKey) {
    if (!injection)
      return;
    const collection2 = injection[collectionKey];
    if (oldKey !== void 0)
      removeInstance(collection2, oldKey);
    if (key !== void 0)
      addInstance(collection2, key);
  }
  function removeInstance(collection2, key) {
    if (!collection2[key])
      collection2[key] = [];
    collection2[key].splice(collection2[key].findIndex((instance) => instance === vm), 1);
  }
  function addInstance(collection2, key) {
    if (!collection2[key])
      collection2[key] = [];
    if (!~collection2[key].findIndex((instance) => instance === vm)) {
      collection2[key].push(vm);
    }
  }
}
function useDeferredTrue(valueRef, delay2, shouldDelayRef) {
  if (!delay2)
    return valueRef;
  const delayedRef = ref(valueRef.value);
  let timerId = null;
  watch(valueRef, (value) => {
    if (timerId !== null)
      window.clearTimeout(timerId);
    if (value === true) {
      if (shouldDelayRef && !shouldDelayRef.value) {
        delayedRef.value = true;
      } else {
        timerId = window.setTimeout(() => {
          delayedRef.value = true;
        }, delay2);
      }
    } else {
      delayedRef.value = false;
    }
  });
  return delayedRef;
}
function useFalseUntilTruthy(originalRef) {
  const currentRef = ref(!!originalRef.value);
  if (currentRef.value)
    return readonly$1(currentRef);
  const stop = watch(originalRef, (value) => {
    if (value) {
      currentRef.value = true;
      stop();
    }
  });
  return readonly$1(currentRef);
}
function useMemo(getterOrOptions) {
  const computedValueRef = computed(getterOrOptions);
  const valueRef = ref(computedValueRef.value);
  watch(computedValueRef, (value) => {
    valueRef.value = value;
  });
  if (typeof getterOrOptions === "function") {
    return valueRef;
  } else {
    return {
      __v_isRef: true,
      get value() {
        return valueRef.value;
      },
      set value(v) {
        getterOrOptions.set(v);
      }
    };
  }
}
function hasInstance() {
  return getCurrentInstance() !== null;
}
const isBrowser$1 = typeof window !== "undefined";
let fontsReady;
let isFontReady;
const init = () => {
  var _a, _b;
  fontsReady = isBrowser$1 ? (_b = (_a = document) === null || _a === void 0 ? void 0 : _a.fonts) === null || _b === void 0 ? void 0 : _b.ready : void 0;
  isFontReady = false;
  if (fontsReady !== void 0) {
    void fontsReady.then(() => {
      isFontReady = true;
    });
  } else {
    isFontReady = true;
  }
};
init();
function onFontsReady(cb) {
  if (isFontReady)
    return;
  let deactivated = false;
  onMounted(() => {
    if (!isFontReady) {
      fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
        if (deactivated)
          return;
        cb();
      });
    }
  });
  onBeforeUnmount(() => {
    deactivated = true;
  });
}
function getEventTarget(e) {
  const path = e.composedPath();
  return path[0];
}
const traps = {
  mousemoveoutside: /* @__PURE__ */ new WeakMap(),
  clickoutside: /* @__PURE__ */ new WeakMap()
};
function createTrapHandler(name, el, originalHandler) {
  if (name === "mousemoveoutside") {
    const moveHandler = (e) => {
      if (el.contains(getEventTarget(e)))
        return;
      originalHandler(e);
    };
    return {
      mousemove: moveHandler,
      touchstart: moveHandler
    };
  } else if (name === "clickoutside") {
    let mouseDownOutside = false;
    const downHandler = (e) => {
      mouseDownOutside = !el.contains(getEventTarget(e));
    };
    const upHanlder = (e) => {
      if (!mouseDownOutside)
        return;
      if (el.contains(getEventTarget(e)))
        return;
      originalHandler(e);
    };
    return {
      mousedown: downHandler,
      mouseup: upHanlder,
      touchstart: downHandler,
      touchend: upHanlder
    };
  }
  console.error(
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
  );
  return {};
}
function ensureTrapHandlers(name, el, handler) {
  const handlers = traps[name];
  let elHandlers = handlers.get(el);
  if (elHandlers === void 0) {
    handlers.set(el, elHandlers = /* @__PURE__ */ new WeakMap());
  }
  let trapHandler = elHandlers.get(handler);
  if (trapHandler === void 0) {
    elHandlers.set(handler, trapHandler = createTrapHandler(name, el, handler));
  }
  return trapHandler;
}
function trapOn(name, el, handler, options) {
  if (name === "mousemoveoutside" || name === "clickoutside") {
    const trapHandlers = ensureTrapHandlers(name, el, handler);
    Object.keys(trapHandlers).forEach((key) => {
      on(key, document, trapHandlers[key], options);
    });
    return true;
  }
  return false;
}
function trapOff(name, el, handler, options) {
  if (name === "mousemoveoutside" || name === "clickoutside") {
    const trapHandlers = ensureTrapHandlers(name, el, handler);
    Object.keys(trapHandlers).forEach((key) => {
      off(key, document, trapHandlers[key], options);
    });
    return true;
  }
  return false;
}
function createDelegate() {
  if (typeof window === "undefined") {
    return {
      on: () => {
      },
      off: () => {
      }
    };
  }
  const propagationStopped = /* @__PURE__ */ new WeakMap();
  const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
  function trackPropagation() {
    propagationStopped.set(this, true);
  }
  function trackImmediate() {
    propagationStopped.set(this, true);
    immediatePropagationStopped.set(this, true);
  }
  function spy(event, propName, fn) {
    const source = event[propName];
    event[propName] = function() {
      fn.apply(event, arguments);
      return source.apply(event, arguments);
    };
    return event;
  }
  function unspy(event, propName) {
    event[propName] = Event.prototype[propName];
  }
  const currentTargets = /* @__PURE__ */ new WeakMap();
  const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
  function getCurrentTarget() {
    var _a;
    return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;
  }
  function defineCurrentTarget(event, getter) {
    if (currentTargetDescriptor === void 0)
      return;
    Object.defineProperty(event, "currentTarget", {
      configurable: true,
      enumerable: true,
      get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
    });
  }
  const phaseToTypeToElToHandlers = {
    bubble: {},
    capture: {}
  };
  const typeToWindowEventHandlers = {};
  function createUnifiedHandler() {
    const delegeteHandler = function(e) {
      const { type: type4, eventPhase, bubbles } = e;
      const target = getEventTarget(e);
      if (eventPhase === 2)
        return;
      const phase = eventPhase === 1 ? "capture" : "bubble";
      let cursor = target;
      const path = [];
      while (true) {
        if (cursor === null)
          cursor = window;
        path.push(cursor);
        if (cursor === window) {
          break;
        }
        cursor = cursor.parentNode || null;
      }
      const captureElToHandlers = phaseToTypeToElToHandlers.capture[type4];
      const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type4];
      spy(e, "stopPropagation", trackPropagation);
      spy(e, "stopImmediatePropagation", trackImmediate);
      defineCurrentTarget(e, getCurrentTarget);
      if (phase === "capture") {
        if (captureElToHandlers === void 0)
          return;
        for (let i = path.length - 1; i >= 0; --i) {
          if (propagationStopped.has(e))
            break;
          const target2 = path[i];
          const handlers = captureElToHandlers.get(target2);
          if (handlers !== void 0) {
            currentTargets.set(e, target2);
            for (const handler of handlers) {
              if (immediatePropagationStopped.has(e))
                break;
              handler(e);
            }
          }
          if (i === 0 && !bubbles && bubbleElToHandlers !== void 0) {
            const bubbleHandlers = bubbleElToHandlers.get(target2);
            if (bubbleHandlers !== void 0) {
              for (const handler of bubbleHandlers) {
                if (immediatePropagationStopped.has(e))
                  break;
                handler(e);
              }
            }
          }
        }
      } else if (phase === "bubble") {
        if (bubbleElToHandlers === void 0)
          return;
        for (let i = 0; i < path.length; ++i) {
          if (propagationStopped.has(e))
            break;
          const target2 = path[i];
          const handlers = bubbleElToHandlers.get(target2);
          if (handlers !== void 0) {
            currentTargets.set(e, target2);
            for (const handler of handlers) {
              if (immediatePropagationStopped.has(e))
                break;
              handler(e);
            }
          }
        }
      }
      unspy(e, "stopPropagation");
      unspy(e, "stopImmediatePropagation");
      defineCurrentTarget(e);
    };
    delegeteHandler.displayName = "evtdUnifiedHandler";
    return delegeteHandler;
  }
  function createUnifiedWindowEventHandler() {
    const delegateHandler = function(e) {
      const { type: type4, eventPhase } = e;
      if (eventPhase !== 2)
        return;
      const handlers = typeToWindowEventHandlers[type4];
      if (handlers === void 0)
        return;
      handlers.forEach((handler) => handler(e));
    };
    delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
    return delegateHandler;
  }
  const unifiedHandler = createUnifiedHandler();
  const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
  function ensureElToHandlers(phase, type4) {
    const phaseHandlers = phaseToTypeToElToHandlers[phase];
    if (phaseHandlers[type4] === void 0) {
      phaseHandlers[type4] = /* @__PURE__ */ new Map();
      window.addEventListener(type4, unifiedHandler, phase === "capture");
    }
    return phaseHandlers[type4];
  }
  function ensureWindowEventHandlers(type4) {
    const windowEventHandlers = typeToWindowEventHandlers[type4];
    if (windowEventHandlers === void 0) {
      typeToWindowEventHandlers[type4] = /* @__PURE__ */ new Set();
      window.addEventListener(type4, unfiendWindowEventHandler);
    }
    return typeToWindowEventHandlers[type4];
  }
  function ensureHandlers(elToHandlers, el) {
    let elHandlers = elToHandlers.get(el);
    if (elHandlers === void 0) {
      elToHandlers.set(el, elHandlers = /* @__PURE__ */ new Set());
    }
    return elHandlers;
  }
  function handlerExist(el, phase, type4, handler) {
    const elToHandlers = phaseToTypeToElToHandlers[phase][type4];
    if (elToHandlers !== void 0) {
      const handlers = elToHandlers.get(el);
      if (handlers !== void 0) {
        if (handlers.has(handler))
          return true;
      }
    }
    return false;
  }
  function windowEventHandlerExist(type4, handler) {
    const handlers = typeToWindowEventHandlers[type4];
    if (handlers !== void 0) {
      if (handlers.has(handler)) {
        return true;
      }
    }
    return false;
  }
  function on2(type4, el, handler, options) {
    let mergedHandler;
    if (typeof options === "object" && options.once === true) {
      mergedHandler = (e) => {
        off2(type4, el, mergedHandler, options);
        handler(e);
      };
    } else {
      mergedHandler = handler;
    }
    const trapped = trapOn(type4, el, mergedHandler, options);
    if (trapped)
      return;
    const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
    const elToHandlers = ensureElToHandlers(phase, type4);
    const handlers = ensureHandlers(elToHandlers, el);
    if (!handlers.has(mergedHandler))
      handlers.add(mergedHandler);
    if (el === window) {
      const windowEventHandlers = ensureWindowEventHandlers(type4);
      if (!windowEventHandlers.has(mergedHandler)) {
        windowEventHandlers.add(mergedHandler);
      }
    }
  }
  function off2(type4, el, handler, options) {
    const trapped = trapOff(type4, el, handler, options);
    if (trapped)
      return;
    const capture = options === true || typeof options === "object" && options.capture === true;
    const phase = capture ? "capture" : "bubble";
    const elToHandlers = ensureElToHandlers(phase, type4);
    const handlers = ensureHandlers(elToHandlers, el);
    if (el === window) {
      const mirrorPhase = capture ? "bubble" : "capture";
      if (!handlerExist(el, mirrorPhase, type4, handler) && windowEventHandlerExist(type4, handler)) {
        const windowEventHandlers = typeToWindowEventHandlers[type4];
        windowEventHandlers.delete(handler);
        if (windowEventHandlers.size === 0) {
          window.removeEventListener(type4, unfiendWindowEventHandler);
          typeToWindowEventHandlers[type4] = void 0;
        }
      }
    }
    if (handlers.has(handler))
      handlers.delete(handler);
    if (handlers.size === 0) {
      elToHandlers.delete(el);
    }
    if (elToHandlers.size === 0) {
      window.removeEventListener(type4, unifiedHandler, phase === "capture");
      phaseToTypeToElToHandlers[phase][type4] = void 0;
    }
  }
  return {
    on: on2,
    off: off2
  };
}
const { on, off } = createDelegate();
const mousePositionRef = ref(null);
function clickHandler(e) {
  if (e.clientX > 0 || e.clientY > 0) {
    mousePositionRef.value = {
      x: e.clientX,
      y: e.clientY
    };
  } else {
    const { target } = e;
    if (target instanceof Element) {
      const { left, top, width, height } = target.getBoundingClientRect();
      if (left > 0 || top > 0) {
        mousePositionRef.value = {
          x: left + width / 2,
          y: top + height / 2
        };
      } else {
        mousePositionRef.value = { x: 0, y: 0 };
      }
    } else {
      mousePositionRef.value = null;
    }
  }
}
let usedCount$1 = 0;
let managable$1 = true;
function useClickPosition() {
  if (!isBrowser$1)
    return readonly$1(ref(null));
  if (usedCount$1 === 0)
    on("click", document, clickHandler, true);
  const setup = () => {
    usedCount$1 += 1;
  };
  if (managable$1 && (managable$1 = hasInstance())) {
    onBeforeMount(setup);
    onBeforeUnmount(() => {
      usedCount$1 -= 1;
      if (usedCount$1 === 0)
        off("click", document, clickHandler, true);
    });
  } else {
    setup();
  }
  return readonly$1(mousePositionRef);
}
const clickedTimeRef = ref(void 0);
let usedCount = 0;
function handleClick() {
  clickedTimeRef.value = Date.now();
}
let managable = true;
function useClicked(timeout) {
  if (!isBrowser$1)
    return readonly$1(ref(false));
  const clickedRef = ref(false);
  let timerId = null;
  function clearTimer() {
    if (timerId !== null)
      window.clearTimeout(timerId);
  }
  function clickedHandler() {
    clearTimer();
    clickedRef.value = true;
    timerId = window.setTimeout(() => {
      clickedRef.value = false;
    }, timeout);
  }
  if (usedCount === 0) {
    on("click", window, handleClick, true);
  }
  const setup = () => {
    usedCount += 1;
    on("click", window, clickedHandler, true);
  };
  if (managable && (managable = hasInstance())) {
    onBeforeMount(setup);
    onBeforeUnmount(() => {
      usedCount -= 1;
      if (usedCount === 0) {
        off("click", window, handleClick, true);
      }
      off("click", window, clickedHandler, true);
      clearTimer();
    });
  } else {
    setup();
  }
  return readonly$1(clickedRef);
}
function useMergedState(controlledStateRef, uncontrolledStateRef) {
  watch(controlledStateRef, (value) => {
    if (value !== void 0) {
      uncontrolledStateRef.value = value;
    }
  });
  return computed(() => {
    if (controlledStateRef.value === void 0) {
      return uncontrolledStateRef.value;
    }
    return controlledStateRef.value;
  });
}
function isMounted() {
  const isMounted2 = ref(false);
  onMounted(() => {
    isMounted2.value = true;
  });
  return readonly$1(isMounted2);
}
function useCompitable(reactive2, keys2) {
  return computed(() => {
    for (const key of keys2) {
      if (reactive2[key] !== void 0)
        return reactive2[key];
    }
    return reactive2[keys2[keys2.length - 1]];
  });
}
const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
!window.MSStream;
function useIsIos() {
  return isIos;
}
function useKeyboard(options = {}, enabledRef) {
  const state = reactive({
    ctrl: false,
    command: false,
    win: false,
    shift: false,
    tab: false
  });
  const { keydown, keyup } = options;
  const keydownHandler = (e) => {
    switch (e.key) {
      case "Control":
        state.ctrl = true;
        break;
      case "Meta":
        state.command = true;
        state.win = true;
        break;
      case "Shift":
        state.shift = true;
        break;
      case "Tab":
        state.tab = true;
        break;
    }
    if (keydown !== void 0) {
      Object.keys(keydown).forEach((key) => {
        if (key !== e.key)
          return;
        const handler = keydown[key];
        if (typeof handler === "function") {
          handler(e);
        } else {
          const { stop = false, prevent = false } = handler;
          if (stop)
            e.stopPropagation();
          if (prevent)
            e.preventDefault();
          handler.handler(e);
        }
      });
    }
  };
  const keyupHandler = (e) => {
    switch (e.key) {
      case "Control":
        state.ctrl = false;
        break;
      case "Meta":
        state.command = false;
        state.win = false;
        break;
      case "Shift":
        state.shift = false;
        break;
      case "Tab":
        state.tab = false;
        break;
    }
    if (keyup !== void 0) {
      Object.keys(keyup).forEach((key) => {
        if (key !== e.key)
          return;
        const handler = keyup[key];
        if (typeof handler === "function") {
          handler(e);
        } else {
          const { stop = false, prevent = false } = handler;
          if (stop)
            e.stopPropagation();
          if (prevent)
            e.preventDefault();
          handler.handler(e);
        }
      });
    }
  };
  const setup = () => {
    if (enabledRef === void 0 || enabledRef.value) {
      on("keydown", document, keydownHandler);
      on("keyup", document, keyupHandler);
    }
    if (enabledRef !== void 0) {
      watch(enabledRef, (value) => {
        if (value) {
          on("keydown", document, keydownHandler);
          on("keyup", document, keyupHandler);
        } else {
          off("keydown", document, keydownHandler);
          off("keyup", document, keyupHandler);
        }
      });
    }
  };
  if (hasInstance()) {
    onBeforeMount(setup);
    onBeforeUnmount(() => {
      if (enabledRef === void 0 || enabledRef.value) {
        off("keydown", document, keydownHandler);
        off("keyup", document, keyupHandler);
      }
    });
  } else {
    setup();
  }
  return readonly$1(state);
}
const internalSelectionMenuBodyInjectionKey = createInjectionKey("n-internal-select-menu-body");
const modalBodyInjectionKey = createInjectionKey("n-modal-body");
const modalProviderInjectionKey = createInjectionKey("n-modal-provider");
const modalInjectionKey = createInjectionKey("n-modal");
const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
const teleportDisabled = "__disabled__";
function useAdjustedTo(props) {
  const modal = inject(modalBodyInjectionKey, null);
  const drawer = inject(drawerBodyInjectionKey, null);
  const popover = inject(popoverBodyInjectionKey, null);
  const selectMenu = inject(internalSelectionMenuBodyInjectionKey, null);
  const fullscreenElementRef = ref();
  if (typeof document !== "undefined") {
    fullscreenElementRef.value = document.fullscreenElement;
    const handleFullscreenChange = () => {
      fullscreenElementRef.value = document.fullscreenElement;
    };
    onMounted(() => {
      on("fullscreenchange", document, handleFullscreenChange);
    });
    onBeforeUnmount(() => {
      off("fullscreenchange", document, handleFullscreenChange);
    });
  }
  return useMemo(() => {
    var _a;
    const {
      to
    } = props;
    if (to !== void 0) {
      if (to === false)
        return teleportDisabled;
      if (to === true)
        return fullscreenElementRef.value || "body";
      return to;
    }
    if (modal === null || modal === void 0 ? void 0 : modal.value) {
      return (_a = modal.value.$el) !== null && _a !== void 0 ? _a : modal.value;
    }
    if (drawer === null || drawer === void 0 ? void 0 : drawer.value)
      return drawer.value;
    if (popover === null || popover === void 0 ? void 0 : popover.value)
      return popover.value;
    if (selectMenu === null || selectMenu === void 0 ? void 0 : selectMenu.value)
      return selectMenu.value;
    return to !== null && to !== void 0 ? to : fullscreenElementRef.value || "body";
  });
}
useAdjustedTo.tdkey = teleportDisabled;
useAdjustedTo.propTo = {
  type: [String, Object, Boolean],
  default: void 0
};
function getSlot(scope, slots, slotName = "default") {
  const slot = slots[slotName];
  if (slot === void 0) {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
  }
  return slot();
}
function flatten$1(vNodes, filterCommentNode = true, result2 = []) {
  vNodes.forEach((vNode) => {
    if (vNode === null)
      return;
    if (typeof vNode !== "object") {
      if (typeof vNode === "string" || typeof vNode === "number") {
        result2.push(createTextVNode(String(vNode)));
      }
      return;
    }
    if (Array.isArray(vNode)) {
      flatten$1(vNode, filterCommentNode, result2);
      return;
    }
    if (vNode.type === Fragment) {
      if (vNode.children === null)
        return;
      if (Array.isArray(vNode.children)) {
        flatten$1(vNode.children, filterCommentNode, result2);
      }
    } else if (vNode.type !== Comment) {
      result2.push(vNode);
    }
  });
  return result2;
}
function getFirstVNode(scope, slots, slotName = "default") {
  const slot = slots[slotName];
  if (slot === void 0) {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
  }
  const content = flatten$1(slot());
  if (content.length === 1) {
    return content[0];
  } else {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);
  }
}
let viewMeasurer = null;
function ensureViewBoundingRect() {
  if (viewMeasurer === null) {
    viewMeasurer = document.getElementById("v-binder-view-measurer");
    if (viewMeasurer === null) {
      viewMeasurer = document.createElement("div");
      viewMeasurer.id = "v-binder-view-measurer";
      const { style: style2 } = viewMeasurer;
      style2.position = "fixed";
      style2.left = "0";
      style2.right = "0";
      style2.top = "0";
      style2.bottom = "0";
      style2.pointerEvents = "none";
      style2.visibility = "hidden";
      document.body.appendChild(viewMeasurer);
    }
  }
  return viewMeasurer.getBoundingClientRect();
}
function getPointRect(x, y) {
  const viewRect = ensureViewBoundingRect();
  return {
    top: y,
    left: x,
    height: 0,
    width: 0,
    right: viewRect.width - x,
    bottom: viewRect.height - y
  };
}
function getRect(el) {
  const elRect = el.getBoundingClientRect();
  const viewRect = ensureViewBoundingRect();
  return {
    left: elRect.left - viewRect.left,
    top: elRect.top - viewRect.top,
    bottom: viewRect.height + viewRect.top - elRect.bottom,
    right: viewRect.width + viewRect.left - elRect.right,
    width: elRect.width,
    height: elRect.height
  };
}
function getParentNode(node) {
  if (node.nodeType === 9) {
    return null;
  }
  return node.parentNode;
}
function getScrollParent(node) {
  if (node === null)
    return null;
  const parentNode = getParentNode(node);
  if (parentNode === null) {
    return null;
  }
  if (parentNode.nodeType === 9) {
    return document;
  }
  if (parentNode.nodeType === 1) {
    const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return parentNode;
    }
  }
  return getScrollParent(parentNode);
}
const Binder = /* @__PURE__ */ defineComponent({
  name: "Binder",
  props: {
    syncTargetWithParent: Boolean,
    syncTarget: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    var _a;
    provide("VBinder", (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy);
    const VBinder2 = inject("VBinder", null);
    const targetRef = ref(null);
    const setTargetRef = (el) => {
      targetRef.value = el;
      if (VBinder2 && props.syncTargetWithParent) {
        VBinder2.setTargetRef(el);
      }
    };
    let scrollableNodes = [];
    const ensureScrollListener = () => {
      let cursor = targetRef.value;
      while (true) {
        cursor = getScrollParent(cursor);
        if (cursor === null)
          break;
        scrollableNodes.push(cursor);
      }
      for (const el of scrollableNodes) {
        on("scroll", el, onScroll, true);
      }
    };
    const removeScrollListeners = () => {
      for (const el of scrollableNodes) {
        off("scroll", el, onScroll, true);
      }
      scrollableNodes = [];
    };
    const followerScrollListeners = /* @__PURE__ */ new Set();
    const addScrollListener = (listener) => {
      if (followerScrollListeners.size === 0) {
        ensureScrollListener();
      }
      if (!followerScrollListeners.has(listener)) {
        followerScrollListeners.add(listener);
      }
    };
    const removeScrollListener = (listener) => {
      if (followerScrollListeners.has(listener)) {
        followerScrollListeners.delete(listener);
      }
      if (followerScrollListeners.size === 0) {
        removeScrollListeners();
      }
    };
    const onScroll = () => {
      beforeNextFrameOnce(onScrollRaf);
    };
    const onScrollRaf = () => {
      followerScrollListeners.forEach((listener) => listener());
    };
    const followerResizeListeners = /* @__PURE__ */ new Set();
    const addResizeListener = (listener) => {
      if (followerResizeListeners.size === 0) {
        on("resize", window, onResize);
      }
      if (!followerResizeListeners.has(listener)) {
        followerResizeListeners.add(listener);
      }
    };
    const removeResizeListener = (listener) => {
      if (followerResizeListeners.has(listener)) {
        followerResizeListeners.delete(listener);
      }
      if (followerResizeListeners.size === 0) {
        off("resize", window, onResize);
      }
    };
    const onResize = () => {
      followerResizeListeners.forEach((listener) => listener());
    };
    onBeforeUnmount(() => {
      off("resize", window, onResize);
      removeScrollListeners();
    });
    return {
      targetRef,
      setTargetRef,
      addScrollListener,
      removeScrollListener,
      addResizeListener,
      removeResizeListener
    };
  },
  render() {
    return getSlot("binder", this.$slots);
  }
});
const VBinder = Binder;
const VTarget = /* @__PURE__ */ defineComponent({
  name: "Target",
  setup() {
    const { setTargetRef, syncTarget } = inject("VBinder");
    const setTargetDirective = {
      mounted: setTargetRef,
      updated: setTargetRef
    };
    return {
      syncTarget,
      setTargetDirective
    };
  },
  render() {
    const { syncTarget, setTargetDirective } = this;
    if (syncTarget) {
      return withDirectives(getFirstVNode("follower", this.$slots), [
        [setTargetDirective]
      ]);
    }
    return getFirstVNode("follower", this.$slots);
  }
});
const ctxKey$1 = "@@mmoContext";
const mousemoveoutside = {
  mounted(el, { value }) {
    el[ctxKey$1] = {
      handler: void 0
    };
    if (typeof value === "function") {
      el[ctxKey$1].handler = value;
      on("mousemoveoutside", el, value);
    }
  },
  updated(el, { value }) {
    const ctx2 = el[ctxKey$1];
    if (typeof value === "function") {
      if (ctx2.handler) {
        if (ctx2.handler !== value) {
          off("mousemoveoutside", el, ctx2.handler);
          ctx2.handler = value;
          on("mousemoveoutside", el, value);
        }
      } else {
        el[ctxKey$1].handler = value;
        on("mousemoveoutside", el, value);
      }
    } else {
      if (ctx2.handler) {
        off("mousemoveoutside", el, ctx2.handler);
        ctx2.handler = void 0;
      }
    }
  },
  unmounted(el) {
    const { handler } = el[ctxKey$1];
    if (handler) {
      off("mousemoveoutside", el, handler);
    }
    el[ctxKey$1].handler = void 0;
  }
};
const mousemoveoutside$1 = mousemoveoutside;
const ctxKey = "@@coContext";
const clickoutside = {
  mounted(el, { value, modifiers }) {
    el[ctxKey] = {
      handler: void 0
    };
    if (typeof value === "function") {
      el[ctxKey].handler = value;
      on("clickoutside", el, value, {
        capture: modifiers.capture
      });
    }
  },
  updated(el, { value, modifiers }) {
    const ctx2 = el[ctxKey];
    if (typeof value === "function") {
      if (ctx2.handler) {
        if (ctx2.handler !== value) {
          off("clickoutside", el, ctx2.handler, {
            capture: modifiers.capture
          });
          ctx2.handler = value;
          on("clickoutside", el, value, {
            capture: modifiers.capture
          });
        }
      } else {
        el[ctxKey].handler = value;
        on("clickoutside", el, value, {
          capture: modifiers.capture
        });
      }
    } else {
      if (ctx2.handler) {
        off("clickoutside", el, ctx2.handler, {
          capture: modifiers.capture
        });
        ctx2.handler = void 0;
      }
    }
  },
  unmounted(el, { modifiers }) {
    const { handler } = el[ctxKey];
    if (handler) {
      off("clickoutside", el, handler, {
        capture: modifiers.capture
      });
    }
    el[ctxKey].handler = void 0;
  }
};
const clickoutside$1 = clickoutside;
function warn$1(location, message) {
  console.error(`[vdirs/${location}]: ${message}`);
}
class ZIndexManager {
  constructor() {
    this.elementZIndex = /* @__PURE__ */ new Map();
    this.nextZIndex = 2e3;
  }
  get elementCount() {
    return this.elementZIndex.size;
  }
  ensureZIndex(el, zIndex) {
    const { elementZIndex } = this;
    if (zIndex !== void 0) {
      el.style.zIndex = `${zIndex}`;
      elementZIndex.delete(el);
      return;
    }
    const { nextZIndex } = this;
    if (elementZIndex.has(el)) {
      const currentZIndex = elementZIndex.get(el);
      if (currentZIndex + 1 === this.nextZIndex)
        return;
    }
    el.style.zIndex = `${nextZIndex}`;
    elementZIndex.set(el, nextZIndex);
    this.nextZIndex = nextZIndex + 1;
    this.squashState();
  }
  unregister(el, zIndex) {
    const { elementZIndex } = this;
    if (elementZIndex.has(el)) {
      elementZIndex.delete(el);
    } else if (zIndex === void 0) {
      warn$1("z-index-manager/unregister-element", "Element not found when unregistering.");
    }
    this.squashState();
  }
  squashState() {
    const { elementCount } = this;
    if (!elementCount) {
      this.nextZIndex = 2e3;
    }
    if (this.nextZIndex - elementCount > 2500)
      this.rearrange();
  }
  rearrange() {
    const elementZIndexPair = Array.from(this.elementZIndex.entries());
    elementZIndexPair.sort((pair1, pair2) => {
      return pair1[1] - pair2[1];
    });
    this.nextZIndex = 2e3;
    elementZIndexPair.forEach((pair) => {
      const el = pair[0];
      const zIndex = this.nextZIndex++;
      if (`${zIndex}` !== el.style.zIndex)
        el.style.zIndex = `${zIndex}`;
    });
  }
}
const zIndexManager = new ZIndexManager();
const ctx = "@@ziContext";
const zindexable = {
  mounted(el, bindings) {
    const { value = {} } = bindings;
    const { zIndex, enabled } = value;
    el[ctx] = {
      enabled: !!enabled,
      initialized: false
    };
    if (enabled) {
      zIndexManager.ensureZIndex(el, zIndex);
      el[ctx].initialized = true;
    }
  },
  updated(el, bindings) {
    const { value = {} } = bindings;
    const { zIndex, enabled } = value;
    const cachedEnabled = el[ctx].enabled;
    if (enabled && !cachedEnabled) {
      zIndexManager.ensureZIndex(el, zIndex);
      el[ctx].initialized = true;
    }
    el[ctx].enabled = !!enabled;
  },
  unmounted(el, bindings) {
    if (!el[ctx].initialized)
      return;
    const { value = {} } = bindings;
    const { zIndex } = value;
    zIndexManager.unregister(el, zIndex);
  }
};
const zindexable$1 = zindexable;
const ssrContextKey = "@css-render/vue3-ssr";
function createStyleString(id, style2) {
  return `<style cssr-id="${id}">
${style2}
</style>`;
}
function ssrAdapter(id, style2, ssrContext) {
  const { styles: styles2, ids } = ssrContext;
  if (ids.has(id))
    return;
  if (styles2 !== null) {
    ids.add(id);
    styles2.push(createStyleString(id, style2));
  }
}
const isBrowser = typeof document !== "undefined";
function useSsrAdapter() {
  if (isBrowser)
    return void 0;
  const context = inject(ssrContextKey, null);
  if (context === null)
    return void 0;
  return {
    adapter: (id, style2) => ssrAdapter(id, style2, context),
    context
  };
}
function warn(location, message) {
  console.error(`[vueuc/${location}]: ${message}`);
}
const { c } = CssRender();
const cssrAnchorMetaName$1 = "vueuc-style";
function resolveTo(selector) {
  if (typeof selector === "string") {
    return document.querySelector(selector);
  }
  return selector();
}
const LazyTeleport = /* @__PURE__ */ defineComponent({
  name: "LazyTeleport",
  props: {
    to: {
      type: [String, Object],
      default: void 0
    },
    disabled: Boolean,
    show: {
      type: Boolean,
      required: true
    }
  },
  setup(props) {
    return {
      showTeleport: useFalseUntilTruthy(toRef(props, "show")),
      mergedTo: computed(() => {
        const { to } = props;
        return to !== null && to !== void 0 ? to : "body";
      })
    };
  },
  render() {
    return this.showTeleport ? this.disabled ? getSlot("lazy-teleport", this.$slots) : h(Teleport, {
      disabled: this.disabled,
      to: this.mergedTo
    }, getSlot("lazy-teleport", this.$slots)) : null;
  }
});
const oppositionPositions = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
const oppositeAligns = {
  start: "end",
  center: "center",
  end: "start"
};
const propToCompare = {
  top: "height",
  bottom: "height",
  left: "width",
  right: "width"
};
const transformOrigins = {
  "bottom-start": "top left",
  bottom: "top center",
  "bottom-end": "top right",
  "top-start": "bottom left",
  top: "bottom center",
  "top-end": "bottom right",
  "right-start": "top left",
  right: "center left",
  "right-end": "bottom left",
  "left-start": "top right",
  left: "center right",
  "left-end": "bottom right"
};
const overlapTransformOrigin = {
  "bottom-start": "bottom left",
  bottom: "bottom center",
  "bottom-end": "bottom right",
  "top-start": "top left",
  top: "top center",
  "top-end": "top right",
  "right-start": "top right",
  right: "center right",
  "right-end": "bottom right",
  "left-start": "top left",
  left: "center left",
  "left-end": "bottom left"
};
const oppositeAlignCssPositionProps = {
  "bottom-start": "right",
  "bottom-end": "left",
  "top-start": "right",
  "top-end": "left",
  "right-start": "bottom",
  "right-end": "top",
  "left-start": "bottom",
  "left-end": "top"
};
const keepOffsetDirection = {
  top: true,
  bottom: false,
  left: true,
  right: false
  // left--
};
const cssPositionToOppositeAlign = {
  top: "end",
  bottom: "start",
  left: "end",
  right: "start"
};
function getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, shift, flip2, overlap) {
  if (!flip2 || overlap) {
    return { placement, top: 0, left: 0 };
  }
  const [position, align] = placement.split("-");
  let properAlign = align !== null && align !== void 0 ? align : "center";
  let properOffset = {
    top: 0,
    left: 0
  };
  const deriveOffset = (oppositeAlignCssSizeProp, alignCssPositionProp, offsetVertically2) => {
    let left = 0;
    let top = 0;
    const diff = followerRect[oppositeAlignCssSizeProp] - targetRect[alignCssPositionProp] - targetRect[oppositeAlignCssSizeProp];
    if (diff > 0 && shift) {
      if (offsetVertically2) {
        top = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
      } else {
        left = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
      }
    }
    return {
      left,
      top
    };
  };
  const offsetVertically = position === "left" || position === "right";
  if (properAlign !== "center") {
    const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
    const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
    const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp];
    if (followerRect[oppositeAlignCssSizeProp] > targetRect[oppositeAlignCssSizeProp]) {
      if (
        // current space is not enough
        // ----------[ target ]---------|
        // -------[     follower        ]
        targetRect[oppositeAlignCssPositionProp] + targetRect[oppositeAlignCssSizeProp] < followerRect[oppositeAlignCssSizeProp]
      ) {
        const followerOverTargetSize = (followerRect[oppositeAlignCssSizeProp] - targetRect[oppositeAlignCssSizeProp]) / 2;
        if (targetRect[oppositeAlignCssPositionProp] < followerOverTargetSize || targetRect[currentAlignCssPositionProp] < followerOverTargetSize) {
          if (targetRect[oppositeAlignCssPositionProp] < targetRect[currentAlignCssPositionProp]) {
            properAlign = oppositeAligns[align];
            properOffset = deriveOffset(oppositeAlignCssSizeProp, currentAlignCssPositionProp, offsetVertically);
          } else {
            properOffset = deriveOffset(oppositeAlignCssSizeProp, oppositeAlignCssPositionProp, offsetVertically);
          }
        } else {
          properAlign = "center";
        }
      }
    } else if (followerRect[oppositeAlignCssSizeProp] < targetRect[oppositeAlignCssSizeProp]) {
      if (targetRect[currentAlignCssPositionProp] < 0 && // opposite align has larger space
      // ------------[   target   ]
      // ----------------[follower]
      targetRect[oppositeAlignCssPositionProp] > targetRect[currentAlignCssPositionProp]) {
        properAlign = oppositeAligns[align];
      }
    }
  } else {
    const possibleAlternativeAlignCssPositionProp1 = position === "bottom" || position === "top" ? "left" : "top";
    const possibleAlternativeAlignCssPositionProp2 = oppositionPositions[possibleAlternativeAlignCssPositionProp1];
    const alternativeAlignCssSizeProp = propToCompare[possibleAlternativeAlignCssPositionProp1];
    const followerOverTargetSize = (followerRect[alternativeAlignCssSizeProp] - targetRect[alternativeAlignCssSizeProp]) / 2;
    if (
      // center is not enough
      // ----------- [ target ]--|
      // -------[     follower     ]
      targetRect[possibleAlternativeAlignCssPositionProp1] < followerOverTargetSize || targetRect[possibleAlternativeAlignCssPositionProp2] < followerOverTargetSize
    ) {
      if (targetRect[possibleAlternativeAlignCssPositionProp1] > targetRect[possibleAlternativeAlignCssPositionProp2]) {
        properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp1];
        properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp1, offsetVertically);
      } else {
        properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp2];
        properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp2, offsetVertically);
      }
    }
  }
  let properPosition = position;
  if (
    // space is not enough
    targetRect[position] < followerRect[propToCompare[position]] && // opposite position's space is larger
    targetRect[position] < targetRect[oppositionPositions[position]]
  ) {
    properPosition = oppositionPositions[position];
  }
  return {
    placement: properAlign !== "center" ? `${properPosition}-${properAlign}` : properPosition,
    left: properOffset.left,
    top: properOffset.top
  };
}
function getProperTransformOrigin(placement, overlap) {
  if (overlap)
    return overlapTransformOrigin[placement];
  return transformOrigins[placement];
}
function getOffset(placement, offsetRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap) {
  if (overlap) {
    switch (placement) {
      case "bottom-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-100%)"
        };
      case "bottom-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "top-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: ""
        };
      case "top-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%)"
        };
      case "right-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%)"
        };
      case "right-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "left-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: ""
        };
      case "left-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-100%)"
        };
      case "top":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
          transform: "translateX(-50%)"
        };
      case "right":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-50%)"
        };
      case "left":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-50%)"
        };
      case "bottom":
      default:
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
          transform: "translateX(-50%) translateY(-100%)"
        };
    }
  }
  switch (placement) {
    case "bottom-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: ""
      };
    case "bottom-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%)"
      };
    case "top-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%)"
      };
    case "top-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%) translateY(-100%)"
      };
    case "right-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: ""
      };
    case "right-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%)"
      };
    case "left-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%)"
      };
    case "left-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%) translateY(-100%)"
      };
    case "top":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%) translateX(-50%)"
      };
    case "right":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-50%)"
      };
    case "left":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-50%) translateX(-100%)"
      };
    case "bottom":
    default:
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-50%)"
      };
  }
}
const style$r = c([
  c(".v-binder-follower-container", {
    position: "absolute",
    left: "0",
    right: "0",
    top: "0",
    height: "0",
    pointerEvents: "none",
    zIndex: "auto"
  }),
  c(".v-binder-follower-content", {
    position: "absolute",
    zIndex: "auto"
  }, [
    c("> *", {
      pointerEvents: "all"
    })
  ])
]);
const VFollower = /* @__PURE__ */ defineComponent({
  name: "Follower",
  inheritAttrs: false,
  props: {
    show: Boolean,
    enabled: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String,
      default: "bottom"
    },
    syncTrigger: {
      type: Array,
      default: ["resize", "scroll"]
    },
    to: [String, Object],
    flip: {
      type: Boolean,
      default: true
    },
    internalShift: Boolean,
    x: Number,
    y: Number,
    width: String,
    minWidth: String,
    containerClass: String,
    teleportDisabled: Boolean,
    zindexable: {
      type: Boolean,
      default: true
    },
    zIndex: Number,
    overlap: Boolean
  },
  setup(props) {
    const VBinder2 = inject("VBinder");
    const mergedEnabledRef = useMemo(() => {
      return props.enabled !== void 0 ? props.enabled : props.show;
    });
    const followerRef = ref(null);
    const offsetContainerRef = ref(null);
    const ensureListeners = () => {
      const { syncTrigger } = props;
      if (syncTrigger.includes("scroll")) {
        VBinder2.addScrollListener(syncPosition);
      }
      if (syncTrigger.includes("resize")) {
        VBinder2.addResizeListener(syncPosition);
      }
    };
    const removeListeners = () => {
      VBinder2.removeScrollListener(syncPosition);
      VBinder2.removeResizeListener(syncPosition);
    };
    onMounted(() => {
      if (mergedEnabledRef.value) {
        syncPosition();
        ensureListeners();
      }
    });
    const ssrAdapter2 = useSsrAdapter();
    style$r.mount({
      id: "vueuc/binder",
      head: true,
      anchorMetaName: cssrAnchorMetaName$1,
      ssr: ssrAdapter2
    });
    onBeforeUnmount(() => {
      removeListeners();
    });
    onFontsReady(() => {
      if (mergedEnabledRef.value) {
        syncPosition();
      }
    });
    const syncPosition = () => {
      if (!mergedEnabledRef.value) {
        return;
      }
      const follower = followerRef.value;
      if (follower === null)
        return;
      const target = VBinder2.targetRef;
      const { x, y, overlap } = props;
      const targetRect = x !== void 0 && y !== void 0 ? getPointRect(x, y) : getRect(target);
      follower.style.setProperty("--v-target-width", `${Math.round(targetRect.width)}px`);
      follower.style.setProperty("--v-target-height", `${Math.round(targetRect.height)}px`);
      const { width, minWidth, placement, internalShift, flip: flip2 } = props;
      follower.setAttribute("v-placement", placement);
      if (overlap) {
        follower.setAttribute("v-overlap", "");
      } else {
        follower.removeAttribute("v-overlap");
      }
      const { style: style2 } = follower;
      if (width === "target") {
        style2.width = `${targetRect.width}px`;
      } else if (width !== void 0) {
        style2.width = width;
      } else {
        style2.width = "";
      }
      if (minWidth === "target") {
        style2.minWidth = `${targetRect.width}px`;
      } else if (minWidth !== void 0) {
        style2.minWidth = minWidth;
      } else {
        style2.minWidth = "";
      }
      const followerRect = getRect(follower);
      const offsetContainerRect = getRect(offsetContainerRef.value);
      const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip2, overlap);
      const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
      const { left, top, transform: transform2 } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);
      follower.setAttribute("v-placement", properPlacement);
      follower.style.setProperty("--v-offset-left", `${Math.round(offsetLeftToStandardPlacement)}px`);
      follower.style.setProperty("--v-offset-top", `${Math.round(offsetTopToStandardPlacement)}px`);
      follower.style.transform = `translateX(${left}) translateY(${top}) ${transform2}`;
      follower.style.setProperty("--v-transform-origin", properTransformOrigin);
      follower.style.transformOrigin = properTransformOrigin;
    };
    watch(mergedEnabledRef, (value) => {
      if (value) {
        ensureListeners();
        syncOnNextTick();
      } else {
        removeListeners();
      }
    });
    const syncOnNextTick = () => {
      nextTick().then(syncPosition).catch((e) => console.error(e));
    };
    [
      "placement",
      "x",
      "y",
      "internalShift",
      "flip",
      "width",
      "overlap",
      "minWidth"
    ].forEach((prop) => {
      watch(toRef(props, prop), syncPosition);
    });
    ["teleportDisabled"].forEach((prop) => {
      watch(toRef(props, prop), syncOnNextTick);
    });
    watch(toRef(props, "syncTrigger"), (value) => {
      if (!value.includes("resize")) {
        VBinder2.removeResizeListener(syncPosition);
      } else {
        VBinder2.addResizeListener(syncPosition);
      }
      if (!value.includes("scroll")) {
        VBinder2.removeScrollListener(syncPosition);
      } else {
        VBinder2.addScrollListener(syncPosition);
      }
    });
    const isMountedRef = isMounted();
    const mergedToRef = useMemo(() => {
      const { to } = props;
      if (to !== void 0)
        return to;
      if (isMountedRef.value) {
        return void 0;
      }
      return void 0;
    });
    return {
      VBinder: VBinder2,
      mergedEnabled: mergedEnabledRef,
      offsetContainerRef,
      followerRef,
      mergedTo: mergedToRef,
      syncPosition
    };
  },
  render() {
    return h(LazyTeleport, {
      show: this.show,
      to: this.mergedTo,
      disabled: this.teleportDisabled
    }, {
      default: () => {
        var _a, _b;
        const vNode = h("div", {
          class: ["v-binder-follower-container", this.containerClass],
          ref: "offsetContainerRef"
        }, [
          h("div", {
            class: "v-binder-follower-content",
            ref: "followerRef"
          }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))
        ]);
        if (this.zindexable) {
          return withDirectives(vNode, [
            [
              zindexable$1,
              {
                enabled: this.mergedEnabled,
                zIndex: this.zIndex
              }
            ]
          ]);
        }
        return vNode;
      }
    });
  }
});
var resizeObservers = [];
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function(obj) {
  return Object.freeze(obj);
};
var ResizeObserverSize = /* @__PURE__ */ function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
}();
var DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
    return { x, y, top, right, bottom, left, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
}();
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a = target.getBBox(), width = _a.width, height = _a.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
  var _a;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};
var global$1 = typeof window !== "undefined" ? window : {};
var cache = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size(),
  borderBoxSize: size(),
  contentBoxSize: size(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
var ResizeObserverEntry = /* @__PURE__ */ function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}();
var calculateDepthForNode = function(node) {
  if (isHidden(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent2 = node.parentNode;
  while (parent2) {
    depth += 1;
    parent2 = parent2.parentNode;
  }
  return depth;
};
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};
var process$1 = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver2() {
    requestAnimationFrame(cb);
  });
};
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process$1();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global$1.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name) {
        return global$1.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name) {
        return global$1.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function(n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size2 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size2;
    }
    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();
var ResizeObserverDetail = /* @__PURE__ */ function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
}();
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
}();
var ResizeObserver$1 = function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver2.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver2.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver2;
}();
class ResizeObserverDelegate {
  constructor() {
    this.handleResize = this.handleResize.bind(this);
    this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver$1)(this.handleResize);
    this.elHandlersMap = /* @__PURE__ */ new Map();
  }
  handleResize(entries) {
    for (const entry of entries) {
      const handler = this.elHandlersMap.get(entry.target);
      if (handler !== void 0) {
        handler(entry);
      }
    }
  }
  registerHandler(el, handler) {
    this.elHandlersMap.set(el, handler);
    this.observer.observe(el);
  }
  unregisterHandler(el) {
    if (!this.elHandlersMap.has(el)) {
      return;
    }
    this.elHandlersMap.delete(el);
    this.observer.unobserve(el);
  }
}
const resizeObserverManager = new ResizeObserverDelegate();
const VResizeObserver = /* @__PURE__ */ defineComponent({
  name: "ResizeObserver",
  props: {
    onResize: Function
  },
  setup(props) {
    let registered = false;
    const proxy = getCurrentInstance().proxy;
    function handleResize(entry) {
      const { onResize } = props;
      if (onResize !== void 0)
        onResize(entry);
    }
    onMounted(() => {
      const el = proxy.$el;
      if (el === void 0) {
        warn("resize-observer", "$el does not exist.");
        return;
      }
      if (el.nextElementSibling !== el.nextSibling) {
        if (el.nodeType === 3 && el.nodeValue !== "") {
          warn("resize-observer", "$el can not be observed (it may be a text node).");
          return;
        }
      }
      if (el.nextElementSibling !== null) {
        resizeObserverManager.registerHandler(el.nextElementSibling, handleResize);
        registered = true;
      }
    });
    onBeforeUnmount(() => {
      if (registered) {
        resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
      }
    });
  },
  render() {
    return renderSlot(this.$slots, "default");
  }
});
const styles = c(".v-x-scroll", {
  overflow: "auto",
  scrollbarWidth: "none"
}, [
  c("&::-webkit-scrollbar", {
    width: 0,
    height: 0
  })
]);
const VXScroll = /* @__PURE__ */ defineComponent({
  name: "XScroll",
  props: {
    disabled: Boolean,
    onScroll: Function
  },
  setup() {
    const selfRef = ref(null);
    function handleWheel(e) {
      const preventYWheel = e.currentTarget.offsetWidth < e.currentTarget.scrollWidth;
      if (!preventYWheel || e.deltaY === 0)
        return;
      e.currentTarget.scrollLeft += e.deltaY + e.deltaX;
      e.preventDefault();
    }
    const ssrAdapter2 = useSsrAdapter();
    styles.mount({
      id: "vueuc/x-scroll",
      head: true,
      anchorMetaName: cssrAnchorMetaName$1,
      ssr: ssrAdapter2
    });
    const exposedMethods = {
      scrollTo(...args) {
        var _a;
        (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(...args);
      }
    };
    return Object.assign({
      selfRef,
      handleWheel
    }, exposedMethods);
  },
  render() {
    return h("div", {
      ref: "selfRef",
      onScroll: this.onScroll,
      onWheel: this.disabled ? void 0 : this.handleWheel,
      class: "v-x-scroll"
    }, this.$slots);
  }
});
const hiddenAttr = "v-hidden";
const style$q = c("[v-hidden]", {
  display: "none!important"
});
const VOverflow = /* @__PURE__ */ defineComponent({
  name: "Overflow",
  props: {
    getCounter: Function,
    getTail: Function,
    updateCounter: Function,
    onUpdateCount: Function,
    onUpdateOverflow: Function
  },
  setup(props, { slots }) {
    const selfRef = ref(null);
    const counterRef = ref(null);
    function deriveCounter(options) {
      const { value: self2 } = selfRef;
      const { getCounter, getTail } = props;
      let counter;
      if (getCounter !== void 0)
        counter = getCounter();
      else {
        counter = counterRef.value;
      }
      if (!self2 || !counter)
        return;
      if (counter.hasAttribute(hiddenAttr)) {
        counter.removeAttribute(hiddenAttr);
      }
      const { children } = self2;
      if (options.showAllItemsBeforeCalculate) {
        for (const child of children) {
          if (child.hasAttribute(hiddenAttr)) {
            child.removeAttribute(hiddenAttr);
          }
        }
      }
      const containerWidth = self2.offsetWidth;
      const childWidths = [];
      const tail2 = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;
      let childWidthSum = tail2 ? tail2.offsetWidth : 0;
      let overflow = false;
      const len2 = self2.children.length - (slots.tail ? 1 : 0);
      for (let i = 0; i < len2 - 1; ++i) {
        if (i < 0)
          continue;
        const child = children[i];
        if (overflow) {
          if (!child.hasAttribute(hiddenAttr)) {
            child.setAttribute(hiddenAttr, "");
          }
          continue;
        } else if (child.hasAttribute(hiddenAttr)) {
          child.removeAttribute(hiddenAttr);
        }
        const childWidth = child.offsetWidth;
        childWidthSum += childWidth;
        childWidths[i] = childWidth;
        if (childWidthSum > containerWidth) {
          const { updateCounter } = props;
          for (let j = i; j >= 0; --j) {
            const restCount = len2 - 1 - j;
            if (updateCounter !== void 0) {
              updateCounter(restCount);
            } else {
              counter.textContent = `${restCount}`;
            }
            const counterWidth = counter.offsetWidth;
            childWidthSum -= childWidths[j];
            if (childWidthSum + counterWidth <= containerWidth || j === 0) {
              overflow = true;
              i = j - 1;
              if (tail2) {
                if (i === -1) {
                  tail2.style.maxWidth = `${containerWidth - counterWidth}px`;
                  tail2.style.boxSizing = "border-box";
                } else {
                  tail2.style.maxWidth = "";
                }
              }
              const { onUpdateCount } = props;
              if (onUpdateCount)
                onUpdateCount(restCount);
              break;
            }
          }
        }
      }
      const { onUpdateOverflow } = props;
      if (!overflow) {
        if (onUpdateOverflow !== void 0) {
          onUpdateOverflow(false);
        }
        counter.setAttribute(hiddenAttr, "");
      } else {
        if (onUpdateOverflow !== void 0) {
          onUpdateOverflow(true);
        }
      }
    }
    const ssrAdapter2 = useSsrAdapter();
    style$q.mount({
      id: "vueuc/overflow",
      head: true,
      anchorMetaName: cssrAnchorMetaName$1,
      ssr: ssrAdapter2
    });
    onMounted(() => deriveCounter({
      showAllItemsBeforeCalculate: false
    }));
    return {
      selfRef,
      counterRef,
      sync: deriveCounter
    };
  },
  render() {
    const { $slots } = this;
    nextTick(() => this.sync({
      showAllItemsBeforeCalculate: false
    }));
    return h("div", {
      class: "v-overflow",
      ref: "selfRef"
    }, [
      renderSlot($slots, "default"),
      // $slots.counter should only has 1 element
      $slots.counter ? $slots.counter() : h("span", {
        style: {
          display: "inline-block"
        },
        ref: "counterRef"
      }),
      // $slots.tail should only has 1 element
      $slots.tail ? $slots.tail() : null
    ]);
  }
});
function isHTMLElement(node) {
  return node instanceof HTMLElement;
}
function focusFirstDescendant(node) {
  for (let i = 0; i < node.childNodes.length; i++) {
    const child = node.childNodes[i];
    if (isHTMLElement(child)) {
      if (attemptFocus(child) || focusFirstDescendant(child)) {
        return true;
      }
    }
  }
  return false;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child)) {
      if (attemptFocus(child) || focusLastDescendant(child)) {
        return true;
      }
    }
  }
  return false;
}
function attemptFocus(element) {
  if (!isFocusable(element)) {
    return false;
  }
  try {
    element.focus({ preventScroll: true });
  } catch (e) {
  }
  return document.activeElement === element;
}
function isFocusable(element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (element.getAttribute("disabled")) {
    return false;
  }
  switch (element.nodeName) {
    case "A":
      return !!element.href && element.rel !== "ignore";
    case "INPUT":
      return element.type !== "hidden" && element.type !== "file";
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
      return true;
    default:
      return false;
  }
}
let stack = [];
const FocusTrap = /* @__PURE__ */ defineComponent({
  name: "FocusTrap",
  props: {
    disabled: Boolean,
    active: Boolean,
    autoFocus: {
      type: Boolean,
      default: true
    },
    onEsc: Function,
    initialFocusTo: String,
    finalFocusTo: String,
    returnFocusOnDeactivated: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const id = createId();
    const focusableStartRef = ref(null);
    const focusableEndRef = ref(null);
    let activated = false;
    let ignoreInternalFocusChange = false;
    const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
    function isCurrentActive() {
      const currentActiveId = stack[stack.length - 1];
      return currentActiveId === id;
    }
    function handleDocumentKeydown(e) {
      var _a;
      if (e.code === "Escape") {
        if (isCurrentActive()) {
          (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props, e);
        }
      }
    }
    onMounted(() => {
      watch(() => props.active, (value) => {
        if (value) {
          activate();
          on("keydown", document, handleDocumentKeydown);
        } else {
          off("keydown", document, handleDocumentKeydown);
          if (activated) {
            deactivate();
          }
        }
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(() => {
      off("keydown", document, handleDocumentKeydown);
      if (activated)
        deactivate();
    });
    function handleDocumentFocus(e) {
      if (ignoreInternalFocusChange)
        return;
      if (isCurrentActive()) {
        const mainEl = getMainEl();
        if (mainEl === null)
          return;
        if (mainEl.contains(getPreciseEventTarget(e)))
          return;
        resetFocusTo("first");
      }
    }
    function getMainEl() {
      const focusableStartEl = focusableStartRef.value;
      if (focusableStartEl === null)
        return null;
      let mainEl = focusableStartEl;
      while (true) {
        mainEl = mainEl.nextSibling;
        if (mainEl === null)
          break;
        if (mainEl instanceof Element && mainEl.tagName === "DIV") {
          break;
        }
      }
      return mainEl;
    }
    function activate() {
      var _a;
      if (props.disabled)
        return;
      stack.push(id);
      if (props.autoFocus) {
        const { initialFocusTo } = props;
        if (initialFocusTo === void 0) {
          resetFocusTo("first");
        } else {
          (_a = resolveTo(initialFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
        }
      }
      activated = true;
      document.addEventListener("focus", handleDocumentFocus, true);
    }
    function deactivate() {
      var _a;
      if (props.disabled)
        return;
      document.removeEventListener("focus", handleDocumentFocus, true);
      stack = stack.filter((idInStack) => idInStack !== id);
      if (isCurrentActive())
        return;
      const { finalFocusTo } = props;
      if (finalFocusTo !== void 0) {
        (_a = resolveTo(finalFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
      } else if (props.returnFocusOnDeactivated) {
        if (lastFocusedElement instanceof HTMLElement) {
          ignoreInternalFocusChange = true;
          lastFocusedElement.focus({ preventScroll: true });
          ignoreInternalFocusChange = false;
        }
      }
    }
    function resetFocusTo(target) {
      if (!isCurrentActive())
        return;
      if (props.active) {
        const focusableStartEl = focusableStartRef.value;
        const focusableEndEl = focusableEndRef.value;
        if (focusableStartEl !== null && focusableEndEl !== null) {
          const mainEl = getMainEl();
          if (mainEl == null || mainEl === focusableEndEl) {
            ignoreInternalFocusChange = true;
            focusableStartEl.focus({ preventScroll: true });
            ignoreInternalFocusChange = false;
            return;
          }
          ignoreInternalFocusChange = true;
          const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
          ignoreInternalFocusChange = false;
          if (!focused) {
            ignoreInternalFocusChange = true;
            focusableStartEl.focus({ preventScroll: true });
            ignoreInternalFocusChange = false;
          }
        }
      }
    }
    function handleStartFocus(e) {
      if (ignoreInternalFocusChange)
        return;
      const mainEl = getMainEl();
      if (mainEl === null)
        return;
      if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
        resetFocusTo("last");
      } else {
        resetFocusTo("first");
      }
    }
    function handleEndFocus(e) {
      if (ignoreInternalFocusChange)
        return;
      if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
        resetFocusTo("last");
      } else {
        resetFocusTo("first");
      }
    }
    return {
      focusableStartRef,
      focusableEndRef,
      focusableStyle: "position: absolute; height: 0; width: 0;",
      handleStartFocus,
      handleEndFocus
    };
  },
  render() {
    const { default: defaultSlot } = this.$slots;
    if (defaultSlot === void 0)
      return null;
    if (this.disabled)
      return defaultSlot();
    const { active, focusableStyle } = this;
    return h(Fragment, null, [
      h("div", {
        "aria-hidden": "true",
        tabindex: active ? "0" : "-1",
        ref: "focusableStartRef",
        style: focusableStyle,
        onFocus: this.handleStartFocus
      }),
      defaultSlot(),
      h("div", {
        "aria-hidden": "true",
        style: focusableStyle,
        ref: "focusableEndRef",
        tabindex: active ? "0" : "-1",
        onFocus: this.handleEndFocus
      })
    ]);
  }
});
let lockCount = 0;
let originalMarginRight = "";
let originalOverflow = "";
let originalOverflowX = "";
let originalOverflowY = "";
const lockHtmlScrollRightCompensationRef = ref("0px");
function useLockHtmlScroll(lockRef) {
  if (typeof document === "undefined")
    return;
  const el = document.documentElement;
  let watchStopHandle;
  let activated = false;
  const unlock = () => {
    el.style.marginRight = originalMarginRight;
    el.style.overflow = originalOverflow;
    el.style.overflowX = originalOverflowX;
    el.style.overflowY = originalOverflowY;
    lockHtmlScrollRightCompensationRef.value = "0px";
  };
  onMounted(() => {
    watchStopHandle = watch(lockRef, (value) => {
      if (value) {
        if (!lockCount) {
          const scrollbarWidth = window.innerWidth - el.offsetWidth;
          if (scrollbarWidth > 0) {
            originalMarginRight = el.style.marginRight;
            el.style.marginRight = `${scrollbarWidth}px`;
            lockHtmlScrollRightCompensationRef.value = `${scrollbarWidth}px`;
          }
          originalOverflow = el.style.overflow;
          originalOverflowX = el.style.overflowX;
          originalOverflowY = el.style.overflowY;
          el.style.overflow = "hidden";
          el.style.overflowX = "hidden";
          el.style.overflowY = "hidden";
        }
        activated = true;
        lockCount++;
      } else {
        lockCount--;
        if (!lockCount) {
          unlock();
        }
        activated = false;
      }
    }, {
      immediate: true
    });
  });
  onBeforeUnmount(() => {
    watchStopHandle === null || watchStopHandle === void 0 ? void 0 : watchStopHandle();
    if (activated) {
      lockCount--;
      if (!lockCount) {
        unlock();
      }
      activated = false;
    }
  });
}
const isComposingRef = ref(false);
function compositionStartHandler() {
  isComposingRef.value = true;
}
function compositionEndHandler() {
  isComposingRef.value = false;
}
let mountedCount = 0;
function useIsComposing() {
  if (isBrowser$2) {
    onBeforeMount(() => {
      if (!mountedCount) {
        window.addEventListener("compositionstart", compositionStartHandler);
        window.addEventListener("compositionend", compositionEndHandler);
      }
      mountedCount++;
    });
    onBeforeUnmount(() => {
      if (mountedCount <= 1) {
        window.removeEventListener("compositionstart", compositionStartHandler);
        window.removeEventListener("compositionend", compositionEndHandler);
        mountedCount = 0;
      } else {
        mountedCount--;
      }
    });
  }
  return isComposingRef;
}
function useReactivated(callback) {
  const isDeactivatedRef = {
    isDeactivated: false
  };
  let activateStateInitialized = false;
  onActivated(() => {
    isDeactivatedRef.isDeactivated = false;
    if (!activateStateInitialized) {
      activateStateInitialized = true;
      return;
    }
    callback();
  });
  onDeactivated(() => {
    isDeactivatedRef.isDeactivated = true;
    if (!activateStateInitialized) {
      activateStateInitialized = true;
    }
  });
  return isDeactivatedRef;
}
const formItemInjectionKey = createInjectionKey("n-form-item");
function useFormItem(props, {
  defaultSize = "medium",
  mergedSize,
  mergedDisabled
} = {}) {
  const NFormItem2 = inject(formItemInjectionKey, null);
  provide(formItemInjectionKey, null);
  const mergedSizeRef = computed(mergedSize ? () => mergedSize(NFormItem2) : () => {
    const {
      size: size2
    } = props;
    if (size2)
      return size2;
    if (NFormItem2) {
      const {
        mergedSize: mergedSize2
      } = NFormItem2;
      if (mergedSize2.value !== void 0) {
        return mergedSize2.value;
      }
    }
    return defaultSize;
  });
  const mergedDisabledRef = computed(mergedDisabled ? () => mergedDisabled(NFormItem2) : () => {
    const {
      disabled
    } = props;
    if (disabled !== void 0) {
      return disabled;
    }
    if (NFormItem2) {
      return NFormItem2.disabled.value;
    }
    return false;
  });
  const mergedStatusRef = computed(() => {
    const {
      status
    } = props;
    if (status)
      return status;
    return NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.mergedValidationStatus.value;
  });
  onBeforeUnmount(() => {
    if (NFormItem2) {
      NFormItem2.restoreValidation();
    }
  });
  return {
    mergedSizeRef,
    mergedDisabledRef,
    mergedStatusRef,
    nTriggerFormBlur() {
      if (NFormItem2) {
        NFormItem2.handleContentBlur();
      }
    },
    nTriggerFormChange() {
      if (NFormItem2) {
        NFormItem2.handleContentChange();
      }
    },
    nTriggerFormFocus() {
      if (NFormItem2) {
        NFormItem2.handleContentFocus();
      }
    },
    nTriggerFormInput() {
      if (NFormItem2) {
        NFormItem2.handleContentInput();
      }
    }
  };
}
const commonVariables$7 = {
  fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
  fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
  fontWeight: "400",
  fontWeightStrong: "500",
  cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
  cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
  cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
  borderRadius: "3px",
  borderRadiusSmall: "2px",
  fontSize: "14px",
  fontSizeMini: "12px",
  fontSizeTiny: "12px",
  fontSizeSmall: "14px",
  fontSizeMedium: "14px",
  fontSizeLarge: "15px",
  fontSizeHuge: "16px",
  lineHeight: "1.6",
  heightMini: "16px",
  // private now, it's too small
  heightTiny: "22px",
  heightSmall: "28px",
  heightMedium: "34px",
  heightLarge: "40px",
  heightHuge: "46px"
};
const {
  fontSize,
  fontFamily,
  lineHeight
} = commonVariables$7;
const globalStyle = c$1("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c$1("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
const configProviderInjectionKey = createInjectionKey("n-config-provider");
const cssrAnchorMetaName = "naive-ui-style";
function createTheme(theme) {
  return theme;
}
function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
  const ssrAdapter2 = useSsrAdapter();
  const NConfigProvider = inject(configProviderInjectionKey, null);
  if (style2) {
    const mountStyle = () => {
      const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
      style2.mount({
        id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
        head: true,
        props: {
          bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
        },
        anchorMetaName: cssrAnchorMetaName,
        ssr: ssrAdapter2
      });
      if (!(NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled)) {
        globalStyle.mount({
          id: "n-global",
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          ssr: ssrAdapter2
        });
      }
    };
    if (ssrAdapter2) {
      mountStyle();
    } else {
      onBeforeMount(mountStyle);
    }
  }
  const mergedThemeRef = computed(() => {
    var _a;
    const {
      theme: {
        common: selfCommon,
        self: self2,
        peers = {}
      } = {},
      themeOverrides: selfOverrides = {},
      builtinThemeOverrides: builtinOverrides = {}
    } = props;
    const {
      common: selfCommonOverrides,
      peers: peersOverrides
    } = selfOverrides;
    const {
      common: globalCommon = void 0,
      [resolveId]: {
        common: globalSelfCommon = void 0,
        self: globalSelf = void 0,
        peers: globalPeers = {}
      } = {}
    } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value) || {};
    const {
      common: globalCommonOverrides = void 0,
      [resolveId]: globalSelfOverrides = {}
    } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value) || {};
    const {
      common: globalSelfCommonOverrides,
      peers: globalPeersOverrides = {}
    } = globalSelfOverrides;
    const mergedCommon = merge$1({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
    const mergedSelf = merge$1(
      // {}, executed every time, no need for empty obj
      (_a = self2 || globalSelf || defaultTheme.self) === null || _a === void 0 ? void 0 : _a(mergedCommon),
      builtinOverrides,
      globalSelfOverrides,
      selfOverrides
    );
    return {
      common: mergedCommon,
      self: mergedSelf,
      peers: merge$1({}, defaultTheme.peers, globalPeers, peers),
      peerOverrides: merge$1({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
    };
  });
  return mergedThemeRef;
}
useTheme.props = {
  theme: Object,
  themeOverrides: Object,
  builtinThemeOverrides: Object
};
const defaultClsPrefix = "n";
function useConfig(props = {}, options = {
  defaultBordered: true
}) {
  const NConfigProvider = inject(configProviderInjectionKey, null);
  return {
    // NConfigProvider,
    inlineThemeDisabled: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.inlineThemeDisabled,
    mergedRtlRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef,
    mergedComponentPropsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef,
    mergedBreakpointsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBreakpointsRef,
    mergedBorderedRef: computed(() => {
      var _a, _b;
      const {
        bordered
      } = props;
      if (bordered !== void 0)
        return bordered;
      return (_b = (_a = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value) !== null && _a !== void 0 ? _a : options.defaultBordered) !== null && _b !== void 0 ? _b : true;
    }),
    mergedClsPrefixRef: NConfigProvider ? NConfigProvider.mergedClsPrefixRef : shallowRef(defaultClsPrefix),
    namespaceRef: computed(() => NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value)
  };
}
const enUS = {
  name: "en-US",
  global: {
    undo: "Undo",
    redo: "Redo",
    confirm: "Confirm",
    clear: "Clear"
  },
  Popconfirm: {
    positiveText: "Confirm",
    negativeText: "Cancel"
  },
  Cascader: {
    placeholder: "Please Select",
    loading: "Loading",
    loadingRequiredMessage: (label) => `Please load all ${label}'s descendants before checking it.`
  },
  Time: {
    dateFormat: "yyyy-MM-dd",
    dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
  },
  DatePicker: {
    yearFormat: "yyyy",
    monthFormat: "MMM",
    dayFormat: "eeeeee",
    yearTypeFormat: "yyyy",
    monthTypeFormat: "yyyy-MM",
    dateFormat: "yyyy-MM-dd",
    dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
    quarterFormat: "yyyy-qqq",
    weekFormat: "RRRR-w",
    clear: "Clear",
    now: "Now",
    confirm: "Confirm",
    selectTime: "Select Time",
    selectDate: "Select Date",
    datePlaceholder: "Select Date",
    datetimePlaceholder: "Select Date and Time",
    monthPlaceholder: "Select Month",
    yearPlaceholder: "Select Year",
    quarterPlaceholder: "Select Quarter",
    weekPlaceholder: "Select Week",
    startDatePlaceholder: "Start Date",
    endDatePlaceholder: "End Date",
    startDatetimePlaceholder: "Start Date and Time",
    endDatetimePlaceholder: "End Date and Time",
    startMonthPlaceholder: "Start Month",
    endMonthPlaceholder: "End Month",
    monthBeforeYear: true,
    firstDayOfWeek: 6,
    today: "Today"
  },
  DataTable: {
    checkTableAll: "Select all in the table",
    uncheckTableAll: "Unselect all in the table",
    confirm: "Confirm",
    clear: "Clear"
  },
  LegacyTransfer: {
    sourceTitle: "Source",
    targetTitle: "Target"
  },
  Transfer: {
    selectAll: "Select all",
    unselectAll: "Unselect all",
    clearAll: "Clear",
    total: (num) => `Total ${num} items`,
    selected: (num) => `${num} items selected`
  },
  Empty: {
    description: "No Data"
  },
  Select: {
    placeholder: "Please Select"
  },
  TimePicker: {
    placeholder: "Select Time",
    positiveText: "OK",
    negativeText: "Cancel",
    now: "Now",
    clear: "Clear"
  },
  Pagination: {
    goto: "Goto",
    selectionSuffix: "page"
  },
  DynamicTags: {
    add: "Add"
  },
  Log: {
    loading: "Loading"
  },
  Input: {
    placeholder: "Please Input"
  },
  InputNumber: {
    placeholder: "Please Input"
  },
  DynamicInput: {
    create: "Create"
  },
  ThemeEditor: {
    title: "Theme Editor",
    clearAllVars: "Clear All Variables",
    clearSearch: "Clear Search",
    filterCompName: "Filter Component Name",
    filterVarName: "Filter Variable Name",
    import: "Import",
    export: "Export",
    restore: "Reset to Default"
  },
  Image: {
    tipPrevious: "Previous picture (←)",
    tipNext: "Next picture (→)",
    tipCounterclockwise: "Counterclockwise",
    tipClockwise: "Clockwise",
    tipZoomOut: "Zoom out",
    tipZoomIn: "Zoom in",
    tipDownload: "Download",
    tipClose: "Close (Esc)",
    // TODO: translation
    tipOriginalSize: "Zoom to original size"
  }
};
const enUS$1 = enUS;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}
function buildMatchFn(args) {
  return function(string3) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string3.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern4) {
      return pattern4.test(matchedString);
    }) : findKey(parsePatterns, function(pattern4) {
      return pattern4.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest2 = string3.slice(matchedString.length);
    return {
      value,
      rest: rest2
    };
  };
}
function findKey(object4, predicate) {
  for (var key in object4) {
    if (object4.hasOwnProperty(key) && predicate(object4[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array4, predicate) {
  for (var key = 0; key < array4.length; key++) {
    if (predicate(array4[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string3) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string3.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string3.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest2 = string3.slice(matchedString.length);
    return {
      value,
      rest: rest2
    };
  };
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function formatDistance2(token, count, options) {
  var result2;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result2 = tokenValue;
  } else if (count === 1) {
    result2 = tokenValue.one;
  } else {
    result2 = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result2;
    } else {
      return result2 + " ago";
    }
  }
  return result2;
};
const formatDistance$1 = formatDistance;
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
const formatRelative$1 = formatRelative;
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number4 = Number(dirtyNumber);
  var rem100 = number4 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number4 + "st";
      case 2:
        return number4 + "nd";
      case 3:
        return number4 + "rd";
    }
  }
  return number4 + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
const localize$1 = localize;
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const match$1 = match;
var locale = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const defaultLocale = locale;
const dateEnUs = {
  name: "en-US",
  locale: defaultLocale
};
const dateEnUS = dateEnUs;
function useLocale(ns) {
  const {
    mergedLocaleRef,
    mergedDateLocaleRef
  } = inject(configProviderInjectionKey, null) || {};
  const localeRef = computed(() => {
    var _a, _b;
    return (_b = (_a = mergedLocaleRef === null || mergedLocaleRef === void 0 ? void 0 : mergedLocaleRef.value) === null || _a === void 0 ? void 0 : _a[ns]) !== null && _b !== void 0 ? _b : enUS$1[ns];
  });
  const dateLocaleRef = computed(() => {
    var _a;
    return (_a = mergedDateLocaleRef === null || mergedDateLocaleRef === void 0 ? void 0 : mergedDateLocaleRef.value) !== null && _a !== void 0 ? _a : dateEnUS;
  });
  return {
    dateLocaleRef,
    localeRef
  };
}
function useStyle(mountId, style2, clsPrefixRef) {
  if (!style2) {
    return;
  }
  const ssrAdapter2 = useSsrAdapter();
  const NConfigProvider = inject(configProviderInjectionKey, null);
  const mountStyle = () => {
    const clsPrefix = clsPrefixRef.value;
    style2.mount({
      id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
      head: true,
      anchorMetaName: cssrAnchorMetaName,
      props: {
        bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
      },
      ssr: ssrAdapter2
    });
    if (!(NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled)) {
      globalStyle.mount({
        id: "n-global",
        head: true,
        anchorMetaName: cssrAnchorMetaName,
        ssr: ssrAdapter2
      });
    }
  };
  if (ssrAdapter2) {
    mountStyle();
  } else {
    onBeforeMount(mountStyle);
  }
}
function useThemeClass(componentName, hashRef, cssVarsRef, props) {
  var _a;
  if (!cssVarsRef)
    throwError("useThemeClass", "cssVarsRef is not passed");
  const mergedThemeHashRef = (_a = inject(configProviderInjectionKey, null)) === null || _a === void 0 ? void 0 : _a.mergedThemeHashRef;
  const themeClassRef = ref("");
  const ssrAdapter2 = useSsrAdapter();
  let renderCallback;
  const hashClassPrefix = `__${componentName}`;
  const mountStyle = () => {
    let finalThemeHash = hashClassPrefix;
    const hashValue = hashRef ? hashRef.value : void 0;
    const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
    if (themeHash)
      finalThemeHash += `-${themeHash}`;
    if (hashValue)
      finalThemeHash += `-${hashValue}`;
    const {
      themeOverrides,
      builtinThemeOverrides
    } = props;
    if (themeOverrides) {
      finalThemeHash += `-${murmur2(JSON.stringify(themeOverrides))}`;
    }
    if (builtinThemeOverrides) {
      finalThemeHash += `-${murmur2(JSON.stringify(builtinThemeOverrides))}`;
    }
    themeClassRef.value = finalThemeHash;
    renderCallback = () => {
      const cssVars = cssVarsRef.value;
      let style2 = "";
      for (const key in cssVars) {
        style2 += `${key}: ${cssVars[key]};`;
      }
      c$1(`.${finalThemeHash}`, style2).mount({
        id: finalThemeHash,
        ssr: ssrAdapter2
      });
      renderCallback = void 0;
    };
  };
  watchEffect(() => {
    mountStyle();
  });
  return {
    themeClass: themeClassRef,
    onRender: () => {
      renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
    }
  };
}
function useRtl(mountId, rtlStateRef, clsPrefixRef) {
  if (!rtlStateRef)
    return void 0;
  const ssrAdapter2 = useSsrAdapter();
  const componentRtlStateRef = computed(() => {
    const {
      value: rtlState
    } = rtlStateRef;
    if (!rtlState) {
      return void 0;
    }
    const componentRtlState = rtlState[mountId];
    if (!componentRtlState) {
      return void 0;
    }
    return componentRtlState;
  });
  const mountStyle = () => {
    watchEffect(() => {
      const {
        value: clsPrefix
      } = clsPrefixRef;
      const id = `${clsPrefix}${mountId}Rtl`;
      if (exists(id, ssrAdapter2))
        return;
      const {
        value: componentRtlState
      } = componentRtlStateRef;
      if (!componentRtlState)
        return;
      componentRtlState.style.mount({
        id,
        head: true,
        anchorMetaName: cssrAnchorMetaName,
        props: {
          bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
        },
        ssr: ssrAdapter2
      });
    });
  };
  if (ssrAdapter2) {
    mountStyle();
  } else {
    onBeforeMount(mountStyle);
  }
  return componentRtlStateRef;
}
const AddIcon = /* @__PURE__ */ defineComponent({
  name: "Add",
  render() {
    return h("svg", {
      width: "512",
      height: "512",
      viewBox: "0 0 512 512",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, h("path", {
      d: "M256 112V400M400 256H112",
      stroke: "currentColor",
      "stroke-width": "32",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }));
  }
});
function replaceable(name, icon) {
  return /* @__PURE__ */ defineComponent({
    name: upperFirst(name),
    setup() {
      var _a;
      const mergedIconsRef = (_a = inject(configProviderInjectionKey, null)) === null || _a === void 0 ? void 0 : _a.mergedIconsRef;
      return () => {
        var _a2;
        const iconOverride = (_a2 = mergedIconsRef === null || mergedIconsRef === void 0 ? void 0 : mergedIconsRef.value) === null || _a2 === void 0 ? void 0 : _a2[name];
        return iconOverride ? iconOverride() : icon;
      };
    }
  });
}
const ChevronLeftIcon = /* @__PURE__ */ defineComponent({
  name: "ChevronLeft",
  render() {
    return h("svg", {
      viewBox: "0 0 16 16",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, h("path", {
      d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z",
      fill: "currentColor"
    }));
  }
});
const ChevronRightIcon = /* @__PURE__ */ defineComponent({
  name: "ChevronRight",
  render() {
    return h("svg", {
      viewBox: "0 0 16 16",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, h("path", {
      d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z",
      fill: "currentColor"
    }));
  }
});
const ErrorIcon$1 = replaceable("close", h("svg", {
  viewBox: "0 0 12 12",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": true
}, h("g", {
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}, h("g", {
  fill: "currentColor",
  "fill-rule": "nonzero"
}, h("path", {
  d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z"
})))));
const EyeIcon = /* @__PURE__ */ defineComponent({
  name: "Eye",
  render() {
    return h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 512 512"
    }, h("path", {
      d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z",
      fill: "none",
      stroke: "currentColor",
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "32"
    }), h("circle", {
      cx: "256",
      cy: "256",
      r: "80",
      fill: "none",
      stroke: "currentColor",
      "stroke-miterlimit": "10",
      "stroke-width": "32"
    }));
  }
});
const EyeOffIcon = /* @__PURE__ */ defineComponent({
  name: "EyeOff",
  render() {
    return h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 512 512"
    }, h("path", {
      d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z",
      fill: "currentColor"
    }), h("path", {
      d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z",
      fill: "currentColor"
    }), h("path", {
      d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z",
      fill: "currentColor"
    }), h("path", {
      d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z",
      fill: "currentColor"
    }), h("path", {
      d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z",
      fill: "currentColor"
    }));
  }
});
const ErrorIcon = replaceable("error", h("svg", {
  viewBox: "0 0 48 48",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, h("g", {
  stroke: "none",
  "stroke-width": "1",
  "fill-rule": "evenodd"
}, h("g", {
  "fill-rule": "nonzero"
}, h("path", {
  d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M17.8838835,16.1161165 L17.7823881,16.0249942 C17.3266086,15.6583353 16.6733914,15.6583353 16.2176119,16.0249942 L16.1161165,16.1161165 L16.0249942,16.2176119 C15.6583353,16.6733914 15.6583353,17.3266086 16.0249942,17.7823881 L16.1161165,17.8838835 L22.233,24 L16.1161165,30.1161165 L16.0249942,30.2176119 C15.6583353,30.6733914 15.6583353,31.3266086 16.0249942,31.7823881 L16.1161165,31.8838835 L16.2176119,31.9750058 C16.6733914,32.3416647 17.3266086,32.3416647 17.7823881,31.9750058 L17.8838835,31.8838835 L24,25.767 L30.1161165,31.8838835 L30.2176119,31.9750058 C30.6733914,32.3416647 31.3266086,32.3416647 31.7823881,31.9750058 L31.8838835,31.8838835 L31.9750058,31.7823881 C32.3416647,31.3266086 32.3416647,30.6733914 31.9750058,30.2176119 L31.8838835,30.1161165 L25.767,24 L31.8838835,17.8838835 L31.9750058,17.7823881 C32.3416647,17.3266086 32.3416647,16.6733914 31.9750058,16.2176119 L31.8838835,16.1161165 L31.7823881,16.0249942 C31.3266086,15.6583353 30.6733914,15.6583353 30.2176119,16.0249942 L30.1161165,16.1161165 L24,22.233 L17.8838835,16.1161165 L17.7823881,16.0249942 L17.8838835,16.1161165 Z"
})))));
const InfoIcon = replaceable("info", h("svg", {
  viewBox: "0 0 28 28",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, h("g", {
  stroke: "none",
  "stroke-width": "1",
  "fill-rule": "evenodd"
}, h("g", {
  "fill-rule": "nonzero"
}, h("path", {
  d: "M14,2 C20.6274,2 26,7.37258 26,14 C26,20.6274 20.6274,26 14,26 C7.37258,26 2,20.6274 2,14 C2,7.37258 7.37258,2 14,2 Z M14,11 C13.4477,11 13,11.4477 13,12 L13,12 L13,20 C13,20.5523 13.4477,21 14,21 C14.5523,21 15,20.5523 15,20 L15,20 L15,12 C15,11.4477 14.5523,11 14,11 Z M14,6.75 C13.3096,6.75 12.75,7.30964 12.75,8 C12.75,8.69036 13.3096,9.25 14,9.25 C14.6904,9.25 15.25,8.69036 15.25,8 C15.25,7.30964 14.6904,6.75 14,6.75 Z"
})))));
const RemoveIcon = /* @__PURE__ */ defineComponent({
  name: "Remove",
  render() {
    return h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 512 512"
    }, h("line", {
      x1: "400",
      y1: "256",
      x2: "112",
      y2: "256",
      style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 32px;\n      "
    }));
  }
});
const SuccessIcon = replaceable("success", h("svg", {
  viewBox: "0 0 48 48",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, h("g", {
  stroke: "none",
  "stroke-width": "1",
  "fill-rule": "evenodd"
}, h("g", {
  "fill-rule": "nonzero"
}, h("path", {
  d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M32.6338835,17.6161165 C32.1782718,17.1605048 31.4584514,17.1301307 30.9676119,17.5249942 L30.8661165,17.6161165 L20.75,27.732233 L17.1338835,24.1161165 C16.6457281,23.6279612 15.8542719,23.6279612 15.3661165,24.1161165 C14.9105048,24.5717282 14.8801307,25.2915486 15.2749942,25.7823881 L15.3661165,25.8838835 L19.8661165,30.3838835 C20.3217282,30.8394952 21.0415486,30.8698693 21.5323881,30.4750058 L21.6338835,30.3838835 L32.6338835,19.3838835 C33.1220388,18.8957281 33.1220388,18.1042719 32.6338835,17.6161165 Z"
})))));
const WarningIcon = replaceable("warning", h("svg", {
  viewBox: "0 0 24 24",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, h("g", {
  stroke: "none",
  "stroke-width": "1",
  "fill-rule": "evenodd"
}, h("g", {
  "fill-rule": "nonzero"
}, h("path", {
  d: "M12,2 C17.523,2 22,6.478 22,12 C22,17.522 17.523,22 12,22 C6.477,22 2,17.522 2,12 C2,6.478 6.477,2 12,2 Z M12.0018002,15.0037242 C11.450254,15.0037242 11.0031376,15.4508407 11.0031376,16.0023869 C11.0031376,16.553933 11.450254,17.0010495 12.0018002,17.0010495 C12.5533463,17.0010495 13.0004628,16.553933 13.0004628,16.0023869 C13.0004628,15.4508407 12.5533463,15.0037242 12.0018002,15.0037242 Z M11.99964,7 C11.4868042,7.00018474 11.0642719,7.38637706 11.0066858,7.8837365 L11,8.00036004 L11.0018003,13.0012393 L11.00857,13.117858 C11.0665141,13.6151758 11.4893244,14.0010638 12.0021602,14.0008793 C12.514996,14.0006946 12.9375283,13.6145023 12.9951144,13.1171428 L13.0018002,13.0005193 L13,7.99964009 L12.9932303,7.8830214 C12.9352861,7.38570354 12.5124758,6.99981552 11.99964,7 Z"
})))));
const ChevronDownIcon = /* @__PURE__ */ defineComponent({
  name: "ChevronDown",
  render() {
    return h("svg", {
      viewBox: "0 0 16 16",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, h("path", {
      d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z",
      fill: "currentColor"
    }));
  }
});
const ClearIcon = replaceable("clear", h("svg", {
  viewBox: "0 0 16 16",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, h("g", {
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}, h("g", {
  fill: "currentColor",
  "fill-rule": "nonzero"
}, h("path", {
  d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z"
})))));
const ChevronDownFilledIcon = /* @__PURE__ */ defineComponent({
  name: "ChevronDownFilled",
  render() {
    return h("svg", {
      viewBox: "0 0 16 16",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, h("path", {
      d: "M3.20041 5.73966C3.48226 5.43613 3.95681 5.41856 4.26034 5.70041L8 9.22652L11.7397 5.70041C12.0432 5.41856 12.5177 5.43613 12.7996 5.73966C13.0815 6.0432 13.0639 6.51775 12.7603 6.7996L8.51034 10.7996C8.22258 11.0668 7.77743 11.0668 7.48967 10.7996L3.23966 6.7996C2.93613 6.51775 2.91856 6.0432 3.20041 5.73966Z",
      fill: "currentColor"
    }));
  }
});
const NIconSwitchTransition = /* @__PURE__ */ defineComponent({
  name: "BaseIconSwitchTransition",
  setup(_, {
    slots
  }) {
    const isMountedRef = isMounted();
    return () => h(Transition, {
      name: "icon-switch-transition",
      appear: isMountedRef.value
    }, slots);
  }
});
const NFadeInExpandTransition = /* @__PURE__ */ defineComponent({
  name: "FadeInExpandTransition",
  props: {
    appear: Boolean,
    group: Boolean,
    mode: String,
    onLeave: Function,
    onAfterLeave: Function,
    onAfterEnter: Function,
    width: Boolean,
    // reverse mode is only used in tree
    // it make it from expanded to collapsed after mounted
    reverse: Boolean
  },
  setup(props, {
    slots
  }) {
    function handleBeforeLeave(el) {
      if (props.width) {
        el.style.maxWidth = `${el.offsetWidth}px`;
      } else {
        el.style.maxHeight = `${el.offsetHeight}px`;
      }
      void el.offsetWidth;
    }
    function handleLeave(el) {
      if (props.width) {
        el.style.maxWidth = "0";
      } else {
        el.style.maxHeight = "0";
      }
      void el.offsetWidth;
      const {
        onLeave
      } = props;
      if (onLeave)
        onLeave();
    }
    function handleAfterLeave(el) {
      if (props.width) {
        el.style.maxWidth = "";
      } else {
        el.style.maxHeight = "";
      }
      const {
        onAfterLeave
      } = props;
      if (onAfterLeave)
        onAfterLeave();
    }
    function handleEnter(el) {
      el.style.transition = "none";
      if (props.width) {
        const memorizedWidth = el.offsetWidth;
        el.style.maxWidth = "0";
        void el.offsetWidth;
        el.style.transition = "";
        el.style.maxWidth = `${memorizedWidth}px`;
      } else {
        if (props.reverse) {
          el.style.maxHeight = `${el.offsetHeight}px`;
          void el.offsetHeight;
          el.style.transition = "";
          el.style.maxHeight = "0";
        } else {
          const memorizedHeight = el.offsetHeight;
          el.style.maxHeight = "0";
          void el.offsetWidth;
          el.style.transition = "";
          el.style.maxHeight = `${memorizedHeight}px`;
        }
      }
      void el.offsetWidth;
    }
    function handleAfterEnter(el) {
      var _a;
      if (props.width) {
        el.style.maxWidth = "";
      } else {
        if (!props.reverse) {
          el.style.maxHeight = "";
        }
      }
      (_a = props.onAfterEnter) === null || _a === void 0 ? void 0 : _a.call(props);
    }
    return () => {
      const {
        group,
        width,
        appear,
        mode
      } = props;
      const type4 = group ? TransitionGroup : Transition;
      const resolvedProps = {
        name: width ? "fade-in-width-expand-transition" : "fade-in-height-expand-transition",
        appear,
        onEnter: handleEnter,
        onAfterEnter: handleAfterEnter,
        onBeforeLeave: handleBeforeLeave,
        onLeave: handleLeave,
        onAfterLeave: handleAfterLeave
      };
      if (!group) {
        resolvedProps.mode = mode;
      }
      return h(type4, resolvedProps, slots);
    };
  }
});
const style$p = cB("base-icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [c$1("svg", `
 height: 1em;
 width: 1em;
 `)]);
const NBaseIcon = /* @__PURE__ */ defineComponent({
  name: "BaseIcon",
  props: {
    role: String,
    ariaLabel: String,
    ariaDisabled: {
      type: Boolean,
      default: void 0
    },
    ariaHidden: {
      type: Boolean,
      default: void 0
    },
    clsPrefix: {
      type: String,
      required: true
    },
    onClick: Function,
    onMousedown: Function,
    onMouseup: Function
  },
  setup(props) {
    useStyle("-base-icon", style$p, toRef(props, "clsPrefix"));
  },
  render() {
    return h("i", {
      class: `${this.clsPrefix}-base-icon`,
      onClick: this.onClick,
      onMousedown: this.onMousedown,
      onMouseup: this.onMouseup,
      role: this.role,
      "aria-label": this.ariaLabel,
      "aria-hidden": this.ariaHidden,
      "aria-disabled": this.ariaDisabled
    }, this.$slots);
  }
});
const style$o = cB("base-close", `
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 background-color: transparent;
 color: var(--n-close-icon-color);
 border-radius: var(--n-close-border-radius);
 height: var(--n-close-size);
 width: var(--n-close-size);
 font-size: var(--n-close-icon-size);
 outline: none;
 border: none;
 position: relative;
 padding: 0;
`, [cM("absolute", `
 height: var(--n-close-icon-size);
 width: var(--n-close-icon-size);
 `), c$1("&::before", `
 content: "";
 position: absolute;
 width: var(--n-close-size);
 height: var(--n-close-size);
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 transition: inherit;
 border-radius: inherit;
 `), cNotM("disabled", [c$1("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c$1("&:hover::before", `
 background-color: var(--n-close-color-hover);
 `), c$1("&:focus::before", `
 background-color: var(--n-close-color-hover);
 `), c$1("&:active", `
 color: var(--n-close-icon-color-pressed);
 `), c$1("&:active::before", `
 background-color: var(--n-close-color-pressed);
 `)]), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-close-icon-color-disabled);
 background-color: transparent;
 `), cM("round", [c$1("&::before", `
 border-radius: 50%;
 `)])]);
const NBaseClose = /* @__PURE__ */ defineComponent({
  name: "BaseClose",
  props: {
    isButtonTag: {
      type: Boolean,
      default: true
    },
    clsPrefix: {
      type: String,
      required: true
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    focusable: {
      type: Boolean,
      default: true
    },
    round: Boolean,
    onClick: Function,
    absolute: Boolean
  },
  setup(props) {
    useStyle("-base-close", style$o, toRef(props, "clsPrefix"));
    return () => {
      const {
        clsPrefix,
        disabled,
        absolute,
        round: round2,
        isButtonTag
      } = props;
      const Tag2 = isButtonTag ? "button" : "div";
      return h(Tag2, {
        type: isButtonTag ? "button" : void 0,
        tabindex: disabled || !props.focusable ? -1 : 0,
        "aria-disabled": disabled,
        "aria-label": "close",
        role: isButtonTag ? void 0 : "button",
        disabled,
        class: [`${clsPrefix}-base-close`, absolute && `${clsPrefix}-base-close--absolute`, disabled && `${clsPrefix}-base-close--disabled`, round2 && `${clsPrefix}-base-close--round`],
        onMousedown: (e) => {
          if (!props.focusable) {
            e.preventDefault();
          }
        },
        onClick: props.onClick
      }, h(NBaseIcon, {
        clsPrefix
      }, {
        default: () => h(ErrorIcon$1, null)
      }));
    };
  }
});
const {
  cubicBezierEaseInOut: cubicBezierEaseInOut$4
} = commonVariables$7;
function iconSwitchTransition({
  originalTransform = "",
  left = 0,
  top = 0,
  transition = `all .3s ${cubicBezierEaseInOut$4} !important`
} = {}) {
  return [c$1("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
    transform: `${originalTransform} scale(0.75)`,
    left,
    top,
    opacity: 0
  }), c$1("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
    transform: `scale(1) ${originalTransform}`,
    left,
    top,
    opacity: 1
  }), c$1("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
    transformOrigin: "center",
    position: "absolute",
    left,
    top,
    transition
  })];
}
const style$n = c$1([c$1("@keyframes rotator", `
 0% {
 -webkit-transform: rotate(0deg);
 transform: rotate(0deg);
 }
 100% {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }`), cB("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
  left: "50%",
  top: "50%",
  originalTransform: "translateX(-50%) translateY(-50%)"
})]), cE("container", `
 animation: rotator 3s linear infinite both;
 `, [cE("icon", `
 height: 1em;
 width: 1em;
 `)])])]);
const duration = "1.6s";
const exposedLoadingProps = {
  strokeWidth: {
    type: Number,
    default: 28
  },
  stroke: {
    type: String,
    default: void 0
  }
};
const NBaseLoading = /* @__PURE__ */ defineComponent({
  name: "BaseLoading",
  props: Object.assign({
    clsPrefix: {
      type: String,
      required: true
    },
    show: {
      type: Boolean,
      default: true
    },
    scale: {
      type: Number,
      default: 1
    },
    radius: {
      type: Number,
      default: 100
    }
  }, exposedLoadingProps),
  setup(props) {
    useStyle("-base-loading", style$n, toRef(props, "clsPrefix"));
  },
  render() {
    const {
      clsPrefix,
      radius,
      strokeWidth,
      stroke,
      scale
    } = this;
    const scaledRadius = radius / scale;
    return h("div", {
      class: `${clsPrefix}-base-loading`,
      role: "img",
      "aria-label": "loading"
    }, h(NIconSwitchTransition, null, {
      default: () => this.show ? h("div", {
        key: "icon",
        class: `${clsPrefix}-base-loading__transition-wrapper`
      }, h("div", {
        class: `${clsPrefix}-base-loading__container`
      }, h("svg", {
        class: `${clsPrefix}-base-loading__icon`,
        viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`,
        xmlns: "http://www.w3.org/2000/svg",
        style: {
          color: stroke
        }
      }, h("g", null, h("animateTransform", {
        attributeName: "transform",
        type: "rotate",
        values: `0 ${scaledRadius} ${scaledRadius};270 ${scaledRadius} ${scaledRadius}`,
        begin: "0s",
        dur: duration,
        fill: "freeze",
        repeatCount: "indefinite"
      }), h("circle", {
        class: `${clsPrefix}-base-loading__icon`,
        fill: "none",
        stroke: "currentColor",
        "stroke-width": strokeWidth,
        "stroke-linecap": "round",
        cx: scaledRadius,
        cy: scaledRadius,
        r: radius - strokeWidth / 2,
        "stroke-dasharray": 5.67 * radius,
        "stroke-dashoffset": 18.48 * radius
      }, h("animateTransform", {
        attributeName: "transform",
        type: "rotate",
        values: `0 ${scaledRadius} ${scaledRadius};135 ${scaledRadius} ${scaledRadius};450 ${scaledRadius} ${scaledRadius}`,
        begin: "0s",
        dur: duration,
        fill: "freeze",
        repeatCount: "indefinite"
      }), h("animate", {
        attributeName: "stroke-dashoffset",
        values: `${5.67 * radius};${1.42 * radius};${5.67 * radius}`,
        begin: "0s",
        dur: duration,
        fill: "freeze",
        repeatCount: "indefinite"
      })))))) : h("div", {
        key: "placeholder",
        class: `${clsPrefix}-base-loading__placeholder`
      }, this.$slots)
    }));
  }
});
function toArray(arg) {
  if (Array.isArray(arg))
    return arg;
  return [arg];
}
const TRAVERSE_COMMAND = {
  STOP: "STOP"
};
function traverseWithCb(treeNode, callback) {
  const command = callback(treeNode);
  if (treeNode.children !== void 0 && command !== TRAVERSE_COMMAND.STOP) {
    treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));
  }
}
function getNonLeafKeys(treeNodes, options = {}) {
  const { preserveGroup = false } = options;
  const keys2 = [];
  const cb = preserveGroup ? (node) => {
    if (!node.isLeaf) {
      keys2.push(node.key);
      traverse2(node.children);
    }
  } : (node) => {
    if (!node.isLeaf) {
      if (!node.isGroup)
        keys2.push(node.key);
      traverse2(node.children);
    }
  };
  function traverse2(nodes) {
    nodes.forEach(cb);
  }
  traverse2(treeNodes);
  return keys2;
}
function isLeaf(rawNode, getChildren) {
  const { isLeaf: isLeaf2 } = rawNode;
  if (isLeaf2 !== void 0)
    return isLeaf2;
  else if (!getChildren(rawNode))
    return true;
  return false;
}
function defaultGetChildren(node) {
  return node.children;
}
function defaultGetKey(node) {
  return node.key;
}
function isIgnored() {
  return false;
}
function isShallowLoaded(rawNode, getChildren) {
  const { isLeaf: isLeaf2 } = rawNode;
  if (isLeaf2 === false && !Array.isArray(getChildren(rawNode)))
    return false;
  return true;
}
function isDisabled(rawNode) {
  return rawNode.disabled === true;
}
function isExpilicitlyNotLoaded(rawNode, getChildren) {
  return rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode));
}
function unwrapCheckedKeys(result2) {
  var _a;
  if (result2 === void 0 || result2 === null)
    return [];
  if (Array.isArray(result2))
    return result2;
  return (_a = result2.checkedKeys) !== null && _a !== void 0 ? _a : [];
}
function unwrapIndeterminateKeys(result2) {
  var _a;
  if (result2 === void 0 || result2 === null || Array.isArray(result2)) {
    return [];
  }
  return (_a = result2.indeterminateKeys) !== null && _a !== void 0 ? _a : [];
}
function merge(originalKeys, keysToAdd) {
  const set2 = new Set(originalKeys);
  keysToAdd.forEach((key) => {
    if (!set2.has(key)) {
      set2.add(key);
    }
  });
  return Array.from(set2);
}
function minus(originalKeys, keysToRemove) {
  const set2 = new Set(originalKeys);
  keysToRemove.forEach((key) => {
    if (set2.has(key)) {
      set2.delete(key);
    }
  });
  return Array.from(set2);
}
function isGroup(rawNode) {
  return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === "group";
}
class SubtreeNotLoadedError extends Error {
  constructor() {
    super();
    this.message = "SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.";
  }
}
function getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
  return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);
}
function getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {
  const visitedKeys = /* @__PURE__ */ new Set();
  uncheckedKeys.forEach((uncheckedKey) => {
    const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);
    if (uncheckedTreeNode !== void 0) {
      let nodeCursor = uncheckedTreeNode.parent;
      while (nodeCursor !== null) {
        if (nodeCursor.disabled)
          break;
        if (visitedKeys.has(nodeCursor.key))
          break;
        else {
          visitedKeys.add(nodeCursor.key);
        }
        nodeCursor = nodeCursor.parent;
      }
    }
  });
  return visitedKeys;
}
function getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
  const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);
  const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);
  const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);
  const keysToRemove = [];
  extendedCheckedKeySet.forEach((key) => {
    if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {
      keysToRemove.push(key);
    }
  });
  keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));
  return extendedCheckedKeySet;
}
function getCheckedKeys(options, treeMate) {
  const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;
  if (!cascade) {
    if (keysToCheck !== void 0) {
      return {
        checkedKeys: merge(checkedKeys, keysToCheck),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    } else if (keysToUncheck !== void 0) {
      return {
        checkedKeys: minus(checkedKeys, keysToUncheck),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    } else {
      return {
        checkedKeys: Array.from(checkedKeys),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    }
  }
  const { levelTreeNodeMap } = treeMate;
  let extendedCheckedKeySet;
  if (keysToUncheck !== void 0) {
    extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);
  } else if (keysToCheck !== void 0) {
    extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);
  } else {
    extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);
  }
  const checkStrategyIsParent = checkStrategy === "parent";
  const checkStrategyIsChild = checkStrategy === "child" || leafOnly;
  const syntheticCheckedKeySet = extendedCheckedKeySet;
  const syntheticIndeterminateKeySet = /* @__PURE__ */ new Set();
  const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));
  for (let level = maxLevel; level >= 0; level -= 1) {
    const levelIsZero = level === 0;
    const levelTreeNodes = levelTreeNodeMap.get(level);
    for (const levelTreeNode of levelTreeNodes) {
      if (levelTreeNode.isLeaf)
        continue;
      const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;
      if (checkStrategyIsChild && shallowLoaded) {
        levelTreeNode.children.forEach((v) => {
          if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {
            syntheticCheckedKeySet.delete(v.key);
          }
        });
      }
      if (levelTreeNode.disabled || !shallowLoaded) {
        continue;
      }
      let fullyChecked = true;
      let partialChecked = false;
      let allDisabled = true;
      for (const childNode of levelTreeNode.children) {
        const childKey = childNode.key;
        if (childNode.disabled)
          continue;
        if (allDisabled)
          allDisabled = false;
        if (syntheticCheckedKeySet.has(childKey)) {
          partialChecked = true;
        } else if (syntheticIndeterminateKeySet.has(childKey)) {
          partialChecked = true;
          fullyChecked = false;
          break;
        } else {
          fullyChecked = false;
          if (partialChecked) {
            break;
          }
        }
      }
      if (fullyChecked && !allDisabled) {
        if (checkStrategyIsParent) {
          levelTreeNode.children.forEach((v) => {
            if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {
              syntheticCheckedKeySet.delete(v.key);
            }
          });
        }
        syntheticCheckedKeySet.add(levelTreeNodeKey);
      } else if (partialChecked) {
        syntheticIndeterminateKeySet.add(levelTreeNodeKey);
      }
      if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {
        syntheticCheckedKeySet.delete(levelTreeNodeKey);
      }
    }
  }
  return {
    checkedKeys: Array.from(syntheticCheckedKeySet),
    indeterminateKeys: Array.from(syntheticIndeterminateKeySet)
  };
}
function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {
  const { treeNodeMap, getChildren } = treeMate;
  const visitedKeySet = /* @__PURE__ */ new Set();
  const extendedKeySet = new Set(checkedKeys);
  checkedKeys.forEach((checkedKey) => {
    const checkedTreeNode = treeNodeMap.get(checkedKey);
    if (checkedTreeNode !== void 0) {
      traverseWithCb(checkedTreeNode, (treeNode) => {
        if (treeNode.disabled) {
          return TRAVERSE_COMMAND.STOP;
        }
        const { key } = treeNode;
        if (visitedKeySet.has(key))
          return;
        visitedKeySet.add(key);
        extendedKeySet.add(key);
        if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {
          if (isUnchecking) {
            return TRAVERSE_COMMAND.STOP;
          } else if (!allowNotLoaded) {
            throw new SubtreeNotLoadedError();
          }
        }
      });
    }
  });
  return extendedKeySet;
}
function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {
  var _a;
  const treeNodeMap = treeMate.treeNodeMap;
  let treeNode = key === null || key === void 0 ? null : (_a = treeNodeMap.get(key)) !== null && _a !== void 0 ? _a : null;
  const mergedPath = {
    keyPath: [],
    treeNodePath: [],
    treeNode
  };
  if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {
    mergedPath.treeNode = null;
    return mergedPath;
  }
  while (treeNode) {
    if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {
      mergedPath.treeNodePath.push(treeNode);
    }
    treeNode = treeNode.parent;
  }
  mergedPath.treeNodePath.reverse();
  if (!includeSelf)
    mergedPath.treeNodePath.pop();
  mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode2) => treeNode2.key);
  return mergedPath;
}
function getFirstAvailableNode(nodes) {
  if (nodes.length === 0)
    return null;
  const node = nodes[0];
  if (node.isGroup || node.ignored || node.disabled) {
    return node.getNext();
  }
  return node;
}
function rawGetNext(node, loop) {
  const sibs = node.siblings;
  const l = sibs.length;
  const { index } = node;
  if (loop) {
    return sibs[(index + 1) % l];
  } else {
    if (index === sibs.length - 1)
      return null;
    return sibs[index + 1];
  }
}
function move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {
  const iterate = dir === "prev" ? rawGetPrev : rawGetNext;
  const getChildOptions = {
    reverse: dir === "prev"
  };
  let meet = false;
  let endNode = null;
  function traverse2(node) {
    if (node === null)
      return;
    if (node === fromNode) {
      if (!meet) {
        meet = true;
      } else if (!fromNode.disabled && !fromNode.isGroup) {
        endNode = fromNode;
        return;
      }
    } else {
      if ((!node.disabled || includeDisabled) && !node.ignored && !node.isGroup) {
        endNode = node;
        return;
      }
    }
    if (node.isGroup) {
      const child = getChild(node, getChildOptions);
      if (child !== null) {
        endNode = child;
      } else {
        traverse2(iterate(node, loop));
      }
    } else {
      const nextNode = iterate(node, false);
      if (nextNode !== null) {
        traverse2(nextNode);
      } else {
        const parent2 = rawGetParent(node);
        if (parent2 === null || parent2 === void 0 ? void 0 : parent2.isGroup) {
          traverse2(iterate(parent2, loop));
        } else if (loop) {
          traverse2(iterate(node, true));
        }
      }
    }
  }
  traverse2(fromNode);
  return endNode;
}
function rawGetPrev(node, loop) {
  const sibs = node.siblings;
  const l = sibs.length;
  const { index } = node;
  if (loop) {
    return sibs[(index - 1 + l) % l];
  } else {
    if (index === 0)
      return null;
    return sibs[index - 1];
  }
}
function rawGetParent(node) {
  return node.parent;
}
function getChild(node, options = {}) {
  const { reverse: reverse2 = false } = options;
  const { children } = node;
  if (children) {
    const { length } = children;
    const start = reverse2 ? length - 1 : 0;
    const end = reverse2 ? -1 : length;
    const delta = reverse2 ? -1 : 1;
    for (let i = start; i !== end; i += delta) {
      const child = children[i];
      if (!child.disabled && !child.ignored) {
        if (child.isGroup) {
          const childInGroup = getChild(child, options);
          if (childInGroup !== null)
            return childInGroup;
        } else {
          return child;
        }
      }
    }
  }
  return null;
}
const moveMethods = {
  getChild() {
    if (this.ignored)
      return null;
    return getChild(this);
  },
  getParent() {
    const { parent: parent2 } = this;
    if (parent2 === null || parent2 === void 0 ? void 0 : parent2.isGroup) {
      return parent2.getParent();
    }
    return parent2;
  },
  getNext(options = {}) {
    return move(this, "next", options);
  },
  getPrev(options = {}) {
    return move(this, "prev", options);
  }
};
function flatten(treeNodes, expandedKeys) {
  const expandedKeySet = expandedKeys ? new Set(expandedKeys) : void 0;
  const flattenedNodes = [];
  function traverse2(treeNodes2) {
    treeNodes2.forEach((treeNode) => {
      flattenedNodes.push(treeNode);
      if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)
        return;
      if (treeNode.isGroup) {
        traverse2(treeNode.children);
      } else if (
        // normal non-leaf node
        expandedKeySet === void 0 || expandedKeySet.has(treeNode.key)
      ) {
        traverse2(treeNode.children);
      }
    });
  }
  traverse2(treeNodes);
  return flattenedNodes;
}
function contains(parent2, child) {
  const parentKey = parent2.key;
  while (child) {
    if (child.key === parentKey)
      return true;
    child = child.parent;
  }
  return false;
}
function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent2 = null, level = 0) {
  const treeNodes = [];
  rawNodes.forEach((rawNode, index) => {
    var _a;
    const treeNode = Object.create(nodeProto);
    treeNode.rawNode = rawNode;
    treeNode.siblings = treeNodes;
    treeNode.level = level;
    treeNode.index = index;
    treeNode.isFirstChild = index === 0;
    treeNode.isLastChild = index + 1 === rawNodes.length;
    treeNode.parent = parent2;
    if (!treeNode.ignored) {
      const rawChildren = getChildren(rawNode);
      if (Array.isArray(rawChildren)) {
        treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);
      }
    }
    treeNodes.push(treeNode);
    treeNodeMap.set(treeNode.key, treeNode);
    if (!levelTreeNodeMap.has(level))
      levelTreeNodeMap.set(level, []);
    (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);
  });
  return treeNodes;
}
function createTreeMate(rawNodes, options = {}) {
  var _a;
  const treeNodeMap = /* @__PURE__ */ new Map();
  const levelTreeNodeMap = /* @__PURE__ */ new Map();
  const { getDisabled = isDisabled, getIgnored = isIgnored, getIsGroup = isGroup, getKey = defaultGetKey } = options;
  const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;
  const getChildren = options.ignoreEmptyChildren ? (node) => {
    const children = _getChildren(node);
    if (Array.isArray(children)) {
      if (!children.length)
        return null;
      return children;
    }
    return children;
  } : _getChildren;
  const nodeProto = Object.assign({
    get key() {
      return getKey(this.rawNode);
    },
    get disabled() {
      return getDisabled(this.rawNode);
    },
    get isGroup() {
      return getIsGroup(this.rawNode);
    },
    get isLeaf() {
      return isLeaf(this.rawNode, getChildren);
    },
    get shallowLoaded() {
      return isShallowLoaded(this.rawNode, getChildren);
    },
    get ignored() {
      return getIgnored(this.rawNode);
    },
    contains(node) {
      return contains(this, node);
    }
  }, moveMethods);
  const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);
  function getNode(key) {
    if (key === null || key === void 0)
      return null;
    const tmNode = treeNodeMap.get(key);
    if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
      return tmNode;
    }
    return null;
  }
  function _getNode(key) {
    if (key === null || key === void 0)
      return null;
    const tmNode = treeNodeMap.get(key);
    if (tmNode && !tmNode.ignored) {
      return tmNode;
    }
    return null;
  }
  function getPrev(key, options2) {
    const node = _getNode(key);
    if (!node)
      return null;
    return node.getPrev(options2);
  }
  function getNext(key, options2) {
    const node = _getNode(key);
    if (!node)
      return null;
    return node.getNext(options2);
  }
  function getParent(key) {
    const node = _getNode(key);
    if (!node)
      return null;
    return node.getParent();
  }
  function getChild2(key) {
    const node = _getNode(key);
    if (!node)
      return null;
    return node.getChild();
  }
  const treemate = {
    treeNodes,
    treeNodeMap,
    levelTreeNodeMap,
    maxLevel: Math.max(...levelTreeNodeMap.keys()),
    getChildren,
    getFlattenedNodes(expandedKeys) {
      return flatten(treeNodes, expandedKeys);
    },
    getNode,
    getPrev,
    getNext,
    getParent,
    getChild: getChild2,
    getFirstAvailableNode() {
      return getFirstAvailableNode(treeNodes);
    },
    getPath(key, options2 = {}) {
      return getPath(key, options2, treemate);
    },
    getCheckedKeys(checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    check(keysToCheck, checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        keysToCheck: keysToCheck === void 0 || keysToCheck === null ? [] : toArray(keysToCheck),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    uncheck(keysToUncheck, checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        keysToUncheck: keysToUncheck === null || keysToUncheck === void 0 ? [] : toArray(keysToUncheck),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    getNonLeafKeys(options2 = {}) {
      return getNonLeafKeys(treeNodes, options2);
    }
  };
  return treemate;
}
const base = {
  neutralBase: "#FFF",
  neutralInvertBase: "#000",
  neutralTextBase: "#000",
  neutralPopover: "#fff",
  neutralCard: "#fff",
  neutralModal: "#fff",
  neutralBody: "#fff",
  alpha1: "0.82",
  alpha2: "0.72",
  alpha3: "0.38",
  alpha4: "0.24",
  // disabled text, placeholder, icon
  alpha5: "0.18",
  // disabled placeholder
  alphaClose: "0.6",
  alphaDisabled: "0.5",
  alphaDisabledInput: "0.02",
  alphaPending: "0.05",
  alphaTablePending: "0.02",
  alphaPressed: "0.07",
  alphaAvatar: "0.2",
  alphaRail: "0.14",
  alphaProgressRail: ".08",
  alphaBorder: "0.12",
  alphaDivider: "0.06",
  alphaInput: "0",
  alphaAction: "0.02",
  alphaTab: "0.04",
  alphaScrollbar: "0.25",
  alphaScrollbarHover: "0.4",
  alphaCode: "0.05",
  alphaTag: "0.02",
  // primary
  primaryHover: "#36ad6a",
  primaryDefault: "#18a058",
  primaryActive: "#0c7a43",
  primarySuppl: "#36ad6a",
  // info
  infoHover: "#4098fc",
  infoDefault: "#2080f0",
  infoActive: "#1060c9",
  infoSuppl: "#4098fc",
  // error
  errorHover: "#de576d",
  errorDefault: "#d03050",
  errorActive: "#ab1f3f",
  errorSuppl: "#de576d",
  // warning
  warningHover: "#fcb040",
  warningDefault: "#f0a020",
  warningActive: "#c97c10",
  warningSuppl: "#fcb040",
  // success
  successHover: "#36ad6a",
  successDefault: "#18a058",
  successActive: "#0c7a43",
  successSuppl: "#36ad6a"
};
const baseBackgroundRgb = rgba(base.neutralBase);
const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
const overlayPrefix = `rgba(${baseInvertBackgroundRgb.slice(0, 3).join(", ")}, `;
function overlay(alpha) {
  return `${overlayPrefix + String(alpha)})`;
}
function neutral(alpha) {
  const overlayRgba = Array.from(baseInvertBackgroundRgb);
  overlayRgba[3] = Number(alpha);
  return composite(baseBackgroundRgb, overlayRgba);
}
const derived = Object.assign(Object.assign({
  name: "common"
}, commonVariables$7), {
  baseColor: base.neutralBase,
  // primary color
  primaryColor: base.primaryDefault,
  primaryColorHover: base.primaryHover,
  primaryColorPressed: base.primaryActive,
  primaryColorSuppl: base.primarySuppl,
  // info color
  infoColor: base.infoDefault,
  infoColorHover: base.infoHover,
  infoColorPressed: base.infoActive,
  infoColorSuppl: base.infoSuppl,
  // success color
  successColor: base.successDefault,
  successColorHover: base.successHover,
  successColorPressed: base.successActive,
  successColorSuppl: base.successSuppl,
  // warning color
  warningColor: base.warningDefault,
  warningColorHover: base.warningHover,
  warningColorPressed: base.warningActive,
  warningColorSuppl: base.warningSuppl,
  // error color
  errorColor: base.errorDefault,
  errorColorHover: base.errorHover,
  errorColorPressed: base.errorActive,
  errorColorSuppl: base.errorSuppl,
  // text color
  textColorBase: base.neutralTextBase,
  textColor1: "rgb(31, 34, 37)",
  textColor2: "rgb(51, 54, 57)",
  textColor3: "rgb(118, 124, 130)",
  // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
  // textColor5: neutral(base.alpha5),
  textColorDisabled: neutral(base.alpha4),
  placeholderColor: neutral(base.alpha4),
  placeholderColorDisabled: neutral(base.alpha5),
  iconColor: neutral(base.alpha4),
  iconColorHover: scaleColor(neutral(base.alpha4), {
    lightness: 0.75
  }),
  iconColorPressed: scaleColor(neutral(base.alpha4), {
    lightness: 0.9
  }),
  iconColorDisabled: neutral(base.alpha5),
  opacity1: base.alpha1,
  opacity2: base.alpha2,
  opacity3: base.alpha3,
  opacity4: base.alpha4,
  opacity5: base.alpha5,
  dividerColor: "rgb(239, 239, 245)",
  borderColor: "rgb(224, 224, 230)",
  // close
  closeIconColor: neutral(Number(base.alphaClose)),
  closeIconColorHover: neutral(Number(base.alphaClose)),
  closeIconColorPressed: neutral(Number(base.alphaClose)),
  closeColorHover: "rgba(0, 0, 0, .09)",
  closeColorPressed: "rgba(0, 0, 0, .13)",
  // clear
  clearColor: neutral(base.alpha4),
  clearColorHover: scaleColor(neutral(base.alpha4), {
    lightness: 0.75
  }),
  clearColorPressed: scaleColor(neutral(base.alpha4), {
    lightness: 0.9
  }),
  scrollbarColor: overlay(base.alphaScrollbar),
  scrollbarColorHover: overlay(base.alphaScrollbarHover),
  scrollbarWidth: "5px",
  scrollbarHeight: "5px",
  scrollbarBorderRadius: "5px",
  progressRailColor: neutral(base.alphaProgressRail),
  railColor: "rgb(219, 219, 223)",
  popoverColor: base.neutralPopover,
  tableColor: base.neutralCard,
  cardColor: base.neutralCard,
  modalColor: base.neutralModal,
  bodyColor: base.neutralBody,
  tagColor: "#eee",
  avatarColor: neutral(base.alphaAvatar),
  invertedColor: "rgb(0, 20, 40)",
  inputColor: neutral(base.alphaInput),
  codeColor: "rgb(244, 244, 248)",
  tabColor: "rgb(247, 247, 250)",
  actionColor: "rgb(250, 250, 252)",
  tableHeaderColor: "rgb(250, 250, 252)",
  hoverColor: "rgb(243, 243, 245)",
  // use color with alpha since it can be nested with header filter & sorter effect
  tableColorHover: "rgba(0, 0, 100, 0.03)",
  tableColorStriped: "rgba(0, 0, 100, 0.02)",
  pressedColor: "rgb(237, 237, 239)",
  opacityDisabled: base.alphaDisabled,
  inputColorDisabled: "rgb(250, 250, 252)",
  // secondary button color
  // can also be used in tertiary button & quaternary button
  buttonColor2: "rgba(46, 51, 56, .05)",
  buttonColor2Hover: "rgba(46, 51, 56, .09)",
  buttonColor2Pressed: "rgba(46, 51, 56, .13)",
  boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
  boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
  boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
});
const commonLight = derived;
const commonVars$2 = {
  railInsetHorizontal: "auto 2px 4px 2px",
  railInsetVertical: "2px 4px 2px auto",
  railColor: "transparent"
};
function self$k(vars) {
  const {
    scrollbarColor,
    scrollbarColorHover,
    scrollbarHeight,
    scrollbarWidth,
    scrollbarBorderRadius
  } = vars;
  return Object.assign(Object.assign({}, commonVars$2), {
    height: scrollbarHeight,
    width: scrollbarWidth,
    borderRadius: scrollbarBorderRadius,
    color: scrollbarColor,
    colorHover: scrollbarColorHover
  });
}
const scrollbarLight = {
  name: "Scrollbar",
  common: commonLight,
  self: self$k
};
const scrollbarLight$1 = scrollbarLight;
const {
  cubicBezierEaseInOut: cubicBezierEaseInOut$3
} = commonVariables$7;
function fadeInTransition({
  name = "fade-in",
  enterDuration = "0.2s",
  leaveDuration = "0.2s",
  enterCubicBezier = cubicBezierEaseInOut$3,
  leaveCubicBezier = cubicBezierEaseInOut$3
} = {}) {
  return [c$1(`&.${name}-transition-enter-active`, {
    transition: `all ${enterDuration} ${enterCubicBezier}!important`
  }), c$1(`&.${name}-transition-leave-active`, {
    transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
  }), c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
    opacity: 0
  }), c$1(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
    opacity: 1
  })];
}
const style$m = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c$1(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1(">", [
  // We can't set overflow hidden since it affects positioning.
  cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)
])])]), c$1(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 background: var(--n-scrollbar-rail-color);
 -webkit-user-select: none;
 `, [cM("horizontal", `
 inset: var(--n-scrollbar-rail-inset-horizontal);
 height: var(--n-scrollbar-height);
 `, [c$1(">", [cE("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM("vertical", `
 inset: var(--n-scrollbar-rail-inset-vertical);
 width: var(--n-scrollbar-width);
 `, [c$1(">", [cE("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM("disabled", [c$1(">", [cE("scrollbar", "pointer-events: none;")])]), c$1(">", [cE("scrollbar", `
 z-index: 1;
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c$1("&:hover", "background-color: var(--n-scrollbar-color-hover);")])])])])]);
const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), {
  duration: {
    type: Number,
    default: 0
  },
  scrollable: {
    type: Boolean,
    default: true
  },
  xScrollable: Boolean,
  trigger: {
    type: String,
    default: "hover"
  },
  useUnifiedContainer: Boolean,
  triggerDisplayManually: Boolean,
  // If container is set, resize observer won't not attached
  container: Function,
  content: Function,
  containerClass: String,
  containerStyle: [String, Object],
  contentClass: [String, Array],
  contentStyle: [String, Object],
  horizontalRailStyle: [String, Object],
  verticalRailStyle: [String, Object],
  onScroll: Function,
  onWheel: Function,
  onResize: Function,
  internalOnUpdateScrollLeft: Function,
  internalHoistYRail: Boolean
});
const Scrollbar = /* @__PURE__ */ defineComponent({
  name: "Scrollbar",
  props: scrollbarProps,
  inheritAttrs: false,
  setup(props) {
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled,
      mergedRtlRef
    } = useConfig(props);
    const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
    const wrapperRef = ref(null);
    const containerRef = ref(null);
    const contentRef = ref(null);
    const yRailRef = ref(null);
    const xRailRef = ref(null);
    const contentHeightRef = ref(null);
    const contentWidthRef = ref(null);
    const containerHeightRef = ref(null);
    const containerWidthRef = ref(null);
    const yRailSizeRef = ref(null);
    const xRailSizeRef = ref(null);
    const containerScrollTopRef = ref(0);
    const containerScrollLeftRef = ref(0);
    const isShowXBarRef = ref(false);
    const isShowYBarRef = ref(false);
    let yBarPressed = false;
    let xBarPressed = false;
    let xBarVanishTimerId;
    let yBarVanishTimerId;
    let memoYTop = 0;
    let memoXLeft = 0;
    let memoMouseX = 0;
    let memoMouseY = 0;
    const isIos2 = useIsIos();
    const themeRef = useTheme("Scrollbar", "-scrollbar", style$m, scrollbarLight$1, props, mergedClsPrefixRef);
    const yBarSizeRef = computed(() => {
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      const {
        value: yRailSize
      } = yRailSizeRef;
      if (containerHeight === null || contentHeight === null || yRailSize === null) {
        return 0;
      } else {
        return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + depx(themeRef.value.self.width) * 1.5);
      }
    });
    const yBarSizePxRef = computed(() => {
      return `${yBarSizeRef.value}px`;
    });
    const xBarSizeRef = computed(() => {
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      const {
        value: xRailSize
      } = xRailSizeRef;
      if (containerWidth === null || contentWidth === null || xRailSize === null) {
        return 0;
      } else {
        return xRailSize * containerWidth / contentWidth + depx(themeRef.value.self.height) * 1.5;
      }
    });
    const xBarSizePxRef = computed(() => {
      return `${xBarSizeRef.value}px`;
    });
    const yBarTopRef = computed(() => {
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: containerScrollTop
      } = containerScrollTopRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      const {
        value: yRailSize
      } = yRailSizeRef;
      if (containerHeight === null || contentHeight === null || yRailSize === null) {
        return 0;
      } else {
        const heightDiff = contentHeight - containerHeight;
        if (!heightDiff)
          return 0;
        return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
      }
    });
    const yBarTopPxRef = computed(() => {
      return `${yBarTopRef.value}px`;
    });
    const xBarLeftRef = computed(() => {
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: containerScrollLeft
      } = containerScrollLeftRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      const {
        value: xRailSize
      } = xRailSizeRef;
      if (containerWidth === null || contentWidth === null || xRailSize === null) {
        return 0;
      } else {
        const widthDiff = contentWidth - containerWidth;
        if (!widthDiff)
          return 0;
        return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
      }
    });
    const xBarLeftPxRef = computed(() => {
      return `${xBarLeftRef.value}px`;
    });
    const needYBarRef = computed(() => {
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
    });
    const needXBarRef = computed(() => {
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
    });
    const mergedShowXBarRef = computed(() => {
      const {
        trigger: trigger2
      } = props;
      return trigger2 === "none" || isShowXBarRef.value;
    });
    const mergedShowYBarRef = computed(() => {
      const {
        trigger: trigger2
      } = props;
      return trigger2 === "none" || isShowYBarRef.value;
    });
    const mergedContainerRef = computed(() => {
      const {
        container
      } = props;
      if (container)
        return container();
      return containerRef.value;
    });
    const mergedContentRef = computed(() => {
      const {
        content
      } = props;
      if (content)
        return content();
      return contentRef.value;
    });
    const scrollTo = (options, y) => {
      if (!props.scrollable)
        return;
      if (typeof options === "number") {
        scrollToPosition(options, y !== null && y !== void 0 ? y : 0, 0, false, "auto");
        return;
      }
      const {
        left,
        top,
        index,
        elSize,
        position,
        behavior,
        el,
        debounce: debounce2 = true
      } = options;
      if (left !== void 0 || top !== void 0) {
        scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
      }
      if (el !== void 0) {
        scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce2, behavior);
      } else if (index !== void 0 && elSize !== void 0) {
        scrollToPosition(0, index * elSize, elSize, debounce2, behavior);
      } else if (position === "bottom") {
        scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
      } else if (position === "top") {
        scrollToPosition(0, 0, 0, false, behavior);
      }
    };
    const activateState = useReactivated(() => {
      if (!props.container) {
        scrollTo({
          top: containerScrollTopRef.value,
          left: containerScrollLeftRef.value
        });
      }
    });
    const handleContentResize = () => {
      if (activateState.isDeactivated)
        return;
      sync();
    };
    const handleContainerResize = (e) => {
      if (activateState.isDeactivated)
        return;
      const {
        onResize
      } = props;
      if (onResize)
        onResize(e);
      sync();
    };
    const scrollBy = (options, y) => {
      if (!props.scrollable)
        return;
      const {
        value: container
      } = mergedContainerRef;
      if (!container)
        return;
      if (typeof options === "object") {
        container.scrollBy(options);
      } else {
        container.scrollBy(options, y || 0);
      }
    };
    function scrollToPosition(left, top, elSize, debounce2, behavior) {
      const {
        value: container
      } = mergedContainerRef;
      if (!container)
        return;
      if (debounce2) {
        const {
          scrollTop,
          offsetHeight
        } = container;
        if (top > scrollTop) {
          if (top + elSize <= scrollTop + offsetHeight)
            ;
          else {
            container.scrollTo({
              left,
              top: top + elSize - offsetHeight,
              behavior
            });
          }
          return;
        }
      }
      container.scrollTo({
        left,
        top,
        behavior
      });
    }
    function handleMouseEnterWrapper() {
      showXBar();
      showYBar();
      sync();
    }
    function handleMouseLeaveWrapper() {
      hideBar();
    }
    function hideBar() {
      hideYBar();
      hideXBar();
    }
    function hideYBar() {
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      yBarVanishTimerId = window.setTimeout(() => {
        isShowYBarRef.value = false;
      }, props.duration);
    }
    function hideXBar() {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      xBarVanishTimerId = window.setTimeout(() => {
        isShowXBarRef.value = false;
      }, props.duration);
    }
    function showXBar() {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      isShowXBarRef.value = true;
    }
    function showYBar() {
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      isShowYBarRef.value = true;
    }
    function handleScroll(e) {
      const {
        onScroll
      } = props;
      if (onScroll)
        onScroll(e);
      syncScrollState();
    }
    function syncScrollState() {
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        containerScrollTopRef.value = container.scrollTop;
        containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
      }
    }
    function syncPositionState() {
      const {
        value: content
      } = mergedContentRef;
      if (content) {
        contentHeightRef.value = content.offsetHeight;
        contentWidthRef.value = content.offsetWidth;
      }
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        containerHeightRef.value = container.offsetHeight;
        containerWidthRef.value = container.offsetWidth;
      }
      const {
        value: xRailEl
      } = xRailRef;
      const {
        value: yRailEl
      } = yRailRef;
      if (xRailEl) {
        xRailSizeRef.value = xRailEl.offsetWidth;
      }
      if (yRailEl) {
        yRailSizeRef.value = yRailEl.offsetHeight;
      }
    }
    function syncUnifiedContainer() {
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        containerScrollTopRef.value = container.scrollTop;
        containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
        containerHeightRef.value = container.offsetHeight;
        containerWidthRef.value = container.offsetWidth;
        contentHeightRef.value = container.scrollHeight;
        contentWidthRef.value = container.scrollWidth;
      }
      const {
        value: xRailEl
      } = xRailRef;
      const {
        value: yRailEl
      } = yRailRef;
      if (xRailEl) {
        xRailSizeRef.value = xRailEl.offsetWidth;
      }
      if (yRailEl) {
        yRailSizeRef.value = yRailEl.offsetHeight;
      }
    }
    function sync() {
      if (!props.scrollable)
        return;
      if (props.useUnifiedContainer) {
        syncUnifiedContainer();
      } else {
        syncPositionState();
        syncScrollState();
      }
    }
    function isMouseUpAway(e) {
      var _a;
      return !((_a = wrapperRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)));
    }
    function handleXScrollMouseDown(e) {
      e.preventDefault();
      e.stopPropagation();
      xBarPressed = true;
      on("mousemove", window, handleXScrollMouseMove, true);
      on("mouseup", window, handleXScrollMouseUp, true);
      memoXLeft = containerScrollLeftRef.value;
      memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
    }
    function handleXScrollMouseMove(e) {
      if (!xBarPressed)
        return;
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      const {
        value: xBarSize
      } = xBarSizeRef;
      if (containerWidth === null || contentWidth === null)
        return;
      const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
      const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
      const toScrollLeftUpperBound = contentWidth - containerWidth;
      let toScrollLeft = memoXLeft + dScrollLeft;
      toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
      toScrollLeft = Math.max(toScrollLeft, 0);
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
        const {
          internalOnUpdateScrollLeft
        } = props;
        if (internalOnUpdateScrollLeft)
          internalOnUpdateScrollLeft(toScrollLeft);
      }
    }
    function handleXScrollMouseUp(e) {
      e.preventDefault();
      e.stopPropagation();
      off("mousemove", window, handleXScrollMouseMove, true);
      off("mouseup", window, handleXScrollMouseUp, true);
      xBarPressed = false;
      sync();
      if (isMouseUpAway(e)) {
        hideBar();
      }
    }
    function handleYScrollMouseDown(e) {
      e.preventDefault();
      e.stopPropagation();
      yBarPressed = true;
      on("mousemove", window, handleYScrollMouseMove, true);
      on("mouseup", window, handleYScrollMouseUp, true);
      memoYTop = containerScrollTopRef.value;
      memoMouseY = e.clientY;
    }
    function handleYScrollMouseMove(e) {
      if (!yBarPressed)
        return;
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      const {
        value: yBarSize
      } = yBarSizeRef;
      if (containerHeight === null || contentHeight === null)
        return;
      const dY = e.clientY - memoMouseY;
      const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
      const toScrollTopUpperBound = contentHeight - containerHeight;
      let toScrollTop = memoYTop + dScrollTop;
      toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
      toScrollTop = Math.max(toScrollTop, 0);
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        container.scrollTop = toScrollTop;
      }
    }
    function handleYScrollMouseUp(e) {
      e.preventDefault();
      e.stopPropagation();
      off("mousemove", window, handleYScrollMouseMove, true);
      off("mouseup", window, handleYScrollMouseUp, true);
      yBarPressed = false;
      sync();
      if (isMouseUpAway(e)) {
        hideBar();
      }
    }
    watchEffect(() => {
      const {
        value: needXBar
      } = needXBarRef;
      const {
        value: needYBar
      } = needYBarRef;
      const {
        value: mergedClsPrefix
      } = mergedClsPrefixRef;
      const {
        value: xRailEl
      } = xRailRef;
      const {
        value: yRailEl
      } = yRailRef;
      if (xRailEl) {
        if (!needXBar) {
          xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        } else {
          xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        }
      }
      if (yRailEl) {
        if (!needYBar) {
          yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        } else {
          yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        }
      }
    });
    onMounted(() => {
      if (props.container)
        return;
      sync();
    });
    onBeforeUnmount(() => {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      off("mousemove", window, handleYScrollMouseMove, true);
      off("mouseup", window, handleYScrollMouseUp, true);
    });
    const cssVarsRef = computed(() => {
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: {
          color,
          colorHover,
          height,
          width,
          borderRadius,
          railInsetHorizontal,
          railInsetVertical,
          railColor
        }
      } = themeRef.value;
      return {
        "--n-scrollbar-bezier": cubicBezierEaseInOut2,
        "--n-scrollbar-color": color,
        "--n-scrollbar-color-hover": colorHover,
        "--n-scrollbar-border-radius": borderRadius,
        "--n-scrollbar-width": width,
        "--n-scrollbar-height": height,
        "--n-scrollbar-rail-inset-horizontal": railInsetHorizontal,
        "--n-scrollbar-rail-inset-vertical": (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVertical) : railInsetVertical,
        "--n-scrollbar-rail-color": railColor
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
    const exposedMethods = {
      scrollTo,
      scrollBy,
      sync,
      syncUnifiedContainer,
      handleMouseEnterWrapper,
      handleMouseLeaveWrapper
    };
    return Object.assign(Object.assign({}, exposedMethods), {
      mergedClsPrefix: mergedClsPrefixRef,
      rtlEnabled: rtlEnabledRef,
      containerScrollTop: containerScrollTopRef,
      wrapperRef,
      containerRef,
      contentRef,
      yRailRef,
      xRailRef,
      needYBar: needYBarRef,
      needXBar: needXBarRef,
      yBarSizePx: yBarSizePxRef,
      xBarSizePx: xBarSizePxRef,
      yBarTopPx: yBarTopPxRef,
      xBarLeftPx: xBarLeftPxRef,
      isShowXBar: mergedShowXBarRef,
      isShowYBar: mergedShowYBarRef,
      isIos: isIos2,
      handleScroll,
      handleContentResize,
      handleContainerResize,
      handleYScrollMouseDown,
      handleXScrollMouseDown,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    });
  },
  render() {
    var _a;
    const {
      $slots,
      mergedClsPrefix,
      triggerDisplayManually,
      rtlEnabled,
      internalHoistYRail
    } = this;
    if (!this.scrollable)
      return (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots);
    const triggerIsNone = this.trigger === "none";
    const createYRail = (className, style2) => {
      return h("div", {
        ref: "yRailRef",
        class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--vertical`, className],
        "data-scrollbar-rail": true,
        style: [style2 || "", this.verticalRailStyle],
        "aria-hidden": true
      }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : {
        name: "fade-in-transition"
      }, {
        default: () => this.needYBar && this.isShowYBar && !this.isIos ? h("div", {
          class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
          style: {
            height: this.yBarSizePx,
            top: this.yBarTopPx
          },
          onMousedown: this.handleYScrollMouseDown
        }) : null
      }));
    };
    const createChildren = () => {
      var _a2, _b;
      (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
      return h("div", mergeProps(this.$attrs, {
        role: "none",
        ref: "wrapperRef",
        class: [`${mergedClsPrefix}-scrollbar`, this.themeClass, rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`],
        style: this.cssVars,
        onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
        onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
      }), [this.container ? (_b = $slots.default) === null || _b === void 0 ? void 0 : _b.call($slots) : h("div", {
        role: "none",
        ref: "containerRef",
        class: [`${mergedClsPrefix}-scrollbar-container`, this.containerClass],
        style: this.containerStyle,
        onScroll: this.handleScroll,
        onWheel: this.onWheel
      }, h(VResizeObserver, {
        onResize: this.handleContentResize
      }, {
        default: () => h("div", {
          ref: "contentRef",
          role: "none",
          style: [{
            width: this.xScrollable ? "fit-content" : null
          }, this.contentStyle],
          class: [`${mergedClsPrefix}-scrollbar-content`, this.contentClass]
        }, $slots)
      })), internalHoistYRail ? null : createYRail(void 0, void 0), this.xScrollable && h("div", {
        ref: "xRailRef",
        class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--horizontal`],
        style: this.horizontalRailStyle,
        "data-scrollbar-rail": true,
        "aria-hidden": true
      }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : {
        name: "fade-in-transition"
      }, {
        default: () => this.needXBar && this.isShowXBar && !this.isIos ? h("div", {
          class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
          style: {
            width: this.xBarSizePx,
            right: rtlEnabled ? this.xBarLeftPx : void 0,
            left: rtlEnabled ? void 0 : this.xBarLeftPx
          },
          onMousedown: this.handleXScrollMouseDown
        }) : null
      }))]);
    };
    const scrollbarNode = this.container ? createChildren() : h(VResizeObserver, {
      onResize: this.handleContainerResize
    }, {
      default: createChildren
    });
    if (internalHoistYRail) {
      return h(Fragment, null, scrollbarNode, createYRail(this.themeClass, this.cssVars));
    } else {
      return scrollbarNode;
    }
  }
});
const NScrollbar = Scrollbar;
const XScrollbar = Scrollbar;
const {
  cubicBezierEaseIn: cubicBezierEaseIn$1,
  cubicBezierEaseOut: cubicBezierEaseOut$1
} = commonVariables$7;
function fadeInScaleUpTransition({
  transformOrigin = "inherit",
  duration: duration2 = ".2s",
  enterScale = ".9",
  originalTransform = "",
  originalTransition = ""
} = {}) {
  return [c$1("&.fade-in-scale-up-transition-leave-active", {
    transformOrigin,
    transition: `opacity ${duration2} ${cubicBezierEaseIn$1}, transform ${duration2} ${cubicBezierEaseIn$1} ${originalTransition && `,${originalTransition}`}`
  }), c$1("&.fade-in-scale-up-transition-enter-active", {
    transformOrigin,
    transition: `opacity ${duration2} ${cubicBezierEaseOut$1}, transform ${duration2} ${cubicBezierEaseOut$1} ${originalTransition && `,${originalTransition}`}`
  }), c$1("&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to", {
    opacity: 0,
    transform: `${originalTransform} scale(${enterScale})`
  }), c$1("&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to", {
    opacity: 1,
    transform: `${originalTransform} scale(1)`
  })];
}
const style$l = cB("base-wave", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`);
const NBaseWave = /* @__PURE__ */ defineComponent({
  name: "BaseWave",
  props: {
    clsPrefix: {
      type: String,
      required: true
    }
  },
  setup(props) {
    useStyle("-base-wave", style$l, toRef(props, "clsPrefix"));
    const selfRef = ref(null);
    const activeRef = ref(false);
    let animationTimerId = null;
    onBeforeUnmount(() => {
      if (animationTimerId !== null) {
        window.clearTimeout(animationTimerId);
      }
    });
    return {
      active: activeRef,
      selfRef,
      play() {
        if (animationTimerId !== null) {
          window.clearTimeout(animationTimerId);
          activeRef.value = false;
          animationTimerId = null;
        }
        void nextTick(() => {
          var _a;
          void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight);
          activeRef.value = true;
          animationTimerId = window.setTimeout(() => {
            activeRef.value = false;
            animationTimerId = null;
          }, 1e3);
        });
      }
    };
  },
  render() {
    const {
      clsPrefix
    } = this;
    return h("div", {
      ref: "selfRef",
      "aria-hidden": true,
      class: [`${clsPrefix}-base-wave`, this.active && `${clsPrefix}-base-wave--active`]
    });
  }
});
const commonVariables$6 = {
  space: "6px",
  spaceArrow: "10px",
  arrowOffset: "10px",
  arrowOffsetVertical: "10px",
  arrowHeight: "6px",
  padding: "8px 14px"
};
function self$j(vars) {
  const {
    boxShadow2,
    popoverColor,
    textColor2,
    borderRadius,
    fontSize: fontSize2,
    dividerColor
  } = vars;
  return Object.assign(Object.assign({}, commonVariables$6), {
    fontSize: fontSize2,
    borderRadius,
    color: popoverColor,
    dividerColor,
    textColor: textColor2,
    boxShadow: boxShadow2
  });
}
const popoverLight = {
  name: "Popover",
  common: commonLight,
  self: self$j
};
const popoverLight$1 = popoverLight;
const oppositePlacement = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
const arrowSize = "var(--n-arrow-height) * 1.414";
const style$k = c$1([cB("popover", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 box-shadow: var(--n-box-shadow);
 word-break: break-word;
 `, [c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("raw", `
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 `, [cNotM("scrollable", [cNotM("show-header-or-footer", "padding: var(--n-padding);")])]), cE("header", `
 padding: var(--n-padding);
 border-bottom: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cE("footer", `
 padding: var(--n-padding);
 border-top: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cM("scrollable, show-header-or-footer", [cE("content", `
 padding: var(--n-padding);
 `)])]), cB("popover-shared", `
 transform-origin: inherit;
 `, [
  cB("popover-arrow-wrapper", `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [cB("popover-arrow", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 display: block;
 width: calc(${arrowSize});
 height: calc(${arrowSize});
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--n-color);
 pointer-events: all;
 `)]),
  // body transition
  c$1("&.popover-transition-enter-from, &.popover-transition-leave-to", `
 opacity: 0;
 transform: scale(.85);
 `),
  c$1("&.popover-transition-enter-to, &.popover-transition-leave-from", `
 transform: scale(1);
 opacity: 1;
 `),
  c$1("&.popover-transition-enter-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-out),
 transform .15s var(--n-bezier-ease-out);
 `),
  c$1("&.popover-transition-leave-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-in),
 transform .15s var(--n-bezier-ease-in);
 `)
]), placementStyle("top-start", `
 top: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("top-start")} - var(--v-offset-left));
 `), placementStyle("top", `
 top: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("top-end", `
 top: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("top-end")} + var(--v-offset-left));
 `), placementStyle("bottom-start", `
 bottom: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("bottom-start")} - var(--v-offset-left));
 `), placementStyle("bottom", `
 bottom: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("bottom-end", `
 bottom: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("bottom-end")} + var(--v-offset-left));
 `), placementStyle("left-start", `
 left: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("left-start")} - var(--v-offset-top));
 `), placementStyle("left", `
 left: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("left-end", `
 left: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("left-end")} + var(--v-offset-top));
 `), placementStyle("right-start", `
 right: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("right-start")} - var(--v-offset-top));
 `), placementStyle("right", `
 right: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("right-end", `
 right: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("right-end")} + var(--v-offset-top));
 `), ...map({
  top: ["right-start", "left-start"],
  right: ["top-end", "bottom-end"],
  bottom: ["right-end", "left-end"],
  left: ["top-start", "bottom-start"]
}, (placements, direction) => {
  const isVertical = ["right", "left"].includes(direction);
  const sizeType = isVertical ? "width" : "height";
  return placements.map((placement) => {
    const isReverse = placement.split("-")[1] === "end";
    const targetSize = `var(--v-target-${sizeType}, 0px)`;
    const centerOffset = `calc((${targetSize} - ${arrowSize}) / 2)`;
    const offset = getArrowOffset(placement);
    return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", [cM("center-arrow", [cB("popover-arrow", `${direction}: calc(max(${centerOffset}, ${offset}) ${isReverse ? "+" : "-"} var(--v-offset-${isVertical ? "left" : "top"}));`)])])]);
  });
})]);
function getArrowOffset(placement) {
  return ["top", "bottom"].includes(placement.split("-")[0]) ? "var(--n-arrow-offset)" : "var(--n-arrow-offset-vertical)";
}
function placementStyle(placement, arrowStyleLiteral) {
  const position = placement.split("-")[0];
  const sizeStyle = ["top", "bottom"].includes(position) ? "height: var(--n-space-arrow);" : "width: var(--n-space-arrow);";
  return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", `
 margin-${oppositePlacement[position]}: var(--n-space);
 `, [cM("show-arrow", `
 margin-${oppositePlacement[position]}: var(--n-space-arrow);
 `), cM("overlap", `
 margin: 0;
 `), cCB("popover-arrow-wrapper", `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${position}: 100%;
 ${oppositePlacement[position]}: auto;
 ${sizeStyle}
 `, [cB("popover-arrow", arrowStyleLiteral)])])]);
}
const popoverBodyProps = Object.assign(Object.assign({}, useTheme.props), {
  to: useAdjustedTo.propTo,
  show: Boolean,
  trigger: String,
  showArrow: Boolean,
  delay: Number,
  duration: Number,
  raw: Boolean,
  arrowPointToCenter: Boolean,
  arrowClass: String,
  arrowStyle: [String, Object],
  arrowWrapperClass: String,
  arrowWrapperStyle: [String, Object],
  displayDirective: String,
  x: Number,
  y: Number,
  flip: Boolean,
  overlap: Boolean,
  placement: String,
  width: [Number, String],
  keepAliveOnHover: Boolean,
  scrollable: Boolean,
  contentClass: String,
  contentStyle: [Object, String],
  headerClass: String,
  headerStyle: [Object, String],
  footerClass: String,
  footerStyle: [Object, String],
  // private
  internalDeactivateImmediately: Boolean,
  animated: Boolean,
  onClickoutside: Function,
  internalTrapFocus: Boolean,
  internalOnAfterLeave: Function,
  // deprecated
  minWidth: Number,
  maxWidth: Number
});
function renderArrow({
  arrowClass,
  arrowStyle,
  arrowWrapperClass,
  arrowWrapperStyle,
  clsPrefix
}) {
  return h("div", {
    key: "__popover-arrow__",
    style: arrowWrapperStyle,
    class: [`${clsPrefix}-popover-arrow-wrapper`, arrowWrapperClass]
  }, h("div", {
    class: [`${clsPrefix}-popover-arrow`, arrowClass],
    style: arrowStyle
  }));
}
const NPopoverBody = /* @__PURE__ */ defineComponent({
  name: "PopoverBody",
  inheritAttrs: false,
  props: popoverBodyProps,
  setup(props, {
    slots,
    attrs
  }) {
    const {
      namespaceRef,
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Popover", "-popover", style$k, popoverLight$1, props, mergedClsPrefixRef);
    const followerRef = ref(null);
    const NPopover2 = inject("NPopover");
    const bodyRef = ref(null);
    const followerEnabledRef = ref(props.show);
    const displayedRef = ref(false);
    watchEffect(() => {
      const {
        show
      } = props;
      if (show && !isJsdom() && !props.internalDeactivateImmediately) {
        displayedRef.value = true;
      }
    });
    const directivesRef = computed(() => {
      const {
        trigger: trigger2,
        onClickoutside
      } = props;
      const directives = [];
      const {
        positionManuallyRef: {
          value: positionManually
        }
      } = NPopover2;
      if (!positionManually) {
        if (trigger2 === "click" && !onClickoutside) {
          directives.push([clickoutside$1, handleClickOutside, void 0, {
            capture: true
          }]);
        }
        if (trigger2 === "hover") {
          directives.push([mousemoveoutside$1, handleMouseMoveOutside]);
        }
      }
      if (onClickoutside) {
        directives.push([clickoutside$1, handleClickOutside, void 0, {
          capture: true
        }]);
      }
      if (props.displayDirective === "show" || props.animated && displayedRef.value) {
        directives.push([vShow, props.show]);
      }
      return directives;
    });
    const cssVarsRef = computed(() => {
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2,
          cubicBezierEaseIn: cubicBezierEaseIn2,
          cubicBezierEaseOut: cubicBezierEaseOut2
        },
        self: {
          space,
          spaceArrow,
          padding,
          fontSize: fontSize2,
          textColor,
          dividerColor,
          color,
          boxShadow,
          borderRadius,
          arrowHeight,
          arrowOffset,
          arrowOffsetVertical
        }
      } = themeRef.value;
      return {
        "--n-box-shadow": boxShadow,
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-bezier-ease-in": cubicBezierEaseIn2,
        "--n-bezier-ease-out": cubicBezierEaseOut2,
        "--n-font-size": fontSize2,
        "--n-text-color": textColor,
        "--n-color": color,
        "--n-divider-color": dividerColor,
        "--n-border-radius": borderRadius,
        "--n-arrow-height": arrowHeight,
        "--n-arrow-offset": arrowOffset,
        "--n-arrow-offset-vertical": arrowOffsetVertical,
        "--n-padding": padding,
        "--n-space": space,
        "--n-space-arrow": spaceArrow
      };
    });
    const styleRef = computed(() => {
      const width = props.width === "trigger" ? void 0 : formatLength(props.width);
      const style2 = [];
      if (width) {
        style2.push({
          width
        });
      }
      const {
        maxWidth,
        minWidth
      } = props;
      if (maxWidth) {
        style2.push({
          maxWidth: formatLength(maxWidth)
        });
      }
      if (minWidth) {
        style2.push({
          maxWidth: formatLength(minWidth)
        });
      }
      if (!inlineThemeDisabled) {
        style2.push(cssVarsRef.value);
      }
      return style2;
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("popover", void 0, cssVarsRef, props) : void 0;
    NPopover2.setBodyInstance({
      syncPosition
    });
    onBeforeUnmount(() => {
      NPopover2.setBodyInstance(null);
    });
    watch(toRef(props, "show"), (value) => {
      if (props.animated)
        return;
      if (value) {
        followerEnabledRef.value = true;
      } else {
        followerEnabledRef.value = false;
      }
    });
    function syncPosition() {
      var _a;
      (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
    }
    function handleMouseEnter(e) {
      if (props.trigger === "hover" && props.keepAliveOnHover && props.show) {
        NPopover2.handleMouseEnter(e);
      }
    }
    function handleMouseLeave(e) {
      if (props.trigger === "hover" && props.keepAliveOnHover) {
        NPopover2.handleMouseLeave(e);
      }
    }
    function handleMouseMoveOutside(e) {
      if (props.trigger === "hover" && !getTriggerElement().contains(getPreciseEventTarget(e))) {
        NPopover2.handleMouseMoveOutside(e);
      }
    }
    function handleClickOutside(e) {
      if (props.trigger === "click" && !getTriggerElement().contains(getPreciseEventTarget(e)) || props.onClickoutside) {
        NPopover2.handleClickOutside(e);
      }
    }
    function getTriggerElement() {
      return NPopover2.getTriggerElement();
    }
    provide(popoverBodyInjectionKey, bodyRef);
    provide(drawerBodyInjectionKey, null);
    provide(modalBodyInjectionKey, null);
    function renderContentNode() {
      themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
      const shouldRenderDom = props.displayDirective === "show" || props.show || props.animated && displayedRef.value;
      if (!shouldRenderDom) {
        return null;
      }
      let contentNode;
      const renderBody = NPopover2.internalRenderBodyRef.value;
      const {
        value: mergedClsPrefix
      } = mergedClsPrefixRef;
      if (!renderBody) {
        const {
          value: extraClass
        } = NPopover2.extraClassRef;
        const {
          internalTrapFocus
        } = props;
        const hasHeaderOrFooter = !isSlotEmpty(slots.header) || !isSlotEmpty(slots.footer);
        const renderContentInnerNode = () => {
          var _a, _b;
          const body = hasHeaderOrFooter ? h(Fragment, null, resolveWrappedSlot(slots.header, (children) => {
            return children ? h("div", {
              class: [`${mergedClsPrefix}-popover__header`, props.headerClass],
              style: props.headerStyle
            }, children) : null;
          }), resolveWrappedSlot(slots.default, (children) => {
            return children ? h("div", {
              class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
              style: props.contentStyle
            }, slots) : null;
          }), resolveWrappedSlot(slots.footer, (children) => {
            return children ? h("div", {
              class: [`${mergedClsPrefix}-popover__footer`, props.footerClass],
              style: props.footerStyle
            }, children) : null;
          })) : props.scrollable ? (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots) : h("div", {
            class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
            style: props.contentStyle
          }, slots);
          const maybeScrollableBody = props.scrollable ? h(XScrollbar, {
            contentClass: hasHeaderOrFooter ? void 0 : `${mergedClsPrefix}-popover__content ${(_b = props.contentClass) !== null && _b !== void 0 ? _b : ""}`,
            contentStyle: hasHeaderOrFooter ? void 0 : props.contentStyle
          }, {
            default: () => body
          }) : body;
          const arrow = props.showArrow ? renderArrow({
            arrowClass: props.arrowClass,
            arrowStyle: props.arrowStyle,
            arrowWrapperClass: props.arrowWrapperClass,
            arrowWrapperStyle: props.arrowWrapperStyle,
            clsPrefix: mergedClsPrefix
          }) : null;
          return [maybeScrollableBody, arrow];
        };
        contentNode = h("div", mergeProps({
          class: [`${mergedClsPrefix}-popover`, `${mergedClsPrefix}-popover-shared`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, extraClass.map((v) => `${mergedClsPrefix}-${v}`), {
            [`${mergedClsPrefix}-popover--scrollable`]: props.scrollable,
            [`${mergedClsPrefix}-popover--show-header-or-footer`]: hasHeaderOrFooter,
            [`${mergedClsPrefix}-popover--raw`]: props.raw,
            [`${mergedClsPrefix}-popover-shared--overlap`]: props.overlap,
            [`${mergedClsPrefix}-popover-shared--show-arrow`]: props.showArrow,
            [`${mergedClsPrefix}-popover-shared--center-arrow`]: props.arrowPointToCenter
          }],
          ref: bodyRef,
          style: styleRef.value,
          onKeydown: NPopover2.handleKeydown,
          onMouseenter: handleMouseEnter,
          onMouseleave: handleMouseLeave
        }, attrs), internalTrapFocus ? h(FocusTrap, {
          active: props.show,
          autoFocus: true
        }, {
          default: renderContentInnerNode
        }) : renderContentInnerNode());
      } else {
        contentNode = renderBody(
          // The popover class and overlap class must exists, they will be used
          // to place the body & transition animation.
          // Shadow class exists for reuse box-shadow.
          [`${mergedClsPrefix}-popover-shared`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, props.overlap && `${mergedClsPrefix}-popover-shared--overlap`, props.showArrow && `${mergedClsPrefix}-popover-shared--show-arrow`, props.arrowPointToCenter && `${mergedClsPrefix}-popover-shared--center-arrow`],
          bodyRef,
          styleRef.value,
          handleMouseEnter,
          handleMouseLeave
        );
      }
      return withDirectives(contentNode, directivesRef.value);
    }
    return {
      displayed: displayedRef,
      namespace: namespaceRef,
      isMounted: NPopover2.isMountedRef,
      zIndex: NPopover2.zIndexRef,
      followerRef,
      adjustedTo: useAdjustedTo(props),
      followerEnabled: followerEnabledRef,
      renderContentNode
    };
  },
  render() {
    return h(VFollower, {
      ref: "followerRef",
      zIndex: this.zIndex,
      show: this.show,
      enabled: this.followerEnabled,
      to: this.adjustedTo,
      x: this.x,
      y: this.y,
      flip: this.flip,
      placement: this.placement,
      containerClass: this.namespace,
      overlap: this.overlap,
      width: this.width === "trigger" ? "target" : void 0,
      teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
    }, {
      default: () => {
        return this.animated ? h(Transition, {
          name: "popover-transition",
          appear: this.isMounted,
          // Don't use watch to enable follower, since the transition may
          // make position sync timing very subtle and buggy.
          onEnter: () => {
            this.followerEnabled = true;
          },
          onAfterLeave: () => {
            var _a;
            (_a = this.internalOnAfterLeave) === null || _a === void 0 ? void 0 : _a.call(this);
            this.followerEnabled = false;
            this.displayed = false;
          }
        }, {
          default: this.renderContentNode
        }) : this.renderContentNode();
      }
    });
  }
});
const bodyPropKeys = Object.keys(popoverBodyProps);
const triggerEventMap = {
  focus: ["onFocus", "onBlur"],
  click: ["onClick"],
  hover: ["onMouseenter", "onMouseleave"],
  manual: [],
  nested: ["onFocus", "onBlur", "onMouseenter", "onMouseleave", "onClick"]
};
function appendEvents(vNode, trigger2, events2) {
  triggerEventMap[trigger2].forEach((eventName) => {
    if (!vNode.props) {
      vNode.props = {};
    } else {
      vNode.props = Object.assign({}, vNode.props);
    }
    const originalHandler = vNode.props[eventName];
    const handler = events2[eventName];
    if (!originalHandler) {
      vNode.props[eventName] = handler;
    } else {
      vNode.props[eventName] = (...args) => {
        originalHandler(...args);
        handler(...args);
      };
    }
  });
}
const popoverBaseProps = {
  show: {
    type: Boolean,
    default: void 0
  },
  defaultShow: Boolean,
  showArrow: {
    type: Boolean,
    default: true
  },
  trigger: {
    type: String,
    default: "hover"
  },
  delay: {
    type: Number,
    default: 100
  },
  duration: {
    type: Number,
    default: 100
  },
  raw: Boolean,
  placement: {
    type: String,
    default: "top"
  },
  x: Number,
  y: Number,
  arrowPointToCenter: Boolean,
  disabled: Boolean,
  getDisabled: Function,
  displayDirective: {
    type: String,
    default: "if"
  },
  arrowClass: String,
  arrowStyle: [String, Object],
  arrowWrapperClass: String,
  arrowWrapperStyle: [String, Object],
  flip: {
    type: Boolean,
    default: true
  },
  animated: {
    type: Boolean,
    default: true
  },
  width: {
    type: [Number, String],
    default: void 0
  },
  overlap: Boolean,
  keepAliveOnHover: {
    type: Boolean,
    default: true
  },
  zIndex: Number,
  to: useAdjustedTo.propTo,
  scrollable: Boolean,
  contentClass: String,
  contentStyle: [Object, String],
  headerClass: String,
  headerStyle: [Object, String],
  footerClass: String,
  footerStyle: [Object, String],
  // events
  onClickoutside: Function,
  "onUpdate:show": [Function, Array],
  onUpdateShow: [Function, Array],
  // internal
  internalDeactivateImmediately: Boolean,
  internalSyncTargetWithParent: Boolean,
  internalInheritedEventHandlers: {
    type: Array,
    default: () => []
  },
  internalTrapFocus: Boolean,
  internalExtraClass: {
    type: Array,
    default: () => []
  },
  // deprecated
  onShow: [Function, Array],
  onHide: [Function, Array],
  arrow: {
    type: Boolean,
    default: void 0
  },
  minWidth: Number,
  maxWidth: Number
};
const popoverProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), {
  internalOnAfterLeave: Function,
  internalRenderBody: Function
});
const NPopover = /* @__PURE__ */ defineComponent({
  name: "Popover",
  inheritAttrs: false,
  props: popoverProps,
  __popover__: true,
  setup(props) {
    const isMountedRef = isMounted();
    const binderInstRef = ref(null);
    const controlledShowRef = computed(() => props.show);
    const uncontrolledShowRef = ref(props.defaultShow);
    const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
    const mergedShowConsideringDisabledPropRef = useMemo(() => {
      if (props.disabled)
        return false;
      return mergedShowWithoutDisabledRef.value;
    });
    const getMergedDisabled = () => {
      if (props.disabled)
        return true;
      const {
        getDisabled
      } = props;
      if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled())
        return true;
      return false;
    };
    const getMergedShow = () => {
      if (getMergedDisabled())
        return false;
      return mergedShowWithoutDisabledRef.value;
    };
    const compatibleShowArrowRef = useCompitable(props, ["arrow", "showArrow"]);
    const mergedShowArrowRef = computed(() => {
      if (props.overlap)
        return false;
      return compatibleShowArrowRef.value;
    });
    let bodyInstance = null;
    const showTimerIdRef = ref(null);
    const hideTimerIdRef = ref(null);
    const positionManuallyRef = useMemo(() => {
      return props.x !== void 0 && props.y !== void 0;
    });
    function doUpdateShow(value) {
      const {
        "onUpdate:show": _onUpdateShow,
        onUpdateShow,
        onShow,
        onHide
      } = props;
      uncontrolledShowRef.value = value;
      if (_onUpdateShow) {
        call(_onUpdateShow, value);
      }
      if (onUpdateShow) {
        call(onUpdateShow, value);
      }
      if (value && onShow) {
        call(onShow, true);
      }
      if (value && onHide) {
        call(onHide, false);
      }
    }
    function syncPosition() {
      if (bodyInstance) {
        bodyInstance.syncPosition();
      }
    }
    function clearShowTimer() {
      const {
        value: showTimerId
      } = showTimerIdRef;
      if (showTimerId) {
        window.clearTimeout(showTimerId);
        showTimerIdRef.value = null;
      }
    }
    function clearHideTimer() {
      const {
        value: hideTimerId
      } = hideTimerIdRef;
      if (hideTimerId) {
        window.clearTimeout(hideTimerId);
        hideTimerIdRef.value = null;
      }
    }
    function handleFocus() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "focus" && !mergedDisabled) {
        if (getMergedShow())
          return;
        doUpdateShow(true);
      }
    }
    function handleBlur() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "focus" && !mergedDisabled) {
        if (!getMergedShow())
          return;
        doUpdateShow(false);
      }
    }
    function handleMouseEnter() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "hover" && !mergedDisabled) {
        clearHideTimer();
        if (showTimerIdRef.value !== null)
          return;
        if (getMergedShow())
          return;
        const delayCallback = () => {
          doUpdateShow(true);
          showTimerIdRef.value = null;
        };
        const {
          delay: delay2
        } = props;
        if (delay2 === 0) {
          delayCallback();
        } else {
          showTimerIdRef.value = window.setTimeout(delayCallback, delay2);
        }
      }
    }
    function handleMouseLeave() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "hover" && !mergedDisabled) {
        clearShowTimer();
        if (hideTimerIdRef.value !== null)
          return;
        if (!getMergedShow())
          return;
        const delayedCallback = () => {
          doUpdateShow(false);
          hideTimerIdRef.value = null;
        };
        const {
          duration: duration2
        } = props;
        if (duration2 === 0) {
          delayedCallback();
        } else {
          hideTimerIdRef.value = window.setTimeout(delayedCallback, duration2);
        }
      }
    }
    function handleMouseMoveOutside() {
      handleMouseLeave();
    }
    function handleClickOutside(e) {
      var _a;
      if (!getMergedShow())
        return;
      if (props.trigger === "click") {
        clearShowTimer();
        clearHideTimer();
        doUpdateShow(false);
      }
      (_a = props.onClickoutside) === null || _a === void 0 ? void 0 : _a.call(props, e);
    }
    function handleClick2() {
      if (props.trigger === "click" && !getMergedDisabled()) {
        clearShowTimer();
        clearHideTimer();
        const nextShow = !getMergedShow();
        doUpdateShow(nextShow);
      }
    }
    function handleKeydown(e) {
      if (!props.internalTrapFocus)
        return;
      if (e.key === "Escape") {
        clearShowTimer();
        clearHideTimer();
        doUpdateShow(false);
      }
    }
    function setShow(value) {
      uncontrolledShowRef.value = value;
    }
    function getTriggerElement() {
      var _a;
      return (_a = binderInstRef.value) === null || _a === void 0 ? void 0 : _a.targetRef;
    }
    function setBodyInstance(value) {
      bodyInstance = value;
    }
    provide("NPopover", {
      getTriggerElement,
      handleKeydown,
      handleMouseEnter,
      handleMouseLeave,
      handleClickOutside,
      handleMouseMoveOutside,
      setBodyInstance,
      positionManuallyRef,
      isMountedRef,
      zIndexRef: toRef(props, "zIndex"),
      extraClassRef: toRef(props, "internalExtraClass"),
      internalRenderBodyRef: toRef(props, "internalRenderBody")
    });
    watchEffect(() => {
      if (mergedShowWithoutDisabledRef.value && getMergedDisabled()) {
        doUpdateShow(false);
      }
    });
    const returned = {
      binderInstRef,
      positionManually: positionManuallyRef,
      mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
      // if to show popover body
      uncontrolledShow: uncontrolledShowRef,
      mergedShowArrow: mergedShowArrowRef,
      getMergedShow,
      setShow,
      handleClick: handleClick2,
      handleMouseEnter,
      handleMouseLeave,
      handleFocus,
      handleBlur,
      syncPosition
    };
    return returned;
  },
  render() {
    var _a;
    const {
      positionManually,
      $slots: slots
    } = this;
    let triggerVNode;
    let popoverInside = false;
    if (!positionManually) {
      if (slots.activator) {
        triggerVNode = getFirstSlotVNode(slots, "activator");
      } else {
        triggerVNode = getFirstSlotVNode(slots, "trigger");
      }
      if (triggerVNode) {
        triggerVNode = cloneVNode(triggerVNode);
        triggerVNode = triggerVNode.type === Text$2 ? h("span", [triggerVNode]) : triggerVNode;
        const handlers = {
          onClick: this.handleClick,
          onMouseenter: this.handleMouseEnter,
          onMouseleave: this.handleMouseLeave,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur
        };
        if ((_a = triggerVNode.type) === null || _a === void 0 ? void 0 : _a.__popover__) {
          popoverInside = true;
          if (!triggerVNode.props) {
            triggerVNode.props = {
              internalSyncTargetWithParent: true,
              internalInheritedEventHandlers: []
            };
          }
          triggerVNode.props.internalSyncTargetWithParent = true;
          if (!triggerVNode.props.internalInheritedEventHandlers) {
            triggerVNode.props.internalInheritedEventHandlers = [handlers];
          } else {
            triggerVNode.props.internalInheritedEventHandlers = [handlers, ...triggerVNode.props.internalInheritedEventHandlers];
          }
        } else {
          const {
            internalInheritedEventHandlers
          } = this;
          const ascendantAndCurrentHandlers = [handlers, ...internalInheritedEventHandlers];
          const mergedHandlers = {
            onBlur: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onBlur(e);
              });
            },
            onFocus: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onFocus(e);
              });
            },
            onClick: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onClick(e);
              });
            },
            onMouseenter: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onMouseenter(e);
              });
            },
            onMouseleave: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onMouseleave(e);
              });
            }
          };
          appendEvents(triggerVNode, internalInheritedEventHandlers ? "nested" : positionManually ? "manual" : this.trigger, mergedHandlers);
        }
      }
    }
    return h(VBinder, {
      ref: "binderInstRef",
      syncTarget: !popoverInside,
      syncTargetWithParent: this.internalSyncTargetWithParent
    }, {
      default: () => {
        void this.mergedShowConsideringDisabledProp;
        const mergedShow = this.getMergedShow();
        return [this.internalTrapFocus && mergedShow ? withDirectives(h("div", {
          style: {
            position: "fixed",
            inset: 0
          }
        }), [[zindexable$1, {
          enabled: mergedShow,
          zIndex: this.zIndex
        }]]) : null, positionManually ? null : h(VTarget, null, {
          default: () => triggerVNode
        }), h(NPopoverBody, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), {
          showArrow: this.mergedShowArrow,
          show: mergedShow
        })), {
          default: () => {
            var _a2, _b;
            return (_b = (_a2 = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a2);
          },
          header: () => {
            var _a2, _b;
            return (_b = (_a2 = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a2);
          },
          footer: () => {
            var _a2, _b;
            return (_b = (_a2 = this.$slots).footer) === null || _b === void 0 ? void 0 : _b.call(_a2);
          }
        })];
      }
    });
  }
});
const style$j = cB("base-clear", `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [c$1(">", [cE("clear", `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [c$1("&:hover", `
 color: var(--n-clear-color-hover)!important;
 `), c$1("&:active", `
 color: var(--n-clear-color-pressed)!important;
 `)]), cE("placeholder", `
 display: flex;
 `), cE("clear, placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
  originalTransform: "translateX(-50%) translateY(-50%)",
  left: "50%",
  top: "50%"
})])])]);
const NBaseClear = /* @__PURE__ */ defineComponent({
  name: "BaseClear",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    show: Boolean,
    onClear: Function
  },
  setup(props) {
    useStyle("-base-clear", style$j, toRef(props, "clsPrefix"));
    return {
      handleMouseDown(e) {
        e.preventDefault();
      }
    };
  },
  render() {
    const {
      clsPrefix
    } = this;
    return h("div", {
      class: `${clsPrefix}-base-clear`
    }, h(NIconSwitchTransition, null, {
      default: () => {
        var _a, _b;
        return this.show ? h("div", {
          key: "dismiss",
          class: `${clsPrefix}-base-clear__clear`,
          onClick: this.onClear,
          onMousedown: this.handleMouseDown,
          "data-clear": true
        }, resolveSlot(this.$slots.icon, () => [h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => h(ClearIcon, null)
        })])) : h("div", {
          key: "icon",
          class: `${clsPrefix}-base-clear__placeholder`
        }, (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a));
      }
    }));
  }
});
const NBaseSuffix = /* @__PURE__ */ defineComponent({
  name: "InternalSelectionSuffix",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    showArrow: {
      type: Boolean,
      default: void 0
    },
    showClear: {
      type: Boolean,
      default: void 0
    },
    loading: {
      type: Boolean,
      default: false
    },
    onClear: Function
  },
  setup(props, {
    slots
  }) {
    return () => {
      const {
        clsPrefix
      } = props;
      return h(NBaseLoading, {
        clsPrefix,
        class: `${clsPrefix}-base-suffix`,
        strokeWidth: 24,
        scale: 0.85,
        show: props.loading
      }, {
        default: () => props.showArrow ? h(NBaseClear, {
          clsPrefix,
          show: props.showClear,
          onClear: props.onClear
        }, {
          placeholder: () => h(NBaseIcon, {
            clsPrefix,
            class: `${clsPrefix}-base-suffix__arrow`
          }, {
            default: () => resolveSlot(slots.default, () => [h(ChevronDownIcon, null)])
          })
        }) : null
      });
    };
  }
});
const {
  cubicBezierEaseInOut: cubicBezierEaseInOut$2
} = commonVariables$7;
function fadeInWidthExpandTransition({
  duration: duration2 = ".2s",
  delay: delay2 = ".1s"
} = {}) {
  return [c$1("&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to", {
    opacity: 1
  }), c$1("&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from", `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), c$1("&.fade-in-width-expand-transition-leave-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$2},
 max-width ${duration2} ${cubicBezierEaseInOut$2} ${delay2},
 margin-left ${duration2} ${cubicBezierEaseInOut$2} ${delay2},
 margin-right ${duration2} ${cubicBezierEaseInOut$2} ${delay2};
 `), c$1("&.fade-in-width-expand-transition-enter-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$2} ${delay2},
 max-width ${duration2} ${cubicBezierEaseInOut$2},
 margin-left ${duration2} ${cubicBezierEaseInOut$2},
 margin-right ${duration2} ${cubicBezierEaseInOut$2};
 `)];
}
const {
  cubicBezierEaseInOut: cubicBezierEaseInOut$1,
  cubicBezierEaseOut,
  cubicBezierEaseIn
} = commonVariables$7;
function fadeInHeightExpandTransition({
  overflow = "hidden",
  duration: duration2 = ".3s",
  originalTransition = "",
  leavingDelay = "0s",
  foldPadding = false,
  enterToProps = void 0,
  leaveToProps = void 0,
  reverse: reverse2 = false
} = {}) {
  const enterClass = reverse2 ? "leave" : "enter";
  const leaveClass = reverse2 ? "enter" : "leave";
  return [c$1(`&.fade-in-height-expand-transition-${leaveClass}-from,
 &.fade-in-height-expand-transition-${enterClass}-to`, Object.assign(Object.assign({}, enterToProps), {
    opacity: 1
  })), c$1(`&.fade-in-height-expand-transition-${leaveClass}-to,
 &.fade-in-height-expand-transition-${enterClass}-from`, Object.assign(Object.assign({}, leaveToProps), {
    opacity: 0,
    marginTop: "0 !important",
    marginBottom: "0 !important",
    paddingTop: foldPadding ? "0 !important" : void 0,
    paddingBottom: foldPadding ? "0 !important" : void 0
  })), c$1(`&.fade-in-height-expand-transition-${leaveClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 opacity ${duration2} ${cubicBezierEaseOut} ${leavingDelay},
 margin-top ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 margin-bottom ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 padding-top ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 padding-bottom ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay}
 ${originalTransition ? `,${originalTransition}` : ""}
 `), c$1(`&.fade-in-height-expand-transition-${enterClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration2} ${cubicBezierEaseInOut$1},
 opacity ${duration2} ${cubicBezierEaseIn},
 margin-top ${duration2} ${cubicBezierEaseInOut$1},
 margin-bottom ${duration2} ${cubicBezierEaseInOut$1},
 padding-top ${duration2} ${cubicBezierEaseInOut$1},
 padding-bottom ${duration2} ${cubicBezierEaseInOut$1}
 ${originalTransition ? `,${originalTransition}` : ""}
 `)];
}
const isChrome = isBrowser$2 && "chrome" in window;
isBrowser$2 && navigator.userAgent.includes("Firefox");
const isSafari = isBrowser$2 && navigator.userAgent.includes("Safari") && !isChrome;
const commonVariables$5 = {
  paddingTiny: "0 8px",
  paddingSmall: "0 10px",
  paddingMedium: "0 12px",
  paddingLarge: "0 14px",
  clearSize: "16px"
};
function self$i(vars) {
  const {
    textColor2,
    textColor3,
    textColorDisabled,
    primaryColor,
    primaryColorHover,
    inputColor,
    inputColorDisabled,
    borderColor,
    warningColor,
    warningColorHover,
    errorColor,
    errorColorHover,
    borderRadius,
    lineHeight: lineHeight2,
    fontSizeTiny,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    heightTiny,
    heightSmall,
    heightMedium,
    heightLarge,
    actionColor,
    clearColor,
    clearColorHover,
    clearColorPressed,
    placeholderColor,
    placeholderColorDisabled,
    iconColor,
    iconColorDisabled,
    iconColorHover,
    iconColorPressed
  } = vars;
  return Object.assign(Object.assign({}, commonVariables$5), {
    countTextColorDisabled: textColorDisabled,
    countTextColor: textColor3,
    heightTiny,
    heightSmall,
    heightMedium,
    heightLarge,
    fontSizeTiny,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    lineHeight: lineHeight2,
    lineHeightTextarea: lineHeight2,
    borderRadius,
    iconSize: "16px",
    groupLabelColor: actionColor,
    groupLabelTextColor: textColor2,
    textColor: textColor2,
    textColorDisabled,
    textDecorationColor: textColor2,
    caretColor: primaryColor,
    placeholderColor,
    placeholderColorDisabled,
    color: inputColor,
    colorDisabled: inputColorDisabled,
    colorFocus: inputColor,
    groupLabelBorder: `1px solid ${borderColor}`,
    border: `1px solid ${borderColor}`,
    borderHover: `1px solid ${primaryColorHover}`,
    borderDisabled: `1px solid ${borderColor}`,
    borderFocus: `1px solid ${primaryColorHover}`,
    boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
      alpha: 0.2
    })}`,
    loadingColor: primaryColor,
    // warning
    loadingColorWarning: warningColor,
    borderWarning: `1px solid ${warningColor}`,
    borderHoverWarning: `1px solid ${warningColorHover}`,
    colorFocusWarning: inputColor,
    borderFocusWarning: `1px solid ${warningColorHover}`,
    boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
      alpha: 0.2
    })}`,
    caretColorWarning: warningColor,
    // error
    loadingColorError: errorColor,
    borderError: `1px solid ${errorColor}`,
    borderHoverError: `1px solid ${errorColorHover}`,
    colorFocusError: inputColor,
    borderFocusError: `1px solid ${errorColorHover}`,
    boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
      alpha: 0.2
    })}`,
    caretColorError: errorColor,
    clearColor,
    clearColorHover,
    clearColorPressed,
    iconColor,
    iconColorDisabled,
    iconColorHover,
    iconColorPressed,
    suffixTextColor: textColor2
  });
}
const inputLight = {
  name: "Input",
  common: commonLight,
  self: self$i
};
const inputLight$1 = inputLight;
const inputInjectionKey = createInjectionKey("n-input");
function len(s) {
  let count = 0;
  for (const _ of s) {
    count++;
  }
  return count;
}
function isEmptyInputValue(value) {
  return value === "" || value == null;
}
function useCursor(inputElRef) {
  const selectionRef = ref(null);
  function recordCursor() {
    const {
      value: input
    } = inputElRef;
    if (!(input === null || input === void 0 ? void 0 : input.focus)) {
      reset();
      return;
    }
    const {
      selectionStart,
      selectionEnd,
      value
    } = input;
    if (selectionStart == null || selectionEnd == null) {
      reset();
      return;
    }
    selectionRef.value = {
      start: selectionStart,
      end: selectionEnd,
      beforeText: value.slice(0, selectionStart),
      afterText: value.slice(selectionEnd)
    };
  }
  function restoreCursor() {
    var _a;
    const {
      value: selection
    } = selectionRef;
    const {
      value: inputEl
    } = inputElRef;
    if (!selection || !inputEl) {
      return;
    }
    const {
      value
    } = inputEl;
    const {
      start,
      beforeText,
      afterText
    } = selection;
    let startPos = value.length;
    if (value.endsWith(afterText)) {
      startPos = value.length - afterText.length;
    } else if (value.startsWith(beforeText)) {
      startPos = beforeText.length;
    } else {
      const beforeLastChar = beforeText[start - 1];
      const newIndex = value.indexOf(beforeLastChar, start - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    (_a = inputEl.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(inputEl, startPos, startPos);
  }
  function reset() {
    selectionRef.value = null;
  }
  watch(inputElRef, reset);
  return {
    recordCursor,
    restoreCursor
  };
}
const WordCount = /* @__PURE__ */ defineComponent({
  name: "InputWordCount",
  setup(_, {
    slots
  }) {
    const {
      mergedValueRef,
      maxlengthRef,
      mergedClsPrefixRef,
      countGraphemesRef
    } = inject(inputInjectionKey);
    const wordCountRef = computed(() => {
      const {
        value: mergedValue
      } = mergedValueRef;
      if (mergedValue === null || Array.isArray(mergedValue))
        return 0;
      return (countGraphemesRef.value || len)(mergedValue);
    });
    return () => {
      const {
        value: maxlength
      } = maxlengthRef;
      const {
        value: mergedValue
      } = mergedValueRef;
      return h("span", {
        class: `${mergedClsPrefixRef.value}-input-word-count`
      }, resolveSlotWithProps(slots.default, {
        value: mergedValue === null || Array.isArray(mergedValue) ? "" : mergedValue
      }, () => [maxlength === void 0 ? wordCountRef.value : `${wordCountRef.value} / ${maxlength}`]));
    };
  }
});
const style$i = cB("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [
  // common
  cE("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `),
  cE("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `),
  cE("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), c$1("&:-webkit-autofill ~", [cE("placeholder", "display: none;")])]),
  cM("round", [cNotM("textarea", "border-radius: calc(var(--n-height) / 2);")]),
  cE("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [c$1("span", `
 width: 100%;
 display: inline-block;
 `)]),
  cM("textarea", [cE("placeholder", "overflow: visible;")]),
  cNotM("autosize", "width: 100%;"),
  cM("autosize", [cE("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]),
  // input
  cB("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `),
  cE("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `),
  cE("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [c$1("&[type=password]::-ms-reveal", "display: none;"), c$1("+", [cE("placeholder", `
 display: flex;
 align-items: center; 
 `)])]),
  cNotM("textarea", [cE("placeholder", "white-space: nowrap;")]),
  cE("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `),
  // textarea
  cM("textarea", "width: 100%;", [cB("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), cM("resizable", [cB("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), cE("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), cE("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]),
  // pair
  cM("pair", [cE("input-el, placeholder", "text-align: center;"), cE("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [cB("icon", `
 color: var(--n-icon-color);
 `), cB("base-icon", `
 color: var(--n-icon-color);
 `)])]),
  cM("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [cE("border", "border: var(--n-border-disabled);"), cE("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), cE("placeholder", "color: var(--n-placeholder-color-disabled);"), cE("separator", "color: var(--n-text-color-disabled);", [cB("icon", `
 color: var(--n-icon-color-disabled);
 `), cB("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), cB("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), cE("suffix, prefix", "color: var(--n-text-color-disabled);", [cB("icon", `
 color: var(--n-icon-color-disabled);
 `), cB("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]),
  cNotM("disabled", [cE("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [c$1("&:hover", `
 color: var(--n-icon-color-hover);
 `), c$1("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), c$1("&:hover", [cE("state-border", "border: var(--n-border-hover);")]), cM("focus", "background-color: var(--n-color-focus);", [cE("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]),
  cE("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `),
  cE("state-border", `
 border-color: #0000;
 z-index: 1;
 `),
  cE("prefix", "margin-right: 4px;"),
  cE("suffix", `
 margin-left: 4px;
 `),
  cE("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [cB("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), cB("base-clear", `
 font-size: var(--n-icon-size);
 `, [cE("placeholder", [cB("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), c$1(">", [cB("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), cB("base-icon", `
 font-size: var(--n-icon-size);
 `)]),
  cB("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `),
  ["warning", "error"].map((status) => cM(`${status}-status`, [cNotM("disabled", [cB("base-loading", `
 color: var(--n-loading-color-${status})
 `), cE("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${status});
 `), cE("state-border", `
 border: var(--n-border-${status});
 `), c$1("&:hover", [cE("state-border", `
 border: var(--n-border-hover-${status});
 `)]), c$1("&:focus", `
 background-color: var(--n-color-focus-${status});
 `, [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)]), cM("focus", `
 background-color: var(--n-color-focus-${status});
 `, [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)])])]))
]);
const safariStyle = cB("input", [cM("disabled", [cE("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
const inputProps = Object.assign(Object.assign({}, useTheme.props), {
  bordered: {
    type: Boolean,
    default: void 0
  },
  type: {
    type: String,
    default: "text"
  },
  placeholder: [Array, String],
  defaultValue: {
    type: [String, Array],
    default: null
  },
  value: [String, Array],
  disabled: {
    type: Boolean,
    default: void 0
  },
  size: String,
  rows: {
    type: [Number, String],
    default: 3
  },
  round: Boolean,
  minlength: [String, Number],
  maxlength: [String, Number],
  clearable: Boolean,
  autosize: {
    type: [Boolean, Object],
    default: false
  },
  pair: Boolean,
  separator: String,
  readonly: {
    type: [String, Boolean],
    default: false
  },
  passivelyActivated: Boolean,
  showPasswordOn: String,
  stateful: {
    type: Boolean,
    default: true
  },
  autofocus: Boolean,
  inputProps: Object,
  resizable: {
    type: Boolean,
    default: true
  },
  showCount: Boolean,
  loading: {
    type: Boolean,
    default: void 0
  },
  allowInput: Function,
  renderCount: Function,
  onMousedown: Function,
  onKeydown: Function,
  onKeyup: [Function, Array],
  onInput: [Function, Array],
  onFocus: [Function, Array],
  onBlur: [Function, Array],
  onClick: [Function, Array],
  onChange: [Function, Array],
  onClear: [Function, Array],
  countGraphemes: Function,
  status: String,
  "onUpdate:value": [Function, Array],
  onUpdateValue: [Function, Array],
  /** private */
  textDecoration: [String, Array],
  attrSize: {
    type: Number,
    default: 20
  },
  onInputBlur: [Function, Array],
  onInputFocus: [Function, Array],
  onDeactivate: [Function, Array],
  onActivate: [Function, Array],
  onWrapperFocus: [Function, Array],
  onWrapperBlur: [Function, Array],
  internalDeactivateOnEnter: Boolean,
  internalForceFocus: Boolean,
  internalLoadingBeforeSuffix: {
    type: Boolean,
    default: true
  },
  /** deprecated */
  showPasswordToggle: Boolean
});
const NInput = /* @__PURE__ */ defineComponent({
  name: "Input",
  props: inputProps,
  setup(props) {
    const {
      mergedClsPrefixRef,
      mergedBorderedRef,
      inlineThemeDisabled,
      mergedRtlRef
    } = useConfig(props);
    const themeRef = useTheme("Input", "-input", style$i, inputLight$1, props, mergedClsPrefixRef);
    if (isSafari) {
      useStyle("-input-safari", safariStyle, mergedClsPrefixRef);
    }
    const wrapperElRef = ref(null);
    const textareaElRef = ref(null);
    const textareaMirrorElRef = ref(null);
    const inputMirrorElRef = ref(null);
    const inputElRef = ref(null);
    const inputEl2Ref = ref(null);
    const currentFocusedInputRef = ref(null);
    const focusedInputCursorControl = useCursor(currentFocusedInputRef);
    const textareaScrollbarInstRef = ref(null);
    const {
      localeRef
    } = useLocale("Input");
    const uncontrolledValueRef = ref(props.defaultValue);
    const controlledValueRef = toRef(props, "value");
    const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
    const formItem = useFormItem(props);
    const {
      mergedSizeRef,
      mergedDisabledRef,
      mergedStatusRef
    } = formItem;
    const focusedRef = ref(false);
    const hoverRef = ref(false);
    const isComposingRef2 = ref(false);
    const activatedRef = ref(false);
    let syncSource = null;
    const mergedPlaceholderRef = computed(() => {
      const {
        placeholder,
        pair
      } = props;
      if (pair) {
        if (Array.isArray(placeholder)) {
          return placeholder;
        } else if (placeholder === void 0) {
          return ["", ""];
        }
        return [placeholder, placeholder];
      } else if (placeholder === void 0) {
        return [localeRef.value.placeholder];
      } else {
        return [placeholder];
      }
    });
    const showPlaceholder1Ref = computed(() => {
      const {
        value: isComposing
      } = isComposingRef2;
      const {
        value: mergedValue
      } = mergedValueRef;
      const {
        value: mergedPlaceholder
      } = mergedPlaceholderRef;
      return !isComposing && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[0])) && mergedPlaceholder[0];
    });
    const showPlaceholder2Ref = computed(() => {
      const {
        value: isComposing
      } = isComposingRef2;
      const {
        value: mergedValue
      } = mergedValueRef;
      const {
        value: mergedPlaceholder
      } = mergedPlaceholderRef;
      return !isComposing && mergedPlaceholder[1] && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[1]));
    });
    const mergedFocusRef = useMemo(() => {
      return props.internalForceFocus || focusedRef.value;
    });
    const showClearButton = useMemo(() => {
      if (mergedDisabledRef.value || props.readonly || !props.clearable || !mergedFocusRef.value && !hoverRef.value) {
        return false;
      }
      const {
        value: mergedValue
      } = mergedValueRef;
      const {
        value: mergedFocus
      } = mergedFocusRef;
      if (props.pair) {
        return !!(Array.isArray(mergedValue) && (mergedValue[0] || mergedValue[1])) && (hoverRef.value || mergedFocus);
      } else {
        return !!mergedValue && (hoverRef.value || mergedFocus);
      }
    });
    const mergedShowPasswordOnRef = computed(() => {
      const {
        showPasswordOn
      } = props;
      if (showPasswordOn) {
        return showPasswordOn;
      }
      if (props.showPasswordToggle)
        return "click";
      return void 0;
    });
    const passwordVisibleRef = ref(false);
    const textDecorationStyleRef = computed(() => {
      const {
        textDecoration
      } = props;
      if (!textDecoration)
        return ["", ""];
      if (Array.isArray(textDecoration)) {
        return textDecoration.map((v) => ({
          textDecoration: v
        }));
      }
      return [{
        textDecoration
      }];
    });
    const textAreaScrollContainerWidthRef = ref(void 0);
    const updateTextAreaStyle = () => {
      var _a, _b;
      if (props.type === "textarea") {
        const {
          autosize
        } = props;
        if (autosize) {
          textAreaScrollContainerWidthRef.value = (_b = (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.$el) === null || _b === void 0 ? void 0 : _b.offsetWidth;
        }
        if (!textareaElRef.value)
          return;
        if (typeof autosize === "boolean")
          return;
        const {
          paddingTop: stylePaddingTop,
          paddingBottom: stylePaddingBottom,
          lineHeight: styleLineHeight
        } = window.getComputedStyle(textareaElRef.value);
        const paddingTop = Number(stylePaddingTop.slice(0, -2));
        const paddingBottom = Number(stylePaddingBottom.slice(0, -2));
        const lineHeight2 = Number(styleLineHeight.slice(0, -2));
        const {
          value: textareaMirrorEl
        } = textareaMirrorElRef;
        if (!textareaMirrorEl)
          return;
        if (autosize.minRows) {
          const minRows = Math.max(autosize.minRows, 1);
          const styleMinHeight = `${paddingTop + paddingBottom + lineHeight2 * minRows}px`;
          textareaMirrorEl.style.minHeight = styleMinHeight;
        }
        if (autosize.maxRows) {
          const styleMaxHeight = `${paddingTop + paddingBottom + lineHeight2 * autosize.maxRows}px`;
          textareaMirrorEl.style.maxHeight = styleMaxHeight;
        }
      }
    };
    const maxlengthRef = computed(() => {
      const {
        maxlength
      } = props;
      return maxlength === void 0 ? void 0 : Number(maxlength);
    });
    onMounted(() => {
      const {
        value
      } = mergedValueRef;
      if (!Array.isArray(value)) {
        syncMirror(value);
      }
    });
    const vm = getCurrentInstance().proxy;
    function doUpdateValue(value, meta) {
      const {
        onUpdateValue,
        "onUpdate:value": _onUpdateValue,
        onInput
      } = props;
      const {
        nTriggerFormInput
      } = formItem;
      if (onUpdateValue)
        call(onUpdateValue, value, meta);
      if (_onUpdateValue)
        call(_onUpdateValue, value, meta);
      if (onInput)
        call(onInput, value, meta);
      uncontrolledValueRef.value = value;
      nTriggerFormInput();
    }
    function doChange(value, meta) {
      const {
        onChange
      } = props;
      const {
        nTriggerFormChange
      } = formItem;
      if (onChange)
        call(onChange, value, meta);
      uncontrolledValueRef.value = value;
      nTriggerFormChange();
    }
    function doBlur(e) {
      const {
        onBlur
      } = props;
      const {
        nTriggerFormBlur
      } = formItem;
      if (onBlur)
        call(onBlur, e);
      nTriggerFormBlur();
    }
    function doFocus(e) {
      const {
        onFocus
      } = props;
      const {
        nTriggerFormFocus
      } = formItem;
      if (onFocus)
        call(onFocus, e);
      nTriggerFormFocus();
    }
    function doClear(e) {
      const {
        onClear
      } = props;
      if (onClear)
        call(onClear, e);
    }
    function doUpdateValueBlur(e) {
      const {
        onInputBlur
      } = props;
      if (onInputBlur)
        call(onInputBlur, e);
    }
    function doUpdateValueFocus(e) {
      const {
        onInputFocus
      } = props;
      if (onInputFocus)
        call(onInputFocus, e);
    }
    function doDeactivate() {
      const {
        onDeactivate
      } = props;
      if (onDeactivate)
        call(onDeactivate);
    }
    function doActivate() {
      const {
        onActivate
      } = props;
      if (onActivate)
        call(onActivate);
    }
    function doClick(e) {
      const {
        onClick
      } = props;
      if (onClick)
        call(onClick, e);
    }
    function doWrapperFocus(e) {
      const {
        onWrapperFocus
      } = props;
      if (onWrapperFocus)
        call(onWrapperFocus, e);
    }
    function doWrapperBlur(e) {
      const {
        onWrapperBlur
      } = props;
      if (onWrapperBlur)
        call(onWrapperBlur, e);
    }
    function handleCompositionStart() {
      isComposingRef2.value = true;
    }
    function handleCompositionEnd(e) {
      isComposingRef2.value = false;
      if (e.target === inputEl2Ref.value) {
        handleInput(e, 1);
      } else {
        handleInput(e, 0);
      }
    }
    function handleInput(e, index = 0, event = "input") {
      const targetValue = e.target.value;
      syncMirror(targetValue);
      if (e instanceof InputEvent && !e.isComposing) {
        isComposingRef2.value = false;
      }
      if (props.type === "textarea") {
        const {
          value: textareaScrollbarInst
        } = textareaScrollbarInstRef;
        if (textareaScrollbarInst) {
          textareaScrollbarInst.syncUnifiedContainer();
        }
      }
      syncSource = targetValue;
      if (isComposingRef2.value)
        return;
      focusedInputCursorControl.recordCursor();
      const isIncomingValueValid = allowInput(targetValue);
      if (isIncomingValueValid) {
        if (!props.pair) {
          if (event === "input") {
            doUpdateValue(targetValue, {
              source: index
            });
          } else {
            doChange(targetValue, {
              source: index
            });
          }
        } else {
          let {
            value
          } = mergedValueRef;
          if (!Array.isArray(value)) {
            value = ["", ""];
          } else {
            value = [value[0], value[1]];
          }
          value[index] = targetValue;
          if (event === "input") {
            doUpdateValue(value, {
              source: index
            });
          } else {
            doChange(value, {
              source: index
            });
          }
        }
      }
      vm.$forceUpdate();
      if (!isIncomingValueValid) {
        void nextTick(focusedInputCursorControl.restoreCursor);
      }
    }
    function allowInput(value) {
      const {
        countGraphemes,
        maxlength,
        minlength
      } = props;
      if (countGraphemes) {
        let graphemesCount;
        if (maxlength !== void 0) {
          if (graphemesCount === void 0) {
            graphemesCount = countGraphemes(value);
          }
          if (graphemesCount > Number(maxlength))
            return false;
        }
        if (minlength !== void 0) {
          if (graphemesCount === void 0) {
            graphemesCount = countGraphemes(value);
          }
          if (graphemesCount < Number(maxlength))
            return false;
        }
      }
      const {
        allowInput: allowInput2
      } = props;
      if (typeof allowInput2 === "function") {
        return allowInput2(value);
      }
      return true;
    }
    function handleInputBlur(e) {
      doUpdateValueBlur(e);
      if (e.relatedTarget === wrapperElRef.value) {
        doDeactivate();
      }
      if (!(e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value))) {
        activatedRef.value = false;
      }
      dealWithEvent(e, "blur");
      currentFocusedInputRef.value = null;
    }
    function handleInputFocus(e, index) {
      doUpdateValueFocus(e);
      focusedRef.value = true;
      activatedRef.value = true;
      doActivate();
      dealWithEvent(e, "focus");
      if (index === 0) {
        currentFocusedInputRef.value = inputElRef.value;
      } else if (index === 1) {
        currentFocusedInputRef.value = inputEl2Ref.value;
      } else if (index === 2) {
        currentFocusedInputRef.value = textareaElRef.value;
      }
    }
    function handleWrapperBlur(e) {
      if (props.passivelyActivated) {
        doWrapperBlur(e);
        dealWithEvent(e, "blur");
      }
    }
    function handleWrapperFocus(e) {
      if (props.passivelyActivated) {
        focusedRef.value = true;
        doWrapperFocus(e);
        dealWithEvent(e, "focus");
      }
    }
    function dealWithEvent(e, type4) {
      if (e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value || e.relatedTarget === wrapperElRef.value))
        ;
      else {
        if (type4 === "focus") {
          doFocus(e);
          focusedRef.value = true;
        } else if (type4 === "blur") {
          doBlur(e);
          focusedRef.value = false;
        }
      }
    }
    function handleChange(e, index) {
      handleInput(e, index, "change");
    }
    function handleClick2(e) {
      doClick(e);
    }
    function handleClear(e) {
      doClear(e);
      clearValue();
    }
    function clearValue() {
      if (props.pair) {
        doUpdateValue(["", ""], {
          source: "clear"
        });
        doChange(["", ""], {
          source: "clear"
        });
      } else {
        doUpdateValue("", {
          source: "clear"
        });
        doChange("", {
          source: "clear"
        });
      }
    }
    function handleMouseDown(e) {
      const {
        onMousedown
      } = props;
      if (onMousedown)
        onMousedown(e);
      const {
        tagName
      } = e.target;
      if (tagName !== "INPUT" && tagName !== "TEXTAREA") {
        if (props.resizable) {
          const {
            value: wrapperEl
          } = wrapperElRef;
          if (wrapperEl) {
            const {
              left,
              top,
              width,
              height
            } = wrapperEl.getBoundingClientRect();
            const resizeHandleSize = 14;
            if (left + width - resizeHandleSize < e.clientX && e.clientX < left + width && top + height - resizeHandleSize < e.clientY && e.clientY < top + height) {
              return;
            }
          }
        }
        e.preventDefault();
        if (!focusedRef.value) {
          focus();
        }
      }
    }
    function handleMouseEnter() {
      var _a;
      hoverRef.value = true;
      if (props.type === "textarea") {
        (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseEnterWrapper();
      }
    }
    function handleMouseLeave() {
      var _a;
      hoverRef.value = false;
      if (props.type === "textarea") {
        (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseLeaveWrapper();
      }
    }
    function handlePasswordToggleClick() {
      if (mergedDisabledRef.value)
        return;
      if (mergedShowPasswordOnRef.value !== "click")
        return;
      passwordVisibleRef.value = !passwordVisibleRef.value;
    }
    function handlePasswordToggleMousedown(e) {
      if (mergedDisabledRef.value)
        return;
      e.preventDefault();
      const preventDefaultOnce = (e2) => {
        e2.preventDefault();
        off("mouseup", document, preventDefaultOnce);
      };
      on("mouseup", document, preventDefaultOnce);
      if (mergedShowPasswordOnRef.value !== "mousedown")
        return;
      passwordVisibleRef.value = true;
      const hidePassword = () => {
        passwordVisibleRef.value = false;
        off("mouseup", document, hidePassword);
      };
      on("mouseup", document, hidePassword);
    }
    function handleWrapperKeyup(e) {
      if (props.onKeyup)
        call(props.onKeyup, e);
    }
    function handleWrapperKeydown(e) {
      if (props.onKeydown)
        call(props.onKeydown, e);
      switch (e.key) {
        case "Escape":
          handleWrapperKeydownEsc();
          break;
        case "Enter":
          handleWrapperKeydownEnter(e);
          break;
      }
    }
    function handleWrapperKeydownEnter(e) {
      var _a, _b;
      if (props.passivelyActivated) {
        const {
          value: focused
        } = activatedRef;
        if (focused) {
          if (props.internalDeactivateOnEnter) {
            handleWrapperKeydownEsc();
          }
          return;
        }
        e.preventDefault();
        if (props.type === "textarea") {
          (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        } else {
          (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
        }
      }
    }
    function handleWrapperKeydownEsc() {
      if (props.passivelyActivated) {
        activatedRef.value = false;
        void nextTick(() => {
          var _a;
          (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        });
      }
    }
    function focus() {
      var _a, _b, _c;
      if (mergedDisabledRef.value)
        return;
      if (props.passivelyActivated) {
        (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      } else {
        (_b = textareaElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
        (_c = inputElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
      }
    }
    function blur() {
      var _a;
      if ((_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
        document.activeElement.blur();
      }
    }
    function select() {
      var _a, _b;
      (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.select();
      (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.select();
    }
    function activate() {
      if (mergedDisabledRef.value)
        return;
      if (textareaElRef.value)
        textareaElRef.value.focus();
      else if (inputElRef.value)
        inputElRef.value.focus();
    }
    function deactivate() {
      const {
        value: wrapperEl
      } = wrapperElRef;
      if ((wrapperEl === null || wrapperEl === void 0 ? void 0 : wrapperEl.contains(document.activeElement)) && wrapperEl !== document.activeElement) {
        handleWrapperKeydownEsc();
      }
    }
    function scrollTo(options) {
      if (props.type === "textarea") {
        const {
          value: textareaEl
        } = textareaElRef;
        textareaEl === null || textareaEl === void 0 ? void 0 : textareaEl.scrollTo(options);
      } else {
        const {
          value: inputEl
        } = inputElRef;
        inputEl === null || inputEl === void 0 ? void 0 : inputEl.scrollTo(options);
      }
    }
    function syncMirror(value) {
      const {
        type: type4,
        pair,
        autosize
      } = props;
      if (!pair && autosize) {
        if (type4 === "textarea") {
          const {
            value: textareaMirrorEl
          } = textareaMirrorElRef;
          if (textareaMirrorEl) {
            textareaMirrorEl.textContent = `${value !== null && value !== void 0 ? value : ""}\r
`;
          }
        } else {
          const {
            value: inputMirrorEl
          } = inputMirrorElRef;
          if (inputMirrorEl) {
            if (value) {
              inputMirrorEl.textContent = value;
            } else {
              inputMirrorEl.innerHTML = "&nbsp;";
            }
          }
        }
      }
    }
    function handleTextAreaMirrorResize() {
      updateTextAreaStyle();
    }
    const placeholderStyleRef = ref({
      top: "0"
    });
    function handleTextAreaScroll(e) {
      var _a;
      const {
        scrollTop
      } = e.target;
      placeholderStyleRef.value.top = `${-scrollTop}px`;
      (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
    }
    let stopWatchMergedValue1 = null;
    watchEffect(() => {
      const {
        autosize,
        type: type4
      } = props;
      if (autosize && type4 === "textarea") {
        stopWatchMergedValue1 = watch(mergedValueRef, (value) => {
          if (!Array.isArray(value) && value !== syncSource) {
            syncMirror(value);
          }
        });
      } else {
        stopWatchMergedValue1 === null || stopWatchMergedValue1 === void 0 ? void 0 : stopWatchMergedValue1();
      }
    });
    let stopWatchMergedValue2 = null;
    watchEffect(() => {
      if (props.type === "textarea") {
        stopWatchMergedValue2 = watch(mergedValueRef, (value) => {
          var _a;
          if (!Array.isArray(value) && value !== syncSource) {
            (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
          }
        });
      } else {
        stopWatchMergedValue2 === null || stopWatchMergedValue2 === void 0 ? void 0 : stopWatchMergedValue2();
      }
    });
    provide(inputInjectionKey, {
      mergedValueRef,
      maxlengthRef,
      mergedClsPrefixRef,
      countGraphemesRef: toRef(props, "countGraphemes")
    });
    const exposedProps = {
      wrapperElRef,
      inputElRef,
      textareaElRef,
      isCompositing: isComposingRef2,
      clear: clearValue,
      focus,
      blur,
      select,
      deactivate,
      activate,
      scrollTo
    };
    const rtlEnabledRef = useRtl("Input", mergedRtlRef, mergedClsPrefixRef);
    const cssVarsRef = computed(() => {
      const {
        value: size2
      } = mergedSizeRef;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: {
          color,
          borderRadius,
          textColor,
          caretColor,
          caretColorError,
          caretColorWarning,
          textDecorationColor,
          border,
          borderDisabled,
          borderHover,
          borderFocus,
          placeholderColor,
          placeholderColorDisabled,
          lineHeightTextarea,
          colorDisabled,
          colorFocus,
          textColorDisabled,
          boxShadowFocus,
          iconSize,
          colorFocusWarning,
          boxShadowFocusWarning,
          borderWarning,
          borderFocusWarning,
          borderHoverWarning,
          colorFocusError,
          boxShadowFocusError,
          borderError,
          borderFocusError,
          borderHoverError,
          clearSize,
          clearColor,
          clearColorHover,
          clearColorPressed,
          iconColor,
          iconColorDisabled,
          suffixTextColor,
          countTextColor,
          countTextColorDisabled,
          iconColorHover,
          iconColorPressed,
          loadingColor,
          loadingColorError,
          loadingColorWarning,
          [createKey("padding", size2)]: padding,
          [createKey("fontSize", size2)]: fontSize2,
          [createKey("height", size2)]: height
        }
      } = themeRef.value;
      const {
        left: paddingLeft,
        right: paddingRight
      } = getMargin(padding);
      return {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-count-text-color": countTextColor,
        "--n-count-text-color-disabled": countTextColorDisabled,
        "--n-color": color,
        "--n-font-size": fontSize2,
        "--n-border-radius": borderRadius,
        "--n-height": height,
        "--n-padding-left": paddingLeft,
        "--n-padding-right": paddingRight,
        "--n-text-color": textColor,
        "--n-caret-color": caretColor,
        "--n-text-decoration-color": textDecorationColor,
        "--n-border": border,
        "--n-border-disabled": borderDisabled,
        "--n-border-hover": borderHover,
        "--n-border-focus": borderFocus,
        "--n-placeholder-color": placeholderColor,
        "--n-placeholder-color-disabled": placeholderColorDisabled,
        "--n-icon-size": iconSize,
        "--n-line-height-textarea": lineHeightTextarea,
        "--n-color-disabled": colorDisabled,
        "--n-color-focus": colorFocus,
        "--n-text-color-disabled": textColorDisabled,
        "--n-box-shadow-focus": boxShadowFocus,
        "--n-loading-color": loadingColor,
        // form warning
        "--n-caret-color-warning": caretColorWarning,
        "--n-color-focus-warning": colorFocusWarning,
        "--n-box-shadow-focus-warning": boxShadowFocusWarning,
        "--n-border-warning": borderWarning,
        "--n-border-focus-warning": borderFocusWarning,
        "--n-border-hover-warning": borderHoverWarning,
        "--n-loading-color-warning": loadingColorWarning,
        // form error
        "--n-caret-color-error": caretColorError,
        "--n-color-focus-error": colorFocusError,
        "--n-box-shadow-focus-error": boxShadowFocusError,
        "--n-border-error": borderError,
        "--n-border-focus-error": borderFocusError,
        "--n-border-hover-error": borderHoverError,
        "--n-loading-color-error": loadingColorError,
        // clear-button
        "--n-clear-color": clearColor,
        "--n-clear-size": clearSize,
        "--n-clear-color-hover": clearColorHover,
        "--n-clear-color-pressed": clearColorPressed,
        "--n-icon-color": iconColor,
        "--n-icon-color-hover": iconColorHover,
        "--n-icon-color-pressed": iconColorPressed,
        "--n-icon-color-disabled": iconColorDisabled,
        "--n-suffix-text-color": suffixTextColor
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("input", computed(() => {
      const {
        value: size2
      } = mergedSizeRef;
      return size2[0];
    }), cssVarsRef, props) : void 0;
    return Object.assign(Object.assign({}, exposedProps), {
      // DOM ref
      wrapperElRef,
      inputElRef,
      inputMirrorElRef,
      inputEl2Ref,
      textareaElRef,
      textareaMirrorElRef,
      textareaScrollbarInstRef,
      // value
      rtlEnabled: rtlEnabledRef,
      uncontrolledValue: uncontrolledValueRef,
      mergedValue: mergedValueRef,
      passwordVisible: passwordVisibleRef,
      mergedPlaceholder: mergedPlaceholderRef,
      showPlaceholder1: showPlaceholder1Ref,
      showPlaceholder2: showPlaceholder2Ref,
      mergedFocus: mergedFocusRef,
      isComposing: isComposingRef2,
      activated: activatedRef,
      showClearButton,
      mergedSize: mergedSizeRef,
      mergedDisabled: mergedDisabledRef,
      textDecorationStyle: textDecorationStyleRef,
      mergedClsPrefix: mergedClsPrefixRef,
      mergedBordered: mergedBorderedRef,
      mergedShowPasswordOn: mergedShowPasswordOnRef,
      placeholderStyle: placeholderStyleRef,
      mergedStatus: mergedStatusRef,
      textAreaScrollContainerWidth: textAreaScrollContainerWidthRef,
      // methods
      handleTextAreaScroll,
      handleCompositionStart,
      handleCompositionEnd,
      handleInput,
      handleInputBlur,
      handleInputFocus,
      handleWrapperBlur,
      handleWrapperFocus,
      handleMouseEnter,
      handleMouseLeave,
      handleMouseDown,
      handleChange,
      handleClick: handleClick2,
      handleClear,
      handlePasswordToggleClick,
      handlePasswordToggleMousedown,
      handleWrapperKeydown,
      handleWrapperKeyup,
      handleTextAreaMirrorResize,
      getTextareaScrollContainer: () => {
        return textareaElRef.value;
      },
      mergedTheme: themeRef,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    });
  },
  render() {
    var _a, _b;
    const {
      mergedClsPrefix,
      mergedStatus,
      themeClass,
      type: type4,
      countGraphemes,
      onRender
    } = this;
    const $slots = this.$slots;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return h("div", {
      ref: "wrapperElRef",
      class: [`${mergedClsPrefix}-input`, themeClass, mergedStatus && `${mergedClsPrefix}-input--${mergedStatus}-status`, {
        [`${mergedClsPrefix}-input--rtl`]: this.rtlEnabled,
        [`${mergedClsPrefix}-input--disabled`]: this.mergedDisabled,
        [`${mergedClsPrefix}-input--textarea`]: type4 === "textarea",
        [`${mergedClsPrefix}-input--resizable`]: this.resizable && !this.autosize,
        [`${mergedClsPrefix}-input--autosize`]: this.autosize,
        [`${mergedClsPrefix}-input--round`]: this.round && !(type4 === "textarea"),
        [`${mergedClsPrefix}-input--pair`]: this.pair,
        [`${mergedClsPrefix}-input--focus`]: this.mergedFocus,
        [`${mergedClsPrefix}-input--stateful`]: this.stateful
      }],
      style: this.cssVars,
      tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0,
      onFocus: this.handleWrapperFocus,
      onBlur: this.handleWrapperBlur,
      onClick: this.handleClick,
      onMousedown: this.handleMouseDown,
      onMouseenter: this.handleMouseEnter,
      onMouseleave: this.handleMouseLeave,
      onCompositionstart: this.handleCompositionStart,
      onCompositionend: this.handleCompositionEnd,
      onKeyup: this.handleWrapperKeyup,
      onKeydown: this.handleWrapperKeydown
    }, h("div", {
      class: `${mergedClsPrefix}-input-wrapper`
    }, resolveWrappedSlot($slots.prefix, (children) => children && h("div", {
      class: `${mergedClsPrefix}-input__prefix`
    }, children)), type4 === "textarea" ? h(NScrollbar, {
      ref: "textareaScrollbarInstRef",
      class: `${mergedClsPrefix}-input__textarea`,
      container: this.getTextareaScrollContainer,
      triggerDisplayManually: true,
      useUnifiedContainer: true,
      internalHoistYRail: true
    }, {
      default: () => {
        var _a2, _b2;
        const {
          textAreaScrollContainerWidth
        } = this;
        const scrollContainerWidthStyle = {
          width: this.autosize && textAreaScrollContainerWidth && `${textAreaScrollContainerWidth}px`
        };
        return h(Fragment, null, h("textarea", Object.assign({}, this.inputProps, {
          ref: "textareaElRef",
          class: [`${mergedClsPrefix}-input__textarea-el`, (_a2 = this.inputProps) === null || _a2 === void 0 ? void 0 : _a2.class],
          autofocus: this.autofocus,
          rows: Number(this.rows),
          placeholder: this.placeholder,
          value: this.mergedValue,
          disabled: this.mergedDisabled,
          maxlength: countGraphemes ? void 0 : this.maxlength,
          minlength: countGraphemes ? void 0 : this.minlength,
          readonly: this.readonly,
          tabindex: this.passivelyActivated && !this.activated ? -1 : void 0,
          style: [this.textDecorationStyle[0], (_b2 = this.inputProps) === null || _b2 === void 0 ? void 0 : _b2.style, scrollContainerWidthStyle],
          onBlur: this.handleInputBlur,
          onFocus: (e) => {
            this.handleInputFocus(e, 2);
          },
          onInput: this.handleInput,
          onChange: this.handleChange,
          onScroll: this.handleTextAreaScroll
        })), this.showPlaceholder1 ? h("div", {
          class: `${mergedClsPrefix}-input__placeholder`,
          style: [this.placeholderStyle, scrollContainerWidthStyle],
          key: "placeholder"
        }, this.mergedPlaceholder[0]) : null, this.autosize ? h(VResizeObserver, {
          onResize: this.handleTextAreaMirrorResize
        }, {
          default: () => h("div", {
            ref: "textareaMirrorElRef",
            class: `${mergedClsPrefix}-input__textarea-mirror`,
            key: "mirror"
          })
        }) : null);
      }
    }) : h("div", {
      class: `${mergedClsPrefix}-input__input`
    }, h("input", Object.assign({
      type: type4 === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : type4
    }, this.inputProps, {
      ref: "inputElRef",
      class: [`${mergedClsPrefix}-input__input-el`, (_a = this.inputProps) === null || _a === void 0 ? void 0 : _a.class],
      style: [this.textDecorationStyle[0], (_b = this.inputProps) === null || _b === void 0 ? void 0 : _b.style],
      tabindex: this.passivelyActivated && !this.activated ? -1 : void 0,
      placeholder: this.mergedPlaceholder[0],
      disabled: this.mergedDisabled,
      maxlength: countGraphemes ? void 0 : this.maxlength,
      minlength: countGraphemes ? void 0 : this.minlength,
      value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue,
      readonly: this.readonly,
      autofocus: this.autofocus,
      size: this.attrSize,
      onBlur: this.handleInputBlur,
      onFocus: (e) => {
        this.handleInputFocus(e, 0);
      },
      onInput: (e) => {
        this.handleInput(e, 0);
      },
      onChange: (e) => {
        this.handleChange(e, 0);
      }
    })), this.showPlaceholder1 ? h("div", {
      class: `${mergedClsPrefix}-input__placeholder`
    }, h("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? h("div", {
      class: `${mergedClsPrefix}-input__input-mirror`,
      key: "mirror",
      ref: "inputMirrorElRef"
    }, " ") : null), !this.pair && resolveWrappedSlot($slots.suffix, (children) => {
      return children || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? h("div", {
        class: `${mergedClsPrefix}-input__suffix`
      }, [resolveWrappedSlot($slots["clear-icon-placeholder"], (children2) => {
        return (this.clearable || children2) && h(NBaseClear, {
          clsPrefix: mergedClsPrefix,
          show: this.showClearButton,
          onClear: this.handleClear
        }, {
          placeholder: () => children2,
          icon: () => {
            var _a2, _b2;
            return (_b2 = (_a2 = this.$slots)["clear-icon"]) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
          }
        });
      }), !this.internalLoadingBeforeSuffix ? children : null, this.loading !== void 0 ? h(NBaseSuffix, {
        clsPrefix: mergedClsPrefix,
        loading: this.loading,
        showArrow: false,
        showClear: false,
        style: this.cssVars
      }) : null, this.internalLoadingBeforeSuffix ? children : null, this.showCount && this.type !== "textarea" ? h(WordCount, null, {
        default: (props) => {
          var _a2;
          return (_a2 = $slots.count) === null || _a2 === void 0 ? void 0 : _a2.call($slots, props);
        }
      }) : null, this.mergedShowPasswordOn && this.type === "password" ? h("div", {
        class: `${mergedClsPrefix}-input__eye`,
        onMousedown: this.handlePasswordToggleMousedown,
        onClick: this.handlePasswordToggleClick
      }, this.passwordVisible ? resolveSlot($slots["password-visible-icon"], () => [h(NBaseIcon, {
        clsPrefix: mergedClsPrefix
      }, {
        default: () => h(EyeIcon, null)
      })]) : resolveSlot($slots["password-invisible-icon"], () => [h(NBaseIcon, {
        clsPrefix: mergedClsPrefix
      }, {
        default: () => h(EyeOffIcon, null)
      })])) : null]) : null;
    })), this.pair ? h("span", {
      class: `${mergedClsPrefix}-input__separator`
    }, resolveSlot($slots.separator, () => [this.separator])) : null, this.pair ? h("div", {
      class: `${mergedClsPrefix}-input-wrapper`
    }, h("div", {
      class: `${mergedClsPrefix}-input__input`
    }, h("input", {
      ref: "inputEl2Ref",
      type: this.type,
      class: `${mergedClsPrefix}-input__input-el`,
      tabindex: this.passivelyActivated && !this.activated ? -1 : void 0,
      placeholder: this.mergedPlaceholder[1],
      disabled: this.mergedDisabled,
      maxlength: countGraphemes ? void 0 : this.maxlength,
      minlength: countGraphemes ? void 0 : this.minlength,
      value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0,
      readonly: this.readonly,
      style: this.textDecorationStyle[1],
      onBlur: this.handleInputBlur,
      onFocus: (e) => {
        this.handleInputFocus(e, 1);
      },
      onInput: (e) => {
        this.handleInput(e, 1);
      },
      onChange: (e) => {
        this.handleChange(e, 1);
      }
    }), this.showPlaceholder2 ? h("div", {
      class: `${mergedClsPrefix}-input__placeholder`
    }, h("span", null, this.mergedPlaceholder[1])) : null), resolveWrappedSlot($slots.suffix, (children) => {
      return (this.clearable || children) && h("div", {
        class: `${mergedClsPrefix}-input__suffix`
      }, [this.clearable && h(NBaseClear, {
        clsPrefix: mergedClsPrefix,
        show: this.showClearButton,
        onClear: this.handleClear
      }, {
        icon: () => {
          var _a2;
          return (_a2 = $slots["clear-icon"]) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
        },
        placeholder: () => {
          var _a2;
          return (_a2 = $slots["clear-icon-placeholder"]) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
        }
      }), children]);
    })) : null, this.mergedBordered ? h("div", {
      class: `${mergedClsPrefix}-input__border`
    }) : null, this.mergedBordered ? h("div", {
      class: `${mergedClsPrefix}-input__state-border`
    }) : null, this.showCount && type4 === "textarea" ? h(WordCount, null, {
      default: (props) => {
        var _a2;
        const {
          renderCount
        } = this;
        if (renderCount) {
          return renderCount(props);
        }
        return (_a2 = $slots.count) === null || _a2 === void 0 ? void 0 : _a2.call($slots, props);
      }
    }) : null);
  }
});
const style$h = cB("input-group", `
 display: inline-flex;
 width: 100%;
 flex-wrap: nowrap;
 vertical-align: bottom;
`, [c$1(">", [cB("input", [c$1("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), c$1("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 margin-left: -1px!important;
 `)]), cB("button", [c$1("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [cE("state-border, border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)]), c$1("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [cE("state-border, border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])]), c$1("*", [c$1("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [c$1(">", [cB("input", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cB("base-selection", [cB("base-selection-label", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cB("base-selection-tags", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cE("box-shadow, border, state-border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)])])]), c$1("&:not(:first-child)", `
 margin-left: -1px!important;
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [c$1(">", [cB("input", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cB("base-selection", [cB("base-selection-label", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cB("base-selection-tags", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cE("box-shadow, border, state-border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])])])])])]);
const inputGroupProps = {};
const NInputGroup = /* @__PURE__ */ defineComponent({
  name: "InputGroup",
  props: inputGroupProps,
  setup(props) {
    const {
      mergedClsPrefixRef
    } = useConfig(props);
    useStyle("-input-group", style$h, mergedClsPrefixRef);
    return {
      mergedClsPrefix: mergedClsPrefixRef
    };
  },
  render() {
    const {
      mergedClsPrefix
    } = this;
    return h("div", {
      class: `${mergedClsPrefix}-input-group`
    }, this.$slots);
  }
});
function createHoverColor(rgb) {
  return composite(rgb, [255, 255, 255, 0.16]);
}
function createPressedColor(rgb) {
  return composite(rgb, [0, 0, 0, 0.12]);
}
const buttonGroupInjectionKey = createInjectionKey("n-button-group");
const commonVariables$4 = {
  paddingTiny: "0 6px",
  paddingSmall: "0 10px",
  paddingMedium: "0 14px",
  paddingLarge: "0 18px",
  paddingRoundTiny: "0 10px",
  paddingRoundSmall: "0 14px",
  paddingRoundMedium: "0 18px",
  paddingRoundLarge: "0 22px",
  iconMarginTiny: "6px",
  iconMarginSmall: "6px",
  iconMarginMedium: "6px",
  iconMarginLarge: "6px",
  iconSizeTiny: "14px",
  iconSizeSmall: "18px",
  iconSizeMedium: "18px",
  iconSizeLarge: "20px",
  rippleDuration: ".6s"
};
function self$h(vars) {
  const {
    heightTiny,
    heightSmall,
    heightMedium,
    heightLarge,
    borderRadius,
    fontSizeTiny,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    opacityDisabled,
    textColor2,
    textColor3,
    primaryColorHover,
    primaryColorPressed,
    borderColor,
    primaryColor,
    baseColor,
    infoColor,
    infoColorHover,
    infoColorPressed,
    successColor,
    successColorHover,
    successColorPressed,
    warningColor,
    warningColorHover,
    warningColorPressed,
    errorColor,
    errorColorHover,
    errorColorPressed,
    fontWeight,
    buttonColor2,
    buttonColor2Hover,
    buttonColor2Pressed,
    fontWeightStrong
  } = vars;
  return Object.assign(Object.assign({}, commonVariables$4), {
    heightTiny,
    heightSmall,
    heightMedium,
    heightLarge,
    borderRadiusTiny: borderRadius,
    borderRadiusSmall: borderRadius,
    borderRadiusMedium: borderRadius,
    borderRadiusLarge: borderRadius,
    fontSizeTiny,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    opacityDisabled,
    // secondary
    colorOpacitySecondary: "0.16",
    colorOpacitySecondaryHover: "0.22",
    colorOpacitySecondaryPressed: "0.28",
    colorSecondary: buttonColor2,
    colorSecondaryHover: buttonColor2Hover,
    colorSecondaryPressed: buttonColor2Pressed,
    // tertiary
    colorTertiary: buttonColor2,
    colorTertiaryHover: buttonColor2Hover,
    colorTertiaryPressed: buttonColor2Pressed,
    // quaternary
    colorQuaternary: "#0000",
    colorQuaternaryHover: buttonColor2Hover,
    colorQuaternaryPressed: buttonColor2Pressed,
    // default type
    color: "#0000",
    colorHover: "#0000",
    colorPressed: "#0000",
    colorFocus: "#0000",
    colorDisabled: "#0000",
    textColor: textColor2,
    textColorTertiary: textColor3,
    textColorHover: primaryColorHover,
    textColorPressed: primaryColorPressed,
    textColorFocus: primaryColorHover,
    textColorDisabled: textColor2,
    textColorText: textColor2,
    textColorTextHover: primaryColorHover,
    textColorTextPressed: primaryColorPressed,
    textColorTextFocus: primaryColorHover,
    textColorTextDisabled: textColor2,
    textColorGhost: textColor2,
    textColorGhostHover: primaryColorHover,
    textColorGhostPressed: primaryColorPressed,
    textColorGhostFocus: primaryColorHover,
    textColorGhostDisabled: textColor2,
    border: `1px solid ${borderColor}`,
    borderHover: `1px solid ${primaryColorHover}`,
    borderPressed: `1px solid ${primaryColorPressed}`,
    borderFocus: `1px solid ${primaryColorHover}`,
    borderDisabled: `1px solid ${borderColor}`,
    rippleColor: primaryColor,
    // primary
    colorPrimary: primaryColor,
    colorHoverPrimary: primaryColorHover,
    colorPressedPrimary: primaryColorPressed,
    colorFocusPrimary: primaryColorHover,
    colorDisabledPrimary: primaryColor,
    textColorPrimary: baseColor,
    textColorHoverPrimary: baseColor,
    textColorPressedPrimary: baseColor,
    textColorFocusPrimary: baseColor,
    textColorDisabledPrimary: baseColor,
    textColorTextPrimary: primaryColor,
    textColorTextHoverPrimary: primaryColorHover,
    textColorTextPressedPrimary: primaryColorPressed,
    textColorTextFocusPrimary: primaryColorHover,
    textColorTextDisabledPrimary: textColor2,
    textColorGhostPrimary: primaryColor,
    textColorGhostHoverPrimary: primaryColorHover,
    textColorGhostPressedPrimary: primaryColorPressed,
    textColorGhostFocusPrimary: primaryColorHover,
    textColorGhostDisabledPrimary: primaryColor,
    borderPrimary: `1px solid ${primaryColor}`,
    borderHoverPrimary: `1px solid ${primaryColorHover}`,
    borderPressedPrimary: `1px solid ${primaryColorPressed}`,
    borderFocusPrimary: `1px solid ${primaryColorHover}`,
    borderDisabledPrimary: `1px solid ${primaryColor}`,
    rippleColorPrimary: primaryColor,
    // info
    colorInfo: infoColor,
    colorHoverInfo: infoColorHover,
    colorPressedInfo: infoColorPressed,
    colorFocusInfo: infoColorHover,
    colorDisabledInfo: infoColor,
    textColorInfo: baseColor,
    textColorHoverInfo: baseColor,
    textColorPressedInfo: baseColor,
    textColorFocusInfo: baseColor,
    textColorDisabledInfo: baseColor,
    textColorTextInfo: infoColor,
    textColorTextHoverInfo: infoColorHover,
    textColorTextPressedInfo: infoColorPressed,
    textColorTextFocusInfo: infoColorHover,
    textColorTextDisabledInfo: textColor2,
    textColorGhostInfo: infoColor,
    textColorGhostHoverInfo: infoColorHover,
    textColorGhostPressedInfo: infoColorPressed,
    textColorGhostFocusInfo: infoColorHover,
    textColorGhostDisabledInfo: infoColor,
    borderInfo: `1px solid ${infoColor}`,
    borderHoverInfo: `1px solid ${infoColorHover}`,
    borderPressedInfo: `1px solid ${infoColorPressed}`,
    borderFocusInfo: `1px solid ${infoColorHover}`,
    borderDisabledInfo: `1px solid ${infoColor}`,
    rippleColorInfo: infoColor,
    // success
    colorSuccess: successColor,
    colorHoverSuccess: successColorHover,
    colorPressedSuccess: successColorPressed,
    colorFocusSuccess: successColorHover,
    colorDisabledSuccess: successColor,
    textColorSuccess: baseColor,
    textColorHoverSuccess: baseColor,
    textColorPressedSuccess: baseColor,
    textColorFocusSuccess: baseColor,
    textColorDisabledSuccess: baseColor,
    textColorTextSuccess: successColor,
    textColorTextHoverSuccess: successColorHover,
    textColorTextPressedSuccess: successColorPressed,
    textColorTextFocusSuccess: successColorHover,
    textColorTextDisabledSuccess: textColor2,
    textColorGhostSuccess: successColor,
    textColorGhostHoverSuccess: successColorHover,
    textColorGhostPressedSuccess: successColorPressed,
    textColorGhostFocusSuccess: successColorHover,
    textColorGhostDisabledSuccess: successColor,
    borderSuccess: `1px solid ${successColor}`,
    borderHoverSuccess: `1px solid ${successColorHover}`,
    borderPressedSuccess: `1px solid ${successColorPressed}`,
    borderFocusSuccess: `1px solid ${successColorHover}`,
    borderDisabledSuccess: `1px solid ${successColor}`,
    rippleColorSuccess: successColor,
    // warning
    colorWarning: warningColor,
    colorHoverWarning: warningColorHover,
    colorPressedWarning: warningColorPressed,
    colorFocusWarning: warningColorHover,
    colorDisabledWarning: warningColor,
    textColorWarning: baseColor,
    textColorHoverWarning: baseColor,
    textColorPressedWarning: baseColor,
    textColorFocusWarning: baseColor,
    textColorDisabledWarning: baseColor,
    textColorTextWarning: warningColor,
    textColorTextHoverWarning: warningColorHover,
    textColorTextPressedWarning: warningColorPressed,
    textColorTextFocusWarning: warningColorHover,
    textColorTextDisabledWarning: textColor2,
    textColorGhostWarning: warningColor,
    textColorGhostHoverWarning: warningColorHover,
    textColorGhostPressedWarning: warningColorPressed,
    textColorGhostFocusWarning: warningColorHover,
    textColorGhostDisabledWarning: warningColor,
    borderWarning: `1px solid ${warningColor}`,
    borderHoverWarning: `1px solid ${warningColorHover}`,
    borderPressedWarning: `1px solid ${warningColorPressed}`,
    borderFocusWarning: `1px solid ${warningColorHover}`,
    borderDisabledWarning: `1px solid ${warningColor}`,
    rippleColorWarning: warningColor,
    // error
    colorError: errorColor,
    colorHoverError: errorColorHover,
    colorPressedError: errorColorPressed,
    colorFocusError: errorColorHover,
    colorDisabledError: errorColor,
    textColorError: baseColor,
    textColorHoverError: baseColor,
    textColorPressedError: baseColor,
    textColorFocusError: baseColor,
    textColorDisabledError: baseColor,
    textColorTextError: errorColor,
    textColorTextHoverError: errorColorHover,
    textColorTextPressedError: errorColorPressed,
    textColorTextFocusError: errorColorHover,
    textColorTextDisabledError: textColor2,
    textColorGhostError: errorColor,
    textColorGhostHoverError: errorColorHover,
    textColorGhostPressedError: errorColorPressed,
    textColorGhostFocusError: errorColorHover,
    textColorGhostDisabledError: errorColor,
    borderError: `1px solid ${errorColor}`,
    borderHoverError: `1px solid ${errorColorHover}`,
    borderPressedError: `1px solid ${errorColorPressed}`,
    borderFocusError: `1px solid ${errorColorHover}`,
    borderDisabledError: `1px solid ${errorColor}`,
    rippleColorError: errorColor,
    waveOpacity: "0.6",
    fontWeight,
    fontWeightStrong
  });
}
const buttonLight = {
  name: "Button",
  common: commonLight,
  self: self$h
};
const buttonLight$1 = buttonLight;
const style$g = c$1([cB("button", `
 margin: 0;
 font-weight: var(--n-font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--n-padding);
 height: var(--n-height);
 font-size: var(--n-font-size);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 width: var(--n-width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 -webkit-user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("color", [cE("border", {
  borderColor: "var(--n-border-color)"
}), cM("disabled", [cE("border", {
  borderColor: "var(--n-border-color-disabled)"
})]), cNotM("disabled", [c$1("&:focus", [cE("state-border", {
  borderColor: "var(--n-border-color-focus)"
})]), c$1("&:hover", [cE("state-border", {
  borderColor: "var(--n-border-color-hover)"
})]), c$1("&:active", [cE("state-border", {
  borderColor: "var(--n-border-color-pressed)"
})]), cM("pressed", [cE("state-border", {
  borderColor: "var(--n-border-color-pressed)"
})])])]), cM("disabled", {
  backgroundColor: "var(--n-color-disabled)",
  color: "var(--n-text-color-disabled)"
}, [cE("border", {
  border: "var(--n-border-disabled)"
})]), cNotM("disabled", [c$1("&:focus", {
  backgroundColor: "var(--n-color-focus)",
  color: "var(--n-text-color-focus)"
}, [cE("state-border", {
  border: "var(--n-border-focus)"
})]), c$1("&:hover", {
  backgroundColor: "var(--n-color-hover)",
  color: "var(--n-text-color-hover)"
}, [cE("state-border", {
  border: "var(--n-border-hover)"
})]), c$1("&:active", {
  backgroundColor: "var(--n-color-pressed)",
  color: "var(--n-text-color-pressed)"
}, [cE("state-border", {
  border: "var(--n-border-pressed)"
})]), cM("pressed", {
  backgroundColor: "var(--n-color-pressed)",
  color: "var(--n-text-color-pressed)"
}, [cE("state-border", {
  border: "var(--n-border-pressed)"
})])]), cM("loading", "cursor: wait;"), cB("base-wave", `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--n-ripple-duration);
 animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
 `, [cM("active", {
  zIndex: 1,
  animationName: "button-wave-spread, button-wave-opacity"
})]), isBrowser$2 && "MozBoxSizing" in document.createElement("div").style ? c$1("&::moz-focus-inner", {
  border: 0
}) : null, cE("border, state-border", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 `), cE("border", {
  border: "var(--n-border)"
}), cE("state-border", {
  border: "var(--n-border)",
  borderColor: "#0000",
  zIndex: 1
}), cE("icon", `
 margin: var(--n-icon-margin);
 margin-left: 0;
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 max-width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB("icon-slot", `
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [iconSwitchTransition({
  top: "50%",
  originalTransform: "translateY(-50%)"
})]), fadeInWidthExpandTransition()]), cE("content", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 min-width: 0;
 `, [c$1("~", [cE("icon", {
  margin: "var(--n-icon-margin)",
  marginRight: 0
})])]), cM("block", `
 display: flex;
 width: 100%;
 `), cM("dashed", [cE("border, state-border", {
  borderStyle: "dashed !important"
})]), cM("disabled", {
  cursor: "not-allowed",
  opacity: "var(--n-opacity-disabled)"
})]), c$1("@keyframes button-wave-spread", {
  from: {
    boxShadow: "0 0 0.5px 0 var(--n-ripple-color)"
  },
  to: {
    // don't use exact 5px since chrome will display the animation with glitches
    boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)"
  }
}), c$1("@keyframes button-wave-opacity", {
  from: {
    opacity: "var(--n-wave-opacity)"
  },
  to: {
    opacity: 0
  }
})]);
const buttonProps = Object.assign(Object.assign({}, useTheme.props), {
  color: String,
  textColor: String,
  text: Boolean,
  block: Boolean,
  loading: Boolean,
  disabled: Boolean,
  circle: Boolean,
  size: String,
  ghost: Boolean,
  round: Boolean,
  secondary: Boolean,
  tertiary: Boolean,
  quaternary: Boolean,
  strong: Boolean,
  focusable: {
    type: Boolean,
    default: true
  },
  keyboard: {
    type: Boolean,
    default: true
  },
  tag: {
    type: String,
    default: "button"
  },
  type: {
    type: String,
    default: "default"
  },
  dashed: Boolean,
  renderIcon: Function,
  iconPlacement: {
    type: String,
    default: "left"
  },
  attrType: {
    type: String,
    default: "button"
  },
  bordered: {
    type: Boolean,
    default: true
  },
  onClick: [Function, Array],
  nativeFocusBehavior: {
    type: Boolean,
    default: !isSafari
  }
});
const Button = /* @__PURE__ */ defineComponent({
  name: "Button",
  props: buttonProps,
  setup(props) {
    const selfElRef = ref(null);
    const waveElRef = ref(null);
    const enterPressedRef = ref(false);
    const showBorderRef = useMemo(() => {
      return !props.quaternary && !props.tertiary && !props.secondary && !props.text && (!props.color || props.ghost || props.dashed) && props.bordered;
    });
    const NButtonGroup = inject(buttonGroupInjectionKey, {});
    const {
      mergedSizeRef
    } = useFormItem({}, {
      defaultSize: "medium",
      mergedSize: (NFormItem2) => {
        const {
          size: size2
        } = props;
        if (size2)
          return size2;
        const {
          size: buttonGroupSize
        } = NButtonGroup;
        if (buttonGroupSize)
          return buttonGroupSize;
        const {
          mergedSize: formItemSize2
        } = NFormItem2 || {};
        if (formItemSize2) {
          return formItemSize2.value;
        }
        return "medium";
      }
    });
    const mergedFocusableRef = computed(() => {
      return props.focusable && !props.disabled;
    });
    const handleMousedown = (e) => {
      var _a;
      if (!mergedFocusableRef.value) {
        e.preventDefault();
      }
      if (props.nativeFocusBehavior) {
        return;
      }
      e.preventDefault();
      if (props.disabled) {
        return;
      }
      if (mergedFocusableRef.value) {
        (_a = selfElRef.value) === null || _a === void 0 ? void 0 : _a.focus({
          preventScroll: true
        });
      }
    };
    const handleClick2 = (e) => {
      var _a;
      if (!props.disabled && !props.loading) {
        const {
          onClick
        } = props;
        if (onClick)
          call(onClick, e);
        if (!props.text) {
          (_a = waveElRef.value) === null || _a === void 0 ? void 0 : _a.play();
        }
      }
    };
    const handleKeyup = (e) => {
      switch (e.key) {
        case "Enter":
          if (!props.keyboard) {
            return;
          }
          enterPressedRef.value = false;
      }
    };
    const handleKeydown = (e) => {
      switch (e.key) {
        case "Enter":
          if (!props.keyboard || props.loading) {
            e.preventDefault();
            return;
          }
          enterPressedRef.value = true;
      }
    };
    const handleBlur = () => {
      enterPressedRef.value = false;
    };
    const {
      inlineThemeDisabled,
      mergedClsPrefixRef,
      mergedRtlRef
    } = useConfig(props);
    const themeRef = useTheme("Button", "-button", style$g, buttonLight$1, props, mergedClsPrefixRef);
    const rtlEnabledRef = useRtl("Button", mergedRtlRef, mergedClsPrefixRef);
    const cssVarsRef = computed(() => {
      const theme = themeRef.value;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2,
          cubicBezierEaseOut: cubicBezierEaseOut2
        },
        self: self2
      } = theme;
      const {
        rippleDuration,
        opacityDisabled,
        fontWeight,
        fontWeightStrong
      } = self2;
      const size2 = mergedSizeRef.value;
      const {
        dashed,
        type: type4,
        ghost,
        text,
        color,
        round: round2,
        circle,
        textColor,
        secondary,
        tertiary,
        quaternary,
        strong
      } = props;
      const fontProps = {
        "font-weight": strong ? fontWeightStrong : fontWeight
      };
      let colorProps = {
        "--n-color": "initial",
        "--n-color-hover": "initial",
        "--n-color-pressed": "initial",
        "--n-color-focus": "initial",
        "--n-color-disabled": "initial",
        "--n-ripple-color": "initial",
        "--n-text-color": "initial",
        "--n-text-color-hover": "initial",
        "--n-text-color-pressed": "initial",
        "--n-text-color-focus": "initial",
        "--n-text-color-disabled": "initial"
      };
      const typeIsTertiary = type4 === "tertiary";
      const typeIsDefault = type4 === "default";
      const mergedType = typeIsTertiary ? "default" : type4;
      if (text) {
        const propTextColor = textColor || color;
        const mergedTextColor = propTextColor || self2[createKey("textColorText", mergedType)];
        colorProps = {
          "--n-color": "#0000",
          "--n-color-hover": "#0000",
          "--n-color-pressed": "#0000",
          "--n-color-focus": "#0000",
          "--n-color-disabled": "#0000",
          "--n-ripple-color": "#0000",
          "--n-text-color": mergedTextColor,
          "--n-text-color-hover": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
          "--n-text-color-pressed": propTextColor ? createPressedColor(propTextColor) : self2[createKey("textColorTextPressed", mergedType)],
          "--n-text-color-focus": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
          "--n-text-color-disabled": propTextColor || self2[createKey("textColorTextDisabled", mergedType)]
        };
      } else if (ghost || dashed) {
        const mergedTextColor = textColor || color;
        colorProps = {
          "--n-color": "#0000",
          "--n-color-hover": "#0000",
          "--n-color-pressed": "#0000",
          "--n-color-focus": "#0000",
          "--n-color-disabled": "#0000",
          "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
          "--n-text-color": mergedTextColor || self2[createKey("textColorGhost", mergedType)],
          "--n-text-color-hover": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
          "--n-text-color-pressed": mergedTextColor ? createPressedColor(mergedTextColor) : self2[createKey("textColorGhostPressed", mergedType)],
          "--n-text-color-focus": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
          "--n-text-color-disabled": mergedTextColor || self2[createKey("textColorGhostDisabled", mergedType)]
        };
      } else if (secondary) {
        const typeTextColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
        const mergedTextColor = color || typeTextColor;
        const isColoredType = type4 !== "default" && type4 !== "tertiary";
        colorProps = {
          "--n-color": isColoredType ? changeColor(mergedTextColor, {
            alpha: Number(self2.colorOpacitySecondary)
          }) : self2.colorSecondary,
          "--n-color-hover": isColoredType ? changeColor(mergedTextColor, {
            alpha: Number(self2.colorOpacitySecondaryHover)
          }) : self2.colorSecondaryHover,
          "--n-color-pressed": isColoredType ? changeColor(mergedTextColor, {
            alpha: Number(self2.colorOpacitySecondaryPressed)
          }) : self2.colorSecondaryPressed,
          "--n-color-focus": isColoredType ? changeColor(mergedTextColor, {
            alpha: Number(self2.colorOpacitySecondaryHover)
          }) : self2.colorSecondaryHover,
          "--n-color-disabled": self2.colorSecondary,
          "--n-ripple-color": "#0000",
          "--n-text-color": mergedTextColor,
          "--n-text-color-hover": mergedTextColor,
          "--n-text-color-pressed": mergedTextColor,
          "--n-text-color-focus": mergedTextColor,
          "--n-text-color-disabled": mergedTextColor
        };
      } else if (tertiary || quaternary) {
        const typeColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
        const mergedColor = color || typeColor;
        if (tertiary) {
          colorProps["--n-color"] = self2.colorTertiary;
          colorProps["--n-color-hover"] = self2.colorTertiaryHover;
          colorProps["--n-color-pressed"] = self2.colorTertiaryPressed;
          colorProps["--n-color-focus"] = self2.colorSecondaryHover;
          colorProps["--n-color-disabled"] = self2.colorTertiary;
        } else {
          colorProps["--n-color"] = self2.colorQuaternary;
          colorProps["--n-color-hover"] = self2.colorQuaternaryHover;
          colorProps["--n-color-pressed"] = self2.colorQuaternaryPressed;
          colorProps["--n-color-focus"] = self2.colorQuaternaryHover;
          colorProps["--n-color-disabled"] = self2.colorQuaternary;
        }
        colorProps["--n-ripple-color"] = "#0000";
        colorProps["--n-text-color"] = mergedColor;
        colorProps["--n-text-color-hover"] = mergedColor;
        colorProps["--n-text-color-pressed"] = mergedColor;
        colorProps["--n-text-color-focus"] = mergedColor;
        colorProps["--n-text-color-disabled"] = mergedColor;
      } else {
        colorProps = {
          "--n-color": color || self2[createKey("color", mergedType)],
          "--n-color-hover": color ? createHoverColor(color) : self2[createKey("colorHover", mergedType)],
          "--n-color-pressed": color ? createPressedColor(color) : self2[createKey("colorPressed", mergedType)],
          "--n-color-focus": color ? createHoverColor(color) : self2[createKey("colorFocus", mergedType)],
          "--n-color-disabled": color || self2[createKey("colorDisabled", mergedType)],
          "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
          "--n-text-color": textColor || (color ? self2.textColorPrimary : typeIsTertiary ? self2.textColorTertiary : self2[createKey("textColor", mergedType)]),
          "--n-text-color-hover": textColor || (color ? self2.textColorHoverPrimary : self2[createKey("textColorHover", mergedType)]),
          "--n-text-color-pressed": textColor || (color ? self2.textColorPressedPrimary : self2[createKey("textColorPressed", mergedType)]),
          "--n-text-color-focus": textColor || (color ? self2.textColorFocusPrimary : self2[createKey("textColorFocus", mergedType)]),
          "--n-text-color-disabled": textColor || (color ? self2.textColorDisabledPrimary : self2[createKey("textColorDisabled", mergedType)])
        };
      }
      let borderProps = {
        "--n-border": "initial",
        "--n-border-hover": "initial",
        "--n-border-pressed": "initial",
        "--n-border-focus": "initial",
        "--n-border-disabled": "initial"
      };
      if (text) {
        borderProps = {
          "--n-border": "none",
          "--n-border-hover": "none",
          "--n-border-pressed": "none",
          "--n-border-focus": "none",
          "--n-border-disabled": "none"
        };
      } else {
        borderProps = {
          "--n-border": self2[createKey("border", mergedType)],
          "--n-border-hover": self2[createKey("borderHover", mergedType)],
          "--n-border-pressed": self2[createKey("borderPressed", mergedType)],
          "--n-border-focus": self2[createKey("borderFocus", mergedType)],
          "--n-border-disabled": self2[createKey("borderDisabled", mergedType)]
        };
      }
      const {
        [createKey("height", size2)]: height,
        [createKey("fontSize", size2)]: fontSize2,
        [createKey("padding", size2)]: padding,
        [createKey("paddingRound", size2)]: paddingRound,
        [createKey("iconSize", size2)]: iconSize,
        [createKey("borderRadius", size2)]: borderRadius,
        [createKey("iconMargin", size2)]: iconMargin,
        waveOpacity
      } = self2;
      const sizeProps = {
        "--n-width": circle && !text ? height : "initial",
        "--n-height": text ? "initial" : height,
        "--n-font-size": fontSize2,
        "--n-padding": circle ? "initial" : text ? "initial" : round2 ? paddingRound : padding,
        "--n-icon-size": iconSize,
        "--n-icon-margin": iconMargin,
        "--n-border-radius": text ? "initial" : circle || round2 ? height : borderRadius
      };
      return Object.assign(Object.assign(Object.assign(Object.assign({
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-bezier-ease-out": cubicBezierEaseOut2,
        "--n-ripple-duration": rippleDuration,
        "--n-opacity-disabled": opacityDisabled,
        "--n-wave-opacity": waveOpacity
      }, fontProps), colorProps), borderProps), sizeProps);
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("button", computed(() => {
      let hash2 = "";
      const {
        dashed,
        type: type4,
        ghost,
        text,
        color,
        round: round2,
        circle,
        textColor,
        secondary,
        tertiary,
        quaternary,
        strong
      } = props;
      if (dashed)
        hash2 += "a";
      if (ghost)
        hash2 += "b";
      if (text)
        hash2 += "c";
      if (round2)
        hash2 += "d";
      if (circle)
        hash2 += "e";
      if (secondary)
        hash2 += "f";
      if (tertiary)
        hash2 += "g";
      if (quaternary)
        hash2 += "h";
      if (strong)
        hash2 += "i";
      if (color)
        hash2 += `j${color2Class(color)}`;
      if (textColor)
        hash2 += `k${color2Class(textColor)}`;
      const {
        value: size2
      } = mergedSizeRef;
      hash2 += `l${size2[0]}`;
      hash2 += `m${type4[0]}`;
      return hash2;
    }), cssVarsRef, props) : void 0;
    return {
      selfElRef,
      waveElRef,
      mergedClsPrefix: mergedClsPrefixRef,
      mergedFocusable: mergedFocusableRef,
      mergedSize: mergedSizeRef,
      showBorder: showBorderRef,
      enterPressed: enterPressedRef,
      rtlEnabled: rtlEnabledRef,
      handleMousedown,
      handleKeydown,
      handleBlur,
      handleKeyup,
      handleClick: handleClick2,
      customColorCssVars: computed(() => {
        const {
          color
        } = props;
        if (!color)
          return null;
        const hoverColor = createHoverColor(color);
        return {
          "--n-border-color": color,
          "--n-border-color-hover": hoverColor,
          "--n-border-color-pressed": createPressedColor(color),
          "--n-border-color-focus": hoverColor,
          "--n-border-color-disabled": color
        };
      }),
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const {
      mergedClsPrefix,
      tag: Component,
      onRender
    } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    const children = resolveWrappedSlot(this.$slots.default, (children2) => children2 && h("span", {
      class: `${mergedClsPrefix}-button__content`
    }, children2));
    return h(Component, {
      ref: "selfElRef",
      class: [
        this.themeClass,
        `${mergedClsPrefix}-button`,
        `${mergedClsPrefix}-button--${this.type}-type`,
        `${mergedClsPrefix}-button--${this.mergedSize}-type`,
        this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
        this.disabled && `${mergedClsPrefix}-button--disabled`,
        this.block && `${mergedClsPrefix}-button--block`,
        this.enterPressed && `${mergedClsPrefix}-button--pressed`,
        !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
        this.color && `${mergedClsPrefix}-button--color`,
        this.secondary && `${mergedClsPrefix}-button--secondary`,
        this.loading && `${mergedClsPrefix}-button--loading`,
        this.ghost && `${mergedClsPrefix}-button--ghost`
        // required for button group border collapse
      ],
      tabindex: this.mergedFocusable ? 0 : -1,
      type: this.attrType,
      style: this.cssVars,
      disabled: this.disabled,
      onClick: this.handleClick,
      onBlur: this.handleBlur,
      onMousedown: this.handleMousedown,
      onKeyup: this.handleKeyup,
      onKeydown: this.handleKeydown
    }, this.iconPlacement === "right" && children, h(NFadeInExpandTransition, {
      width: true
    }, {
      default: () => resolveWrappedSlot(this.$slots.icon, (children2) => (this.loading || this.renderIcon || children2) && h("span", {
        class: `${mergedClsPrefix}-button__icon`,
        style: {
          margin: isSlotEmpty(this.$slots.default) ? "0" : ""
        }
      }, h(NIconSwitchTransition, null, {
        default: () => this.loading ? h(NBaseLoading, {
          clsPrefix: mergedClsPrefix,
          key: "loading",
          class: `${mergedClsPrefix}-icon-slot`,
          strokeWidth: 20
        }) : h("div", {
          key: "icon",
          class: `${mergedClsPrefix}-icon-slot`,
          role: "none"
        }, this.renderIcon ? this.renderIcon() : children2)
      })))
    }), this.iconPlacement === "left" && children, !this.text ? h(NBaseWave, {
      ref: "waveElRef",
      clsPrefix: mergedClsPrefix
    }) : null, this.showBorder ? h("div", {
      "aria-hidden": true,
      class: `${mergedClsPrefix}-button__border`,
      style: this.customColorCssVars
    }) : null, this.showBorder ? h("div", {
      "aria-hidden": true,
      class: `${mergedClsPrefix}-button__state-border`,
      style: this.customColorCssVars
    }) : null);
  }
});
const NButton = Button;
const XButton = Button;
function self$g(vars) {
  const {
    fontSize: fontSize2,
    boxShadow2,
    popoverColor,
    textColor2,
    borderRadius,
    borderColor,
    heightSmall,
    heightMedium,
    heightLarge,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    dividerColor
  } = vars;
  return {
    panelFontSize: fontSize2,
    boxShadow: boxShadow2,
    color: popoverColor,
    textColor: textColor2,
    borderRadius,
    border: `1px solid ${borderColor}`,
    heightSmall,
    heightMedium,
    heightLarge,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    dividerColor
  };
}
const colorPickerLight = createTheme({
  name: "ColorPicker",
  common: commonLight,
  peers: {
    Input: inputLight$1,
    Button: buttonLight$1
  },
  self: self$g
});
const colorPickerLight$1 = colorPickerLight;
function deriveDefaultValue(modes, showAlpha) {
  const mode = modes[0];
  switch (mode) {
    case "hex":
      return showAlpha ? "#000000FF" : "#000000";
    case "rgb":
      return showAlpha ? "rgba(0, 0, 0, 1)" : "rgb(0, 0, 0)";
    case "hsl":
      return showAlpha ? "hsla(0, 0%, 0%, 1)" : "hsl(0, 0%, 0%)";
    case "hsv":
      return showAlpha ? "hsva(0, 0%, 0%, 1)" : "hsv(0, 0%, 0%)";
  }
  return "#000000";
}
function getModeFromValue(color) {
  if (color === null)
    return null;
  if (/^ *#/.test(color))
    return "hex";
  if (color.includes("rgb"))
    return "rgb";
  if (color.includes("hsl"))
    return "hsl";
  if (color.includes("hsv"))
    return "hsv";
  return null;
}
function normalizeHue(hue) {
  hue = Math.round(hue);
  return hue >= 360 ? 359 : hue < 0 ? 0 : hue;
}
function normalizeAlpha(alpha) {
  alpha = Math.round(alpha * 100) / 100;
  return alpha > 1 ? 1 : alpha < 0 ? 0 : alpha;
}
const convert = {
  rgb: {
    hex(value) {
      return toHexaString(rgba(value));
    },
    hsl(value) {
      const [r, g, b, a] = rgba(value);
      return toHslaString([...rgb2hsl(r, g, b), a]);
    },
    hsv(value) {
      const [r, g, b, a] = rgba(value);
      return toHsvaString([...rgb2hsv(r, g, b), a]);
    }
  },
  hex: {
    rgb(value) {
      return toRgbaString(rgba(value));
    },
    hsl(value) {
      const [r, g, b, a] = rgba(value);
      return toHslaString([...rgb2hsl(r, g, b), a]);
    },
    hsv(value) {
      const [r, g, b, a] = rgba(value);
      return toHsvaString([...rgb2hsv(r, g, b), a]);
    }
  },
  hsl: {
    hex(value) {
      const [h2, s, l, a] = hsla(value);
      return toHexaString([...hsl2rgb(h2, s, l), a]);
    },
    rgb(value) {
      const [h2, s, l, a] = hsla(value);
      return toRgbaString([...hsl2rgb(h2, s, l), a]);
    },
    hsv(value) {
      const [h2, s, l, a] = hsla(value);
      return toHsvaString([...hsl2hsv(h2, s, l), a]);
    }
  },
  hsv: {
    hex(value) {
      const [h2, s, v, a] = hsva(value);
      return toHexaString([...hsv2rgb(h2, s, v), a]);
    },
    rgb(value) {
      const [h2, s, v, a] = hsva(value);
      return toRgbaString([...hsv2rgb(h2, s, v), a]);
    },
    hsl(value) {
      const [h2, s, v, a] = hsva(value);
      return toHslaString([...hsv2hsl(h2, s, v), a]);
    }
  }
};
function convertColor(value, mode, originalMode) {
  originalMode = originalMode || getModeFromValue(value);
  if (!originalMode)
    return null;
  if (originalMode === mode)
    return value;
  const conversions = convert[originalMode];
  return conversions[mode](value);
}
const HANDLE_SIZE$2 = "12px";
const HANDLE_SIZE_NUM$1 = 12;
const RADIUS$2 = "6px";
const RADIUS_NUM = 6;
const GRADIENT = "linear-gradient(90deg,red,#ff0 16.66%,#0f0 33.33%,#0ff 50%,#00f 66.66%,#f0f 83.33%,red)";
const HueSlider = /* @__PURE__ */ defineComponent({
  name: "HueSlider",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    hue: {
      type: Number,
      required: true
    },
    onUpdateHue: {
      type: Function,
      required: true
    },
    onComplete: Function
  },
  setup(props) {
    const railRef = ref(null);
    function handleMouseDown(e) {
      if (!railRef.value)
        return;
      on("mousemove", document, handleMouseMove);
      on("mouseup", document, handleMouseUp);
      handleMouseMove(e);
    }
    function handleMouseMove(e) {
      const {
        value: railEl
      } = railRef;
      if (!railEl)
        return;
      const {
        width,
        left
      } = railEl.getBoundingClientRect();
      const newHue = normalizeHue((e.clientX - left - RADIUS_NUM) / (width - HANDLE_SIZE_NUM$1) * 360);
      props.onUpdateHue(newHue);
    }
    function handleMouseUp() {
      var _a;
      off("mousemove", document, handleMouseMove);
      off("mouseup", document, handleMouseUp);
      (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
    }
    return {
      railRef,
      handleMouseDown
    };
  },
  render() {
    const {
      clsPrefix
    } = this;
    return h("div", {
      class: `${clsPrefix}-color-picker-slider`,
      style: {
        height: HANDLE_SIZE$2,
        borderRadius: RADIUS$2
      }
    }, h("div", {
      ref: "railRef",
      style: {
        boxShadow: "inset 0 0 2px 0 rgba(0, 0, 0, .24)",
        boxSizing: "border-box",
        backgroundImage: GRADIENT,
        height: HANDLE_SIZE$2,
        borderRadius: RADIUS$2,
        position: "relative"
      },
      onMousedown: this.handleMouseDown
    }, h("div", {
      style: {
        position: "absolute",
        left: RADIUS$2,
        right: RADIUS$2,
        top: 0,
        bottom: 0
      }
    }, h("div", {
      class: `${clsPrefix}-color-picker-handle`,
      style: {
        left: `calc((${this.hue}%) / 359 * 100 - ${RADIUS$2})`,
        borderRadius: RADIUS$2,
        width: HANDLE_SIZE$2,
        height: HANDLE_SIZE$2
      }
    }, h("div", {
      class: `${clsPrefix}-color-picker-handle__fill`,
      style: {
        backgroundColor: `hsl(${this.hue}, 100%, 50%)`,
        borderRadius: RADIUS$2,
        width: HANDLE_SIZE$2,
        height: HANDLE_SIZE$2
      }
    })))));
  }
});
const HANDLE_SIZE$1 = "12px";
const HANDLE_SIZE_NUM = 12;
const RADIUS$1 = "6px";
const AlphaSlider = /* @__PURE__ */ defineComponent({
  name: "AlphaSlider",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    rgba: {
      type: Array,
      default: null
    },
    alpha: {
      type: Number,
      default: 0
    },
    onUpdateAlpha: {
      type: Function,
      required: true
    },
    onComplete: Function
  },
  setup(props) {
    const railRef = ref(null);
    function handleMouseDown(e) {
      if (!railRef.value || !props.rgba)
        return;
      on("mousemove", document, handleMouseMove);
      on("mouseup", document, handleMouseUp);
      handleMouseMove(e);
    }
    function handleMouseMove(e) {
      const {
        value: railEl
      } = railRef;
      if (!railEl)
        return;
      const {
        width,
        left
      } = railEl.getBoundingClientRect();
      const newAlpha = (e.clientX - left) / (width - HANDLE_SIZE_NUM);
      props.onUpdateAlpha(normalizeAlpha(newAlpha));
    }
    function handleMouseUp() {
      var _a;
      off("mousemove", document, handleMouseMove);
      off("mouseup", document, handleMouseUp);
      (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
    }
    return {
      railRef,
      railBackgroundImage: computed(() => {
        const {
          rgba: rgba2
        } = props;
        if (!rgba2)
          return "";
        return `linear-gradient(to right, rgba(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]}, 0) 0%, rgba(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]}, 1) 100%)`;
      }),
      handleMouseDown
    };
  },
  render() {
    const {
      clsPrefix
    } = this;
    return h("div", {
      class: `${clsPrefix}-color-picker-slider`,
      ref: "railRef",
      style: {
        height: HANDLE_SIZE$1,
        borderRadius: RADIUS$1
      },
      onMousedown: this.handleMouseDown
    }, h("div", {
      style: {
        borderRadius: RADIUS$1,
        position: "absolute",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        overflow: "hidden"
      }
    }, h("div", {
      class: `${clsPrefix}-color-picker-checkboard`
    }), h("div", {
      class: `${clsPrefix}-color-picker-slider__image`,
      style: {
        backgroundImage: this.railBackgroundImage
      }
    })), this.rgba && h("div", {
      style: {
        position: "absolute",
        left: RADIUS$1,
        right: RADIUS$1,
        top: 0,
        bottom: 0
      }
    }, h("div", {
      class: `${clsPrefix}-color-picker-handle`,
      style: {
        left: `calc(${this.alpha * 100}% - ${RADIUS$1})`,
        borderRadius: RADIUS$1,
        width: HANDLE_SIZE$1,
        height: HANDLE_SIZE$1
      }
    }, h("div", {
      class: `${clsPrefix}-color-picker-handle__fill`,
      style: {
        backgroundColor: toRgbaString(this.rgba),
        borderRadius: RADIUS$1,
        width: HANDLE_SIZE$1,
        height: HANDLE_SIZE$1
      }
    }))));
  }
});
const HANDLE_SIZE = "12px";
const RADIUS = "6px";
const Pallete = /* @__PURE__ */ defineComponent({
  name: "Pallete",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    rgba: {
      type: Array,
      default: null
    },
    // 0 - 360
    displayedHue: {
      type: Number,
      required: true
    },
    displayedSv: {
      type: Array,
      required: true
    },
    onUpdateSV: {
      type: Function,
      required: true
    },
    onComplete: Function
  },
  setup(props) {
    const palleteRef = ref(null);
    function handleMouseDown(e) {
      if (!palleteRef.value)
        return;
      on("mousemove", document, handleMouseMove);
      on("mouseup", document, handleMouseUp);
      handleMouseMove(e);
    }
    function handleMouseMove(e) {
      const {
        value: palleteEl
      } = palleteRef;
      if (!palleteEl)
        return;
      const {
        width,
        height,
        left,
        bottom
      } = palleteEl.getBoundingClientRect();
      const newV = (bottom - e.clientY) / height;
      const newS = (e.clientX - left) / width;
      const normalizedNewS = 100 * (newS > 1 ? 1 : newS < 0 ? 0 : newS);
      const normalizedNewV = 100 * (newV > 1 ? 1 : newV < 0 ? 0 : newV);
      props.onUpdateSV(normalizedNewS, normalizedNewV);
    }
    function handleMouseUp() {
      var _a;
      off("mousemove", document, handleMouseMove);
      off("mouseup", document, handleMouseUp);
      (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
    }
    return {
      palleteRef,
      handleColor: computed(() => {
        const {
          rgba: rgba2
        } = props;
        if (!rgba2)
          return "";
        return `rgb(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]})`;
      }),
      handleMouseDown
    };
  },
  render() {
    const {
      clsPrefix
    } = this;
    return h("div", {
      class: `${clsPrefix}-color-picker-pallete`,
      onMousedown: this.handleMouseDown,
      ref: "palleteRef"
    }, h("div", {
      class: `${clsPrefix}-color-picker-pallete__layer`,
      style: {
        backgroundImage: `linear-gradient(90deg, white, hsl(${this.displayedHue}, 100%, 50%))`
      }
    }), h("div", {
      class: `${clsPrefix}-color-picker-pallete__layer ${clsPrefix}-color-picker-pallete__layer--shadowed`,
      style: {
        backgroundImage: "linear-gradient(180deg, rgba(0, 0, 0, 0%), rgba(0, 0, 0, 100%))"
      }
    }), this.rgba && h("div", {
      class: `${clsPrefix}-color-picker-handle`,
      style: {
        width: HANDLE_SIZE,
        height: HANDLE_SIZE,
        borderRadius: RADIUS,
        left: `calc(${this.displayedSv[0]}% - ${RADIUS})`,
        bottom: `calc(${this.displayedSv[1]}% - ${RADIUS})`
      }
    }, h("div", {
      class: `${clsPrefix}-color-picker-handle__fill`,
      style: {
        backgroundColor: this.handleColor,
        borderRadius: RADIUS,
        width: HANDLE_SIZE,
        height: HANDLE_SIZE
      }
    })));
  }
});
const colorPickerInjectionKey = createInjectionKey("n-color-picker");
function normalizeRgbUnit(value) {
  if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
    return Math.max(0, Math.min(Number.parseInt(value), 255));
  }
  return false;
}
function normalizeHueUnit(value) {
  if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
    return Math.max(0, Math.min(Number.parseInt(value), 360));
  }
  return false;
}
function normalizeSlvUnit(value) {
  if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
    return Math.max(0, Math.min(Number.parseInt(value), 100));
  }
  return false;
}
function normalizeHexaUnit(value) {
  const trimmedValue = value.trim();
  if (/^#[0-9a-fA-F]+$/.test(trimmedValue)) {
    return [4, 5, 7, 9].includes(trimmedValue.length);
  }
  return false;
}
function normalizeAlphaUnit(value) {
  if (/^\d{1,3}\.?\d*%$/.test(value.trim())) {
    return Math.max(0, Math.min(Number.parseInt(value) / 100, 100));
  }
  return false;
}
const inputThemeOverrides = {
  paddingSmall: "0 4px"
};
const ColorInputUnit = /* @__PURE__ */ defineComponent({
  name: "ColorInputUnit",
  props: {
    label: {
      type: String,
      required: true
    },
    value: {
      type: [Number, String],
      default: null
    },
    showAlpha: Boolean,
    onUpdateValue: {
      type: Function,
      required: true
    }
  },
  setup(props) {
    const inputValueRef = ref("");
    const {
      themeRef
    } = inject(colorPickerInjectionKey, null);
    watchEffect(() => {
      inputValueRef.value = getInputString();
    });
    function getInputString() {
      const {
        value
      } = props;
      if (value === null)
        return "";
      const {
        label
      } = props;
      if (label === "HEX") {
        return value;
      }
      if (label === "A") {
        return `${Math.floor(value * 100)}%`;
      }
      return String(Math.floor(value));
    }
    function handleInputUpdateValue(value) {
      inputValueRef.value = value;
    }
    function handleInputChange(value) {
      let unit;
      let valid;
      switch (props.label) {
        case "HEX":
          valid = normalizeHexaUnit(value);
          if (valid) {
            props.onUpdateValue(value);
          }
          inputValueRef.value = getInputString();
          break;
        case "H":
          unit = normalizeHueUnit(value);
          if (unit === false) {
            inputValueRef.value = getInputString();
          } else {
            props.onUpdateValue(unit);
          }
          break;
        case "S":
        case "L":
        case "V":
          unit = normalizeSlvUnit(value);
          if (unit === false) {
            inputValueRef.value = getInputString();
          } else {
            props.onUpdateValue(unit);
          }
          break;
        case "A":
          unit = normalizeAlphaUnit(value);
          if (unit === false) {
            inputValueRef.value = getInputString();
          } else {
            props.onUpdateValue(unit);
          }
          break;
        case "R":
        case "G":
        case "B":
          unit = normalizeRgbUnit(value);
          if (unit === false) {
            inputValueRef.value = getInputString();
          } else {
            props.onUpdateValue(unit);
          }
          break;
      }
    }
    return {
      mergedTheme: themeRef,
      inputValue: inputValueRef,
      handleInputChange,
      handleInputUpdateValue
    };
  },
  render() {
    const {
      mergedTheme
    } = this;
    return h(NInput, {
      size: "small",
      placeholder: this.label,
      theme: mergedTheme.peers.Input,
      themeOverrides: mergedTheme.peerOverrides.Input,
      builtinThemeOverrides: inputThemeOverrides,
      value: this.inputValue,
      onUpdateValue: this.handleInputUpdateValue,
      onChange: this.handleInputChange,
      // add more space for xxx% input
      style: this.label === "A" ? "flex-grow: 1.25;" : ""
    });
  }
});
const ColorInput = /* @__PURE__ */ defineComponent({
  name: "ColorInput",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    mode: {
      type: String,
      required: true
    },
    modes: {
      type: Array,
      required: true
    },
    showAlpha: {
      type: Boolean,
      required: true
    },
    value: {
      // for hex to get percise value
      type: String,
      default: null
    },
    valueArr: {
      type: Array,
      default: null
    },
    onUpdateValue: {
      type: Function,
      required: true
    },
    onUpdateMode: {
      type: Function,
      required: true
    }
  },
  setup(props) {
    return {
      handleUnitUpdateValue(index, value) {
        const {
          showAlpha
        } = props;
        if (props.mode === "hex") {
          props.onUpdateValue((showAlpha ? toHexaString : toHexString)(value));
          return;
        }
        let nextValueArr;
        if (props.valueArr === null) {
          nextValueArr = [0, 0, 0, 0];
        } else {
          nextValueArr = Array.from(props.valueArr);
        }
        switch (props.mode) {
          case "hsv":
            nextValueArr[index] = value;
            props.onUpdateValue((showAlpha ? toHsvaString : toHsvString)(nextValueArr));
            break;
          case "rgb":
            nextValueArr[index] = value;
            props.onUpdateValue((showAlpha ? toRgbaString : toRgbString)(nextValueArr));
            break;
          case "hsl":
            nextValueArr[index] = value;
            props.onUpdateValue((showAlpha ? toHslaString : toHslString)(nextValueArr));
            break;
        }
      }
    };
  },
  render() {
    const {
      clsPrefix,
      modes
    } = this;
    return h("div", {
      class: `${clsPrefix}-color-picker-input`
    }, h("div", {
      class: `${clsPrefix}-color-picker-input__mode`,
      onClick: this.onUpdateMode,
      style: {
        cursor: modes.length === 1 ? "" : "pointer"
      }
    }, this.mode.toUpperCase() + (this.showAlpha ? "A" : "")), h(NInputGroup, null, {
      default: () => {
        const {
          mode,
          valueArr,
          showAlpha
        } = this;
        if (mode === "hex") {
          let hexValue = null;
          try {
            hexValue = valueArr === null ? null : (showAlpha ? toHexaString : toHexString)(valueArr);
          } catch (_a) {
          }
          return h(ColorInputUnit, {
            label: "HEX",
            showAlpha,
            value: hexValue,
            onUpdateValue: (unitValue) => {
              this.handleUnitUpdateValue(0, unitValue);
            }
          });
        }
        return (mode + (showAlpha ? "a" : "")).split("").map((v, i) => h(ColorInputUnit, {
          label: v.toUpperCase(),
          value: valueArr === null ? null : valueArr[i],
          onUpdateValue: (unitValue) => {
            this.handleUnitUpdateValue(i, unitValue);
          }
        }));
      }
    }));
  }
});
const ColorPickerTrigger = /* @__PURE__ */ defineComponent({
  name: "ColorPickerTrigger",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    value: {
      type: String,
      default: null
    },
    hsla: {
      type: Array,
      default: null
    },
    disabled: Boolean,
    onClick: Function
  },
  setup(props) {
    const {
      colorPickerSlots,
      renderLabelRef
    } = inject(colorPickerInjectionKey, null);
    return () => {
      const {
        hsla: hsla2,
        value,
        clsPrefix,
        onClick,
        disabled
      } = props;
      const renderLabel = colorPickerSlots.label || renderLabelRef.value;
      return h("div", {
        class: [`${clsPrefix}-color-picker-trigger`, disabled && `${clsPrefix}-color-picker-trigger--disabled`],
        onClick: disabled ? void 0 : onClick
      }, h("div", {
        class: `${clsPrefix}-color-picker-trigger__fill`
      }, h("div", {
        class: `${clsPrefix}-color-picker-checkboard`
      }), h("div", {
        style: {
          position: "absolute",
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          backgroundColor: hsla2 ? toHslaString(hsla2) : ""
        }
      }), value && hsla2 ? h("div", {
        class: `${clsPrefix}-color-picker-trigger__value`,
        style: {
          color: hsla2[2] > 50 || hsla2[3] < 0.5 ? "black" : "white"
        }
      }, renderLabel ? renderLabel(value) : value) : null));
    };
  }
});
function normalizeColor(color, mode) {
  if (mode === "hsv") {
    const [h2, s, v, a] = hsva(color);
    return toRgbaString([...hsv2rgb(h2, s, v), a]);
  }
  return color;
}
function getHexFromName(color) {
  const ctx2 = document.createElement("canvas").getContext("2d");
  if (!ctx2) {
    return "#000000";
  }
  ctx2.fillStyle = color;
  return ctx2.fillStyle;
}
const ColorPickerSwatches = /* @__PURE__ */ defineComponent({
  name: "ColorPickerSwatches",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    mode: {
      type: String,
      required: true
    },
    swatches: {
      type: Array,
      required: true
    },
    onUpdateColor: {
      type: Function,
      required: true
    }
  },
  setup(props) {
    const parsedSwatchesRef = computed(() => props.swatches.map((value) => {
      const mode = getModeFromValue(value);
      return {
        value,
        mode,
        legalValue: normalizeColor(value, mode)
      };
    }));
    function normalizeOutput(parsed) {
      const {
        mode: modeProp
      } = props;
      let {
        value,
        mode: swatchColorMode
      } = parsed;
      if (!swatchColorMode) {
        swatchColorMode = "hex";
        if (/^[a-zA-Z]+$/.test(value)) {
          value = getHexFromName(value);
        } else {
          warn$2("color-picker", `color ${value} in swatches is invalid.`);
          value = "#000000";
        }
      }
      if (swatchColorMode === modeProp)
        return value;
      return convertColor(value, modeProp, swatchColorMode);
    }
    function handleSwatchSelect(parsed) {
      props.onUpdateColor(normalizeOutput(parsed));
    }
    function handleSwatchKeyDown(e, parsed) {
      if (e.key === "Enter")
        handleSwatchSelect(parsed);
    }
    return {
      parsedSwatchesRef,
      handleSwatchSelect,
      handleSwatchKeyDown
    };
  },
  render() {
    const {
      clsPrefix
    } = this;
    return h("div", {
      class: `${clsPrefix}-color-picker-swatches`
    }, this.parsedSwatchesRef.map((swatch) => h("div", {
      class: `${clsPrefix}-color-picker-swatch`,
      tabindex: 0,
      onClick: () => {
        this.handleSwatchSelect(swatch);
      },
      onKeydown: (e) => {
        this.handleSwatchKeyDown(e, swatch);
      }
    }, h("div", {
      class: `${clsPrefix}-color-picker-swatch__fill`,
      style: {
        background: swatch.legalValue
      }
    }))));
  }
});
const ColorPreview = /* @__PURE__ */ defineComponent({
  name: "ColorPreview",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    mode: {
      type: String,
      required: true
    },
    color: {
      type: String,
      default: null,
      validator: (value) => {
        const mode = getModeFromValue(value);
        return Boolean(!value || mode && mode !== "hsv");
      }
    },
    onUpdateColor: {
      type: Function,
      required: true
    }
  },
  setup(props) {
    function handleChange(e) {
      var _a;
      const value = e.target.value;
      (_a = props.onUpdateColor) === null || _a === void 0 ? void 0 : _a.call(props, convertColor(value.toUpperCase(), props.mode, "hex"));
      e.stopPropagation();
    }
    return {
      handleChange
    };
  },
  render() {
    const {
      clsPrefix
    } = this;
    return h("div", {
      class: `${clsPrefix}-color-picker-preview__preview`
    }, h("span", {
      class: `${clsPrefix}-color-picker-preview__fill`,
      style: {
        background: this.color || "#000000"
      }
    }), h("input", {
      class: `${clsPrefix}-color-picker-preview__input`,
      type: "color",
      value: this.color,
      onChange: this.handleChange
    }));
  }
});
const style$f = c$1([cB("color-picker", `
 display: inline-block;
 box-sizing: border-box;
 height: var(--n-height);
 font-size: var(--n-font-size);
 width: 100%;
 position: relative;
 `), cB("color-picker-panel", `
 margin: 4px 0;
 width: 240px;
 font-size: var(--n-panel-font-size);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 `, [fadeInScaleUpTransition(), cB("input", `
 text-align: center;
 `)]), cB("color-picker-checkboard", `
 background: white; 
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [c$1("&::after", `
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 12px 12px;
 background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
 background-repeat: repeat;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("color-picker-slider", `
 margin-bottom: 8px;
 position: relative;
 box-sizing: border-box;
 `, [cE("image", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), c$1("&::after", `
 content: "";
 position: absolute;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 pointer-events: none;
 `)]), cB("color-picker-handle", `
 z-index: 1;
 box-shadow: 0 0 2px 0 rgba(0, 0, 0, .45);
 position: absolute;
 background-color: white;
 overflow: hidden;
 `, [cE("fill", `
 box-sizing: border-box;
 border: 2px solid white;
 `)]), cB("color-picker-pallete", `
 height: 180px;
 position: relative;
 margin-bottom: 8px;
 cursor: crosshair;
 `, [cE("layer", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [cM("shadowed", `
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 `)])]), cB("color-picker-preview", `
 display: flex;
 `, [cE("sliders", `
 flex: 1 0 auto;
 `), cE("preview", `
 position: relative;
 height: 30px;
 width: 30px;
 margin: 0 0 8px 6px;
 border-radius: 50%;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 overflow: hidden;
 `), cE("fill", `
 display: block;
 width: 30px;
 height: 30px;
 `), cE("input", `
 position: absolute;
 top: 0;
 left: 0;
 width: 30px;
 height: 30px;
 opacity: 0;
 z-index: 1;
 `)]), cB("color-picker-input", `
 display: flex;
 align-items: center;
 `, [cB("input", `
 flex-grow: 1;
 flex-basis: 0;
 `), cE("mode", `
 width: 72px;
 text-align: center;
 `)]), cB("color-picker-control", `
 padding: 12px;
 `), cB("color-picker-action", `
 display: flex;
 margin-top: -4px;
 border-top: 1px solid var(--n-divider-color);
 padding: 8px 12px;
 justify-content: flex-end;
 `, [cB("button", "margin-left: 8px;")]), cB("color-picker-trigger", `
 border: var(--n-border);
 height: 100%;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 cursor: pointer;
 `, [cE("value", `
 white-space: nowrap;
 position: relative;
 `), cE("fill", `
 border-radius: var(--n-border-radius);
 position: absolute;
 display: flex;
 align-items: center;
 justify-content: center;
 left: 4px;
 right: 4px;
 top: 4px;
 bottom: 4px;
 `), cM("disabled", "cursor: not-allowed"), cB("color-picker-checkboard", `
 border-radius: var(--n-border-radius);
 `, [c$1("&::after", `
 --n-block-size: calc((var(--n-height) - 8px) / 3);
 background-size: calc(var(--n-block-size) * 2) calc(var(--n-block-size) * 2);
 background-position: 0 0, 0 var(--n-block-size), var(--n-block-size) calc(-1 * var(--n-block-size)), calc(-1 * var(--n-block-size)) 0px; 
 `)])]), cB("color-picker-swatches", `
 display: grid;
 grid-gap: 8px;
 flex-wrap: wrap;
 position: relative;
 grid-template-columns: repeat(auto-fill, 18px);
 margin-top: 10px;
 `, [cB("color-picker-swatch", `
 width: 18px;
 height: 18px;
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 8px 8px;
 background-position: 0px 0, 0px 4px, 4px -4px, -4px 0px;
 background-repeat: repeat;
 `, [cE("fill", `
 position: relative;
 width: 100%;
 height: 100%;
 border-radius: 3px;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 cursor: pointer;
 `), c$1("&:focus", `
 outline: none;
 `, [cE("fill", [c$1("&::after", `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 background: inherit;
 filter: blur(2px);
 content: "";
 `)])])])])]);
const colorPickerProps = Object.assign(Object.assign({}, useTheme.props), {
  value: String,
  show: {
    type: Boolean,
    default: void 0
  },
  defaultShow: Boolean,
  defaultValue: String,
  modes: {
    type: Array,
    // no hsva by default since browser doesn't support it
    default: () => ["rgb", "hex", "hsl"]
  },
  placement: {
    type: String,
    default: "bottom-start"
  },
  to: useAdjustedTo.propTo,
  showAlpha: {
    type: Boolean,
    default: true
  },
  showPreview: Boolean,
  swatches: Array,
  disabled: {
    type: Boolean,
    default: void 0
  },
  actions: {
    type: Array,
    default: null
  },
  internalActions: Array,
  size: String,
  renderLabel: Function,
  onComplete: Function,
  onConfirm: Function,
  onClear: Function,
  "onUpdate:show": [Function, Array],
  onUpdateShow: [Function, Array],
  "onUpdate:value": [Function, Array],
  onUpdateValue: [Function, Array]
});
const NColorPicker = /* @__PURE__ */ defineComponent({
  name: "ColorPicker",
  props: colorPickerProps,
  setup(props, {
    slots
  }) {
    const selfRef = ref(null);
    let upcomingValue = null;
    const formItem = useFormItem(props);
    const {
      mergedSizeRef,
      mergedDisabledRef
    } = formItem;
    const {
      localeRef
    } = useLocale("global");
    const {
      mergedClsPrefixRef,
      namespaceRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("ColorPicker", "-color-picker", style$f, colorPickerLight$1, props, mergedClsPrefixRef);
    provide(colorPickerInjectionKey, {
      themeRef,
      renderLabelRef: toRef(props, "renderLabel"),
      colorPickerSlots: slots
    });
    const uncontrolledShowRef = ref(props.defaultShow);
    const mergedShowRef = useMergedState(toRef(props, "show"), uncontrolledShowRef);
    function doUpdateShow(value) {
      const {
        onUpdateShow,
        "onUpdate:show": _onUpdateShow
      } = props;
      if (onUpdateShow)
        call(onUpdateShow, value);
      if (_onUpdateShow)
        call(_onUpdateShow, value);
      uncontrolledShowRef.value = value;
    }
    const {
      defaultValue
    } = props;
    const uncontrolledValueRef = ref(defaultValue === void 0 ? deriveDefaultValue(props.modes, props.showAlpha) : defaultValue);
    const mergedValueRef = useMergedState(toRef(props, "value"), uncontrolledValueRef);
    const undoStackRef = ref([mergedValueRef.value]);
    const valueIndexRef = ref(0);
    const valueModeRef = computed(() => getModeFromValue(mergedValueRef.value));
    const {
      modes
    } = props;
    const displayedModeRef = ref(getModeFromValue(mergedValueRef.value) || modes[0] || "rgb");
    function handleUpdateDisplayedMode() {
      const {
        modes: modes2
      } = props;
      const {
        value: displayedMode
      } = displayedModeRef;
      const currentModeIndex = modes2.findIndex((mode) => mode === displayedMode);
      if (~currentModeIndex) {
        displayedModeRef.value = modes2[(currentModeIndex + 1) % modes2.length];
      } else {
        displayedModeRef.value = "rgb";
      }
    }
    let _h, s, l, v, r, g, b, a;
    const hsvaRef = computed(() => {
      const {
        value: mergedValue
      } = mergedValueRef;
      if (!mergedValue)
        return null;
      switch (valueModeRef.value) {
        case "hsv":
          return hsva(mergedValue);
        case "hsl":
          [_h, s, l, a] = hsla(mergedValue);
          return [...hsl2hsv(_h, s, l), a];
        case "rgb":
        case "hex":
          [r, g, b, a] = rgba(mergedValue);
          return [...rgb2hsv(r, g, b), a];
      }
    });
    const rgbaRef = computed(() => {
      const {
        value: mergedValue
      } = mergedValueRef;
      if (!mergedValue)
        return null;
      switch (valueModeRef.value) {
        case "rgb":
        case "hex":
          return rgba(mergedValue);
        case "hsv":
          [_h, s, v, a] = hsva(mergedValue);
          return [...hsv2rgb(_h, s, v), a];
        case "hsl":
          [_h, s, l, a] = hsla(mergedValue);
          return [...hsl2rgb(_h, s, l), a];
      }
    });
    const hslaRef = computed(() => {
      const {
        value: mergedValue
      } = mergedValueRef;
      if (!mergedValue)
        return null;
      switch (valueModeRef.value) {
        case "hsl":
          return hsla(mergedValue);
        case "hsv":
          [_h, s, v, a] = hsva(mergedValue);
          return [...hsv2hsl(_h, s, v), a];
        case "rgb":
        case "hex":
          [r, g, b, a] = rgba(mergedValue);
          return [...rgb2hsl(r, g, b), a];
      }
    });
    const mergedValueArrRef = computed(() => {
      switch (displayedModeRef.value) {
        case "rgb":
        case "hex":
          return rgbaRef.value;
        case "hsv":
          return hsvaRef.value;
        case "hsl":
          return hslaRef.value;
      }
    });
    const displayedHueRef = ref(0);
    const displayedAlphaRef = ref(1);
    const displayedSvRef = ref([0, 0]);
    function handleUpdateSv(s2, v2) {
      const {
        value: hsvaArr
      } = hsvaRef;
      const hue = displayedHueRef.value;
      const alpha = hsvaArr ? hsvaArr[3] : 1;
      displayedSvRef.value = [s2, v2];
      const {
        showAlpha
      } = props;
      switch (displayedModeRef.value) {
        case "hsv":
          doUpdateValue((showAlpha ? toHsvaString : toHsvString)([hue, s2, v2, alpha]), "cursor");
          break;
        case "hsl":
          doUpdateValue((showAlpha ? toHslaString : toHslString)([...hsv2hsl(hue, s2, v2), alpha]), "cursor");
          break;
        case "rgb":
          doUpdateValue((showAlpha ? toRgbaString : toRgbString)([...hsv2rgb(hue, s2, v2), alpha]), "cursor");
          break;
        case "hex":
          doUpdateValue((showAlpha ? toHexaString : toHexString)([...hsv2rgb(hue, s2, v2), alpha]), "cursor");
          break;
      }
    }
    function handleUpdateHue(hue) {
      displayedHueRef.value = hue;
      const {
        value: hsvaArr
      } = hsvaRef;
      if (!hsvaArr) {
        return;
      }
      const [, s2, v2, a2] = hsvaArr;
      const {
        showAlpha
      } = props;
      switch (displayedModeRef.value) {
        case "hsv":
          doUpdateValue((showAlpha ? toHsvaString : toHsvString)([hue, s2, v2, a2]), "cursor");
          break;
        case "rgb":
          doUpdateValue((showAlpha ? toRgbaString : toRgbString)([...hsv2rgb(hue, s2, v2), a2]), "cursor");
          break;
        case "hex":
          doUpdateValue((showAlpha ? toHexaString : toHexString)([...hsv2rgb(hue, s2, v2), a2]), "cursor");
          break;
        case "hsl":
          doUpdateValue((showAlpha ? toHslaString : toHslString)([...hsv2hsl(hue, s2, v2), a2]), "cursor");
          break;
      }
    }
    function handleUpdateAlpha(alpha) {
      switch (displayedModeRef.value) {
        case "hsv":
          [_h, s, v] = hsvaRef.value;
          doUpdateValue(toHsvaString([_h, s, v, alpha]), "cursor");
          break;
        case "rgb":
          [r, g, b] = rgbaRef.value;
          doUpdateValue(toRgbaString([r, g, b, alpha]), "cursor");
          break;
        case "hex":
          [r, g, b] = rgbaRef.value;
          doUpdateValue(toHexaString([r, g, b, alpha]), "cursor");
          break;
        case "hsl":
          [_h, s, l] = hslaRef.value;
          doUpdateValue(toHslaString([_h, s, l, alpha]), "cursor");
          break;
      }
      displayedAlphaRef.value = alpha;
    }
    function doUpdateValue(value, updateSource) {
      if (updateSource === "cursor") {
        upcomingValue = value;
      } else {
        upcomingValue = null;
      }
      const {
        nTriggerFormChange,
        nTriggerFormInput
      } = formItem;
      const {
        onUpdateValue,
        "onUpdate:value": _onUpdateValue
      } = props;
      if (onUpdateValue)
        call(onUpdateValue, value);
      if (_onUpdateValue)
        call(_onUpdateValue, value);
      nTriggerFormChange();
      nTriggerFormInput();
      uncontrolledValueRef.value = value;
    }
    function handleInputUpdateValue(value) {
      doUpdateValue(value, "input");
      void nextTick(handleComplete);
    }
    function handleComplete(pushStack = true) {
      const {
        value
      } = mergedValueRef;
      if (value) {
        const {
          nTriggerFormChange,
          nTriggerFormInput
        } = formItem;
        const {
          onComplete
        } = props;
        if (onComplete) {
          onComplete(value);
        }
        const {
          value: undoStack
        } = undoStackRef;
        const {
          value: valueIndex
        } = valueIndexRef;
        if (pushStack) {
          undoStack.splice(valueIndex + 1, undoStack.length, value);
          valueIndexRef.value = valueIndex + 1;
        }
        nTriggerFormChange();
        nTriggerFormInput();
      }
    }
    function undo() {
      const {
        value: valueIndex
      } = valueIndexRef;
      if (valueIndex - 1 < 0)
        return;
      doUpdateValue(undoStackRef.value[valueIndex - 1], "input");
      handleComplete(false);
      valueIndexRef.value = valueIndex - 1;
    }
    function redo() {
      const {
        value: valueIndex
      } = valueIndexRef;
      if (valueIndex < 0 || valueIndex + 1 >= undoStackRef.value.length)
        return;
      doUpdateValue(undoStackRef.value[valueIndex + 1], "input");
      handleComplete(false);
      valueIndexRef.value = valueIndex + 1;
    }
    function handleClear() {
      doUpdateValue(null, "input");
      const {
        onClear
      } = props;
      if (onClear) {
        onClear();
      }
      doUpdateShow(false);
    }
    function handleConfirm() {
      const {
        value
      } = mergedValueRef;
      const {
        onConfirm
      } = props;
      if (onConfirm) {
        onConfirm(value);
      }
      doUpdateShow(false);
    }
    const undoableRef = computed(() => valueIndexRef.value >= 1);
    const redoableRef = computed(() => {
      const {
        value: undoStack
      } = undoStackRef;
      return undoStack.length > 1 && valueIndexRef.value < undoStack.length - 1;
    });
    watch(mergedShowRef, (value) => {
      if (!value) {
        undoStackRef.value = [mergedValueRef.value];
        valueIndexRef.value = 0;
      }
    });
    watchEffect(() => {
      if (upcomingValue && upcomingValue === mergedValueRef.value)
        ;
      else {
        const {
          value
        } = hsvaRef;
        if (value) {
          displayedHueRef.value = value[0];
          displayedAlphaRef.value = value[3];
          displayedSvRef.value = [value[1], value[2]];
        }
      }
      upcomingValue = null;
    });
    const cssVarsRef = computed(() => {
      const {
        value: mergedSize
      } = mergedSizeRef;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: {
          textColor,
          color,
          panelFontSize,
          boxShadow,
          border,
          borderRadius,
          dividerColor,
          [createKey("height", mergedSize)]: height,
          [createKey("fontSize", mergedSize)]: fontSize2
        }
      } = themeRef.value;
      return {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-text-color": textColor,
        "--n-color": color,
        "--n-panel-font-size": panelFontSize,
        "--n-font-size": fontSize2,
        "--n-box-shadow": boxShadow,
        "--n-border": border,
        "--n-border-radius": borderRadius,
        "--n-height": height,
        "--n-divider-color": dividerColor
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("color-picker", computed(() => {
      return mergedSizeRef.value[0];
    }), cssVarsRef, props) : void 0;
    function renderPanel() {
      var _a;
      const {
        value: rgba2
      } = rgbaRef;
      const {
        value: displayedHue
      } = displayedHueRef;
      const {
        internalActions,
        modes: modes2,
        actions
      } = props;
      const {
        value: mergedTheme
      } = themeRef;
      const {
        value: mergedClsPrefix
      } = mergedClsPrefixRef;
      return h("div", {
        class: [`${mergedClsPrefix}-color-picker-panel`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value],
        onDragstart: (e) => {
          e.preventDefault();
        },
        style: inlineThemeDisabled ? void 0 : cssVarsRef.value
      }, h("div", {
        class: `${mergedClsPrefix}-color-picker-control`
      }, h(Pallete, {
        clsPrefix: mergedClsPrefix,
        rgba: rgba2,
        displayedHue,
        displayedSv: displayedSvRef.value,
        onUpdateSV: handleUpdateSv,
        onComplete: handleComplete
      }), h("div", {
        class: `${mergedClsPrefix}-color-picker-preview`
      }, h("div", {
        class: `${mergedClsPrefix}-color-picker-preview__sliders`
      }, h(HueSlider, {
        clsPrefix: mergedClsPrefix,
        hue: displayedHue,
        onUpdateHue: handleUpdateHue,
        onComplete: handleComplete
      }), props.showAlpha ? h(AlphaSlider, {
        clsPrefix: mergedClsPrefix,
        rgba: rgba2,
        alpha: displayedAlphaRef.value,
        onUpdateAlpha: handleUpdateAlpha,
        onComplete: handleComplete
      }) : null), props.showPreview ? h(ColorPreview, {
        clsPrefix: mergedClsPrefix,
        mode: displayedModeRef.value,
        color: rgbaRef.value && toHexString(rgbaRef.value),
        onUpdateColor: (color) => {
          doUpdateValue(color, "input");
        }
      }) : null), h(ColorInput, {
        clsPrefix: mergedClsPrefix,
        showAlpha: props.showAlpha,
        mode: displayedModeRef.value,
        modes: modes2,
        onUpdateMode: handleUpdateDisplayedMode,
        value: mergedValueRef.value,
        valueArr: mergedValueArrRef.value,
        onUpdateValue: handleInputUpdateValue
      }), ((_a = props.swatches) === null || _a === void 0 ? void 0 : _a.length) && h(ColorPickerSwatches, {
        clsPrefix: mergedClsPrefix,
        mode: displayedModeRef.value,
        swatches: props.swatches,
        onUpdateColor: (color) => {
          doUpdateValue(color, "input");
        }
      })), (actions === null || actions === void 0 ? void 0 : actions.length) ? h("div", {
        class: `${mergedClsPrefix}-color-picker-action`
      }, actions.includes("confirm") && h(NButton, {
        size: "small",
        onClick: handleConfirm,
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button
      }, {
        default: () => localeRef.value.confirm
      }), actions.includes("clear") && h(NButton, {
        size: "small",
        onClick: handleClear,
        disabled: !mergedValueRef.value,
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button
      }, {
        default: () => localeRef.value.clear
      })) : null, slots.action ? h("div", {
        class: `${mergedClsPrefix}-color-picker-action`
      }, {
        default: slots.action
      }) : internalActions ? h("div", {
        class: `${mergedClsPrefix}-color-picker-action`
      }, internalActions.includes("undo") && h(NButton, {
        size: "small",
        onClick: undo,
        disabled: !undoableRef.value,
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button
      }, {
        default: () => localeRef.value.undo
      }), internalActions.includes("redo") && h(NButton, {
        size: "small",
        onClick: redo,
        disabled: !redoableRef.value,
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button
      }, {
        default: () => localeRef.value.redo
      })) : null);
    }
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      namespace: namespaceRef,
      selfRef,
      hsla: hslaRef,
      rgba: rgbaRef,
      mergedShow: mergedShowRef,
      mergedDisabled: mergedDisabledRef,
      isMounted: isMounted(),
      adjustedTo: useAdjustedTo(props),
      mergedValue: mergedValueRef,
      handleTriggerClick() {
        doUpdateShow(true);
      },
      handleClickOutside(e) {
        var _a;
        if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e))) {
          return;
        }
        doUpdateShow(false);
      },
      renderPanel,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const {
      $slots,
      mergedClsPrefix,
      onRender
    } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return h("div", {
      class: [this.themeClass, `${mergedClsPrefix}-color-picker`],
      ref: "selfRef",
      style: this.cssVars
    }, h(VBinder, null, {
      default: () => [h(VTarget, null, {
        default: () => h(ColorPickerTrigger, {
          clsPrefix: mergedClsPrefix,
          value: this.mergedValue,
          hsla: this.hsla,
          disabled: this.mergedDisabled,
          onClick: this.handleTriggerClick
        }, {
          label: $slots.label
        })
      }), h(VFollower, {
        placement: this.placement,
        show: this.mergedShow,
        containerClass: this.namespace,
        teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
        to: this.adjustedTo
      }, {
        default: () => h(Transition, {
          name: "fade-in-scale-up-transition",
          appear: this.isMounted
        }, {
          default: () => this.mergedShow ? withDirectives(this.renderPanel(), [[clickoutside$1, this.handleClickOutside, void 0, {
            capture: true
          }]]) : null
        })
      })]
    }));
  }
});
const commonVariables$3 = {
  paddingSmall: "12px 16px 12px",
  paddingMedium: "19px 24px 20px",
  paddingLarge: "23px 32px 24px",
  paddingHuge: "27px 40px 28px",
  titleFontSizeSmall: "16px",
  titleFontSizeMedium: "18px",
  titleFontSizeLarge: "18px",
  titleFontSizeHuge: "18px",
  closeIconSize: "18px",
  closeSize: "22px"
};
function self$f(vars) {
  const {
    primaryColor,
    borderRadius,
    lineHeight: lineHeight2,
    fontSize: fontSize2,
    cardColor,
    textColor2,
    textColor1,
    dividerColor,
    fontWeightStrong,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    closeColorHover,
    closeColorPressed,
    modalColor,
    boxShadow1,
    popoverColor,
    actionColor
  } = vars;
  return Object.assign(Object.assign({}, commonVariables$3), {
    lineHeight: lineHeight2,
    color: cardColor,
    colorModal: modalColor,
    colorPopover: popoverColor,
    colorTarget: primaryColor,
    colorEmbedded: actionColor,
    colorEmbeddedModal: actionColor,
    colorEmbeddedPopover: actionColor,
    textColor: textColor2,
    titleTextColor: textColor1,
    borderColor: dividerColor,
    actionColor,
    titleFontWeight: fontWeightStrong,
    closeColorHover,
    closeColorPressed,
    closeBorderRadius: borderRadius,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    fontSizeSmall: fontSize2,
    fontSizeMedium: fontSize2,
    fontSizeLarge: fontSize2,
    fontSizeHuge: fontSize2,
    boxShadow: boxShadow1,
    borderRadius
  });
}
const cardLight = {
  name: "Card",
  common: commonLight,
  self: self$f
};
const cardLight$1 = cardLight;
const style$e = c$1([cB("card", `
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 display: flex;
 flex-direction: column;
 width: 100%;
 box-sizing: border-box;
 position: relative;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 color: var(--n-text-color);
 word-break: break-word;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [asModal({
  background: "var(--n-color-modal)"
}), cM("hoverable", [c$1("&:hover", "box-shadow: var(--n-box-shadow);")]), cM("content-segmented", [c$1(">", [cE("content", {
  paddingTop: "var(--n-padding-bottom)"
})])]), cM("content-soft-segmented", [c$1(">", [cE("content", `
 margin: 0 var(--n-padding-left);
 padding: var(--n-padding-bottom) 0;
 `)])]), cM("footer-segmented", [c$1(">", [cE("footer", {
  paddingTop: "var(--n-padding-bottom)"
})])]), cM("footer-soft-segmented", [c$1(">", [cE("footer", `
 padding: var(--n-padding-bottom) 0;
 margin: 0 var(--n-padding-left);
 `)])]), c$1(">", [cB("card-header", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 padding:
 var(--n-padding-top)
 var(--n-padding-left)
 var(--n-padding-bottom)
 var(--n-padding-left);
 `, [cE("main", `
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 min-width: 0;
 color: var(--n-title-text-color);
 `), cE("extra", `
 display: flex;
 align-items: center;
 font-size: var(--n-font-size);
 font-weight: 400;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE("close", `
 margin: 0 0 0 8px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE("action", `
 box-sizing: border-box;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 background-clip: padding-box;
 background-color: var(--n-action-color);
 `), cE("content", "flex: 1; min-width: 0;"), cE("content, footer", `
 box-sizing: border-box;
 padding: 0 var(--n-padding-left) var(--n-padding-bottom) var(--n-padding-left);
 font-size: var(--n-font-size);
 `, [c$1("&:first-child", {
  paddingTop: "var(--n-padding-bottom)"
})]), cE("action", `
 background-color: var(--n-action-color);
 padding: var(--n-padding-bottom) var(--n-padding-left);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `)]), cB("card-cover", `
 overflow: hidden;
 width: 100%;
 border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
 `, [c$1("img", `
 display: block;
 width: 100%;
 `)]), cM("bordered", `
 border: 1px solid var(--n-border-color);
 `, [c$1("&:target", "border-color: var(--n-color-target);")]), cM("action-segmented", [c$1(">", [cE("action", [c$1("&:not(:first-child)", {
  borderTop: "1px solid var(--n-border-color)"
})])])]), cM("content-segmented, content-soft-segmented", [c$1(">", [cE("content", {
  transition: "border-color 0.3s var(--n-bezier)"
}, [c$1("&:not(:first-child)", {
  borderTop: "1px solid var(--n-border-color)"
})])])]), cM("footer-segmented, footer-soft-segmented", [c$1(">", [cE("footer", {
  transition: "border-color 0.3s var(--n-bezier)"
}, [c$1("&:not(:first-child)", {
  borderTop: "1px solid var(--n-border-color)"
})])])]), cM("embedded", `
 background-color: var(--n-color-embedded);
 `)]), insideModal(cB("card", `
 background: var(--n-color-modal);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-modal);
 `)])), insidePopover(cB("card", `
 background: var(--n-color-popover);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-popover);
 `)]))]);
const cardBaseProps = {
  title: [String, Function],
  contentClass: String,
  contentStyle: [Object, String],
  headerClass: String,
  headerStyle: [Object, String],
  headerExtraClass: String,
  headerExtraStyle: [Object, String],
  footerClass: String,
  footerStyle: [Object, String],
  embedded: Boolean,
  segmented: {
    type: [Boolean, Object],
    default: false
  },
  size: {
    type: String,
    default: "medium"
  },
  bordered: {
    type: Boolean,
    default: true
  },
  closable: Boolean,
  hoverable: Boolean,
  role: String,
  onClose: [Function, Array],
  tag: {
    type: String,
    default: "div"
  },
  cover: Function,
  content: [String, Function],
  footer: Function,
  action: Function,
  headerExtra: Function
};
const cardBasePropKeys = keysOf(cardBaseProps);
const cardProps = Object.assign(Object.assign({}, useTheme.props), cardBaseProps);
const NCard = /* @__PURE__ */ defineComponent({
  name: "Card",
  props: cardProps,
  setup(props) {
    const handleCloseClick = () => {
      const {
        onClose
      } = props;
      if (onClose)
        call(onClose);
    };
    const {
      inlineThemeDisabled,
      mergedClsPrefixRef,
      mergedRtlRef
    } = useConfig(props);
    const themeRef = useTheme("Card", "-card", style$e, cardLight$1, props, mergedClsPrefixRef);
    const rtlEnabledRef = useRtl("Card", mergedRtlRef, mergedClsPrefixRef);
    const cssVarsRef = computed(() => {
      const {
        size: size2
      } = props;
      const {
        self: {
          color,
          colorModal,
          colorTarget,
          textColor,
          titleTextColor,
          titleFontWeight,
          borderColor,
          actionColor,
          borderRadius,
          lineHeight: lineHeight2,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          closeBorderRadius,
          closeIconSize,
          closeSize,
          boxShadow,
          colorPopover,
          colorEmbedded,
          colorEmbeddedModal,
          colorEmbeddedPopover,
          [createKey("padding", size2)]: padding,
          [createKey("fontSize", size2)]: fontSize2,
          [createKey("titleFontSize", size2)]: titleFontSize
        },
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        }
      } = themeRef.value;
      const {
        top: paddingTop,
        left: paddingLeft,
        bottom: paddingBottom
      } = getMargin(padding);
      return {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-border-radius": borderRadius,
        "--n-color": color,
        "--n-color-modal": colorModal,
        "--n-color-popover": colorPopover,
        "--n-color-embedded": colorEmbedded,
        "--n-color-embedded-modal": colorEmbeddedModal,
        "--n-color-embedded-popover": colorEmbeddedPopover,
        "--n-color-target": colorTarget,
        "--n-text-color": textColor,
        "--n-line-height": lineHeight2,
        "--n-action-color": actionColor,
        "--n-title-text-color": titleTextColor,
        "--n-title-font-weight": titleFontWeight,
        "--n-close-icon-color": closeIconColor,
        "--n-close-icon-color-hover": closeIconColorHover,
        "--n-close-icon-color-pressed": closeIconColorPressed,
        "--n-close-color-hover": closeColorHover,
        "--n-close-color-pressed": closeColorPressed,
        "--n-border-color": borderColor,
        "--n-box-shadow": boxShadow,
        // size
        "--n-padding-top": paddingTop,
        "--n-padding-bottom": paddingBottom,
        "--n-padding-left": paddingLeft,
        "--n-font-size": fontSize2,
        "--n-title-font-size": titleFontSize,
        "--n-close-size": closeSize,
        "--n-close-icon-size": closeIconSize,
        "--n-close-border-radius": closeBorderRadius
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("card", computed(() => {
      return props.size[0];
    }), cssVarsRef, props) : void 0;
    return {
      rtlEnabled: rtlEnabledRef,
      mergedClsPrefix: mergedClsPrefixRef,
      mergedTheme: themeRef,
      handleCloseClick,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const {
      segmented,
      bordered,
      hoverable,
      mergedClsPrefix,
      rtlEnabled,
      onRender,
      embedded,
      tag: Component,
      $slots
    } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return h(Component, {
      class: [`${mergedClsPrefix}-card`, this.themeClass, embedded && `${mergedClsPrefix}-card--embedded`, {
        [`${mergedClsPrefix}-card--rtl`]: rtlEnabled,
        [`${mergedClsPrefix}-card--content${typeof segmented !== "boolean" && segmented.content === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.content,
        [`${mergedClsPrefix}-card--footer${typeof segmented !== "boolean" && segmented.footer === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.footer,
        [`${mergedClsPrefix}-card--action-segmented`]: segmented === true || segmented !== false && segmented.action,
        [`${mergedClsPrefix}-card--bordered`]: bordered,
        [`${mergedClsPrefix}-card--hoverable`]: hoverable
      }],
      style: this.cssVars,
      role: this.role
    }, resolveWrappedSlot($slots.cover, (children) => {
      const mergedChildren = this.cover ? ensureValidVNode([this.cover()]) : children;
      return mergedChildren && h("div", {
        class: `${mergedClsPrefix}-card-cover`,
        role: "none"
      }, mergedChildren);
    }), resolveWrappedSlot($slots.header, (children) => {
      const {
        title
      } = this;
      const mergedChildren = title ? ensureValidVNode(typeof title === "function" ? [title()] : [title]) : children;
      return mergedChildren || this.closable ? h("div", {
        class: [`${mergedClsPrefix}-card-header`, this.headerClass],
        style: this.headerStyle,
        role: "heading"
      }, h("div", {
        class: `${mergedClsPrefix}-card-header__main`,
        role: "heading"
      }, mergedChildren), resolveWrappedSlot($slots["header-extra"], (children2) => {
        const mergedChildren2 = this.headerExtra ? ensureValidVNode([this.headerExtra()]) : children2;
        return mergedChildren2 && h("div", {
          class: [`${mergedClsPrefix}-card-header__extra`, this.headerExtraClass],
          style: this.headerExtraStyle
        }, mergedChildren2);
      }), this.closable && h(NBaseClose, {
        clsPrefix: mergedClsPrefix,
        class: `${mergedClsPrefix}-card-header__close`,
        onClick: this.handleCloseClick,
        absolute: true
      })) : null;
    }), resolveWrappedSlot($slots.default, (children) => {
      const {
        content
      } = this;
      const mergedChildren = content ? ensureValidVNode(typeof content === "function" ? [content()] : [content]) : children;
      return mergedChildren && h("div", {
        class: [`${mergedClsPrefix}-card__content`, this.contentClass],
        style: this.contentStyle,
        role: "none"
      }, mergedChildren);
    }), resolveWrappedSlot($slots.footer, (children) => {
      const mergedChildren = this.footer ? ensureValidVNode([this.footer()]) : children;
      return mergedChildren && h("div", {
        class: [`${mergedClsPrefix}-card__footer`, this.footerClass],
        style: this.footerStyle,
        role: "none"
      }, mergedChildren);
    }), resolveWrappedSlot($slots.action, (children) => {
      const mergedChildren = this.action ? ensureValidVNode([this.action()]) : children;
      return mergedChildren && h("div", {
        class: `${mergedClsPrefix}-card__action`,
        role: "none"
      }, mergedChildren);
    }));
  }
});
const commonVariables$2 = {
  sizeSmall: "14px",
  sizeMedium: "16px",
  sizeLarge: "18px",
  labelPadding: "0 8px",
  labelFontWeight: "400"
};
function self$e(vars) {
  const {
    baseColor,
    inputColorDisabled,
    cardColor,
    modalColor,
    popoverColor,
    textColorDisabled,
    borderColor,
    primaryColor,
    textColor2,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    borderRadiusSmall,
    lineHeight: lineHeight2
  } = vars;
  return Object.assign(Object.assign({}, commonVariables$2), {
    labelLineHeight: lineHeight2,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    borderRadius: borderRadiusSmall,
    color: baseColor,
    colorChecked: primaryColor,
    colorDisabled: inputColorDisabled,
    colorDisabledChecked: inputColorDisabled,
    colorTableHeader: cardColor,
    colorTableHeaderModal: modalColor,
    colorTableHeaderPopover: popoverColor,
    checkMarkColor: baseColor,
    checkMarkColorDisabled: textColorDisabled,
    checkMarkColorDisabledChecked: textColorDisabled,
    border: `1px solid ${borderColor}`,
    borderDisabled: `1px solid ${borderColor}`,
    borderDisabledChecked: `1px solid ${borderColor}`,
    borderChecked: `1px solid ${primaryColor}`,
    borderFocus: `1px solid ${primaryColor}`,
    boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
      alpha: 0.3
    })}`,
    textColor: textColor2,
    textColorDisabled
  });
}
const checkboxLight = {
  name: "Checkbox",
  common: commonLight,
  self: self$e
};
const checkboxLight$1 = checkboxLight;
const CheckMark = h("svg", {
  viewBox: "0 0 64 64",
  class: "check-icon"
}, h("path", {
  d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z"
}));
const LineMark = h("svg", {
  viewBox: "0 0 100 100",
  class: "line-icon"
}, h("path", {
  d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z"
}));
const checkboxGroupInjectionKey = createInjectionKey("n-checkbox-group");
const style$d = c$1([
  cB("checkbox", `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [cM("show-label", "line-height: var(--n-label-line-height);"), c$1("&:hover", [cB("checkbox-box", [cE("border", "border: var(--n-border-checked);")])]), c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cM("inside-table", [cB("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [cB("checkbox-icon", [
    // if not set width to 100%, safari & old chrome won't display the icon
    c$1(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)
  ])])]), cM("indeterminate", [cB("checkbox-box", [cB("checkbox-icon", [c$1(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), c$1(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), cM("checked, indeterminate", [c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cB("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [cE("border", {
    border: "var(--n-border-checked)"
  })])]), cM("disabled", {
    cursor: "not-allowed"
  }, [cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [cE("border", {
    border: "var(--n-border-disabled-checked)"
  }), cB("checkbox-icon", [c$1(".check-icon, .line-icon", {
    fill: "var(--n-check-mark-color-disabled-checked)"
  })])])]), cB("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [cE("border", `
 border: var(--n-border-disabled);
 `), cB("checkbox-icon", [c$1(".check-icon, .line-icon", `
 fill: var(--n-check-mark-color-disabled);
 `)])]), cE("label", `
 color: var(--n-text-color-disabled);
 `)]), cB("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), cB("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [cE("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), cB("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [c$1(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), iconSwitchTransition({
    left: "1px",
    top: "1px"
  })])]), cE("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [c$1("&:empty", {
    display: "none"
  })])]),
  // modal table header checkbox
  insideModal(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)),
  // popover table header checkbox
  insidePopover(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))
]);
const checkboxProps = Object.assign(Object.assign({}, useTheme.props), {
  size: String,
  checked: {
    type: [Boolean, String, Number],
    default: void 0
  },
  defaultChecked: {
    type: [Boolean, String, Number],
    default: false
  },
  value: [String, Number],
  disabled: {
    type: Boolean,
    default: void 0
  },
  indeterminate: Boolean,
  label: String,
  focusable: {
    type: Boolean,
    default: true
  },
  checkedValue: {
    type: [Boolean, String, Number],
    default: true
  },
  uncheckedValue: {
    type: [Boolean, String, Number],
    default: false
  },
  "onUpdate:checked": [Function, Array],
  onUpdateChecked: [Function, Array],
  // private
  privateInsideTable: Boolean,
  // deprecated
  onChange: [Function, Array]
});
const NCheckbox = /* @__PURE__ */ defineComponent({
  name: "Checkbox",
  props: checkboxProps,
  setup(props) {
    const NCheckboxGroup = inject(checkboxGroupInjectionKey, null);
    const selfRef = ref(null);
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled,
      mergedRtlRef
    } = useConfig(props);
    const uncontrolledCheckedRef = ref(props.defaultChecked);
    const controlledCheckedRef = toRef(props, "checked");
    const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
    const renderedCheckedRef = useMemo(() => {
      if (NCheckboxGroup) {
        const groupValueSet = NCheckboxGroup.valueSetRef.value;
        if (groupValueSet && props.value !== void 0) {
          return groupValueSet.has(props.value);
        }
        return false;
      } else {
        return mergedCheckedRef.value === props.checkedValue;
      }
    });
    const formItem = useFormItem(props, {
      mergedSize(NFormItem2) {
        const {
          size: size2
        } = props;
        if (size2 !== void 0)
          return size2;
        if (NCheckboxGroup) {
          const {
            value: mergedSize
          } = NCheckboxGroup.mergedSizeRef;
          if (mergedSize !== void 0) {
            return mergedSize;
          }
        }
        if (NFormItem2) {
          const {
            mergedSize
          } = NFormItem2;
          if (mergedSize !== void 0)
            return mergedSize.value;
        }
        return "medium";
      },
      mergedDisabled(NFormItem2) {
        const {
          disabled
        } = props;
        if (disabled !== void 0)
          return disabled;
        if (NCheckboxGroup) {
          if (NCheckboxGroup.disabledRef.value)
            return true;
          const {
            maxRef: {
              value: max2
            },
            checkedCountRef
          } = NCheckboxGroup;
          if (max2 !== void 0 && checkedCountRef.value >= max2 && !renderedCheckedRef.value) {
            return true;
          }
          const {
            minRef: {
              value: min2
            }
          } = NCheckboxGroup;
          if (min2 !== void 0 && checkedCountRef.value <= min2 && renderedCheckedRef.value) {
            return true;
          }
        }
        if (NFormItem2) {
          return NFormItem2.disabled.value;
        }
        return false;
      }
    });
    const {
      mergedDisabledRef,
      mergedSizeRef
    } = formItem;
    const themeRef = useTheme("Checkbox", "-checkbox", style$d, checkboxLight$1, props, mergedClsPrefixRef);
    function toggle(e) {
      if (NCheckboxGroup && props.value !== void 0) {
        NCheckboxGroup.toggleCheckbox(!renderedCheckedRef.value, props.value);
      } else {
        const {
          onChange,
          "onUpdate:checked": _onUpdateCheck,
          onUpdateChecked
        } = props;
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        const nextChecked = renderedCheckedRef.value ? props.uncheckedValue : props.checkedValue;
        if (_onUpdateCheck) {
          call(_onUpdateCheck, nextChecked, e);
        }
        if (onUpdateChecked) {
          call(onUpdateChecked, nextChecked, e);
        }
        if (onChange)
          call(onChange, nextChecked, e);
        nTriggerFormInput();
        nTriggerFormChange();
        uncontrolledCheckedRef.value = nextChecked;
      }
    }
    function handleClick2(e) {
      if (!mergedDisabledRef.value) {
        toggle(e);
      }
    }
    function handleKeyUp(e) {
      if (mergedDisabledRef.value)
        return;
      switch (e.key) {
        case " ":
        case "Enter":
          toggle(e);
      }
    }
    function handleKeyDown(e) {
      switch (e.key) {
        case " ":
          e.preventDefault();
      }
    }
    const exposedMethods = {
      focus: () => {
        var _a;
        (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      },
      blur: () => {
        var _a;
        (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.blur();
      }
    };
    const rtlEnabledRef = useRtl("Checkbox", mergedRtlRef, mergedClsPrefixRef);
    const cssVarsRef = computed(() => {
      const {
        value: mergedSize
      } = mergedSizeRef;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: {
          borderRadius,
          color,
          colorChecked,
          colorDisabled,
          colorTableHeader,
          colorTableHeaderModal,
          colorTableHeaderPopover,
          checkMarkColor,
          checkMarkColorDisabled,
          border,
          borderFocus,
          borderDisabled,
          borderChecked,
          boxShadowFocus,
          textColor,
          textColorDisabled,
          checkMarkColorDisabledChecked,
          colorDisabledChecked,
          borderDisabledChecked,
          labelPadding,
          labelLineHeight,
          labelFontWeight,
          [createKey("fontSize", mergedSize)]: fontSize2,
          [createKey("size", mergedSize)]: size2
        }
      } = themeRef.value;
      return {
        "--n-label-line-height": labelLineHeight,
        "--n-label-font-weight": labelFontWeight,
        "--n-size": size2,
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-border-radius": borderRadius,
        "--n-border": border,
        "--n-border-checked": borderChecked,
        "--n-border-focus": borderFocus,
        "--n-border-disabled": borderDisabled,
        "--n-border-disabled-checked": borderDisabledChecked,
        "--n-box-shadow-focus": boxShadowFocus,
        "--n-color": color,
        "--n-color-checked": colorChecked,
        "--n-color-table": colorTableHeader,
        "--n-color-table-modal": colorTableHeaderModal,
        "--n-color-table-popover": colorTableHeaderPopover,
        "--n-color-disabled": colorDisabled,
        "--n-color-disabled-checked": colorDisabledChecked,
        "--n-text-color": textColor,
        "--n-text-color-disabled": textColorDisabled,
        "--n-check-mark-color": checkMarkColor,
        "--n-check-mark-color-disabled": checkMarkColorDisabled,
        "--n-check-mark-color-disabled-checked": checkMarkColorDisabledChecked,
        "--n-font-size": fontSize2,
        "--n-label-padding": labelPadding
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("checkbox", computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
    return Object.assign(formItem, exposedMethods, {
      rtlEnabled: rtlEnabledRef,
      selfRef,
      mergedClsPrefix: mergedClsPrefixRef,
      mergedDisabled: mergedDisabledRef,
      renderedChecked: renderedCheckedRef,
      mergedTheme: themeRef,
      labelId: createId(),
      handleClick: handleClick2,
      handleKeyUp,
      handleKeyDown,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    });
  },
  render() {
    var _a;
    const {
      $slots,
      renderedChecked,
      mergedDisabled,
      indeterminate,
      privateInsideTable,
      cssVars,
      labelId,
      label,
      mergedClsPrefix,
      focusable,
      handleKeyUp,
      handleKeyDown,
      handleClick: handleClick2
    } = this;
    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
    const labelNode = resolveWrappedSlot($slots.default, (children) => {
      if (label || children) {
        return h("span", {
          class: `${mergedClsPrefix}-checkbox__label`,
          id: labelId
        }, label || children);
      }
      return null;
    });
    return h("div", {
      ref: "selfRef",
      class: [`${mergedClsPrefix}-checkbox`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-checkbox--rtl`, renderedChecked && `${mergedClsPrefix}-checkbox--checked`, mergedDisabled && `${mergedClsPrefix}-checkbox--disabled`, indeterminate && `${mergedClsPrefix}-checkbox--indeterminate`, privateInsideTable && `${mergedClsPrefix}-checkbox--inside-table`, labelNode && `${mergedClsPrefix}-checkbox--show-label`],
      tabindex: mergedDisabled || !focusable ? void 0 : 0,
      role: "checkbox",
      "aria-checked": indeterminate ? "mixed" : renderedChecked,
      "aria-labelledby": labelId,
      style: cssVars,
      onKeyup: handleKeyUp,
      onKeydown: handleKeyDown,
      onClick: handleClick2,
      onMousedown: () => {
        on("selectstart", window, (e) => {
          e.preventDefault();
        }, {
          once: true
        });
      }
    }, h("div", {
      class: `${mergedClsPrefix}-checkbox-box-wrapper`
    }, " ", h("div", {
      class: `${mergedClsPrefix}-checkbox-box`
    }, h(NIconSwitchTransition, null, {
      default: () => this.indeterminate ? h("div", {
        key: "indeterminate",
        class: `${mergedClsPrefix}-checkbox-icon`
      }, LineMark) : h("div", {
        key: "check",
        class: `${mergedClsPrefix}-checkbox-icon`
      }, CheckMark)
    }), h("div", {
      class: `${mergedClsPrefix}-checkbox-box__border`
    }))), labelNode);
  }
});
function self$d(vars) {
  const {
    fontWeight,
    textColor1,
    textColor2,
    textColorDisabled,
    dividerColor,
    fontSize: fontSize2
  } = vars;
  return {
    titleFontSize: fontSize2,
    titleFontWeight: fontWeight,
    dividerColor,
    titleTextColor: textColor1,
    titleTextColorDisabled: textColorDisabled,
    fontSize: fontSize2,
    textColor: textColor2,
    arrowColor: textColor2,
    arrowColorDisabled: textColorDisabled,
    itemMargin: "16px 0 0 0",
    titlePadding: "16px 0 0 0"
  };
}
const collapseLight = {
  name: "Collapse",
  common: commonLight,
  self: self$d
};
const collapseLight$1 = collapseLight;
const style$c = cB("collapse", "width: 100%;", [cB("collapse-item", `
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 margin: var(--n-item-margin);
 `, [cM("disabled", [cE("header", "cursor: not-allowed;", [cE("header-main", `
 color: var(--n-title-text-color-disabled);
 `), cB("collapse-item-arrow", `
 color: var(--n-arrow-color-disabled);
 `)])]), cB("collapse-item", "margin-left: 32px;"), c$1("&:first-child", "margin-top: 0;"), c$1("&:first-child >", [cE("header", "padding-top: 0;")]), cM("left-arrow-placement", [cE("header", [cB("collapse-item-arrow", "margin-right: 4px;")])]), cM("right-arrow-placement", [cE("header", [cB("collapse-item-arrow", "margin-left: 4px;")])]), cE("content-wrapper", [cE("content-inner", "padding-top: 16px;"), fadeInHeightExpandTransition({
  duration: "0.15s"
})]), cM("active", [cE("header", [cM("active", [cB("collapse-item-arrow", "transform: rotate(90deg);")])])]), c$1("&:not(:first-child)", "border-top: 1px solid var(--n-divider-color);"), cNotM("disabled", [cM("trigger-area-main", [cE("header", [cE("header-main", "cursor: pointer;"), cB("collapse-item-arrow", "cursor: default;")])]), cM("trigger-area-arrow", [cE("header", [cB("collapse-item-arrow", "cursor: pointer;")])]), cM("trigger-area-extra", [cE("header", [cE("header-extra", "cursor: pointer;")])])]), cE("header", `
 font-size: var(--n-title-font-size);
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition: color .3s var(--n-bezier);
 position: relative;
 padding: var(--n-title-padding);
 color: var(--n-title-text-color);
 `, [cE("header-main", `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 color: var(--n-title-text-color);
 `), cE("header-extra", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cB("collapse-item-arrow", `
 display: flex;
 transition:
 transform .15s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: 18px;
 color: var(--n-arrow-color);
 `)])])]);
const collapseProps = Object.assign(Object.assign({}, useTheme.props), {
  defaultExpandedNames: {
    type: [Array, String],
    default: null
  },
  expandedNames: [Array, String],
  arrowPlacement: {
    type: String,
    default: "left"
  },
  accordion: {
    type: Boolean,
    default: false
  },
  displayDirective: {
    type: String,
    default: "if"
  },
  triggerAreas: {
    type: Array,
    default: () => ["main", "extra", "arrow"]
  },
  onItemHeaderClick: [Function, Array],
  "onUpdate:expandedNames": [Function, Array],
  onUpdateExpandedNames: [Function, Array],
  // deprecated
  onExpandedNamesChange: {
    type: [Function, Array],
    validator: () => {
      return true;
    },
    default: void 0
  }
});
const collapseInjectionKey = createInjectionKey("n-collapse");
const NCollapse = /* @__PURE__ */ defineComponent({
  name: "Collapse",
  props: collapseProps,
  setup(props, {
    slots
  }) {
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled,
      mergedRtlRef
    } = useConfig(props);
    const uncontrolledExpandedNamesRef = ref(props.defaultExpandedNames);
    const controlledExpandedNamesRef = computed(() => props.expandedNames);
    const mergedExpandedNamesRef = useMergedState(controlledExpandedNamesRef, uncontrolledExpandedNamesRef);
    const themeRef = useTheme("Collapse", "-collapse", style$c, collapseLight$1, props, mergedClsPrefixRef);
    function doUpdateExpandedNames(names) {
      const {
        "onUpdate:expandedNames": _onUpdateExpandedNames,
        onUpdateExpandedNames,
        onExpandedNamesChange
      } = props;
      if (onUpdateExpandedNames) {
        call(onUpdateExpandedNames, names);
      }
      if (_onUpdateExpandedNames) {
        call(_onUpdateExpandedNames, names);
      }
      if (onExpandedNamesChange) {
        call(onExpandedNamesChange, names);
      }
      uncontrolledExpandedNamesRef.value = names;
    }
    function doItemHeaderClick(info) {
      const {
        onItemHeaderClick
      } = props;
      if (onItemHeaderClick) {
        call(onItemHeaderClick, info);
      }
    }
    function toggleItem(collapse, name, event) {
      const {
        accordion
      } = props;
      const {
        value: expandedNames
      } = mergedExpandedNamesRef;
      if (accordion) {
        if (collapse) {
          doUpdateExpandedNames([name]);
          doItemHeaderClick({
            name,
            expanded: true,
            event
          });
        } else {
          doUpdateExpandedNames([]);
          doItemHeaderClick({
            name,
            expanded: false,
            event
          });
        }
      } else {
        if (!Array.isArray(expandedNames)) {
          doUpdateExpandedNames([name]);
          doItemHeaderClick({
            name,
            expanded: true,
            event
          });
        } else {
          const activeNames = expandedNames.slice();
          const index = activeNames.findIndex((activeName) => name === activeName);
          if (~index) {
            activeNames.splice(index, 1);
            doUpdateExpandedNames(activeNames);
            doItemHeaderClick({
              name,
              expanded: false,
              event
            });
          } else {
            activeNames.push(name);
            doUpdateExpandedNames(activeNames);
            doItemHeaderClick({
              name,
              expanded: true,
              event
            });
          }
        }
      }
    }
    provide(collapseInjectionKey, {
      props,
      mergedClsPrefixRef,
      expandedNamesRef: mergedExpandedNamesRef,
      slots,
      toggleItem
    });
    const rtlEnabledRef = useRtl("Collapse", mergedRtlRef, mergedClsPrefixRef);
    const cssVarsRef = computed(() => {
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: {
          titleFontWeight,
          dividerColor,
          titlePadding,
          titleTextColor,
          titleTextColorDisabled,
          textColor,
          arrowColor,
          fontSize: fontSize2,
          titleFontSize,
          arrowColorDisabled,
          itemMargin
        }
      } = themeRef.value;
      return {
        "--n-font-size": fontSize2,
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-text-color": textColor,
        "--n-divider-color": dividerColor,
        "--n-title-padding": titlePadding,
        "--n-title-font-size": titleFontSize,
        "--n-title-text-color": titleTextColor,
        "--n-title-text-color-disabled": titleTextColorDisabled,
        "--n-title-font-weight": titleFontWeight,
        "--n-arrow-color": arrowColor,
        "--n-arrow-color-disabled": arrowColorDisabled,
        "--n-item-margin": itemMargin
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("collapse", void 0, cssVarsRef, props) : void 0;
    return {
      rtlEnabled: rtlEnabledRef,
      mergedTheme: themeRef,
      mergedClsPrefix: mergedClsPrefixRef,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    var _a;
    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
    return h("div", {
      class: [`${this.mergedClsPrefix}-collapse`, this.rtlEnabled && `${this.mergedClsPrefix}-collapse--rtl`, this.themeClass],
      style: this.cssVars
    }, this.$slots);
  }
});
const NCollapseItemContent = /* @__PURE__ */ defineComponent({
  name: "CollapseItemContent",
  props: {
    displayDirective: {
      type: String,
      required: true
    },
    show: Boolean,
    clsPrefix: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const onceTrueRef = useFalseUntilTruthy(toRef(props, "show"));
    return {
      onceTrue: onceTrueRef
    };
  },
  render() {
    return h(NFadeInExpandTransition, null, {
      default: () => {
        const {
          show,
          displayDirective,
          onceTrue,
          clsPrefix
        } = this;
        const useVShow = displayDirective === "show" && onceTrue;
        const contentNode = h("div", {
          class: `${clsPrefix}-collapse-item__content-wrapper`
        }, h("div", {
          class: `${clsPrefix}-collapse-item__content-inner`
        }, this.$slots));
        return useVShow ? withDirectives(contentNode, [[vShow, show]]) : show ? contentNode : null;
      }
    });
  }
});
const collapseItemProps = {
  title: String,
  name: [String, Number],
  disabled: Boolean,
  displayDirective: String
};
const NCollapseItem = /* @__PURE__ */ defineComponent({
  name: "CollapseItem",
  props: collapseItemProps,
  setup(props) {
    const {
      mergedRtlRef
    } = useConfig(props);
    const randomName = createId();
    const mergedNameRef = useMemo(() => {
      var _a;
      return (_a = props.name) !== null && _a !== void 0 ? _a : randomName;
    });
    const NCollapse2 = inject(collapseInjectionKey);
    if (!NCollapse2) {
      throwError("collapse-item", "`n-collapse-item` must be placed inside `n-collapse`.");
    }
    const {
      expandedNamesRef,
      props: collapseProps2,
      mergedClsPrefixRef,
      slots: collapseSlots
    } = NCollapse2;
    const collapsedRef = computed(() => {
      const {
        value: expandedNames
      } = expandedNamesRef;
      if (Array.isArray(expandedNames)) {
        const {
          value: name
        } = mergedNameRef;
        return !~expandedNames.findIndex((expandedName) => expandedName === name);
      } else if (expandedNames) {
        const {
          value: name
        } = mergedNameRef;
        return name !== expandedNames;
      }
      return true;
    });
    const rtlEnabledRef = useRtl("Collapse", mergedRtlRef, mergedClsPrefixRef);
    return {
      rtlEnabled: rtlEnabledRef,
      collapseSlots,
      randomName,
      mergedClsPrefix: mergedClsPrefixRef,
      collapsed: collapsedRef,
      triggerAreas: toRef(collapseProps2, "triggerAreas"),
      mergedDisplayDirective: computed(() => {
        const {
          displayDirective
        } = props;
        if (displayDirective) {
          return displayDirective;
        } else {
          return collapseProps2.displayDirective;
        }
      }),
      arrowPlacement: computed(() => {
        return collapseProps2.arrowPlacement;
      }),
      handleClick(e) {
        let happensInArea = "main";
        if (happensIn(e, "arrow"))
          happensInArea = "arrow";
        if (happensIn(e, "extra"))
          happensInArea = "extra";
        if (!collapseProps2.triggerAreas.includes(happensInArea)) {
          return;
        }
        if (NCollapse2 && !props.disabled) {
          NCollapse2.toggleItem(collapsedRef.value, mergedNameRef.value, e);
        }
      }
    };
  },
  render() {
    const {
      collapseSlots,
      $slots,
      arrowPlacement,
      collapsed,
      mergedDisplayDirective,
      mergedClsPrefix,
      disabled,
      triggerAreas
    } = this;
    const headerNode = resolveSlotWithProps($slots.header, {
      collapsed
    }, () => [this.title]);
    const headerExtraSlot = $slots["header-extra"] || collapseSlots["header-extra"];
    const arrowSlot = $slots.arrow || collapseSlots.arrow;
    return h("div", {
      class: [`${mergedClsPrefix}-collapse-item`, `${mergedClsPrefix}-collapse-item--${arrowPlacement}-arrow-placement`, disabled && `${mergedClsPrefix}-collapse-item--disabled`, !collapsed && `${mergedClsPrefix}-collapse-item--active`, triggerAreas.map((area) => {
        return `${mergedClsPrefix}-collapse-item--trigger-area-${area}`;
      })]
    }, h("div", {
      class: [`${mergedClsPrefix}-collapse-item__header`, !collapsed && `${mergedClsPrefix}-collapse-item__header--active`]
    }, h("div", {
      class: `${mergedClsPrefix}-collapse-item__header-main`,
      onClick: this.handleClick
    }, arrowPlacement === "right" && headerNode, h("div", {
      class: `${mergedClsPrefix}-collapse-item-arrow`,
      key: this.rtlEnabled ? 0 : 1,
      "data-arrow": true
    }, resolveSlotWithProps(arrowSlot, {
      collapsed
    }, () => {
      var _a;
      return [h(NBaseIcon, {
        clsPrefix: mergedClsPrefix
      }, {
        default: (_a = collapseSlots.expandIcon) !== null && _a !== void 0 ? _a : () => this.rtlEnabled ? h(ChevronLeftIcon, null) : h(ChevronRightIcon, null)
      })];
    })), arrowPlacement === "left" && headerNode), resolveWrappedSlotWithProps(headerExtraSlot, {
      collapsed
    }, (children) => h("div", {
      class: `${mergedClsPrefix}-collapse-item__header-extra`,
      onClick: this.handleClick,
      "data-extra": true
    }, children))), h(NCollapseItemContent, {
      clsPrefix: mergedClsPrefix,
      displayDirective: mergedDisplayDirective,
      show: !collapsed
    }, $slots));
  }
});
const commonVars$1 = {
  padding: "8px 14px"
};
function self$c(vars) {
  const {
    borderRadius,
    boxShadow2,
    baseColor
  } = vars;
  return Object.assign(Object.assign({}, commonVars$1), {
    borderRadius,
    boxShadow: boxShadow2,
    color: composite(baseColor, "rgba(0, 0, 0, .85)"),
    textColor: baseColor
  });
}
const tooltipLight = createTheme({
  name: "Tooltip",
  common: commonLight,
  peers: {
    Popover: popoverLight$1
  },
  self: self$c
});
const tooltipLight$1 = tooltipLight;
const commonVariables$1 = {
  padding: "4px 0",
  optionIconSizeSmall: "14px",
  optionIconSizeMedium: "16px",
  optionIconSizeLarge: "16px",
  optionIconSizeHuge: "18px",
  optionSuffixWidthSmall: "14px",
  optionSuffixWidthMedium: "14px",
  optionSuffixWidthLarge: "16px",
  optionSuffixWidthHuge: "16px",
  optionIconSuffixWidthSmall: "32px",
  optionIconSuffixWidthMedium: "32px",
  optionIconSuffixWidthLarge: "36px",
  optionIconSuffixWidthHuge: "36px",
  optionPrefixWidthSmall: "14px",
  optionPrefixWidthMedium: "14px",
  optionPrefixWidthLarge: "16px",
  optionPrefixWidthHuge: "16px",
  optionIconPrefixWidthSmall: "36px",
  optionIconPrefixWidthMedium: "36px",
  optionIconPrefixWidthLarge: "40px",
  optionIconPrefixWidthHuge: "40px"
};
function self$b(vars) {
  const {
    primaryColor,
    textColor2,
    dividerColor,
    hoverColor,
    popoverColor,
    invertedColor,
    borderRadius,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    fontSizeHuge,
    heightSmall,
    heightMedium,
    heightLarge,
    heightHuge,
    textColor3,
    opacityDisabled
  } = vars;
  return Object.assign(Object.assign({}, commonVariables$1), {
    optionHeightSmall: heightSmall,
    optionHeightMedium: heightMedium,
    optionHeightLarge: heightLarge,
    optionHeightHuge: heightHuge,
    borderRadius,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    fontSizeHuge,
    // non-inverted
    optionTextColor: textColor2,
    optionTextColorHover: textColor2,
    optionTextColorActive: primaryColor,
    optionTextColorChildActive: primaryColor,
    color: popoverColor,
    dividerColor,
    suffixColor: textColor2,
    prefixColor: textColor2,
    optionColorHover: hoverColor,
    optionColorActive: changeColor(primaryColor, {
      alpha: 0.1
    }),
    groupHeaderTextColor: textColor3,
    // inverted
    optionTextColorInverted: "#BBB",
    optionTextColorHoverInverted: "#FFF",
    optionTextColorActiveInverted: "#FFF",
    optionTextColorChildActiveInverted: "#FFF",
    colorInverted: invertedColor,
    dividerColorInverted: "#BBB",
    suffixColorInverted: "#BBB",
    prefixColorInverted: "#BBB",
    optionColorHoverInverted: primaryColor,
    optionColorActiveInverted: primaryColor,
    groupHeaderTextColorInverted: "#AAA",
    optionOpacityDisabled: opacityDisabled
  });
}
const dropdownLight = createTheme({
  name: "Dropdown",
  common: commonLight,
  peers: {
    Popover: popoverLight$1
  },
  self: self$b
});
const dropdownLight$1 = dropdownLight;
const tooltipProps = Object.assign(Object.assign({}, popoverBaseProps), useTheme.props);
const NTooltip = /* @__PURE__ */ defineComponent({
  name: "Tooltip",
  props: tooltipProps,
  __popover__: true,
  setup(props) {
    const {
      mergedClsPrefixRef
    } = useConfig(props);
    const themeRef = useTheme("Tooltip", "-tooltip", void 0, tooltipLight$1, props, mergedClsPrefixRef);
    const popoverRef = ref(null);
    const tooltipExposedMethod = {
      syncPosition() {
        popoverRef.value.syncPosition();
      },
      setShow(show) {
        popoverRef.value.setShow(show);
      }
    };
    return Object.assign(Object.assign({}, tooltipExposedMethod), {
      popoverRef,
      mergedTheme: themeRef,
      popoverThemeOverrides: computed(() => {
        return themeRef.value.self;
      })
    });
  },
  render() {
    const {
      mergedTheme,
      internalExtraClass
    } = this;
    return h(NPopover, Object.assign(Object.assign({}, this.$props), {
      theme: mergedTheme.peers.Popover,
      themeOverrides: mergedTheme.peerOverrides.Popover,
      builtinThemeOverrides: this.popoverThemeOverrides,
      internalExtraClass: internalExtraClass.concat("tooltip"),
      ref: "popoverRef"
    }), this.$slots);
  }
});
const NDropdownDivider = /* @__PURE__ */ defineComponent({
  name: "DropdownDivider",
  props: {
    clsPrefix: {
      type: String,
      required: true
    }
  },
  render() {
    return h("div", {
      class: `${this.clsPrefix}-dropdown-divider`
    });
  }
});
function self$a(vars) {
  const {
    textColorBase,
    opacity1,
    opacity2,
    opacity3,
    opacity4,
    opacity5
  } = vars;
  return {
    color: textColorBase,
    opacity1Depth: opacity1,
    opacity2Depth: opacity2,
    opacity3Depth: opacity3,
    opacity4Depth: opacity4,
    opacity5Depth: opacity5
  };
}
const iconLight = {
  name: "Icon",
  common: commonLight,
  self: self$a
};
const iconLight$1 = iconLight;
const style$b = cB("icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [cM("color-transition", {
  transition: "color .3s var(--n-bezier)"
}), cM("depth", {
  color: "var(--n-color)"
}, [c$1("svg", {
  opacity: "var(--n-opacity)",
  transition: "opacity .3s var(--n-bezier)"
})]), c$1("svg", {
  height: "1em",
  width: "1em"
})]);
const iconProps = Object.assign(Object.assign({}, useTheme.props), {
  depth: [String, Number],
  size: [Number, String],
  color: String,
  component: Object
});
const NIcon = /* @__PURE__ */ defineComponent({
  _n_icon__: true,
  name: "Icon",
  inheritAttrs: false,
  props: iconProps,
  setup(props) {
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Icon", "-icon", style$b, iconLight$1, props, mergedClsPrefixRef);
    const cssVarsRef = computed(() => {
      const {
        depth
      } = props;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: self2
      } = themeRef.value;
      if (depth !== void 0) {
        const {
          color,
          [`opacity${depth}Depth`]: opacity
        } = self2;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color": color,
          "--n-opacity": opacity
        };
      }
      return {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-color": "",
        "--n-opacity": ""
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon", computed(() => `${props.depth || "d"}`), cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      mergedStyle: computed(() => {
        const {
          size: size2,
          color
        } = props;
        return {
          fontSize: formatLength(size2),
          color
        };
      }),
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    var _a;
    const {
      $parent,
      depth,
      mergedClsPrefix,
      component,
      onRender,
      themeClass
    } = this;
    if ((_a = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a === void 0 ? void 0 : _a._n_icon__) {
      warn$2("icon", "don't wrap `n-icon` inside `n-icon`");
    }
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return h("i", mergeProps(this.$attrs, {
      role: "img",
      class: [`${mergedClsPrefix}-icon`, themeClass, {
        [`${mergedClsPrefix}-icon--depth`]: depth,
        [`${mergedClsPrefix}-icon--color-transition`]: depth !== void 0
      }],
      style: [this.cssVars, this.mergedStyle]
    }), component ? h(component) : this.$slots);
  }
});
const dropdownMenuInjectionKey = createInjectionKey("n-dropdown-menu");
const dropdownInjectionKey = createInjectionKey("n-dropdown");
const dropdownOptionInjectionKey = createInjectionKey("n-dropdown-option");
function isSubmenuNode(rawNode, childrenField) {
  return rawNode.type === "submenu" || rawNode.type === void 0 && rawNode[childrenField] !== void 0;
}
function isGroupNode(rawNode) {
  return rawNode.type === "group";
}
function isDividerNode$1(rawNode) {
  return rawNode.type === "divider";
}
function isRenderNode(rawNode) {
  return rawNode.type === "render";
}
const NDropdownOption = /* @__PURE__ */ defineComponent({
  name: "DropdownOption",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    },
    parentKey: {
      type: [String, Number],
      default: null
    },
    placement: {
      type: String,
      default: "right-start"
    },
    props: Object,
    scrollable: Boolean
  },
  setup(props) {
    const NDropdown2 = inject(dropdownInjectionKey);
    const {
      hoverKeyRef,
      keyboardKeyRef,
      lastToggledSubmenuKeyRef,
      pendingKeyPathRef,
      activeKeyPathRef,
      animatedRef,
      mergedShowRef,
      renderLabelRef,
      renderIconRef,
      labelFieldRef,
      childrenFieldRef,
      renderOptionRef,
      nodePropsRef,
      menuPropsRef
    } = NDropdown2;
    const NDropdownOption2 = inject(dropdownOptionInjectionKey, null);
    const NDropdownMenu2 = inject(dropdownMenuInjectionKey);
    const NPopoverBody2 = inject(popoverBodyInjectionKey);
    const rawNodeRef = computed(() => props.tmNode.rawNode);
    const hasSubmenuRef = computed(() => {
      const {
        value: childrenField
      } = childrenFieldRef;
      return isSubmenuNode(props.tmNode.rawNode, childrenField);
    });
    const mergedDisabledRef = computed(() => {
      const {
        disabled
      } = props.tmNode;
      return disabled;
    });
    const showSubmenuRef = computed(() => {
      if (!hasSubmenuRef.value)
        return false;
      const {
        key,
        disabled
      } = props.tmNode;
      if (disabled)
        return false;
      const {
        value: hoverKey
      } = hoverKeyRef;
      const {
        value: keyboardKey
      } = keyboardKeyRef;
      const {
        value: lastToggledSubmenuKey
      } = lastToggledSubmenuKeyRef;
      const {
        value: pendingKeyPath
      } = pendingKeyPathRef;
      if (hoverKey !== null)
        return pendingKeyPath.includes(key);
      if (keyboardKey !== null) {
        return pendingKeyPath.includes(key) && pendingKeyPath[pendingKeyPath.length - 1] !== key;
      }
      if (lastToggledSubmenuKey !== null)
        return pendingKeyPath.includes(key);
      return false;
    });
    const shouldDelayRef = computed(() => {
      return keyboardKeyRef.value === null && !animatedRef.value;
    });
    const deferredShowSubmenuRef = useDeferredTrue(showSubmenuRef, 300, shouldDelayRef);
    const parentEnteringSubmenuRef = computed(() => {
      return !!(NDropdownOption2 === null || NDropdownOption2 === void 0 ? void 0 : NDropdownOption2.enteringSubmenuRef.value);
    });
    const enteringSubmenuRef = ref(false);
    provide(dropdownOptionInjectionKey, {
      enteringSubmenuRef
    });
    function handleSubmenuBeforeEnter() {
      enteringSubmenuRef.value = true;
    }
    function handleSubmenuAfterEnter() {
      enteringSubmenuRef.value = false;
    }
    function handleMouseEnter() {
      const {
        parentKey,
        tmNode
      } = props;
      if (tmNode.disabled)
        return;
      if (!mergedShowRef.value)
        return;
      lastToggledSubmenuKeyRef.value = parentKey;
      keyboardKeyRef.value = null;
      hoverKeyRef.value = tmNode.key;
    }
    function handleMouseMove() {
      const {
        tmNode
      } = props;
      if (tmNode.disabled)
        return;
      if (!mergedShowRef.value)
        return;
      if (hoverKeyRef.value === tmNode.key)
        return;
      handleMouseEnter();
    }
    function handleMouseLeave(e) {
      if (props.tmNode.disabled)
        return;
      if (!mergedShowRef.value)
        return;
      const {
        relatedTarget
      } = e;
      if (relatedTarget && !happensIn({
        target: relatedTarget
      }, "dropdownOption") && !happensIn({
        target: relatedTarget
      }, "scrollbarRail")) {
        hoverKeyRef.value = null;
      }
    }
    function handleClick2() {
      const {
        value: hasSubmenu
      } = hasSubmenuRef;
      const {
        tmNode
      } = props;
      if (!mergedShowRef.value)
        return;
      if (!hasSubmenu && !tmNode.disabled) {
        NDropdown2.doSelect(tmNode.key, tmNode.rawNode);
        NDropdown2.doUpdateShow(false);
      }
    }
    return {
      labelField: labelFieldRef,
      renderLabel: renderLabelRef,
      renderIcon: renderIconRef,
      siblingHasIcon: NDropdownMenu2.showIconRef,
      siblingHasSubmenu: NDropdownMenu2.hasSubmenuRef,
      menuProps: menuPropsRef,
      popoverBody: NPopoverBody2,
      animated: animatedRef,
      mergedShowSubmenu: computed(() => {
        return deferredShowSubmenuRef.value && !parentEnteringSubmenuRef.value;
      }),
      rawNode: rawNodeRef,
      hasSubmenu: hasSubmenuRef,
      pending: useMemo(() => {
        const {
          value: pendingKeyPath
        } = pendingKeyPathRef;
        const {
          key
        } = props.tmNode;
        return pendingKeyPath.includes(key);
      }),
      childActive: useMemo(() => {
        const {
          value: activeKeyPath
        } = activeKeyPathRef;
        const {
          key
        } = props.tmNode;
        const index = activeKeyPath.findIndex((k) => key === k);
        if (index === -1)
          return false;
        return index < activeKeyPath.length - 1;
      }),
      active: useMemo(() => {
        const {
          value: activeKeyPath
        } = activeKeyPathRef;
        const {
          key
        } = props.tmNode;
        const index = activeKeyPath.findIndex((k) => key === k);
        if (index === -1)
          return false;
        return index === activeKeyPath.length - 1;
      }),
      mergedDisabled: mergedDisabledRef,
      renderOption: renderOptionRef,
      nodeProps: nodePropsRef,
      handleClick: handleClick2,
      handleMouseMove,
      handleMouseEnter,
      handleMouseLeave,
      handleSubmenuBeforeEnter,
      handleSubmenuAfterEnter
    };
  },
  render() {
    var _a, _b;
    const {
      animated,
      rawNode,
      mergedShowSubmenu,
      clsPrefix,
      siblingHasIcon,
      siblingHasSubmenu,
      renderLabel,
      renderIcon,
      renderOption,
      nodeProps,
      props,
      scrollable
    } = this;
    let submenuVNode = null;
    if (mergedShowSubmenu) {
      const submenuNodeProps = (_a = this.menuProps) === null || _a === void 0 ? void 0 : _a.call(this, rawNode, rawNode.children);
      submenuVNode = h(NDropdownMenu, Object.assign({}, submenuNodeProps, {
        clsPrefix,
        scrollable: this.scrollable,
        tmNodes: this.tmNode.children,
        parentKey: this.tmNode.key
      }));
    }
    const builtinProps = {
      class: [`${clsPrefix}-dropdown-option-body`, this.pending && `${clsPrefix}-dropdown-option-body--pending`, this.active && `${clsPrefix}-dropdown-option-body--active`, this.childActive && `${clsPrefix}-dropdown-option-body--child-active`, this.mergedDisabled && `${clsPrefix}-dropdown-option-body--disabled`],
      onMousemove: this.handleMouseMove,
      onMouseenter: this.handleMouseEnter,
      onMouseleave: this.handleMouseLeave,
      onClick: this.handleClick
    };
    const optionNodeProps = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
    const node = h("div", Object.assign({
      class: [`${clsPrefix}-dropdown-option`, optionNodeProps === null || optionNodeProps === void 0 ? void 0 : optionNodeProps.class],
      "data-dropdown-option": true
    }, optionNodeProps), h("div", mergeProps(builtinProps, props), [h("div", {
      class: [`${clsPrefix}-dropdown-option-body__prefix`, siblingHasIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
    }, [renderIcon ? renderIcon(rawNode) : render$1(rawNode.icon)]), h("div", {
      "data-dropdown-option": true,
      class: `${clsPrefix}-dropdown-option-body__label`
    }, renderLabel ? renderLabel(rawNode) : render$1((_b = rawNode[this.labelField]) !== null && _b !== void 0 ? _b : rawNode.title)), h("div", {
      "data-dropdown-option": true,
      class: [`${clsPrefix}-dropdown-option-body__suffix`, siblingHasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`]
    }, this.hasSubmenu ? h(NIcon, null, {
      default: () => h(ChevronRightIcon, null)
    }) : null)]), this.hasSubmenu ? h(VBinder, null, {
      default: () => [h(VTarget, null, {
        default: () => h("div", {
          class: `${clsPrefix}-dropdown-offset-container`
        }, h(VFollower, {
          show: this.mergedShowSubmenu,
          placement: this.placement,
          to: scrollable ? this.popoverBody || void 0 : void 0,
          teleportDisabled: !scrollable
        }, {
          default: () => {
            return h("div", {
              class: `${clsPrefix}-dropdown-menu-wrapper`
            }, animated ? h(Transition, {
              onBeforeEnter: this.handleSubmenuBeforeEnter,
              onAfterEnter: this.handleSubmenuAfterEnter,
              name: "fade-in-scale-up-transition",
              appear: true
            }, {
              default: () => submenuVNode
            }) : submenuVNode);
          }
        }))
      })]
    }) : null);
    if (renderOption) {
      return renderOption({
        node,
        option: rawNode
      });
    }
    return node;
  }
});
const NDropdownGroupHeader = /* @__PURE__ */ defineComponent({
  name: "DropdownGroupHeader",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    }
  },
  setup() {
    const {
      showIconRef,
      hasSubmenuRef
    } = inject(dropdownMenuInjectionKey);
    const {
      renderLabelRef,
      labelFieldRef,
      nodePropsRef,
      renderOptionRef
    } = inject(dropdownInjectionKey);
    return {
      labelField: labelFieldRef,
      showIcon: showIconRef,
      hasSubmenu: hasSubmenuRef,
      renderLabel: renderLabelRef,
      nodeProps: nodePropsRef,
      renderOption: renderOptionRef
    };
  },
  render() {
    var _a;
    const {
      clsPrefix,
      hasSubmenu,
      showIcon,
      nodeProps,
      renderLabel,
      renderOption
    } = this;
    const {
      rawNode
    } = this.tmNode;
    const node = h("div", Object.assign({
      class: `${clsPrefix}-dropdown-option`
    }, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode)), h("div", {
      class: `${clsPrefix}-dropdown-option-body ${clsPrefix}-dropdown-option-body--group`
    }, h("div", {
      "data-dropdown-option": true,
      class: [`${clsPrefix}-dropdown-option-body__prefix`, showIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
    }, render$1(rawNode.icon)), h("div", {
      class: `${clsPrefix}-dropdown-option-body__label`,
      "data-dropdown-option": true
    }, renderLabel ? renderLabel(rawNode) : render$1((_a = rawNode.title) !== null && _a !== void 0 ? _a : rawNode[this.labelField])), h("div", {
      class: [`${clsPrefix}-dropdown-option-body__suffix`, hasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`],
      "data-dropdown-option": true
    })));
    if (renderOption) {
      return renderOption({
        node,
        option: rawNode
      });
    }
    return node;
  }
});
const NDropdownGroup = /* @__PURE__ */ defineComponent({
  name: "NDropdownGroup",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    },
    parentKey: {
      type: [String, Number],
      default: null
    }
  },
  render() {
    const {
      tmNode,
      parentKey,
      clsPrefix
    } = this;
    const {
      children
    } = tmNode;
    return h(Fragment, null, h(NDropdownGroupHeader, {
      clsPrefix,
      tmNode,
      key: tmNode.key
    }), children === null || children === void 0 ? void 0 : children.map((child) => {
      const {
        rawNode
      } = child;
      if (rawNode.show === false)
        return null;
      if (isDividerNode$1(rawNode)) {
        return h(NDropdownDivider, {
          clsPrefix,
          key: child.key
        });
      }
      if (child.isGroup) {
        warn$2("dropdown", "`group` node is not allowed to be put in `group` node.");
        return null;
      }
      return h(NDropdownOption, {
        clsPrefix,
        tmNode: child,
        parentKey,
        key: child.key
      });
    }));
  }
});
const NDropdownRenderOption = /* @__PURE__ */ defineComponent({
  name: "DropdownRenderOption",
  props: {
    tmNode: {
      type: Object,
      required: true
    }
  },
  render() {
    const {
      rawNode: {
        render: render22,
        props
      }
    } = this.tmNode;
    return h("div", props, [render22 === null || render22 === void 0 ? void 0 : render22()]);
  }
});
const NDropdownMenu = /* @__PURE__ */ defineComponent({
  name: "DropdownMenu",
  props: {
    scrollable: Boolean,
    showArrow: Boolean,
    arrowStyle: [String, Object],
    clsPrefix: {
      type: String,
      required: true
    },
    tmNodes: {
      type: Array,
      default: () => []
    },
    parentKey: {
      type: [String, Number],
      default: null
    }
  },
  setup(props) {
    const {
      renderIconRef,
      childrenFieldRef
    } = inject(dropdownInjectionKey);
    provide(dropdownMenuInjectionKey, {
      showIconRef: computed(() => {
        const renderIcon = renderIconRef.value;
        return props.tmNodes.some((tmNode) => {
          var _a;
          if (tmNode.isGroup) {
            return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({
              rawNode: rawChild
            }) => renderIcon ? renderIcon(rawChild) : rawChild.icon);
          }
          const {
            rawNode
          } = tmNode;
          return renderIcon ? renderIcon(rawNode) : rawNode.icon;
        });
      }),
      hasSubmenuRef: computed(() => {
        const {
          value: childrenField
        } = childrenFieldRef;
        return props.tmNodes.some((tmNode) => {
          var _a;
          if (tmNode.isGroup) {
            return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({
              rawNode: rawChild
            }) => isSubmenuNode(rawChild, childrenField));
          }
          const {
            rawNode
          } = tmNode;
          return isSubmenuNode(rawNode, childrenField);
        });
      })
    });
    const bodyRef = ref(null);
    provide(modalBodyInjectionKey, null);
    provide(drawerBodyInjectionKey, null);
    provide(popoverBodyInjectionKey, bodyRef);
    return {
      bodyRef
    };
  },
  render() {
    const {
      parentKey,
      clsPrefix,
      scrollable
    } = this;
    const menuOptionsNode = this.tmNodes.map((tmNode) => {
      const {
        rawNode
      } = tmNode;
      if (rawNode.show === false)
        return null;
      if (isRenderNode(rawNode)) {
        return h(NDropdownRenderOption, {
          tmNode,
          key: tmNode.key
        });
      }
      if (isDividerNode$1(rawNode)) {
        return h(NDropdownDivider, {
          clsPrefix,
          key: tmNode.key
        });
      }
      if (isGroupNode(rawNode)) {
        return h(NDropdownGroup, {
          clsPrefix,
          tmNode,
          parentKey,
          key: tmNode.key
        });
      }
      return h(NDropdownOption, {
        clsPrefix,
        tmNode,
        parentKey,
        key: tmNode.key,
        props: rawNode.props,
        scrollable
      });
    });
    return h("div", {
      class: [`${clsPrefix}-dropdown-menu`, scrollable && `${clsPrefix}-dropdown-menu--scrollable`],
      ref: "bodyRef"
    }, scrollable ? h(XScrollbar, {
      contentClass: `${clsPrefix}-dropdown-menu__content`
    }, {
      default: () => menuOptionsNode
    }) : menuOptionsNode, this.showArrow ? renderArrow({
      clsPrefix,
      arrowStyle: this.arrowStyle,
      arrowClass: void 0,
      arrowWrapperClass: void 0,
      arrowWrapperStyle: void 0
    }) : null);
  }
});
const style$a = cB("dropdown-menu", `
 transform-origin: var(--v-transform-origin);
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 position: relative;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [fadeInScaleUpTransition(), cB("dropdown-option", `
 position: relative;
 `, [c$1("a", `
 text-decoration: none;
 color: inherit;
 outline: none;
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("dropdown-option-body", `
 display: flex;
 cursor: pointer;
 position: relative;
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-font-size);
 color: var(--n-option-text-color);
 transition: color .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 left: 4px;
 right: 4px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `), cNotM("disabled", [cM("pending", `
 color: var(--n-option-text-color-hover);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-hover);
 `), c$1("&::before", "background-color: var(--n-option-color-hover);")]), cM("active", `
 color: var(--n-option-text-color-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-active);
 `), c$1("&::before", "background-color: var(--n-option-color-active);")]), cM("child-active", `
 color: var(--n-option-text-color-child-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-child-active);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-option-opacity-disabled);
 `), cM("group", `
 font-size: calc(var(--n-font-size) - 1px);
 color: var(--n-group-header-text-color);
 `, [cE("prefix", `
 width: calc(var(--n-option-prefix-width) / 2);
 `, [cM("show-icon", `
 width: calc(var(--n-option-icon-prefix-width) / 2);
 `)])]), cE("prefix", `
 width: var(--n-option-prefix-width);
 display: flex;
 justify-content: center;
 align-items: center;
 color: var(--n-prefix-color);
 transition: color .3s var(--n-bezier);
 z-index: 1;
 `, [cM("show-icon", `
 width: var(--n-option-icon-prefix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cE("label", `
 white-space: nowrap;
 flex: 1;
 z-index: 1;
 `), cE("suffix", `
 box-sizing: border-box;
 flex-grow: 0;
 flex-shrink: 0;
 display: flex;
 justify-content: flex-end;
 align-items: center;
 min-width: var(--n-option-suffix-width);
 padding: 0 8px;
 transition: color .3s var(--n-bezier);
 color: var(--n-suffix-color);
 z-index: 1;
 `, [cM("has-submenu", `
 width: var(--n-option-icon-suffix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cB("dropdown-menu", "pointer-events: all;")]), cB("dropdown-offset-container", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: -4px;
 bottom: -4px;
 `)]), cB("dropdown-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 4px 0;
 `), cB("dropdown-menu-wrapper", `
 transform-origin: var(--v-transform-origin);
 width: fit-content;
 `), c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("scrollable", `
 padding: var(--n-padding);
 `), cM("scrollable", [cE("content", `
 padding: var(--n-padding);
 `)])]);
const dropdownBaseProps = {
  animated: {
    type: Boolean,
    default: true
  },
  keyboard: {
    type: Boolean,
    default: true
  },
  size: {
    type: String,
    default: "medium"
  },
  inverted: Boolean,
  placement: {
    type: String,
    default: "bottom"
  },
  onSelect: [Function, Array],
  options: {
    type: Array,
    default: () => []
  },
  menuProps: Function,
  showArrow: Boolean,
  renderLabel: Function,
  renderIcon: Function,
  renderOption: Function,
  nodeProps: Function,
  labelField: {
    type: String,
    default: "label"
  },
  keyField: {
    type: String,
    default: "key"
  },
  childrenField: {
    type: String,
    default: "children"
  },
  // for menu, not documented
  value: [String, Number]
};
const popoverPropKeys = Object.keys(popoverBaseProps);
const dropdownProps = Object.assign(Object.assign(Object.assign({}, popoverBaseProps), dropdownBaseProps), useTheme.props);
const NDropdown = /* @__PURE__ */ defineComponent({
  name: "Dropdown",
  inheritAttrs: false,
  props: dropdownProps,
  setup(props) {
    const uncontrolledShowRef = ref(false);
    const mergedShowRef = useMergedState(toRef(props, "show"), uncontrolledShowRef);
    const treemateRef = computed(() => {
      const {
        keyField,
        childrenField
      } = props;
      return createTreeMate(props.options, {
        getKey(node) {
          return node[keyField];
        },
        getDisabled(node) {
          return node.disabled === true;
        },
        getIgnored(node) {
          return node.type === "divider" || node.type === "render";
        },
        getChildren(node) {
          return node[childrenField];
        }
      });
    });
    const tmNodesRef = computed(() => {
      return treemateRef.value.treeNodes;
    });
    const hoverKeyRef = ref(null);
    const keyboardKeyRef = ref(null);
    const lastToggledSubmenuKeyRef = ref(null);
    const pendingKeyRef = computed(() => {
      var _a, _b, _c;
      return (_c = (_b = (_a = hoverKeyRef.value) !== null && _a !== void 0 ? _a : keyboardKeyRef.value) !== null && _b !== void 0 ? _b : lastToggledSubmenuKeyRef.value) !== null && _c !== void 0 ? _c : null;
    });
    const pendingKeyPathRef = computed(() => treemateRef.value.getPath(pendingKeyRef.value).keyPath);
    const activeKeyPathRef = computed(() => treemateRef.value.getPath(props.value).keyPath);
    const keyboardEnabledRef = useMemo(() => {
      return props.keyboard && mergedShowRef.value;
    });
    useKeyboard({
      keydown: {
        ArrowUp: {
          prevent: true,
          handler: handleKeydownUp
        },
        ArrowRight: {
          prevent: true,
          handler: handleKeydownRight
        },
        ArrowDown: {
          prevent: true,
          handler: handleKeydownDown
        },
        ArrowLeft: {
          prevent: true,
          handler: handleKeydownLeft
        },
        Enter: {
          prevent: true,
          handler: handleKeydownEnter
        },
        Escape: handleKeydownEsc
      }
    }, keyboardEnabledRef);
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Dropdown", "-dropdown", style$a, dropdownLight$1, props, mergedClsPrefixRef);
    provide(dropdownInjectionKey, {
      labelFieldRef: toRef(props, "labelField"),
      childrenFieldRef: toRef(props, "childrenField"),
      renderLabelRef: toRef(props, "renderLabel"),
      renderIconRef: toRef(props, "renderIcon"),
      hoverKeyRef,
      keyboardKeyRef,
      lastToggledSubmenuKeyRef,
      pendingKeyPathRef,
      activeKeyPathRef,
      animatedRef: toRef(props, "animated"),
      mergedShowRef,
      nodePropsRef: toRef(props, "nodeProps"),
      renderOptionRef: toRef(props, "renderOption"),
      menuPropsRef: toRef(props, "menuProps"),
      doSelect,
      doUpdateShow
    });
    watch(mergedShowRef, (value) => {
      if (!props.animated && !value) {
        clearPendingState();
      }
    });
    function doSelect(key, node) {
      const {
        onSelect
      } = props;
      if (onSelect)
        call(onSelect, key, node);
    }
    function doUpdateShow(value) {
      const {
        "onUpdate:show": _onUpdateShow,
        onUpdateShow
      } = props;
      if (_onUpdateShow)
        call(_onUpdateShow, value);
      if (onUpdateShow)
        call(onUpdateShow, value);
      uncontrolledShowRef.value = value;
    }
    function clearPendingState() {
      hoverKeyRef.value = null;
      keyboardKeyRef.value = null;
      lastToggledSubmenuKeyRef.value = null;
    }
    function handleKeydownEsc() {
      doUpdateShow(false);
    }
    function handleKeydownLeft() {
      handleKeydown("left");
    }
    function handleKeydownRight() {
      handleKeydown("right");
    }
    function handleKeydownUp() {
      handleKeydown("up");
    }
    function handleKeydownDown() {
      handleKeydown("down");
    }
    function handleKeydownEnter() {
      const pendingNode = getPendingNode();
      if ((pendingNode === null || pendingNode === void 0 ? void 0 : pendingNode.isLeaf) && mergedShowRef.value) {
        doSelect(pendingNode.key, pendingNode.rawNode);
        doUpdateShow(false);
      }
    }
    function getPendingNode() {
      var _a;
      const {
        value: treeMate
      } = treemateRef;
      const {
        value: pendingKey
      } = pendingKeyRef;
      if (!treeMate || pendingKey === null)
        return null;
      return (_a = treeMate.getNode(pendingKey)) !== null && _a !== void 0 ? _a : null;
    }
    function handleKeydown(direction) {
      const {
        value: pendingKey
      } = pendingKeyRef;
      const {
        value: {
          getFirstAvailableNode: getFirstAvailableNode2
        }
      } = treemateRef;
      let nextKeyboardKey = null;
      if (pendingKey === null) {
        const firstNode = getFirstAvailableNode2();
        if (firstNode !== null) {
          nextKeyboardKey = firstNode.key;
        }
      } else {
        const currentNode = getPendingNode();
        if (currentNode) {
          let nextNode;
          switch (direction) {
            case "down":
              nextNode = currentNode.getNext();
              break;
            case "up":
              nextNode = currentNode.getPrev();
              break;
            case "right":
              nextNode = currentNode.getChild();
              break;
            case "left":
              nextNode = currentNode.getParent();
              break;
          }
          if (nextNode)
            nextKeyboardKey = nextNode.key;
        }
      }
      if (nextKeyboardKey !== null) {
        hoverKeyRef.value = null;
        keyboardKeyRef.value = nextKeyboardKey;
      }
    }
    const cssVarsRef = computed(() => {
      const {
        size: size2,
        inverted
      } = props;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: self2
      } = themeRef.value;
      const {
        padding,
        dividerColor,
        borderRadius,
        optionOpacityDisabled,
        [createKey("optionIconSuffixWidth", size2)]: optionIconSuffixWidth,
        [createKey("optionSuffixWidth", size2)]: optionSuffixWidth,
        [createKey("optionIconPrefixWidth", size2)]: optionIconPrefixWidth,
        [createKey("optionPrefixWidth", size2)]: optionPrefixWidth,
        [createKey("fontSize", size2)]: fontSize2,
        [createKey("optionHeight", size2)]: optionHeight,
        [createKey("optionIconSize", size2)]: optionIconSize
      } = self2;
      const vars = {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-font-size": fontSize2,
        "--n-padding": padding,
        "--n-border-radius": borderRadius,
        "--n-option-height": optionHeight,
        "--n-option-prefix-width": optionPrefixWidth,
        "--n-option-icon-prefix-width": optionIconPrefixWidth,
        "--n-option-suffix-width": optionSuffixWidth,
        "--n-option-icon-suffix-width": optionIconSuffixWidth,
        "--n-option-icon-size": optionIconSize,
        "--n-divider-color": dividerColor,
        "--n-option-opacity-disabled": optionOpacityDisabled
      };
      if (inverted) {
        vars["--n-color"] = self2.colorInverted;
        vars["--n-option-color-hover"] = self2.optionColorHoverInverted;
        vars["--n-option-color-active"] = self2.optionColorActiveInverted;
        vars["--n-option-text-color"] = self2.optionTextColorInverted;
        vars["--n-option-text-color-hover"] = self2.optionTextColorHoverInverted;
        vars["--n-option-text-color-active"] = self2.optionTextColorActiveInverted;
        vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActiveInverted;
        vars["--n-prefix-color"] = self2.prefixColorInverted;
        vars["--n-suffix-color"] = self2.suffixColorInverted;
        vars["--n-group-header-text-color"] = self2.groupHeaderTextColorInverted;
      } else {
        vars["--n-color"] = self2.color;
        vars["--n-option-color-hover"] = self2.optionColorHover;
        vars["--n-option-color-active"] = self2.optionColorActive;
        vars["--n-option-text-color"] = self2.optionTextColor;
        vars["--n-option-text-color-hover"] = self2.optionTextColorHover;
        vars["--n-option-text-color-active"] = self2.optionTextColorActive;
        vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActive;
        vars["--n-prefix-color"] = self2.prefixColor;
        vars["--n-suffix-color"] = self2.suffixColor;
        vars["--n-group-header-text-color"] = self2.groupHeaderTextColor;
      }
      return vars;
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("dropdown", computed(() => `${props.size[0]}${props.inverted ? "i" : ""}`), cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      mergedTheme: themeRef,
      // data
      tmNodes: tmNodesRef,
      // show
      mergedShow: mergedShowRef,
      // methods
      handleAfterLeave: () => {
        if (!props.animated)
          return;
        clearPendingState();
      },
      doUpdateShow,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const renderPopoverBody = (className, ref2, style2, onMouseenter, onMouseleave) => {
      var _a;
      const {
        mergedClsPrefix,
        menuProps: menuProps2
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      const menuNodeProps = (menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2(void 0, this.tmNodes.map((v) => v.rawNode))) || {};
      const dropdownProps2 = {
        ref: createRefSetter(ref2),
        class: [className, `${mergedClsPrefix}-dropdown`, this.themeClass],
        clsPrefix: mergedClsPrefix,
        tmNodes: this.tmNodes,
        style: [...style2, this.cssVars],
        showArrow: this.showArrow,
        arrowStyle: this.arrowStyle,
        scrollable: this.scrollable,
        onMouseenter,
        onMouseleave
      };
      return h(NDropdownMenu, mergeProps(this.$attrs, dropdownProps2, menuNodeProps));
    };
    const {
      mergedTheme
    } = this;
    const popoverProps2 = {
      show: this.mergedShow,
      theme: mergedTheme.peers.Popover,
      themeOverrides: mergedTheme.peerOverrides.Popover,
      internalOnAfterLeave: this.handleAfterLeave,
      internalRenderBody: renderPopoverBody,
      onUpdateShow: this.doUpdateShow,
      "onUpdate:show": void 0
    };
    return h(NPopover, Object.assign({}, keep(this.$props, popoverPropKeys), popoverProps2), {
      trigger: () => {
        var _a, _b;
        return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    });
  }
});
const commonVars = {
  titleFontSize: "18px",
  padding: "16px 28px 20px 28px",
  iconSize: "28px",
  actionSpace: "12px",
  contentMargin: "8px 0 16px 0",
  iconMargin: "0 4px 0 0",
  iconMarginIconTop: "4px 0 8px 0",
  closeSize: "22px",
  closeIconSize: "18px",
  closeMargin: "20px 26px 0 0",
  closeMarginIconTop: "10px 16px 0 0"
};
function self$9(vars) {
  const {
    textColor1,
    textColor2,
    modalColor,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    closeColorHover,
    closeColorPressed,
    infoColor,
    successColor,
    warningColor,
    errorColor,
    primaryColor,
    dividerColor,
    borderRadius,
    fontWeightStrong,
    lineHeight: lineHeight2,
    fontSize: fontSize2
  } = vars;
  return Object.assign(Object.assign({}, commonVars), {
    fontSize: fontSize2,
    lineHeight: lineHeight2,
    border: `1px solid ${dividerColor}`,
    titleTextColor: textColor1,
    textColor: textColor2,
    color: modalColor,
    closeColorHover,
    closeColorPressed,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    closeBorderRadius: borderRadius,
    iconColor: primaryColor,
    iconColorInfo: infoColor,
    iconColorSuccess: successColor,
    iconColorWarning: warningColor,
    iconColorError: errorColor,
    borderRadius,
    titleFontWeight: fontWeightStrong
  });
}
const dialogLight = createTheme({
  name: "Dialog",
  common: commonLight,
  peers: {
    Button: buttonLight$1
  },
  self: self$9
});
const dialogLight$1 = dialogLight;
const dialogProps = {
  icon: Function,
  type: {
    type: String,
    default: "default"
  },
  title: [String, Function],
  closable: {
    type: Boolean,
    default: true
  },
  negativeText: String,
  positiveText: String,
  positiveButtonProps: Object,
  negativeButtonProps: Object,
  content: [String, Function],
  action: Function,
  showIcon: {
    type: Boolean,
    default: true
  },
  loading: Boolean,
  bordered: Boolean,
  iconPlacement: String,
  titleClass: [String, Array],
  titleStyle: [String, Object],
  contentClass: [String, Array],
  contentStyle: [String, Object],
  actionClass: [String, Array],
  actionStyle: [String, Object],
  onPositiveClick: Function,
  onNegativeClick: Function,
  onClose: Function
};
const dialogPropKeys = keysOf(dialogProps);
const style$9 = c$1([cB("dialog", `
 --n-icon-margin: var(--n-icon-margin-top) var(--n-icon-margin-right) var(--n-icon-margin-bottom) var(--n-icon-margin-left);
 word-break: break-word;
 line-height: var(--n-line-height);
 position: relative;
 background: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 margin: auto;
 border-radius: var(--n-border-radius);
 padding: var(--n-padding);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `, [cE("icon", {
  color: "var(--n-icon-color)"
}), cM("bordered", {
  border: "var(--n-border)"
}), cM("icon-top", [cE("close", {
  margin: "var(--n-close-margin)"
}), cE("icon", {
  margin: "var(--n-icon-margin)"
}), cE("content", {
  textAlign: "center"
}), cE("title", {
  justifyContent: "center"
}), cE("action", {
  justifyContent: "center"
})]), cM("icon-left", [cE("icon", {
  margin: "var(--n-icon-margin)"
}), cM("closable", [cE("title", `
 padding-right: calc(var(--n-close-size) + 6px);
 `)])]), cE("close", `
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 z-index: 1;
 `), cE("content", `
 font-size: var(--n-font-size);
 margin: var(--n-content-margin);
 position: relative;
 word-break: break-word;
 `, [cM("last", "margin-bottom: 0;")]), cE("action", `
 display: flex;
 justify-content: flex-end;
 `, [c$1("> *:not(:last-child)", `
 margin-right: var(--n-action-space);
 `)]), cE("icon", `
 font-size: var(--n-icon-size);
 transition: color .3s var(--n-bezier);
 `), cE("title", `
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cB("dialog-icon-container", `
 display: flex;
 justify-content: center;
 `)]), insideModal(cB("dialog", `
 width: 446px;
 max-width: calc(100vw - 32px);
 `)), cB("dialog", [asModal(`
 width: 446px;
 max-width: calc(100vw - 32px);
 `)])]);
const iconRenderMap = {
  default: () => h(InfoIcon, null),
  info: () => h(InfoIcon, null),
  success: () => h(SuccessIcon, null),
  warning: () => h(WarningIcon, null),
  error: () => h(ErrorIcon, null)
};
const NDialog = /* @__PURE__ */ defineComponent({
  name: "Dialog",
  alias: [
    "NimbusConfirmCard",
    // deprecated
    "Confirm"
    // deprecated
  ],
  props: Object.assign(Object.assign({}, useTheme.props), dialogProps),
  setup(props) {
    const {
      mergedComponentPropsRef,
      mergedClsPrefixRef,
      inlineThemeDisabled,
      mergedRtlRef
    } = useConfig(props);
    const rtlEnabledRef = useRtl("Dialog", mergedRtlRef, mergedClsPrefixRef);
    const mergedIconPlacementRef = computed(() => {
      var _a, _b;
      const {
        iconPlacement
      } = props;
      return iconPlacement || ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Dialog) === null || _b === void 0 ? void 0 : _b.iconPlacement) || "left";
    });
    function handlePositiveClick(e) {
      const {
        onPositiveClick
      } = props;
      if (onPositiveClick)
        onPositiveClick(e);
    }
    function handleNegativeClick(e) {
      const {
        onNegativeClick
      } = props;
      if (onNegativeClick)
        onNegativeClick(e);
    }
    function handleCloseClick() {
      const {
        onClose
      } = props;
      if (onClose)
        onClose();
    }
    const themeRef = useTheme("Dialog", "-dialog", style$9, dialogLight$1, props, mergedClsPrefixRef);
    const cssVarsRef = computed(() => {
      const {
        type: type4
      } = props;
      const iconPlacement = mergedIconPlacementRef.value;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: {
          fontSize: fontSize2,
          lineHeight: lineHeight2,
          border,
          titleTextColor,
          textColor,
          color,
          closeBorderRadius,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeIconSize,
          borderRadius,
          titleFontWeight,
          titleFontSize,
          padding,
          iconSize,
          actionSpace,
          contentMargin,
          closeSize,
          [iconPlacement === "top" ? "iconMarginIconTop" : "iconMargin"]: iconMargin,
          [iconPlacement === "top" ? "closeMarginIconTop" : "closeMargin"]: closeMargin,
          [createKey("iconColor", type4)]: iconColor
        }
      } = themeRef.value;
      const iconMarginDiscrete = getMargin(iconMargin);
      return {
        "--n-font-size": fontSize2,
        "--n-icon-color": iconColor,
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-close-margin": closeMargin,
        "--n-icon-margin-top": iconMarginDiscrete.top,
        "--n-icon-margin-right": iconMarginDiscrete.right,
        "--n-icon-margin-bottom": iconMarginDiscrete.bottom,
        "--n-icon-margin-left": iconMarginDiscrete.left,
        "--n-icon-size": iconSize,
        "--n-close-size": closeSize,
        "--n-close-icon-size": closeIconSize,
        "--n-close-border-radius": closeBorderRadius,
        "--n-close-color-hover": closeColorHover,
        "--n-close-color-pressed": closeColorPressed,
        "--n-close-icon-color": closeIconColor,
        "--n-close-icon-color-hover": closeIconColorHover,
        "--n-close-icon-color-pressed": closeIconColorPressed,
        "--n-color": color,
        "--n-text-color": textColor,
        "--n-border-radius": borderRadius,
        "--n-padding": padding,
        "--n-line-height": lineHeight2,
        "--n-border": border,
        "--n-content-margin": contentMargin,
        "--n-title-font-size": titleFontSize,
        "--n-title-font-weight": titleFontWeight,
        "--n-title-text-color": titleTextColor,
        "--n-action-space": actionSpace
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("dialog", computed(() => `${props.type[0]}${mergedIconPlacementRef.value[0]}`), cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      rtlEnabled: rtlEnabledRef,
      mergedIconPlacement: mergedIconPlacementRef,
      mergedTheme: themeRef,
      handlePositiveClick,
      handleNegativeClick,
      handleCloseClick,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    var _a;
    const {
      bordered,
      mergedIconPlacement,
      cssVars,
      closable,
      showIcon,
      title,
      content,
      action,
      negativeText,
      positiveText,
      positiveButtonProps,
      negativeButtonProps,
      handlePositiveClick,
      handleNegativeClick,
      mergedTheme,
      loading,
      type: type4,
      mergedClsPrefix
    } = this;
    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
    const icon = showIcon ? h(NBaseIcon, {
      clsPrefix: mergedClsPrefix,
      class: `${mergedClsPrefix}-dialog__icon`
    }, {
      default: () => resolveWrappedSlot(this.$slots.icon, (children) => children || (this.icon ? render$1(this.icon) : iconRenderMap[this.type]()))
    }) : null;
    const actionNode = resolveWrappedSlot(this.$slots.action, (children) => children || positiveText || negativeText || action ? h("div", {
      class: [`${mergedClsPrefix}-dialog__action`, this.actionClass],
      style: this.actionStyle
    }, children || (action ? [render$1(action)] : [this.negativeText && h(NButton, Object.assign({
      theme: mergedTheme.peers.Button,
      themeOverrides: mergedTheme.peerOverrides.Button,
      ghost: true,
      size: "small",
      onClick: handleNegativeClick
    }, negativeButtonProps), {
      default: () => render$1(this.negativeText)
    }), this.positiveText && h(NButton, Object.assign({
      theme: mergedTheme.peers.Button,
      themeOverrides: mergedTheme.peerOverrides.Button,
      size: "small",
      type: type4 === "default" ? "primary" : type4,
      disabled: loading,
      loading,
      onClick: handlePositiveClick
    }, positiveButtonProps), {
      default: () => render$1(this.positiveText)
    })])) : null);
    return h("div", {
      class: [`${mergedClsPrefix}-dialog`, this.themeClass, this.closable && `${mergedClsPrefix}-dialog--closable`, `${mergedClsPrefix}-dialog--icon-${mergedIconPlacement}`, bordered && `${mergedClsPrefix}-dialog--bordered`, this.rtlEnabled && `${mergedClsPrefix}-dialog--rtl`],
      style: cssVars,
      role: "dialog"
    }, closable ? resolveWrappedSlot(this.$slots.close, (node) => {
      const classNames = [`${mergedClsPrefix}-dialog__close`, this.rtlEnabled && `${mergedClsPrefix}-dialog--rtl`];
      return node ? h("div", {
        class: classNames
      }, node) : h(NBaseClose, {
        clsPrefix: mergedClsPrefix,
        class: classNames,
        onClick: this.handleCloseClick
      });
    }) : null, showIcon && mergedIconPlacement === "top" ? h("div", {
      class: `${mergedClsPrefix}-dialog-icon-container`
    }, icon) : null, h("div", {
      class: [`${mergedClsPrefix}-dialog__title`, this.titleClass],
      style: this.titleStyle
    }, showIcon && mergedIconPlacement === "left" ? icon : null, resolveSlot(this.$slots.header, () => [render$1(title)])), h("div", {
      class: [`${mergedClsPrefix}-dialog__content`, actionNode ? "" : `${mergedClsPrefix}-dialog__content--last`, this.contentClass],
      style: this.contentStyle
    }, resolveSlot(this.$slots.default, () => [render$1(content)])), actionNode);
  }
});
const dialogProviderInjectionKey = createInjectionKey("n-dialog-provider");
function self$8(vars) {
  const {
    modalColor,
    textColor2,
    boxShadow3
  } = vars;
  return {
    color: modalColor,
    textColor: textColor2,
    boxShadow: boxShadow3
  };
}
const modalLight = createTheme({
  name: "Modal",
  common: commonLight,
  peers: {
    Scrollbar: scrollbarLight$1,
    Dialog: dialogLight$1,
    Card: cardLight$1
  },
  self: self$8
});
const modalLight$1 = modalLight;
const presetProps = Object.assign(Object.assign({}, cardBaseProps), dialogProps);
const presetPropsKeys = keysOf(presetProps);
const NModalBodyWrapper = /* @__PURE__ */ defineComponent({
  name: "ModalBody",
  inheritAttrs: false,
  props: Object.assign(Object.assign({
    show: {
      type: Boolean,
      required: true
    },
    preset: String,
    displayDirective: {
      type: String,
      required: true
    },
    trapFocus: {
      type: Boolean,
      default: true
    },
    autoFocus: {
      type: Boolean,
      default: true
    },
    blockScroll: Boolean
  }, presetProps), {
    renderMask: Function,
    // events
    onClickoutside: Function,
    onBeforeLeave: {
      type: Function,
      required: true
    },
    onAfterLeave: {
      type: Function,
      required: true
    },
    onPositiveClick: {
      type: Function,
      required: true
    },
    onNegativeClick: {
      type: Function,
      required: true
    },
    onClose: {
      type: Function,
      required: true
    },
    onAfterEnter: Function,
    onEsc: Function
  }),
  setup(props) {
    const bodyRef = ref(null);
    const scrollbarRef = ref(null);
    const displayedRef = ref(props.show);
    const transformOriginXRef = ref(null);
    const transformOriginYRef = ref(null);
    watch(toRef(props, "show"), (value) => {
      if (value)
        displayedRef.value = true;
    });
    useLockHtmlScroll(computed(() => props.blockScroll && displayedRef.value));
    const NModal2 = inject(modalInjectionKey);
    function styleTransformOrigin() {
      if (NModal2.transformOriginRef.value === "center") {
        return "";
      }
      const {
        value: transformOriginX
      } = transformOriginXRef;
      const {
        value: transformOriginY
      } = transformOriginYRef;
      if (transformOriginX === null || transformOriginY === null) {
        return "";
      } else if (scrollbarRef.value) {
        const scrollTop = scrollbarRef.value.containerScrollTop;
        return `${transformOriginX}px ${transformOriginY + scrollTop}px`;
      }
      return "";
    }
    function syncTransformOrigin(el) {
      if (NModal2.transformOriginRef.value === "center") {
        return;
      }
      const mousePosition = NModal2.getMousePosition();
      if (!mousePosition) {
        return;
      }
      if (!scrollbarRef.value)
        return;
      const scrollTop = scrollbarRef.value.containerScrollTop;
      const {
        offsetLeft,
        offsetTop
      } = el;
      if (mousePosition) {
        const top = mousePosition.y;
        const left = mousePosition.x;
        transformOriginXRef.value = -(offsetLeft - left);
        transformOriginYRef.value = -(offsetTop - top - scrollTop);
      }
      el.style.transformOrigin = styleTransformOrigin();
    }
    function handleEnter(el) {
      void nextTick(() => {
        syncTransformOrigin(el);
      });
    }
    function handleBeforeLeave(el) {
      el.style.transformOrigin = styleTransformOrigin();
      props.onBeforeLeave();
    }
    function handleAfterLeave() {
      displayedRef.value = false;
      transformOriginXRef.value = null;
      transformOriginYRef.value = null;
      props.onAfterLeave();
    }
    function handleCloseClick() {
      const {
        onClose
      } = props;
      if (onClose) {
        onClose();
      }
    }
    function handleNegativeClick() {
      props.onNegativeClick();
    }
    function handlePositiveClick() {
      props.onPositiveClick();
    }
    const childNodeRef = ref(null);
    watch(childNodeRef, (node) => {
      if (node) {
        void nextTick(() => {
          const el = node.el;
          if (el && bodyRef.value !== el) {
            bodyRef.value = el;
          }
        });
      }
    });
    provide(modalBodyInjectionKey, bodyRef);
    provide(drawerBodyInjectionKey, null);
    provide(popoverBodyInjectionKey, null);
    return {
      mergedTheme: NModal2.mergedThemeRef,
      appear: NModal2.appearRef,
      isMounted: NModal2.isMountedRef,
      mergedClsPrefix: NModal2.mergedClsPrefixRef,
      bodyRef,
      scrollbarRef,
      displayed: displayedRef,
      childNodeRef,
      handlePositiveClick,
      handleNegativeClick,
      handleCloseClick,
      handleAfterLeave,
      handleBeforeLeave,
      handleEnter
    };
  },
  render() {
    const {
      $slots,
      $attrs,
      handleEnter,
      handleAfterLeave,
      handleBeforeLeave,
      preset,
      mergedClsPrefix
    } = this;
    let childNode = null;
    if (!preset) {
      childNode = getFirstSlotVNode($slots);
      if (!childNode) {
        warn$2("modal", "default slot is empty");
        return;
      }
      childNode = cloneVNode(childNode);
      childNode.props = mergeProps({
        class: `${mergedClsPrefix}-modal`
      }, $attrs, childNode.props || {});
    }
    return this.displayDirective === "show" || this.displayed || this.show ? withDirectives(h("div", {
      role: "none",
      class: `${mergedClsPrefix}-modal-body-wrapper`
    }, h(NScrollbar, {
      ref: "scrollbarRef",
      theme: this.mergedTheme.peers.Scrollbar,
      themeOverrides: this.mergedTheme.peerOverrides.Scrollbar,
      contentClass: `${mergedClsPrefix}-modal-scroll-content`
    }, {
      default: () => {
        var _a;
        return [(_a = this.renderMask) === null || _a === void 0 ? void 0 : _a.call(this), h(FocusTrap, {
          disabled: !this.trapFocus,
          active: this.show,
          onEsc: this.onEsc,
          autoFocus: this.autoFocus
        }, {
          default: () => {
            var _a2;
            return h(Transition, {
              name: "fade-in-scale-up-transition",
              appear: (_a2 = this.appear) !== null && _a2 !== void 0 ? _a2 : this.isMounted,
              onEnter: handleEnter,
              onAfterEnter: this.onAfterEnter,
              onAfterLeave: handleAfterLeave,
              onBeforeLeave: handleBeforeLeave
            }, {
              default: () => {
                const dirs = [[vShow, this.show]];
                const {
                  onClickoutside
                } = this;
                if (onClickoutside) {
                  dirs.push([clickoutside$1, this.onClickoutside, void 0, {
                    capture: true
                  }]);
                }
                return withDirectives(this.preset === "confirm" || this.preset === "dialog" ? h(NDialog, Object.assign({}, this.$attrs, {
                  class: [`${mergedClsPrefix}-modal`, this.$attrs.class],
                  ref: "bodyRef",
                  theme: this.mergedTheme.peers.Dialog,
                  themeOverrides: this.mergedTheme.peerOverrides.Dialog
                }, keep(this.$props, dialogPropKeys), {
                  "aria-modal": "true"
                }), $slots) : this.preset === "card" ? h(NCard, Object.assign({}, this.$attrs, {
                  ref: "bodyRef",
                  class: [`${mergedClsPrefix}-modal`, this.$attrs.class],
                  theme: this.mergedTheme.peers.Card,
                  themeOverrides: this.mergedTheme.peerOverrides.Card
                }, keep(this.$props, cardBasePropKeys), {
                  "aria-modal": "true",
                  role: "dialog"
                }), $slots) : this.childNodeRef = childNode, dirs);
              }
            });
          }
        })];
      }
    })), [[vShow, this.displayDirective === "if" || this.displayed || this.show]]) : null;
  }
});
const style$8 = c$1([cB("modal-container", `
 position: fixed;
 left: 0;
 top: 0;
 height: 0;
 width: 0;
 display: flex;
 `), cB("modal-mask", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background-color: rgba(0, 0, 0, .4);
 `, [fadeInTransition({
  enterDuration: ".25s",
  leaveDuration: ".25s",
  enterCubicBezier: "var(--n-bezier-ease-out)",
  leaveCubicBezier: "var(--n-bezier-ease-out)"
})]), cB("modal-body-wrapper", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: visible;
 `, [cB("modal-scroll-content", `
 min-height: 100%;
 display: flex;
 position: relative;
 `)]), cB("modal", `
 position: relative;
 align-self: center;
 color: var(--n-text-color);
 margin: auto;
 box-shadow: var(--n-box-shadow);
 `, [fadeInScaleUpTransition({
  duration: ".25s",
  enterScale: ".5"
})])]);
const modalProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {
  show: Boolean,
  unstableShowMask: {
    type: Boolean,
    default: true
  },
  maskClosable: {
    type: Boolean,
    default: true
  },
  preset: String,
  to: [String, Object],
  displayDirective: {
    type: String,
    default: "if"
  },
  transformOrigin: {
    type: String,
    default: "mouse"
  },
  zIndex: Number,
  autoFocus: {
    type: Boolean,
    default: true
  },
  trapFocus: {
    type: Boolean,
    default: true
  },
  closeOnEsc: {
    type: Boolean,
    default: true
  },
  blockScroll: {
    type: Boolean,
    default: true
  }
}), presetProps), {
  // events
  onEsc: Function,
  "onUpdate:show": [Function, Array],
  onUpdateShow: [Function, Array],
  onAfterEnter: Function,
  onBeforeLeave: Function,
  onAfterLeave: Function,
  onClose: Function,
  onPositiveClick: Function,
  onNegativeClick: Function,
  onMaskClick: Function,
  // private
  internalDialog: Boolean,
  internalModal: Boolean,
  internalAppear: {
    type: Boolean,
    default: void 0
  },
  // deprecated
  overlayStyle: [String, Object],
  onBeforeHide: Function,
  onAfterHide: Function,
  onHide: Function
});
const NModal = /* @__PURE__ */ defineComponent({
  name: "Modal",
  inheritAttrs: false,
  props: modalProps,
  setup(props) {
    const containerRef = ref(null);
    const {
      mergedClsPrefixRef,
      namespaceRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Modal", "-modal", style$8, modalLight$1, props, mergedClsPrefixRef);
    const clickedRef = useClicked(64);
    const clickedPositionRef = useClickPosition();
    const isMountedRef = isMounted();
    const NDialogProvider = props.internalDialog ? inject(dialogProviderInjectionKey, null) : null;
    const NModalProvider = props.internalModal ? inject(modalProviderInjectionKey, null) : null;
    const isComposingRef2 = useIsComposing();
    function doUpdateShow(show) {
      const {
        onUpdateShow,
        "onUpdate:show": _onUpdateShow,
        onHide
      } = props;
      if (onUpdateShow)
        call(onUpdateShow, show);
      if (_onUpdateShow)
        call(_onUpdateShow, show);
      if (onHide && !show)
        onHide(show);
    }
    function handleCloseClick() {
      const {
        onClose
      } = props;
      if (onClose) {
        void Promise.resolve(onClose()).then((value) => {
          if (value === false)
            return;
          doUpdateShow(false);
        });
      } else {
        doUpdateShow(false);
      }
    }
    function handlePositiveClick() {
      const {
        onPositiveClick
      } = props;
      if (onPositiveClick) {
        void Promise.resolve(onPositiveClick()).then((value) => {
          if (value === false)
            return;
          doUpdateShow(false);
        });
      } else {
        doUpdateShow(false);
      }
    }
    function handleNegativeClick() {
      const {
        onNegativeClick
      } = props;
      if (onNegativeClick) {
        void Promise.resolve(onNegativeClick()).then((value) => {
          if (value === false)
            return;
          doUpdateShow(false);
        });
      } else {
        doUpdateShow(false);
      }
    }
    function handleBeforeLeave() {
      const {
        onBeforeLeave,
        onBeforeHide
      } = props;
      if (onBeforeLeave)
        call(onBeforeLeave);
      if (onBeforeHide)
        onBeforeHide();
    }
    function handleAfterLeave() {
      const {
        onAfterLeave,
        onAfterHide
      } = props;
      if (onAfterLeave)
        call(onAfterLeave);
      if (onAfterHide)
        onAfterHide();
    }
    function handleClickoutside(e) {
      var _a;
      const {
        onMaskClick
      } = props;
      if (onMaskClick) {
        onMaskClick(e);
      }
      if (props.maskClosable) {
        if ((_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e))) {
          doUpdateShow(false);
        }
      }
    }
    function handleEsc(e) {
      var _a;
      (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props);
      if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
        if (!isComposingRef2.value) {
          doUpdateShow(false);
        }
      }
    }
    provide(modalInjectionKey, {
      getMousePosition: () => {
        const mergedProvider = NDialogProvider || NModalProvider;
        if (mergedProvider) {
          const {
            clickedRef: clickedRef2,
            clickedPositionRef: clickedPositionRef2
          } = mergedProvider;
          if (clickedRef2.value && clickedPositionRef2.value) {
            return clickedPositionRef2.value;
          }
        }
        if (clickedRef.value) {
          return clickedPositionRef.value;
        }
        return null;
      },
      mergedClsPrefixRef,
      mergedThemeRef: themeRef,
      isMountedRef,
      appearRef: toRef(props, "internalAppear"),
      transformOriginRef: toRef(props, "transformOrigin")
    });
    const cssVarsRef = computed(() => {
      const {
        common: {
          cubicBezierEaseOut: cubicBezierEaseOut2
        },
        self: {
          boxShadow,
          color,
          textColor
        }
      } = themeRef.value;
      return {
        "--n-bezier-ease-out": cubicBezierEaseOut2,
        "--n-box-shadow": boxShadow,
        "--n-color": color,
        "--n-text-color": textColor
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("theme-class", void 0, cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      namespace: namespaceRef,
      isMounted: isMountedRef,
      containerRef,
      presetProps: computed(() => {
        const pickedProps = keep(props, presetPropsKeys);
        return pickedProps;
      }),
      handleEsc,
      handleAfterLeave,
      handleClickoutside,
      handleBeforeLeave,
      doUpdateShow,
      handleNegativeClick,
      handlePositiveClick,
      handleCloseClick,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const {
      mergedClsPrefix
    } = this;
    return h(LazyTeleport, {
      to: this.to,
      show: this.show
    }, {
      default: () => {
        var _a;
        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
        const {
          unstableShowMask
        } = this;
        return withDirectives(h("div", {
          role: "none",
          ref: "containerRef",
          class: [`${mergedClsPrefix}-modal-container`, this.themeClass, this.namespace],
          style: this.cssVars
        }, h(NModalBodyWrapper, Object.assign({
          style: this.overlayStyle
        }, this.$attrs, {
          ref: "bodyWrapper",
          displayDirective: this.displayDirective,
          show: this.show,
          preset: this.preset,
          autoFocus: this.autoFocus,
          trapFocus: this.trapFocus,
          blockScroll: this.blockScroll
        }, this.presetProps, {
          onEsc: this.handleEsc,
          onClose: this.handleCloseClick,
          onNegativeClick: this.handleNegativeClick,
          onPositiveClick: this.handlePositiveClick,
          onBeforeLeave: this.handleBeforeLeave,
          onAfterEnter: this.onAfterEnter,
          onAfterLeave: this.handleAfterLeave,
          onClickoutside: unstableShowMask ? void 0 : this.handleClickoutside,
          renderMask: unstableShowMask ? () => {
            var _a2;
            return h(Transition, {
              name: "fade-in-transition",
              key: "mask",
              appear: (_a2 = this.internalAppear) !== null && _a2 !== void 0 ? _a2 : this.isMounted
            }, {
              default: () => {
                return this.show ? h("div", {
                  "aria-hidden": true,
                  ref: "containerRef",
                  class: `${mergedClsPrefix}-modal-mask`,
                  onClick: this.handleClickoutside
                }) : null;
              }
            });
          } : void 0
        }), this.$slots)), [[zindexable$1, {
          zIndex: this.zIndex,
          enabled: this.show
        }]]);
      }
    });
  }
});
function self$7(vars) {
  const {
    textColor1,
    dividerColor,
    fontWeightStrong
  } = vars;
  return {
    textColor: textColor1,
    color: dividerColor,
    fontWeight: fontWeightStrong
  };
}
const dividerLight = {
  name: "Divider",
  common: commonLight,
  self: self$7
};
const dividerLight$1 = dividerLight;
const style$7 = cB("divider", `
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`, [cNotM("vertical", `
 margin-top: 24px;
 margin-bottom: 24px;
 `, [cNotM("no-title", `
 display: flex;
 align-items: center;
 `)]), cE("title", `
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `), cM("title-position-left", [cE("line", [cM("left", {
  width: "28px"
})])]), cM("title-position-right", [cE("line", [cM("right", {
  width: "28px"
})])]), cM("dashed", [cE("line", `
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]), cM("vertical", `
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `), cE("line", `
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `), cNotM("dashed", [cE("line", {
  backgroundColor: "var(--n-color)"
})]), cM("dashed", [cE("line", {
  borderColor: "var(--n-color)"
})]), cM("vertical", {
  backgroundColor: "var(--n-color)"
})]);
const dividerProps = Object.assign(Object.assign({}, useTheme.props), {
  titlePlacement: {
    type: String,
    default: "center"
  },
  dashed: Boolean,
  vertical: Boolean
});
const NDivider = /* @__PURE__ */ defineComponent({
  name: "Divider",
  props: dividerProps,
  setup(props) {
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Divider", "-divider", style$7, dividerLight$1, props, mergedClsPrefixRef);
    const cssVarsRef = computed(() => {
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: {
          color,
          textColor,
          fontWeight
        }
      } = themeRef.value;
      return {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-color": color,
        "--n-text-color": textColor,
        "--n-font-weight": fontWeight
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("divider", void 0, cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    var _a;
    const {
      $slots,
      titlePlacement,
      vertical,
      dashed,
      cssVars,
      mergedClsPrefix
    } = this;
    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
    return h("div", {
      role: "separator",
      class: [`${mergedClsPrefix}-divider`, this.themeClass, {
        [`${mergedClsPrefix}-divider--vertical`]: vertical,
        [`${mergedClsPrefix}-divider--no-title`]: !$slots.default,
        [`${mergedClsPrefix}-divider--dashed`]: dashed,
        [`${mergedClsPrefix}-divider--title-position-${titlePlacement}`]: $slots.default && titlePlacement
      }],
      style: cssVars
    }, !vertical ? h("div", {
      class: `${mergedClsPrefix}-divider__line ${mergedClsPrefix}-divider__line--left`
    }) : null, !vertical && $slots.default ? h(Fragment, null, h("div", {
      class: `${mergedClsPrefix}-divider__title`
    }, this.$slots), h("div", {
      class: `${mergedClsPrefix}-divider__line ${mergedClsPrefix}-divider__line--right`
    })) : null);
  }
});
const commonVariables = {
  feedbackPadding: "4px 0 0 2px",
  feedbackHeightSmall: "24px",
  feedbackHeightMedium: "24px",
  feedbackHeightLarge: "26px",
  feedbackFontSizeSmall: "13px",
  feedbackFontSizeMedium: "14px",
  feedbackFontSizeLarge: "14px",
  labelFontSizeLeftSmall: "14px",
  labelFontSizeLeftMedium: "14px",
  labelFontSizeLeftLarge: "15px",
  labelFontSizeTopSmall: "13px",
  labelFontSizeTopMedium: "14px",
  labelFontSizeTopLarge: "14px",
  labelHeightSmall: "24px",
  labelHeightMedium: "26px",
  labelHeightLarge: "28px",
  labelPaddingVertical: "0 0 6px 2px",
  labelPaddingHorizontal: "0 12px 0 0",
  labelTextAlignVertical: "left",
  labelTextAlignHorizontal: "right",
  labelFontWeight: "400"
};
function self$6(vars) {
  const {
    heightSmall,
    heightMedium,
    heightLarge,
    textColor1,
    errorColor,
    warningColor,
    lineHeight: lineHeight2,
    textColor3
  } = vars;
  return Object.assign(Object.assign({}, commonVariables), {
    blankHeightSmall: heightSmall,
    blankHeightMedium: heightMedium,
    blankHeightLarge: heightLarge,
    lineHeight: lineHeight2,
    labelTextColor: textColor1,
    asteriskColor: errorColor,
    feedbackTextColorError: errorColor,
    feedbackTextColorWarning: warningColor,
    feedbackTextColor: textColor3
  });
}
const formLight = {
  name: "Form",
  common: commonLight,
  self: self$6
};
const formLight$1 = formLight;
const style$6 = cB("form", [cM("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [cB("form-item", {
  width: "auto",
  marginRight: "18px"
}, [c$1("&:last-child", {
  marginRight: 0
})])])]);
const formInjectionKey = createInjectionKey("n-form");
const formItemInstsInjectionKey = createInjectionKey("n-form-item-insts");
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const formProps = Object.assign(Object.assign({}, useTheme.props), {
  inline: Boolean,
  labelWidth: [Number, String],
  labelAlign: String,
  labelPlacement: {
    type: String,
    default: "top"
  },
  model: {
    type: Object,
    default: () => {
    }
  },
  rules: Object,
  disabled: Boolean,
  size: String,
  showRequireMark: {
    type: Boolean,
    default: void 0
  },
  requireMarkPlacement: String,
  showFeedback: {
    type: Boolean,
    default: true
  },
  onSubmit: {
    type: Function,
    default: (e) => {
      e.preventDefault();
    }
  },
  showLabel: {
    type: Boolean,
    default: void 0
  },
  validateMessages: Object
});
const NForm = /* @__PURE__ */ defineComponent({
  name: "Form",
  props: formProps,
  setup(props) {
    const {
      mergedClsPrefixRef
    } = useConfig(props);
    useTheme("Form", "-form", style$6, formLight$1, props, mergedClsPrefixRef);
    const formItems = {};
    const maxChildLabelWidthRef = ref(void 0);
    const deriveMaxChildLabelWidth = (currentWidth) => {
      const currentMaxChildLabelWidth = maxChildLabelWidthRef.value;
      if (currentMaxChildLabelWidth === void 0 || currentWidth >= currentMaxChildLabelWidth) {
        maxChildLabelWidthRef.value = currentWidth;
      }
    };
    function validate(validateCallback_1) {
      return __awaiter$1(this, arguments, void 0, function* (validateCallback, shouldRuleBeApplied = () => true) {
        return yield new Promise((resolve, reject2) => {
          const formItemValidationPromises = [];
          for (const key of keysOf(formItems)) {
            const formItemInstances = formItems[key];
            for (const formItemInstance of formItemInstances) {
              if (formItemInstance.path) {
                formItemValidationPromises.push(formItemInstance.internalValidate(null, shouldRuleBeApplied));
              }
            }
          }
          void Promise.all(formItemValidationPromises).then((results) => {
            const formInvalid = results.some((result2) => !result2.valid);
            const errors = [];
            const warnings = [];
            results.forEach((result2) => {
              var _a, _b;
              if ((_a = result2.errors) === null || _a === void 0 ? void 0 : _a.length) {
                errors.push(result2.errors);
              }
              if ((_b = result2.warnings) === null || _b === void 0 ? void 0 : _b.length) {
                warnings.push(result2.warnings);
              }
            });
            if (validateCallback) {
              validateCallback(errors.length ? errors : void 0, {
                warnings: warnings.length ? warnings : void 0
              });
            }
            if (formInvalid) {
              reject2(errors.length ? errors : void 0);
            } else {
              resolve({
                warnings: warnings.length ? warnings : void 0
              });
            }
          });
        });
      });
    }
    function restoreValidation() {
      for (const key of keysOf(formItems)) {
        const formItemInstances = formItems[key];
        for (const formItemInstance of formItemInstances) {
          formItemInstance.restoreValidation();
        }
      }
    }
    provide(formInjectionKey, {
      props,
      maxChildLabelWidthRef,
      deriveMaxChildLabelWidth
    });
    provide(formItemInstsInjectionKey, {
      formItems
    });
    const formExposedMethod = {
      validate,
      restoreValidation
    };
    return Object.assign(formExposedMethod, {
      mergedClsPrefix: mergedClsPrefixRef
    });
  },
  render() {
    const {
      mergedClsPrefix
    } = this;
    return h("form", {
      class: [`${mergedClsPrefix}-form`, this.inline && `${mergedClsPrefix}-form--inline`],
      onSubmit: this.onSubmit
    }, this.$slots);
  }
});
var define_process_env_default = {};
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
    o2.__proto__ = p22;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper2);
    }
    function Wrapper2() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper2.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper2,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper2, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning = function warning2() {
};
if (typeof process !== "undefined" && define_process_env_default && false) {
  warning = function warning3(type4, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e) {
        return typeof e === "string";
      })) {
        console.warn(type4, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format$1(template2) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i = 0;
  var len2 = args.length;
  if (typeof template2 === "function") {
    return template2.apply(null, args);
  }
  if (typeof template2 === "string") {
    var str = template2.replace(formatRegExp, function(x) {
      if (x === "%%") {
        return "%";
      }
      if (i >= len2) {
        return x;
      }
      switch (x) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
          break;
        default:
          return x;
      }
    });
    return str;
  }
  return template2;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value, type4) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func2, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, errors || []);
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a) {
    func2(a, count);
  });
}
function asyncSerialArray(arr, func2, callback) {
  var index = 0;
  var arrLength = arr.length;
  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index;
    index = index + 1;
    if (original < arrLength) {
      func2(arr[original], next);
    } else {
      callback([]);
    }
  }
  next([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k) {
    ret.push.apply(ret, objArr[k] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func2, callback, source) {
  if (option.first) {
    var _pending = new Promise(function(resolve, reject2) {
      var next = function next2(errors) {
        callback(errors);
        return errors.length ? reject2(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func2, next);
    });
    _pending["catch"](function(e) {
      return e;
    });
    return _pending;
  }
  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject2) {
    var next = function next2(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject2(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }
    objArrKeys.forEach(function(key) {
      var arr = objArr[key];
      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func2, next);
      } else {
        asyncParallelArray(arr, func2, next);
      }
    });
  });
  pending["catch"](function(e) {
    return e;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue(value, path) {
  var v = value;
  for (var i = 0; i < path.length; i++) {
    if (v == void 0) {
      return v;
    }
    v = v[path[i]];
  }
  return v;
}
function complementError(rule, source) {
  return function(oe) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }
    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];
        if (typeof value === "object" && typeof target[s] === "object") {
          target[s] = _extends({}, target[s], value);
        } else {
          target[s] = value;
        }
      }
    }
  }
  return target;
}
var required$1 = function required(rule, value, source, errors, options, type4) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
    errors.push(format$1(options.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format$1(options.messages.whitespace, rule.fullField));
  }
};
var urlReg;
var getUrlRegex = function() {
  if (urlReg) {
    return urlReg;
  }
  var word = "[a-fA-F\\d:]";
  var b = function b2(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
  };
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
  var v4exact = new RegExp("^" + v4 + "$");
  var v6exact = new RegExp("^" + v6 + "$");
  var ip = function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
  };
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
  urlReg = new RegExp("(?:^" + regex + "$)", "i");
  return urlReg;
};
var pattern$2 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float2(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array2(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date2(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number2(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object2(value) {
    return typeof value === "object" && !types.array(value);
  },
  method: function method2(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
  },
  hex: function hex2(value) {
    return typeof value === "string" && !!value.match(pattern$2.hex);
  }
};
var type$1 = function type(rule, value, source, errors, options) {
  if (rule.required && value === void 0) {
    required$1(rule, value, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value, source, errors, options) {
  var len2 = typeof rule.len === "number";
  var min2 = typeof rule.min === "number";
  var max2 = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key = "number";
  } else if (str) {
    key = "string";
  } else if (arr) {
    key = "array";
  }
  if (!key) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len2) {
    if (val !== rule.len) {
      errors.push(format$1(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min2 && !max2 && val < rule.min) {
    errors.push(format$1(options.messages[key].min, rule.fullField, rule.min));
  } else if (max2 && !min2 && val > rule.max) {
    errors.push(format$1(options.messages[key].max, rule.fullField, rule.max));
  } else if (min2 && max2 && (val < rule.min || val > rule.max)) {
    errors.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable(rule, value, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var rules = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string = function string2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
};
var method22 = function method3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var number22 = function number3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var regexp2 = function regexp3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var integer2 = function integer3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var array22 = function array3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var object22 = function object3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable2 = function enumerable3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules[ENUM](rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var pattern2 = function pattern3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "string")) {
      rules.pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var date22 = function date3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rules.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
};
var required2 = function required3(rule, value, callback, source, options) {
  var errors = [];
  var type4 = Array.isArray(value) ? "array" : typeof value;
  rules.required(rule, value, source, errors, options, type4);
  callback(errors);
};
var type2 = function type3(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var any = function any2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
  }
  callback(errors);
};
var validators = {
  string,
  method: method22,
  number: number22,
  "boolean": _boolean,
  regexp: regexp2,
  integer: integer2,
  "float": floatFn,
  array: array22,
  object: object22,
  "enum": enumerable2,
  pattern: pattern2,
  date: date22,
  url: type2,
  hex: type2,
  email: type2,
  required: required2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone2() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema2.prototype;
  _proto.define = function define(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name) {
      var item = rules2[name];
      _this.rules[name] = Array.isArray(item) ? item : [item];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o, oc) {
    var _this2 = this;
    if (o === void 0) {
      o = {};
    }
    if (oc === void 0) {
      oc = function oc2() {
      };
    }
    var source = source_;
    var options = o;
    var callback = oc;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }
      return Promise.resolve(source);
    }
    function complete(results) {
      var errors = [];
      var fields = {};
      function add2(e) {
        if (Array.isArray(e)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }
      for (var i = 0; i < results.length; i++) {
        add2(results[i]);
      }
      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }
    var series = {};
    var keys2 = options.keys || Object.keys(this.rules);
    keys2.forEach(function(z) {
      var arr = _this2.rules[z];
      var value = source[z];
      arr.forEach(function(r) {
        var rule = r;
        if (typeof rule.transform === "function") {
          if (source === source_) {
            source = _extends({}, source);
          }
          value = source[z] = rule.transform(value);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this2.getType(rule);
        series[z] = series[z] || [];
        series[z].push({
          rule,
          value,
          source,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function(data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;
      function addFullField(key, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
        });
      }
      function cb(e) {
        if (e === void 0) {
          e = [];
        }
        var errorList = Array.isArray(e) ? e : [e];
        if (!options.suppressWarning && errorList.length) {
          Schema2.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source));
        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data.value).map(function(key) {
              fieldsSchema[key] = rule.defaultField;
            });
          }
          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema2(paredFieldsSchema);
          schema.messages(options.messages);
          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }
          schema.validate(data.value, data.rule.options || options, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options);
      } else if (rule.validator) {
        try {
          res = rule.validator(rule, data.value, cb, data.source, options);
        } catch (error) {
          console.error == null ? void 0 : console.error(error);
          if (!options.suppressValidatorError) {
            setTimeout(function() {
              throw error;
            }, 0);
          }
          cb(error.message);
        }
        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb();
        }, function(e) {
          return cb(e);
        });
      }
    }, function(results) {
      complete(results);
    }, source);
  };
  _proto.getType = function getType2(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format$1("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators.required;
    }
    return validators[this.getType(rule)] || void 0;
  };
  return Schema2;
}();
Schema.register = function register(type4, validator2) {
  if (typeof validator2 !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators[type4] = validator2;
};
Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;
function formItemSize(props) {
  const NForm2 = inject(formInjectionKey, null);
  return {
    mergedSize: computed(() => {
      if (props.size !== void 0)
        return props.size;
      if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.size) !== void 0)
        return NForm2.props.size;
      return "medium";
    })
  };
}
function formItemMisc(props) {
  const NForm2 = inject(formInjectionKey, null);
  const mergedLabelPlacementRef = computed(() => {
    const {
      labelPlacement
    } = props;
    if (labelPlacement !== void 0)
      return labelPlacement;
    if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelPlacement)
      return NForm2.props.labelPlacement;
    return "top";
  });
  const isAutoLabelWidthRef = computed(() => {
    return mergedLabelPlacementRef.value === "left" && (props.labelWidth === "auto" || (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) === "auto");
  });
  const mergedLabelWidthRef = computed(() => {
    if (mergedLabelPlacementRef.value === "top")
      return;
    const {
      labelWidth
    } = props;
    if (labelWidth !== void 0 && labelWidth !== "auto") {
      return formatLength(labelWidth);
    }
    if (isAutoLabelWidthRef.value) {
      const autoComputedWidth = NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.maxChildLabelWidthRef.value;
      if (autoComputedWidth !== void 0) {
        return formatLength(autoComputedWidth);
      } else {
        return void 0;
      }
    }
    if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) !== void 0) {
      return formatLength(NForm2.props.labelWidth);
    }
    return void 0;
  });
  const mergedLabelAlignRef = computed(() => {
    const {
      labelAlign
    } = props;
    if (labelAlign)
      return labelAlign;
    if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelAlign)
      return NForm2.props.labelAlign;
    return void 0;
  });
  const mergedLabelStyleRef = computed(() => {
    var _a;
    return [(_a = props.labelProps) === null || _a === void 0 ? void 0 : _a.style, props.labelStyle, {
      width: mergedLabelWidthRef.value
    }];
  });
  const mergedShowRequireMarkRef = computed(() => {
    const {
      showRequireMark
    } = props;
    if (showRequireMark !== void 0)
      return showRequireMark;
    return NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showRequireMark;
  });
  const mergedRequireMarkPlacementRef = computed(() => {
    const {
      requireMarkPlacement
    } = props;
    if (requireMarkPlacement !== void 0)
      return requireMarkPlacement;
    return (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.requireMarkPlacement) || "right";
  });
  const validationErroredRef = ref(false);
  const validationWarnedRef = ref(false);
  const mergedValidationStatusRef = computed(() => {
    const {
      validationStatus
    } = props;
    if (validationStatus !== void 0)
      return validationStatus;
    if (validationErroredRef.value)
      return "error";
    if (validationWarnedRef.value)
      return "warning";
    return void 0;
  });
  const mergedShowFeedbackRef = computed(() => {
    const {
      showFeedback
    } = props;
    if (showFeedback !== void 0)
      return showFeedback;
    if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showFeedback) !== void 0)
      return NForm2.props.showFeedback;
    return true;
  });
  const mergedShowLabelRef = computed(() => {
    const {
      showLabel
    } = props;
    if (showLabel !== void 0)
      return showLabel;
    if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showLabel) !== void 0)
      return NForm2.props.showLabel;
    return true;
  });
  return {
    validationErrored: validationErroredRef,
    validationWarned: validationWarnedRef,
    mergedLabelStyle: mergedLabelStyleRef,
    mergedLabelPlacement: mergedLabelPlacementRef,
    mergedLabelAlign: mergedLabelAlignRef,
    mergedShowRequireMark: mergedShowRequireMarkRef,
    mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
    mergedValidationStatus: mergedValidationStatusRef,
    mergedShowFeedback: mergedShowFeedbackRef,
    mergedShowLabel: mergedShowLabelRef,
    isAutoLabelWidth: isAutoLabelWidthRef
  };
}
function formItemRule(props) {
  const NForm2 = inject(formInjectionKey, null);
  const compatibleRulePathRef = computed(() => {
    const {
      rulePath
    } = props;
    if (rulePath !== void 0)
      return rulePath;
    const {
      path
    } = props;
    if (path !== void 0)
      return path;
    return void 0;
  });
  const mergedRulesRef = computed(() => {
    const rules2 = [];
    const {
      rule
    } = props;
    if (rule !== void 0) {
      if (Array.isArray(rule))
        rules2.push(...rule);
      else
        rules2.push(rule);
    }
    if (NForm2) {
      const {
        rules: formRules
      } = NForm2.props;
      const {
        value: rulePath
      } = compatibleRulePathRef;
      if (formRules !== void 0 && rulePath !== void 0) {
        const formRule = get(formRules, rulePath);
        if (formRule !== void 0) {
          if (Array.isArray(formRule)) {
            rules2.push(...formRule);
          } else {
            rules2.push(formRule);
          }
        }
      }
    }
    return rules2;
  });
  const hasRequiredRuleRef = computed(() => {
    return mergedRulesRef.value.some((rule) => rule.required);
  });
  const mergedRequiredRef = computed(() => {
    return hasRequiredRuleRef.value || props.required;
  });
  return {
    mergedRules: mergedRulesRef,
    mergedRequired: mergedRequiredRef
  };
}
const {
  cubicBezierEaseInOut
} = commonVariables$7;
function fadeDownTransition({
  name = "fade-down",
  fromOffset = "-4px",
  enterDuration = ".3s",
  leaveDuration = ".3s",
  enterCubicBezier = cubicBezierEaseInOut,
  leaveCubicBezier = cubicBezierEaseInOut
} = {}) {
  return [c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
    opacity: 0,
    transform: `translateY(${fromOffset})`
  }), c$1(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
    opacity: 1,
    transform: "translateY(0)"
  }), c$1(`&.${name}-transition-leave-active`, {
    transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
  }), c$1(`&.${name}-transition-enter-active`, {
    transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
  })];
}
const style$5 = cB("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [cB("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [cE("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), cE("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), cB("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), cM("auto-label-width", [cB("form-item-label", "white-space: nowrap;")]), cM("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [cB("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [cM("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), cM("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), cM("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cM("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cE("text", `
 grid-area: text; 
 `), cE("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), cM("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [cM("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), cB("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), cB("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), cB("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [c$1("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), cB("form-item-feedback", {
  transition: "color .3s var(--n-bezier)",
  color: "var(--n-feedback-text-color)"
}, [cM("warning", {
  color: "var(--n-feedback-text-color-warning)"
}), cM("error", {
  color: "var(--n-feedback-text-color-error)"
}), fadeDownTransition({
  fromOffset: "-3px",
  enterDuration: ".3s",
  leaveDuration: ".2s"
})])])]);
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const formItemProps = Object.assign(Object.assign({}, useTheme.props), {
  label: String,
  labelWidth: [Number, String],
  labelStyle: [String, Object],
  labelAlign: String,
  labelPlacement: String,
  path: String,
  first: Boolean,
  rulePath: String,
  required: Boolean,
  showRequireMark: {
    type: Boolean,
    default: void 0
  },
  requireMarkPlacement: String,
  showFeedback: {
    type: Boolean,
    default: void 0
  },
  rule: [Object, Array],
  size: String,
  ignorePathChange: Boolean,
  validationStatus: String,
  feedback: String,
  feedbackClass: String,
  feedbackStyle: [String, Object],
  showLabel: {
    type: Boolean,
    default: void 0
  },
  labelProps: Object
});
function wrapValidator(validator2, async) {
  return (...args) => {
    try {
      const validateResult = validator2(...args);
      if (!async && (typeof validateResult === "boolean" || validateResult instanceof Error || Array.isArray(validateResult)) || (validateResult === null || validateResult === void 0 ? void 0 : validateResult.then)) {
        return validateResult;
      } else if (validateResult === void 0) {
        return true;
      } else {
        warn$2("form-item/validate", `You return a ${typeof validateResult} typed value in the validator method, which is not recommended. Please use ${async ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`);
        return true;
      }
    } catch (err) {
      warn$2("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation.");
      console.error(err);
      return void 0;
    }
  };
}
const NFormItem = /* @__PURE__ */ defineComponent({
  name: "FormItem",
  props: formItemProps,
  setup(props) {
    useInjectionInstanceCollection(formItemInstsInjectionKey, "formItems", toRef(props, "path"));
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const NForm2 = inject(formInjectionKey, null);
    const formItemSizeRefs = formItemSize(props);
    const formItemMiscRefs = formItemMisc(props);
    const {
      validationErrored: validationErroredRef,
      validationWarned: validationWarnedRef
    } = formItemMiscRefs;
    const {
      mergedRequired: mergedRequiredRef,
      mergedRules: mergedRulesRef
    } = formItemRule(props);
    const {
      mergedSize: mergedSizeRef
    } = formItemSizeRefs;
    const {
      mergedLabelPlacement: labelPlacementRef,
      mergedLabelAlign: labelTextAlignRef,
      mergedRequireMarkPlacement: mergedRequireMarkPlacementRef
    } = formItemMiscRefs;
    const renderExplainsRef = ref([]);
    const feedbackIdRef = ref(createId());
    const mergedDisabledRef = NForm2 ? toRef(NForm2.props, "disabled") : ref(false);
    const themeRef = useTheme("Form", "-form-item", style$5, formLight$1, props, mergedClsPrefixRef);
    watch(toRef(props, "path"), () => {
      if (props.ignorePathChange)
        return;
      restoreValidation();
    });
    function restoreValidation() {
      renderExplainsRef.value = [];
      validationErroredRef.value = false;
      validationWarnedRef.value = false;
      if (props.feedback) {
        feedbackIdRef.value = createId();
      }
    }
    const internalValidate = (...args_1) => __awaiter(this, [...args_1], void 0, function* (trigger2 = null, shouldRuleBeApplied = () => true, options = {
      suppressWarning: true
    }) {
      const {
        path
      } = props;
      if (!options) {
        options = {};
      } else {
        if (!options.first)
          options.first = props.first;
      }
      const {
        value: rules2
      } = mergedRulesRef;
      const value = NForm2 ? get(NForm2.props.model, path || "") : void 0;
      const messageRenderers = {};
      const originalMessageRendersMessage = {};
      const activeRules = (!trigger2 ? rules2 : rules2.filter((rule) => {
        if (Array.isArray(rule.trigger)) {
          return rule.trigger.includes(trigger2);
        } else {
          return rule.trigger === trigger2;
        }
      })).filter(shouldRuleBeApplied).map((rule, i) => {
        const shallowClonedRule = Object.assign({}, rule);
        if (shallowClonedRule.validator) {
          shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
        }
        if (shallowClonedRule.asyncValidator) {
          shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
        }
        if (shallowClonedRule.renderMessage) {
          const rendererKey = `__renderMessage__${i}`;
          originalMessageRendersMessage[rendererKey] = shallowClonedRule.message;
          shallowClonedRule.message = rendererKey;
          messageRenderers[rendererKey] = shallowClonedRule.renderMessage;
        }
        return shallowClonedRule;
      });
      const activeErrorRules = activeRules.filter((r) => r.level !== "warning");
      const activeWarningRules = activeRules.filter((r) => r.level === "warning");
      const validationResult = {
        valid: true,
        errors: void 0,
        warnings: void 0
      };
      if (!activeRules.length)
        return validationResult;
      const mergedPath = path !== null && path !== void 0 ? path : "__n_no_path__";
      const validator2 = new Schema({
        [mergedPath]: activeErrorRules
      });
      const warningValidator = new Schema({
        [mergedPath]: activeWarningRules
      });
      const {
        validateMessages
      } = (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props) || {};
      if (validateMessages) {
        validator2.messages(validateMessages);
        warningValidator.messages(validateMessages);
      }
      const renderMessages = (errors) => {
        renderExplainsRef.value = errors.map((error) => {
          const transformedMessage = (error === null || error === void 0 ? void 0 : error.message) || "";
          return {
            key: transformedMessage,
            render: () => {
              if (transformedMessage.startsWith("__renderMessage__")) {
                return messageRenderers[transformedMessage]();
              }
              return transformedMessage;
            }
          };
        });
        errors.forEach((error) => {
          var _a;
          if ((_a = error.message) === null || _a === void 0 ? void 0 : _a.startsWith("__renderMessage__")) {
            error.message = originalMessageRendersMessage[error.message];
          }
        });
      };
      if (activeErrorRules.length) {
        const errors = yield new Promise((resolve) => {
          void validator2.validate({
            [mergedPath]: value
          }, options, resolve);
        });
        if (errors === null || errors === void 0 ? void 0 : errors.length) {
          validationResult.valid = false;
          validationResult.errors = errors;
          renderMessages(errors);
        }
      }
      if (activeWarningRules.length && !validationResult.errors) {
        const warnings = yield new Promise((resolve) => {
          void warningValidator.validate({
            [mergedPath]: value
          }, options, resolve);
        });
        if (warnings === null || warnings === void 0 ? void 0 : warnings.length) {
          renderMessages(warnings);
          validationResult.warnings = warnings;
        }
      }
      if (!validationResult.errors && !validationResult.warnings) {
        restoreValidation();
      } else {
        validationErroredRef.value = !!validationResult.errors;
        validationWarnedRef.value = !!validationResult.warnings;
      }
      return validationResult;
    });
    function handleContentBlur() {
      void internalValidate("blur");
    }
    function handleContentChange() {
      void internalValidate("change");
    }
    function handleContentFocus() {
      void internalValidate("focus");
    }
    function handleContentInput() {
      void internalValidate("input");
    }
    function validate(options, callback) {
      return __awaiter(this, void 0, void 0, function* () {
        let trigger2;
        let validateCallback;
        let shouldRuleBeApplied;
        let asyncValidatorOptions;
        if (typeof options === "string") {
          trigger2 = options;
          validateCallback = callback;
        } else if (options !== null && typeof options === "object") {
          trigger2 = options.trigger;
          validateCallback = options.callback;
          shouldRuleBeApplied = options.shouldRuleBeApplied;
          asyncValidatorOptions = options.options;
        }
        return yield new Promise((resolve, reject2) => {
          void internalValidate(trigger2, shouldRuleBeApplied, asyncValidatorOptions).then(({
            valid,
            errors,
            warnings
          }) => {
            if (valid) {
              if (validateCallback) {
                validateCallback(void 0, {
                  warnings
                });
              }
              resolve({
                warnings
              });
            } else {
              if (validateCallback) {
                validateCallback(errors, {
                  warnings
                });
              }
              reject2(errors);
            }
          });
        });
      });
    }
    provide(formItemInjectionKey, {
      path: toRef(props, "path"),
      disabled: mergedDisabledRef,
      mergedSize: formItemSizeRefs.mergedSize,
      mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,
      restoreValidation,
      handleContentBlur,
      handleContentChange,
      handleContentFocus,
      handleContentInput
    });
    const exposedRef = {
      validate,
      restoreValidation,
      internalValidate
    };
    const labelElementRef = ref(null);
    onMounted(() => {
      if (!formItemMiscRefs.isAutoLabelWidth.value)
        return;
      const labelElement = labelElementRef.value;
      if (labelElement !== null) {
        const memoizedWhitespace = labelElement.style.whiteSpace;
        labelElement.style.whiteSpace = "nowrap";
        labelElement.style.width = "";
        NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.deriveMaxChildLabelWidth(Number(getComputedStyle(labelElement).width.slice(0, -2)));
        labelElement.style.whiteSpace = memoizedWhitespace;
      }
    });
    const cssVarsRef = computed(() => {
      var _a;
      const {
        value: size2
      } = mergedSizeRef;
      const {
        value: labelPlacement
      } = labelPlacementRef;
      const direction = labelPlacement === "top" ? "vertical" : "horizontal";
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: {
          labelTextColor,
          asteriskColor,
          lineHeight: lineHeight2,
          feedbackTextColor,
          feedbackTextColorWarning,
          feedbackTextColorError,
          feedbackPadding,
          labelFontWeight,
          [createKey("labelHeight", size2)]: labelHeight,
          [createKey("blankHeight", size2)]: blankHeight,
          [createKey("feedbackFontSize", size2)]: feedbackFontSize,
          [createKey("feedbackHeight", size2)]: feedbackHeight,
          [createKey("labelPadding", direction)]: labelPadding,
          [createKey("labelTextAlign", direction)]: labelTextAlign,
          [createKey(createKey("labelFontSize", labelPlacement), size2)]: labelFontSize
        }
      } = themeRef.value;
      let mergedLabelTextAlign = (_a = labelTextAlignRef.value) !== null && _a !== void 0 ? _a : labelTextAlign;
      if (labelPlacement === "top") {
        mergedLabelTextAlign = mergedLabelTextAlign === "right" ? "flex-end" : "flex-start";
      }
      const cssVars = {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-line-height": lineHeight2,
        "--n-blank-height": blankHeight,
        "--n-label-font-size": labelFontSize,
        "--n-label-text-align": mergedLabelTextAlign,
        "--n-label-height": labelHeight,
        "--n-label-padding": labelPadding,
        "--n-label-font-weight": labelFontWeight,
        "--n-asterisk-color": asteriskColor,
        "--n-label-text-color": labelTextColor,
        "--n-feedback-padding": feedbackPadding,
        "--n-feedback-font-size": feedbackFontSize,
        "--n-feedback-height": feedbackHeight,
        "--n-feedback-text-color": feedbackTextColor,
        "--n-feedback-text-color-warning": feedbackTextColorWarning,
        "--n-feedback-text-color-error": feedbackTextColorError
      };
      return cssVars;
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("form-item", computed(() => {
      var _a;
      return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${((_a = labelTextAlignRef.value) === null || _a === void 0 ? void 0 : _a[0]) || ""}`;
    }), cssVarsRef, props) : void 0;
    const reverseColSpaceRef = computed(() => {
      return labelPlacementRef.value === "left" && mergedRequireMarkPlacementRef.value === "left" && labelTextAlignRef.value === "left";
    });
    return Object.assign(Object.assign(Object.assign(Object.assign({
      labelElementRef,
      mergedClsPrefix: mergedClsPrefixRef,
      mergedRequired: mergedRequiredRef,
      feedbackId: feedbackIdRef,
      renderExplains: renderExplainsRef,
      reverseColSpace: reverseColSpaceRef
    }, formItemMiscRefs), formItemSizeRefs), exposedRef), {
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    });
  },
  render() {
    const {
      $slots,
      mergedClsPrefix,
      mergedShowLabel,
      mergedShowRequireMark,
      mergedRequireMarkPlacement,
      onRender
    } = this;
    const renderedShowRequireMark = mergedShowRequireMark !== void 0 ? mergedShowRequireMark : this.mergedRequired;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    const renderLabel = () => {
      const labelText = this.$slots.label ? this.$slots.label() : this.label;
      if (!labelText)
        return null;
      const textNode = h("span", {
        class: `${mergedClsPrefix}-form-item-label__text`
      }, labelText);
      const markNode = renderedShowRequireMark ? h("span", {
        class: `${mergedClsPrefix}-form-item-label__asterisk`
      }, mergedRequireMarkPlacement !== "left" ? " *" : "* ") : mergedRequireMarkPlacement === "right-hanging" && h("span", {
        class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder`
      }, " *");
      const {
        labelProps
      } = this;
      return h("label", Object.assign({}, labelProps, {
        class: [labelProps === null || labelProps === void 0 ? void 0 : labelProps.class, `${mergedClsPrefix}-form-item-label`, `${mergedClsPrefix}-form-item-label--${mergedRequireMarkPlacement}-mark`, this.reverseColSpace && `${mergedClsPrefix}-form-item-label--reverse-columns-space`],
        style: this.mergedLabelStyle,
        ref: "labelElementRef"
      }), mergedRequireMarkPlacement === "left" ? [markNode, textNode] : [textNode, markNode]);
    };
    return h("div", {
      class: [`${mergedClsPrefix}-form-item`, this.themeClass, `${mergedClsPrefix}-form-item--${this.mergedSize}-size`, `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${mergedClsPrefix}-form-item--auto-label-width`, !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`],
      style: this.cssVars
    }, mergedShowLabel && renderLabel(), h("div", {
      class: [`${mergedClsPrefix}-form-item-blank`, this.mergedValidationStatus && `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`]
    }, $slots), this.mergedShowFeedback ? h("div", {
      key: this.feedbackId,
      style: this.feedbackStyle,
      class: [`${mergedClsPrefix}-form-item-feedback-wrapper`, this.feedbackClass]
    }, h(Transition, {
      name: "fade-down-transition",
      mode: "out-in"
    }, {
      default: () => {
        const {
          mergedValidationStatus
        } = this;
        return resolveWrappedSlot($slots.feedback, (children) => {
          var _a;
          const {
            feedback
          } = this;
          const feedbackNodes = children || feedback ? h("div", {
            key: "__feedback__",
            class: `${mergedClsPrefix}-form-item-feedback__line`
          }, children || feedback) : this.renderExplains.length ? (_a = this.renderExplains) === null || _a === void 0 ? void 0 : _a.map(({
            key,
            render: render22
          }) => h("div", {
            key,
            class: `${mergedClsPrefix}-form-item-feedback__line`
          }, render22())) : null;
          return feedbackNodes ? mergedValidationStatus === "warning" ? h("div", {
            key: "controlled-warning",
            class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning`
          }, feedbackNodes) : mergedValidationStatus === "error" ? h("div", {
            key: "controlled-error",
            class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error`
          }, feedbackNodes) : mergedValidationStatus === "success" ? h("div", {
            key: "controlled-success",
            class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success`
          }, feedbackNodes) : h("div", {
            key: "controlled-default",
            class: `${mergedClsPrefix}-form-item-feedback`
          }, feedbackNodes) : null;
        });
      }
    })) : null);
  }
});
function self$5(vars) {
  const {
    textColorDisabled
  } = vars;
  return {
    iconColorDisabled: textColorDisabled
  };
}
const inputNumberLight = createTheme({
  name: "InputNumber",
  common: commonLight,
  peers: {
    Button: buttonLight$1,
    Input: inputLight$1
  },
  self: self$5
});
const inputNumberLight$1 = inputNumberLight;
function createPartialInvertedVars(color, activeItemColor, activeTextColor, groupTextColor) {
  return {
    itemColorHoverInverted: "#0000",
    itemColorActiveInverted: activeItemColor,
    itemColorActiveHoverInverted: activeItemColor,
    itemColorActiveCollapsedInverted: activeItemColor,
    itemTextColorInverted: color,
    itemTextColorHoverInverted: activeTextColor,
    itemTextColorChildActiveInverted: activeTextColor,
    itemTextColorChildActiveHoverInverted: activeTextColor,
    itemTextColorActiveInverted: activeTextColor,
    itemTextColorActiveHoverInverted: activeTextColor,
    itemTextColorHorizontalInverted: color,
    itemTextColorHoverHorizontalInverted: activeTextColor,
    itemTextColorChildActiveHorizontalInverted: activeTextColor,
    itemTextColorChildActiveHoverHorizontalInverted: activeTextColor,
    itemTextColorActiveHorizontalInverted: activeTextColor,
    itemTextColorActiveHoverHorizontalInverted: activeTextColor,
    itemIconColorInverted: color,
    itemIconColorHoverInverted: activeTextColor,
    itemIconColorActiveInverted: activeTextColor,
    itemIconColorActiveHoverInverted: activeTextColor,
    itemIconColorChildActiveInverted: activeTextColor,
    itemIconColorChildActiveHoverInverted: activeTextColor,
    itemIconColorCollapsedInverted: color,
    itemIconColorHorizontalInverted: color,
    itemIconColorHoverHorizontalInverted: activeTextColor,
    itemIconColorActiveHorizontalInverted: activeTextColor,
    itemIconColorActiveHoverHorizontalInverted: activeTextColor,
    itemIconColorChildActiveHorizontalInverted: activeTextColor,
    itemIconColorChildActiveHoverHorizontalInverted: activeTextColor,
    arrowColorInverted: color,
    arrowColorHoverInverted: activeTextColor,
    arrowColorActiveInverted: activeTextColor,
    arrowColorActiveHoverInverted: activeTextColor,
    arrowColorChildActiveInverted: activeTextColor,
    arrowColorChildActiveHoverInverted: activeTextColor,
    groupTextColorInverted: groupTextColor
  };
}
function self$4(vars) {
  const {
    borderRadius,
    textColor3,
    primaryColor,
    textColor2,
    textColor1,
    fontSize: fontSize2,
    dividerColor,
    hoverColor,
    primaryColorHover
  } = vars;
  return Object.assign({
    borderRadius,
    color: "#0000",
    groupTextColor: textColor3,
    itemColorHover: hoverColor,
    itemColorActive: changeColor(primaryColor, {
      alpha: 0.1
    }),
    itemColorActiveHover: changeColor(primaryColor, {
      alpha: 0.1
    }),
    itemColorActiveCollapsed: changeColor(primaryColor, {
      alpha: 0.1
    }),
    itemTextColor: textColor2,
    itemTextColorHover: textColor2,
    itemTextColorActive: primaryColor,
    itemTextColorActiveHover: primaryColor,
    itemTextColorChildActive: primaryColor,
    itemTextColorChildActiveHover: primaryColor,
    itemTextColorHorizontal: textColor2,
    itemTextColorHoverHorizontal: primaryColorHover,
    itemTextColorActiveHorizontal: primaryColor,
    itemTextColorActiveHoverHorizontal: primaryColor,
    itemTextColorChildActiveHorizontal: primaryColor,
    itemTextColorChildActiveHoverHorizontal: primaryColor,
    itemIconColor: textColor1,
    itemIconColorHover: textColor1,
    itemIconColorActive: primaryColor,
    itemIconColorActiveHover: primaryColor,
    itemIconColorChildActive: primaryColor,
    itemIconColorChildActiveHover: primaryColor,
    itemIconColorCollapsed: textColor1,
    itemIconColorHorizontal: textColor1,
    itemIconColorHoverHorizontal: primaryColorHover,
    itemIconColorActiveHorizontal: primaryColor,
    itemIconColorActiveHoverHorizontal: primaryColor,
    itemIconColorChildActiveHorizontal: primaryColor,
    itemIconColorChildActiveHoverHorizontal: primaryColor,
    itemHeight: "42px",
    arrowColor: textColor2,
    arrowColorHover: textColor2,
    arrowColorActive: primaryColor,
    arrowColorActiveHover: primaryColor,
    arrowColorChildActive: primaryColor,
    arrowColorChildActiveHover: primaryColor,
    colorInverted: "#0000",
    borderColorHorizontal: "#0000",
    fontSize: fontSize2,
    dividerColor
  }, createPartialInvertedVars("#BBB", primaryColor, "#FFF", "#AAA"));
}
const menuLight = createTheme({
  name: "Menu",
  common: commonLight,
  peers: {
    Tooltip: tooltipLight$1,
    Dropdown: dropdownLight$1
  },
  self: self$4
});
const menuLight$1 = menuLight;
function self$3(vars) {
  const {
    opacityDisabled,
    heightTiny,
    heightSmall,
    heightMedium,
    heightLarge,
    heightHuge,
    primaryColor,
    fontSize: fontSize2
  } = vars;
  return {
    fontSize: fontSize2,
    textColor: primaryColor,
    sizeTiny: heightTiny,
    sizeSmall: heightSmall,
    sizeMedium: heightMedium,
    sizeLarge: heightLarge,
    sizeHuge: heightHuge,
    color: primaryColor,
    opacitySpinning: opacityDisabled
  };
}
const spinLight = {
  name: "Spin",
  common: commonLight,
  self: self$3
};
const spinLight$1 = spinLight;
const sizeVariables = {
  tabFontSizeSmall: "14px",
  tabFontSizeMedium: "14px",
  tabFontSizeLarge: "16px",
  tabGapSmallLine: "36px",
  tabGapMediumLine: "36px",
  tabGapLargeLine: "36px",
  tabGapSmallLineVertical: "8px",
  tabGapMediumLineVertical: "8px",
  tabGapLargeLineVertical: "8px",
  tabPaddingSmallLine: "6px 0",
  tabPaddingMediumLine: "10px 0",
  tabPaddingLargeLine: "14px 0",
  tabPaddingVerticalSmallLine: "6px 12px",
  tabPaddingVerticalMediumLine: "8px 16px",
  tabPaddingVerticalLargeLine: "10px 20px",
  tabGapSmallBar: "36px",
  tabGapMediumBar: "36px",
  tabGapLargeBar: "36px",
  tabGapSmallBarVertical: "8px",
  tabGapMediumBarVertical: "8px",
  tabGapLargeBarVertical: "8px",
  tabPaddingSmallBar: "4px 0",
  tabPaddingMediumBar: "6px 0",
  tabPaddingLargeBar: "10px 0",
  tabPaddingVerticalSmallBar: "6px 12px",
  tabPaddingVerticalMediumBar: "8px 16px",
  tabPaddingVerticalLargeBar: "10px 20px",
  tabGapSmallCard: "4px",
  tabGapMediumCard: "4px",
  tabGapLargeCard: "4px",
  tabGapSmallCardVertical: "4px",
  tabGapMediumCardVertical: "4px",
  tabGapLargeCardVertical: "4px",
  tabPaddingSmallCard: "8px 16px",
  tabPaddingMediumCard: "10px 20px",
  tabPaddingLargeCard: "12px 24px",
  tabPaddingSmallSegment: "4px 0",
  tabPaddingMediumSegment: "6px 0",
  tabPaddingLargeSegment: "8px 0",
  tabPaddingVerticalLargeSegment: "0 8px",
  tabPaddingVerticalSmallCard: "8px 12px",
  tabPaddingVerticalMediumCard: "10px 16px",
  tabPaddingVerticalLargeCard: "12px 20px",
  tabPaddingVerticalSmallSegment: "0 4px",
  tabPaddingVerticalMediumSegment: "0 6px",
  tabGapSmallSegment: "0",
  tabGapMediumSegment: "0",
  tabGapLargeSegment: "0",
  tabGapSmallSegmentVertical: "0",
  tabGapMediumSegmentVertical: "0",
  tabGapLargeSegmentVertical: "0",
  panePaddingSmall: "8px 0 0 0",
  panePaddingMedium: "12px 0 0 0",
  panePaddingLarge: "16px 0 0 0",
  closeSize: "18px",
  closeIconSize: "14px"
};
function self$2(vars) {
  const {
    textColor2,
    primaryColor,
    textColorDisabled,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    closeColorHover,
    closeColorPressed,
    tabColor,
    baseColor,
    dividerColor,
    fontWeight,
    textColor1,
    borderRadius,
    fontSize: fontSize2,
    fontWeightStrong
  } = vars;
  return Object.assign(Object.assign({}, sizeVariables), {
    colorSegment: tabColor,
    tabFontSizeCard: fontSize2,
    tabTextColorLine: textColor1,
    tabTextColorActiveLine: primaryColor,
    tabTextColorHoverLine: primaryColor,
    tabTextColorDisabledLine: textColorDisabled,
    tabTextColorSegment: textColor1,
    tabTextColorActiveSegment: textColor2,
    tabTextColorHoverSegment: textColor2,
    tabTextColorDisabledSegment: textColorDisabled,
    tabTextColorBar: textColor1,
    tabTextColorActiveBar: primaryColor,
    tabTextColorHoverBar: primaryColor,
    tabTextColorDisabledBar: textColorDisabled,
    tabTextColorCard: textColor1,
    tabTextColorHoverCard: textColor1,
    tabTextColorActiveCard: primaryColor,
    tabTextColorDisabledCard: textColorDisabled,
    barColor: primaryColor,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    closeColorHover,
    closeColorPressed,
    closeBorderRadius: borderRadius,
    tabColor,
    tabColorSegment: baseColor,
    tabBorderColor: dividerColor,
    tabFontWeightActive: fontWeight,
    tabFontWeight: fontWeight,
    tabBorderRadius: borderRadius,
    paneTextColor: textColor2,
    fontWeightStrong
  });
}
const tabsLight = {
  name: "Tabs",
  common: commonLight,
  self: self$2
};
const tabsLight$1 = tabsLight;
Object.assign(Object.assign({}, useTheme.props), {
  left: [Number, String],
  right: [Number, String],
  top: [Number, String],
  bottom: [Number, String],
  shape: {
    type: String,
    default: "circle"
  },
  position: {
    type: String,
    default: "fixed"
  }
});
const floatButtonGroupInjectionKey = createInjectionKey("n-float-button-group");
function self$1(vars) {
  const {
    popoverColor,
    textColor2,
    buttonColor2Hover,
    buttonColor2Pressed,
    primaryColor,
    primaryColorHover,
    primaryColorPressed,
    borderRadius
  } = vars;
  return {
    color: popoverColor,
    colorHover: buttonColor2Hover,
    colorPressed: buttonColor2Pressed,
    colorPrimary: primaryColor,
    colorPrimaryHover: primaryColorHover,
    colorPrimaryPressed: primaryColorPressed,
    textColor: textColor2,
    boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .16)",
    boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .24)",
    boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .24)",
    textColorPrimary: "#fff",
    borderRadiusSquare: borderRadius
  };
}
const themeLight = {
  name: "FloatButton",
  common: commonLight,
  self: self$1
};
const floatButtonLight = themeLight;
const style$4 = cB("float-button", `
 user-select: none;
 cursor: pointer;
 color: var(--n-text-color);
 background-color: var(--n-color);
 font-size: 18px;
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 box-shadow: var(--n-box-shadow);
 display: flex;
 align-items: stretch;
 box-sizing: border-box;
`, [cM("circle-shape", `
 border-radius: 4096px;
 `), cM("square-shape", `
 border-radius: var(--n-border-radius-square);
 `), cE("fill", `
 position: absolute;
 inset: 0;
 transition: background-color .3s var(--n-bezier);
 border-radius: inherit;
 `), cE("body", `
 position: relative;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: transform .3s var(--n-bezier), opacity .3s var(--n-bezier);
 border-radius: inherit;
 flex-direction: column;
 box-sizing: border-box;
 padding: 2px 4px;
 gap: 2px;
 transform: scale(1);
 `, [cE("description", `
 font-size: 12px;
 text-align: center;
 line-height: 14px;
 `)]), c$1("&:hover", "box-shadow: var(--n-box-shadow-hover);", [c$1(">", [cE("fill", `
 background-color: var(--n-color-hover);
 `)])]), c$1("&:active", "box-shadow: var(--n-box-shadow-pressed);", [c$1(">", [cE("fill", `
 background-color: var(--n-color-pressed);
 `)])]), cM("show-menu", [c$1(">", [cE("menu", `
 pointer-events: all;
 bottom: 100%;
 opacity: 1;
 `), cE("close", `
 transform: scale(1);
 opacity: 1;
 `), cE("body", `
 transform: scale(0.75);
 opacity: 0;
 `)])]), cE("close", `
 opacity: 0;
 transform: scale(0.75);
 position: absolute;
 inset: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: transform .3s var(--n-bezier), opacity .3s var(--n-bezier);
 `), cE("menu", `
 position: absolute;
 bottom: calc(100% - 8px);
 display: flex;
 flex-direction: column;
 opacity: 0;
 pointer-events: none;
 transition:
 opacity .3s var(--n-bezier),
 bottom .3s var(--n-bezier); 
 `, [c$1("> *", `
 margin-bottom: 16px;
 `), cB("float-button", `
 position: relative !important;
 `)])]);
const floatButtonProps = Object.assign(Object.assign({}, useTheme.props), {
  width: {
    type: [Number, String],
    default: 40
  },
  height: {
    type: [Number, String],
    default: 40
  },
  left: [Number, String],
  right: [Number, String],
  top: [Number, String],
  bottom: [Number, String],
  shape: {
    type: String,
    default: "circle"
  },
  position: {
    type: String,
    default: "fixed"
  },
  type: {
    type: String,
    default: "default"
  },
  menuTrigger: String,
  showMenu: {
    type: Boolean,
    default: void 0
  },
  onUpdateShowMenu: {
    type: [Function, Array],
    default: void 0
  },
  "onUpdate:showMenu": {
    type: [Function, Array],
    default: void 0
  }
});
const NFloatButton = /* @__PURE__ */ defineComponent({
  name: "FloatButton",
  props: floatButtonProps,
  setup(props) {
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("FloatButton", "-float-button", style$4, floatButtonLight, props, mergedClsPrefixRef);
    const floatButtonGroupInjection = inject(floatButtonGroupInjectionKey, null);
    const uncontrolledShowMenuRef = ref(false);
    const controlledShoeMenuRef = toRef(props, "showMenu");
    const mergedShowMenuRef = useMergedState(controlledShoeMenuRef, uncontrolledShowMenuRef);
    function doUpdateShowMenu(value) {
      const {
        onUpdateShowMenu,
        "onUpdate:showMenu": _onUpdateShowMenu
      } = props;
      uncontrolledShowMenuRef.value = value;
      if (onUpdateShowMenu) {
        call(onUpdateShowMenu, value);
      }
      if (_onUpdateShowMenu) {
        call(_onUpdateShowMenu, value);
      }
    }
    const cssVarsRef = computed(() => {
      const {
        self: {
          color,
          textColor,
          boxShadow,
          boxShadowHover,
          boxShadowPressed,
          colorHover,
          colorPrimary,
          colorPrimaryHover,
          textColorPrimary,
          borderRadiusSquare,
          colorPressed,
          colorPrimaryPressed
        },
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        }
      } = themeRef.value;
      const {
        type: type4
      } = props;
      return {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-box-shadow": boxShadow,
        "--n-box-shadow-hover": boxShadowHover,
        "--n-box-shadow-pressed": boxShadowPressed,
        "--n-color": type4 === "primary" ? colorPrimary : color,
        "--n-text-color": type4 === "primary" ? textColorPrimary : textColor,
        "--n-color-hover": type4 === "primary" ? colorPrimaryHover : colorHover,
        "--n-color-pressed": type4 === "primary" ? colorPrimaryPressed : colorPressed,
        "--n-border-radius-square": borderRadiusSquare
      };
    });
    const inlineStyle = computed(() => {
      const {
        width,
        height
      } = props;
      return Object.assign({
        position: floatButtonGroupInjection ? void 0 : props.position,
        width: formatLength(width),
        minHeight: formatLength(height)
      }, floatButtonGroupInjection ? null : {
        left: formatLength(props.left),
        right: formatLength(props.right),
        top: formatLength(props.top),
        bottom: formatLength(props.bottom)
      });
    });
    const mergedShapeRef = computed(() => {
      return floatButtonGroupInjection ? floatButtonGroupInjection.shapeRef.value : props.shape;
    });
    const Mouseenter = () => {
      if (props.menuTrigger === "hover") {
        doUpdateShowMenu(true);
      }
    };
    const handleMouseleave = () => {
      if (props.menuTrigger === "hover" && mergedShowMenuRef.value) {
        doUpdateShowMenu(false);
      }
    };
    const handleClick2 = () => {
      if (props.menuTrigger === "click") {
        doUpdateShowMenu(!mergedShowMenuRef.value);
      }
    };
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("float-button", computed(() => props.type[0]), cssVarsRef, props) : void 0;
    return {
      inlineStyle,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      mergedClsPrefix: mergedClsPrefixRef,
      mergedShape: mergedShapeRef,
      mergedShowMenu: mergedShowMenuRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
      Mouseenter,
      handleMouseleave,
      handleClick: handleClick2
    };
  },
  render() {
    var _a;
    const {
      mergedClsPrefix,
      cssVars,
      mergedShape,
      type: type4,
      menuTrigger,
      mergedShowMenu,
      themeClass,
      $slots,
      inlineStyle,
      onRender
    } = this;
    const dirs = [[mousemoveoutside$1, this.handleMouseleave]];
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return withDirectives(h("div", {
      class: [`${mergedClsPrefix}-float-button`, `${mergedClsPrefix}-float-button--${mergedShape}-shape`, `${mergedClsPrefix}-float-button--${type4}-type`, mergedShowMenu && `${mergedClsPrefix}-float-button--show-menu`, themeClass],
      style: [cssVars, inlineStyle],
      onMouseenter: this.Mouseenter,
      onMouseleave: this.handleMouseleave,
      onClick: this.handleClick,
      role: "button"
    }, h("div", {
      class: `${mergedClsPrefix}-float-button__fill`,
      "aria-hidden": true
    }), h("div", {
      class: `${mergedClsPrefix}-float-button__body`
    }, (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots), resolveWrappedSlot($slots.description, (children) => {
      if (children) {
        return h("div", {
          class: `${mergedClsPrefix}-float-button__description`
        }, children);
      }
      return null;
    })), menuTrigger ? h("div", {
      class: `${mergedClsPrefix}-float-button__close`
    }, h(NBaseIcon, {
      clsPrefix: mergedClsPrefix
    }, {
      default: () => h(ErrorIcon$1, null)
    })) : null, menuTrigger ? h("div", {
      onClick: (e) => {
        e.stopPropagation();
      },
      "data-float-button-menu": true,
      class: `${mergedClsPrefix}-float-button__menu`
    }, resolveSlot($slots.menu, () => [])) : null), dirs);
  }
});
function parse(value) {
  if (value === void 0 || value === null || typeof value === "string" && value.trim() === "") {
    return null;
  }
  return Number(value);
}
function isWipValue(value) {
  return value.includes(".") && (/^(-)?\d+.*(\.|0)$/.test(value) || /^\.\d+$/.test(value));
}
function validator(value) {
  if (value === void 0 || value === null)
    return true;
  if (Number.isNaN(value))
    return false;
  return true;
}
function format(value, precision) {
  if (typeof value !== "number")
    return "";
  return precision === void 0 ? String(value) : value.toFixed(precision);
}
function parseNumber(number4) {
  if (number4 === null)
    return null;
  if (typeof number4 === "number") {
    return number4;
  } else {
    const parsedNumber = Number(number4);
    if (Number.isNaN(parsedNumber)) {
      return null;
    } else {
      return parsedNumber;
    }
  }
}
const style$3 = c$1([cB("input-number-suffix", `
 display: inline-block;
 margin-right: 10px;
 `), cB("input-number-prefix", `
 display: inline-block;
 margin-left: 10px;
 `)]);
const HOLDING_CHANGE_THRESHOLD = 800;
const HOLDING_CHANGE_INTERVAL = 100;
const inputNumberProps = Object.assign(Object.assign({}, useTheme.props), {
  autofocus: Boolean,
  loading: {
    type: Boolean,
    default: void 0
  },
  placeholder: String,
  defaultValue: {
    type: Number,
    default: null
  },
  value: Number,
  step: {
    type: [Number, String],
    default: 1
  },
  min: [Number, String],
  max: [Number, String],
  size: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  validator: Function,
  bordered: {
    type: Boolean,
    default: void 0
  },
  showButton: {
    type: Boolean,
    default: true
  },
  buttonPlacement: {
    type: String,
    default: "right"
  },
  inputProps: Object,
  readonly: Boolean,
  clearable: Boolean,
  keyboard: {
    type: Object,
    default: {}
  },
  updateValueOnInput: {
    type: Boolean,
    default: true
  },
  round: {
    type: Boolean,
    default: void 0
  },
  parse: Function,
  format: Function,
  precision: Number,
  status: String,
  "onUpdate:value": [Function, Array],
  onUpdateValue: [Function, Array],
  onFocus: [Function, Array],
  onBlur: [Function, Array],
  onClear: [Function, Array],
  // deprecated
  onChange: [Function, Array]
});
const NInputNumber = /* @__PURE__ */ defineComponent({
  name: "InputNumber",
  props: inputNumberProps,
  setup(props) {
    const {
      mergedBorderedRef,
      mergedClsPrefixRef,
      mergedRtlRef
    } = useConfig(props);
    const themeRef = useTheme("InputNumber", "-input-number", style$3, inputNumberLight$1, props, mergedClsPrefixRef);
    const {
      localeRef
    } = useLocale("InputNumber");
    const formItem = useFormItem(props);
    const {
      mergedSizeRef,
      mergedDisabledRef,
      mergedStatusRef
    } = formItem;
    const inputInstRef = ref(null);
    const minusButtonInstRef = ref(null);
    const addButtonInstRef = ref(null);
    const uncontrolledValueRef = ref(props.defaultValue);
    const controlledValueRef = toRef(props, "value");
    const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
    const displayedValueRef = ref("");
    const getPrecision = (value) => {
      const fraction = String(value).split(".")[1];
      return fraction ? fraction.length : 0;
    };
    const getMaxPrecision = (currentValue) => {
      const precisions = [props.min, props.max, props.step, currentValue].map((value) => {
        if (value === void 0)
          return 0;
        return getPrecision(value);
      });
      return Math.max(...precisions);
    };
    const mergedPlaceholderRef = useMemo(() => {
      const {
        placeholder
      } = props;
      if (placeholder !== void 0)
        return placeholder;
      return localeRef.value.placeholder;
    });
    const mergedStepRef = useMemo(() => {
      const parsedNumber = parseNumber(props.step);
      if (parsedNumber !== null) {
        return parsedNumber === 0 ? 1 : Math.abs(parsedNumber);
      }
      return 1;
    });
    const mergedMinRef = useMemo(() => {
      const parsedNumber = parseNumber(props.min);
      if (parsedNumber !== null)
        return parsedNumber;
      else
        return null;
    });
    const mergedMaxRef = useMemo(() => {
      const parsedNumber = parseNumber(props.max);
      if (parsedNumber !== null)
        return parsedNumber;
      else
        return null;
    });
    const deriveDisplayedValueFromValue = () => {
      const {
        value: mergedValue
      } = mergedValueRef;
      if (validator(mergedValue)) {
        const {
          format: formatProp2,
          precision
        } = props;
        if (formatProp2) {
          displayedValueRef.value = formatProp2(mergedValue);
        } else {
          if (mergedValue === null || precision === void 0 || getPrecision(mergedValue) > precision) {
            displayedValueRef.value = format(mergedValue, void 0);
          } else {
            displayedValueRef.value = format(mergedValue, precision);
          }
        }
      } else {
        displayedValueRef.value = String(mergedValue);
      }
    };
    deriveDisplayedValueFromValue();
    const doUpdateValue = (value) => {
      const {
        value: mergedValue
      } = mergedValueRef;
      if (value === mergedValue) {
        deriveDisplayedValueFromValue();
        return;
      }
      const {
        "onUpdate:value": _onUpdateValue,
        onUpdateValue,
        onChange
      } = props;
      const {
        nTriggerFormInput,
        nTriggerFormChange
      } = formItem;
      if (onChange)
        call(onChange, value);
      if (onUpdateValue)
        call(onUpdateValue, value);
      if (_onUpdateValue)
        call(_onUpdateValue, value);
      uncontrolledValueRef.value = value;
      nTriggerFormInput();
      nTriggerFormChange();
    };
    const deriveValueFromDisplayedValue = ({
      offset,
      doUpdateIfValid,
      fixPrecision,
      isInputing
    }) => {
      const {
        value: displayedValue
      } = displayedValueRef;
      if (isInputing && isWipValue(displayedValue)) {
        return false;
      }
      const parsedValue = (props.parse || parse)(displayedValue);
      if (parsedValue === null) {
        if (doUpdateIfValid)
          doUpdateValue(null);
        return null;
      }
      if (validator(parsedValue)) {
        const currentPrecision = getPrecision(parsedValue);
        const {
          precision
        } = props;
        if (precision !== void 0 && precision < currentPrecision && !fixPrecision) {
          return false;
        }
        let nextValue = Number.parseFloat((parsedValue + offset).toFixed(precision !== null && precision !== void 0 ? precision : getMaxPrecision(parsedValue)));
        if (validator(nextValue)) {
          const {
            value: mergedMax
          } = mergedMaxRef;
          const {
            value: mergedMin
          } = mergedMinRef;
          if (mergedMax !== null && nextValue > mergedMax) {
            if (!doUpdateIfValid || isInputing)
              return false;
            nextValue = mergedMax;
          }
          if (mergedMin !== null && nextValue < mergedMin) {
            if (!doUpdateIfValid || isInputing)
              return false;
            nextValue = mergedMin;
          }
          if (props.validator && !props.validator(nextValue))
            return false;
          if (doUpdateIfValid)
            doUpdateValue(nextValue);
          return nextValue;
        }
      }
      return false;
    };
    const displayedValueInvalidRef = useMemo(() => {
      const derivedValue = deriveValueFromDisplayedValue({
        offset: 0,
        doUpdateIfValid: false,
        isInputing: false,
        fixPrecision: false
      });
      return derivedValue === false;
    });
    const minusableRef = useMemo(() => {
      const {
        value: mergedValue
      } = mergedValueRef;
      if (props.validator && mergedValue === null) {
        return false;
      }
      const {
        value: mergedStep
      } = mergedStepRef;
      const derivedNextValue = deriveValueFromDisplayedValue({
        offset: -mergedStep,
        doUpdateIfValid: false,
        isInputing: false,
        fixPrecision: false
      });
      return derivedNextValue !== false;
    });
    const addableRef = useMemo(() => {
      const {
        value: mergedValue
      } = mergedValueRef;
      if (props.validator && mergedValue === null) {
        return false;
      }
      const {
        value: mergedStep
      } = mergedStepRef;
      const derivedNextValue = deriveValueFromDisplayedValue({
        offset: +mergedStep,
        doUpdateIfValid: false,
        isInputing: false,
        fixPrecision: false
      });
      return derivedNextValue !== false;
    });
    function doFocus(e) {
      const {
        onFocus
      } = props;
      const {
        nTriggerFormFocus
      } = formItem;
      if (onFocus)
        call(onFocus, e);
      nTriggerFormFocus();
    }
    function doBlur(e) {
      var _a, _b;
      if (e.target === ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef)) {
        return;
      }
      const value = deriveValueFromDisplayedValue({
        offset: 0,
        doUpdateIfValid: true,
        isInputing: false,
        fixPrecision: true
      });
      if (value !== false) {
        const inputElRef = (_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.inputElRef;
        if (inputElRef) {
          inputElRef.value = String(value || "");
        }
        if (mergedValueRef.value === value) {
          deriveDisplayedValueFromValue();
        }
      } else {
        deriveDisplayedValueFromValue();
      }
      const {
        onBlur
      } = props;
      const {
        nTriggerFormBlur
      } = formItem;
      if (onBlur)
        call(onBlur, e);
      nTriggerFormBlur();
      void nextTick(() => {
        deriveDisplayedValueFromValue();
      });
    }
    function doClear(e) {
      const {
        onClear
      } = props;
      if (onClear)
        call(onClear, e);
    }
    function doAdd() {
      const {
        value: addable
      } = addableRef;
      if (!addable) {
        clearAddHoldTimeout();
        return;
      }
      const {
        value: mergedValue
      } = mergedValueRef;
      if (mergedValue === null) {
        if (!props.validator) {
          doUpdateValue(createValidValue());
        }
      } else {
        const {
          value: mergedStep
        } = mergedStepRef;
        deriveValueFromDisplayedValue({
          offset: mergedStep,
          doUpdateIfValid: true,
          isInputing: false,
          fixPrecision: true
        });
      }
    }
    function doMinus() {
      const {
        value: minusable
      } = minusableRef;
      if (!minusable) {
        clearMinusHoldTimeout();
        return;
      }
      const {
        value: mergedValue
      } = mergedValueRef;
      if (mergedValue === null) {
        if (!props.validator) {
          doUpdateValue(createValidValue());
        }
      } else {
        const {
          value: mergedStep
        } = mergedStepRef;
        deriveValueFromDisplayedValue({
          offset: -mergedStep,
          doUpdateIfValid: true,
          isInputing: false,
          fixPrecision: true
        });
      }
    }
    const handleFocus = doFocus;
    const handleBlur = doBlur;
    function createValidValue() {
      if (props.validator)
        return null;
      const {
        value: mergedMin
      } = mergedMinRef;
      const {
        value: mergedMax
      } = mergedMaxRef;
      if (mergedMin !== null) {
        return Math.max(0, mergedMin);
      } else if (mergedMax !== null) {
        return Math.min(0, mergedMax);
      } else {
        return 0;
      }
    }
    function handleClear(e) {
      doClear(e);
      doUpdateValue(null);
    }
    function handleMouseDown(e) {
      var _a, _b, _c;
      if ((_a = addButtonInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.target)) {
        e.preventDefault();
      }
      if ((_b = minusButtonInstRef.value) === null || _b === void 0 ? void 0 : _b.$el.contains(e.target)) {
        e.preventDefault();
      }
      (_c = inputInstRef.value) === null || _c === void 0 ? void 0 : _c.activate();
    }
    let minusHoldStateIntervalId = null;
    let addHoldStateIntervalId = null;
    let firstMinusMousedownId = null;
    function clearMinusHoldTimeout() {
      if (firstMinusMousedownId) {
        window.clearTimeout(firstMinusMousedownId);
        firstMinusMousedownId = null;
      }
      if (minusHoldStateIntervalId) {
        window.clearInterval(minusHoldStateIntervalId);
        minusHoldStateIntervalId = null;
      }
    }
    let firstAddMousedownId = null;
    function clearAddHoldTimeout() {
      if (firstAddMousedownId) {
        window.clearTimeout(firstAddMousedownId);
        firstAddMousedownId = null;
      }
      if (addHoldStateIntervalId) {
        window.clearInterval(addHoldStateIntervalId);
        addHoldStateIntervalId = null;
      }
    }
    function handleMinusMousedown() {
      clearMinusHoldTimeout();
      firstMinusMousedownId = window.setTimeout(() => {
        minusHoldStateIntervalId = window.setInterval(() => {
          doMinus();
        }, HOLDING_CHANGE_INTERVAL);
      }, HOLDING_CHANGE_THRESHOLD);
      on("mouseup", document, clearMinusHoldTimeout, {
        once: true
      });
    }
    function handleAddMousedown() {
      clearAddHoldTimeout();
      firstAddMousedownId = window.setTimeout(() => {
        addHoldStateIntervalId = window.setInterval(() => {
          doAdd();
        }, HOLDING_CHANGE_INTERVAL);
      }, HOLDING_CHANGE_THRESHOLD);
      on("mouseup", document, clearAddHoldTimeout, {
        once: true
      });
    }
    const handleAddClick = () => {
      if (addHoldStateIntervalId)
        return;
      doAdd();
    };
    const handleMinusClick = () => {
      if (minusHoldStateIntervalId)
        return;
      doMinus();
    };
    function handleKeyDown(e) {
      var _a, _b;
      if (e.key === "Enter") {
        if (e.target === ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef)) {
          return;
        }
        const value = deriveValueFromDisplayedValue({
          offset: 0,
          doUpdateIfValid: true,
          isInputing: false,
          fixPrecision: true
        });
        if (value !== false) {
          (_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.deactivate();
        }
      } else if (e.key === "ArrowUp") {
        if (!addableRef.value)
          return;
        if (props.keyboard.ArrowUp === false)
          return;
        e.preventDefault();
        const value = deriveValueFromDisplayedValue({
          offset: 0,
          doUpdateIfValid: true,
          isInputing: false,
          fixPrecision: true
        });
        if (value !== false) {
          doAdd();
        }
      } else if (e.key === "ArrowDown") {
        if (!minusableRef.value)
          return;
        if (props.keyboard.ArrowDown === false)
          return;
        e.preventDefault();
        const value = deriveValueFromDisplayedValue({
          offset: 0,
          doUpdateIfValid: true,
          isInputing: false,
          fixPrecision: true
        });
        if (value !== false) {
          doMinus();
        }
      }
    }
    function handleUpdateDisplayedValue(value) {
      displayedValueRef.value = value;
      if (props.updateValueOnInput && !props.format && !props.parse && props.precision === void 0) {
        deriveValueFromDisplayedValue({
          offset: 0,
          doUpdateIfValid: true,
          isInputing: true,
          fixPrecision: false
        });
      }
    }
    watch(mergedValueRef, () => {
      deriveDisplayedValueFromValue();
    });
    const exposedMethods = {
      focus: () => {
        var _a;
        return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      },
      blur: () => {
        var _a;
        return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
      },
      select: () => {
        var _a;
        return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.select();
      }
    };
    const rtlEnabledRef = useRtl("InputNumber", mergedRtlRef, mergedClsPrefixRef);
    return Object.assign(Object.assign({}, exposedMethods), {
      rtlEnabled: rtlEnabledRef,
      inputInstRef,
      minusButtonInstRef,
      addButtonInstRef,
      mergedClsPrefix: mergedClsPrefixRef,
      mergedBordered: mergedBorderedRef,
      uncontrolledValue: uncontrolledValueRef,
      mergedValue: mergedValueRef,
      mergedPlaceholder: mergedPlaceholderRef,
      displayedValueInvalid: displayedValueInvalidRef,
      mergedSize: mergedSizeRef,
      mergedDisabled: mergedDisabledRef,
      displayedValue: displayedValueRef,
      addable: addableRef,
      minusable: minusableRef,
      mergedStatus: mergedStatusRef,
      handleFocus,
      handleBlur,
      handleClear,
      handleMouseDown,
      handleAddClick,
      handleMinusClick,
      handleAddMousedown,
      handleMinusMousedown,
      handleKeyDown,
      handleUpdateDisplayedValue,
      // theme
      mergedTheme: themeRef,
      inputThemeOverrides: {
        paddingSmall: "0 8px 0 10px",
        paddingMedium: "0 8px 0 12px",
        paddingLarge: "0 8px 0 14px"
      },
      buttonThemeOverrides: computed(() => {
        const {
          self: {
            iconColorDisabled
          }
        } = themeRef.value;
        const [r, g, b, a] = rgba(iconColorDisabled);
        return {
          textColorTextDisabled: `rgb(${r}, ${g}, ${b})`,
          opacityDisabled: `${a}`
        };
      })
    });
  },
  render() {
    const {
      mergedClsPrefix,
      $slots
    } = this;
    const renderMinusButton = () => {
      return h(XButton, {
        text: true,
        disabled: !this.minusable || this.mergedDisabled || this.readonly,
        focusable: false,
        theme: this.mergedTheme.peers.Button,
        themeOverrides: this.mergedTheme.peerOverrides.Button,
        builtinThemeOverrides: this.buttonThemeOverrides,
        onClick: this.handleMinusClick,
        onMousedown: this.handleMinusMousedown,
        ref: "minusButtonInstRef"
      }, {
        icon: () => resolveSlot($slots["minus-icon"], () => [h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: () => h(RemoveIcon, null)
        })])
      });
    };
    const renderAddButton = () => {
      return h(XButton, {
        text: true,
        disabled: !this.addable || this.mergedDisabled || this.readonly,
        focusable: false,
        theme: this.mergedTheme.peers.Button,
        themeOverrides: this.mergedTheme.peerOverrides.Button,
        builtinThemeOverrides: this.buttonThemeOverrides,
        onClick: this.handleAddClick,
        onMousedown: this.handleAddMousedown,
        ref: "addButtonInstRef"
      }, {
        icon: () => resolveSlot($slots["add-icon"], () => [h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: () => h(AddIcon, null)
        })])
      });
    };
    return h("div", {
      class: [`${mergedClsPrefix}-input-number`, this.rtlEnabled && `${mergedClsPrefix}-input-number--rtl`]
    }, h(NInput, {
      ref: "inputInstRef",
      autofocus: this.autofocus,
      status: this.mergedStatus,
      bordered: this.mergedBordered,
      loading: this.loading,
      value: this.displayedValue,
      onUpdateValue: this.handleUpdateDisplayedValue,
      theme: this.mergedTheme.peers.Input,
      themeOverrides: this.mergedTheme.peerOverrides.Input,
      builtinThemeOverrides: this.inputThemeOverrides,
      size: this.mergedSize,
      placeholder: this.mergedPlaceholder,
      disabled: this.mergedDisabled,
      readonly: this.readonly,
      round: this.round,
      textDecoration: this.displayedValueInvalid ? "line-through" : void 0,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      onKeydown: this.handleKeyDown,
      onMousedown: this.handleMouseDown,
      onClear: this.handleClear,
      clearable: this.clearable,
      inputProps: this.inputProps,
      internalLoadingBeforeSuffix: true
    }, {
      prefix: () => {
        var _a;
        return this.showButton && this.buttonPlacement === "both" ? [renderMinusButton(), resolveWrappedSlot($slots.prefix, (children) => {
          if (children) {
            return h("span", {
              class: `${mergedClsPrefix}-input-number-prefix`
            }, children);
          }
          return null;
        })] : (_a = $slots.prefix) === null || _a === void 0 ? void 0 : _a.call($slots);
      },
      suffix: () => {
        var _a;
        return this.showButton ? [resolveWrappedSlot($slots.suffix, (children) => {
          if (children) {
            return h("span", {
              class: `${mergedClsPrefix}-input-number-suffix`
            }, children);
          }
          return null;
        }), this.buttonPlacement === "right" ? renderMinusButton() : null, renderAddButton()] : (_a = $slots.suffix) === null || _a === void 0 ? void 0 : _a.call($slots);
      }
    }));
  }
});
const layoutSiderInjectionKey = createInjectionKey("n-layout-sider");
const menuInjectionKey = createInjectionKey("n-menu");
const submenuInjectionKey = createInjectionKey("n-submenu");
const menuItemGroupInjectionKey = createInjectionKey("n-menu-item-group");
const ICON_MARGIN_RIGHT = 8;
function useMenuChild(props) {
  const NMenu2 = inject(menuInjectionKey);
  const {
    props: menuProps2,
    mergedCollapsedRef
  } = NMenu2;
  const NSubmenu2 = inject(submenuInjectionKey, null);
  const NMenuOptionGroup2 = inject(menuItemGroupInjectionKey, null);
  const horizontalRef = computed(() => {
    return menuProps2.mode === "horizontal";
  });
  const dropdownPlacementRef = computed(() => {
    if (horizontalRef.value) {
      return menuProps2.dropdownPlacement;
    }
    if ("tmNodes" in props)
      return "right-start";
    return "right";
  });
  const maxIconSizeRef = computed(() => {
    var _a;
    return Math.max((_a = menuProps2.collapsedIconSize) !== null && _a !== void 0 ? _a : menuProps2.iconSize, menuProps2.iconSize);
  });
  const activeIconSizeRef = computed(() => {
    var _a;
    if (!horizontalRef.value && props.root && mergedCollapsedRef.value) {
      return (_a = menuProps2.collapsedIconSize) !== null && _a !== void 0 ? _a : menuProps2.iconSize;
    } else {
      return menuProps2.iconSize;
    }
  });
  const paddingLeftRef = computed(() => {
    if (horizontalRef.value)
      return void 0;
    const {
      collapsedWidth,
      indent,
      rootIndent
    } = menuProps2;
    const {
      root: root2,
      isGroup: isGroup2
    } = props;
    const mergedRootIndent = rootIndent === void 0 ? indent : rootIndent;
    if (root2) {
      if (mergedCollapsedRef.value) {
        return collapsedWidth / 2 - maxIconSizeRef.value / 2;
      }
      return mergedRootIndent;
    }
    if (NMenuOptionGroup2 && typeof NMenuOptionGroup2.paddingLeftRef.value === "number") {
      return indent / 2 + NMenuOptionGroup2.paddingLeftRef.value;
    }
    if (NSubmenu2 && typeof NSubmenu2.paddingLeftRef.value === "number") {
      return (isGroup2 ? indent / 2 : indent) + NSubmenu2.paddingLeftRef.value;
    }
    return 0;
  });
  const iconMarginRightRef = computed(() => {
    const {
      collapsedWidth,
      indent,
      rootIndent
    } = menuProps2;
    const {
      value: maxIconSize
    } = maxIconSizeRef;
    const {
      root: root2
    } = props;
    if (horizontalRef.value)
      return ICON_MARGIN_RIGHT;
    if (!root2)
      return ICON_MARGIN_RIGHT;
    if (!mergedCollapsedRef.value)
      return ICON_MARGIN_RIGHT;
    const mergedRootIndent = rootIndent === void 0 ? indent : rootIndent;
    return mergedRootIndent + maxIconSize + ICON_MARGIN_RIGHT - (collapsedWidth + maxIconSize) / 2;
  });
  return {
    dropdownPlacement: dropdownPlacementRef,
    activeIconSize: activeIconSizeRef,
    maxIconSize: maxIconSizeRef,
    paddingLeft: paddingLeftRef,
    iconMarginRight: iconMarginRightRef,
    NMenu: NMenu2,
    NSubmenu: NSubmenu2
  };
}
const useMenuChildProps = {
  internalKey: {
    type: [String, Number],
    required: true
  },
  root: Boolean,
  isGroup: Boolean,
  level: {
    type: Number,
    required: true
  },
  title: [String, Function],
  extra: [String, Function]
};
const menuItemGroupProps = Object.assign(Object.assign({}, useMenuChildProps), {
  tmNode: {
    type: Object,
    required: true
  },
  tmNodes: {
    type: Array,
    required: true
  }
});
const NMenuOptionGroup = /* @__PURE__ */ defineComponent({
  name: "MenuOptionGroup",
  props: menuItemGroupProps,
  setup(props) {
    provide(submenuInjectionKey, null);
    const MenuChild = useMenuChild(props);
    provide(menuItemGroupInjectionKey, {
      paddingLeftRef: MenuChild.paddingLeft
    });
    const {
      mergedClsPrefixRef,
      props: menuProps2
    } = inject(menuInjectionKey);
    return function() {
      const {
        value: mergedClsPrefix
      } = mergedClsPrefixRef;
      const paddingLeft = MenuChild.paddingLeft.value;
      const {
        nodeProps
      } = menuProps2;
      const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(props.tmNode.rawNode);
      return h("div", {
        class: `${mergedClsPrefix}-menu-item-group`,
        role: "group"
      }, h("div", Object.assign({}, attrs, {
        class: [`${mergedClsPrefix}-menu-item-group-title`, attrs === null || attrs === void 0 ? void 0 : attrs.class],
        style: [(attrs === null || attrs === void 0 ? void 0 : attrs.style) || "", paddingLeft !== void 0 ? `padding-left: ${paddingLeft}px;` : ""]
      }), render$1(props.title), props.extra ? h(Fragment, null, " ", render$1(props.extra)) : null), h("div", null, props.tmNodes.map((tmNode) => itemRenderer(tmNode, menuProps2))));
    };
  }
});
const NMenuOptionContent = /* @__PURE__ */ defineComponent({
  name: "MenuOptionContent",
  props: {
    collapsed: Boolean,
    disabled: Boolean,
    title: [String, Function],
    icon: Function,
    extra: [String, Function],
    showArrow: Boolean,
    childActive: Boolean,
    hover: Boolean,
    paddingLeft: Number,
    selected: Boolean,
    maxIconSize: {
      type: Number,
      required: true
    },
    activeIconSize: {
      type: Number,
      required: true
    },
    iconMarginRight: {
      type: Number,
      required: true
    },
    clsPrefix: {
      type: String,
      required: true
    },
    onClick: Function,
    tmNode: {
      type: Object,
      required: true
    },
    isEllipsisPlaceholder: Boolean
  },
  setup(props) {
    const {
      props: menuProps2
    } = inject(menuInjectionKey);
    return {
      menuProps: menuProps2,
      style: computed(() => {
        const {
          paddingLeft
        } = props;
        return {
          paddingLeft: paddingLeft && `${paddingLeft}px`
        };
      }),
      iconStyle: computed(() => {
        const {
          maxIconSize,
          activeIconSize,
          iconMarginRight
        } = props;
        return {
          width: `${maxIconSize}px`,
          height: `${maxIconSize}px`,
          fontSize: `${activeIconSize}px`,
          marginRight: `${iconMarginRight}px`
        };
      })
    };
  },
  render() {
    const {
      clsPrefix,
      tmNode,
      menuProps: {
        renderIcon,
        renderLabel,
        renderExtra,
        expandIcon
      }
    } = this;
    const icon = renderIcon ? renderIcon(tmNode.rawNode) : render$1(this.icon);
    return h("div", {
      onClick: (e) => {
        var _a;
        (_a = this.onClick) === null || _a === void 0 ? void 0 : _a.call(this, e);
      },
      role: "none",
      class: [`${clsPrefix}-menu-item-content`, {
        [`${clsPrefix}-menu-item-content--selected`]: this.selected,
        [`${clsPrefix}-menu-item-content--collapsed`]: this.collapsed,
        [`${clsPrefix}-menu-item-content--child-active`]: this.childActive,
        [`${clsPrefix}-menu-item-content--disabled`]: this.disabled,
        [`${clsPrefix}-menu-item-content--hover`]: this.hover
      }],
      style: this.style
    }, icon && h("div", {
      class: `${clsPrefix}-menu-item-content__icon`,
      style: this.iconStyle,
      role: "none"
    }, [icon]), h("div", {
      class: `${clsPrefix}-menu-item-content-header`,
      role: "none"
    }, this.isEllipsisPlaceholder ? this.title : renderLabel ? renderLabel(tmNode.rawNode) : render$1(this.title), this.extra || renderExtra ? h("span", {
      class: `${clsPrefix}-menu-item-content-header__extra`
    }, " ", renderExtra ? renderExtra(tmNode.rawNode) : render$1(this.extra)) : null), this.showArrow ? h(NBaseIcon, {
      ariaHidden: true,
      class: `${clsPrefix}-menu-item-content__arrow`,
      clsPrefix
    }, {
      default: () => expandIcon ? expandIcon(tmNode.rawNode) : h(ChevronDownFilledIcon, null)
    }) : null);
  }
});
const submenuProps = Object.assign(Object.assign({}, useMenuChildProps), {
  rawNodes: {
    type: Array,
    default: () => []
  },
  tmNodes: {
    type: Array,
    default: () => []
  },
  tmNode: {
    type: Object,
    required: true
  },
  disabled: Boolean,
  icon: Function,
  onClick: Function,
  domId: String,
  virtualChildActive: {
    type: Boolean,
    default: void 0
  },
  isEllipsisPlaceholder: Boolean
});
const NSubmenu = /* @__PURE__ */ defineComponent({
  name: "Submenu",
  props: submenuProps,
  setup(props) {
    const MenuChild = useMenuChild(props);
    const {
      NMenu: NMenu2,
      NSubmenu: NSubmenu2
    } = MenuChild;
    const {
      props: menuProps2,
      mergedCollapsedRef,
      mergedThemeRef
    } = NMenu2;
    const mergedDisabledRef = computed(() => {
      const {
        disabled
      } = props;
      if (NSubmenu2 === null || NSubmenu2 === void 0 ? void 0 : NSubmenu2.mergedDisabledRef.value)
        return true;
      if (menuProps2.disabled)
        return true;
      return disabled;
    });
    const dropdownShowRef = ref(false);
    provide(submenuInjectionKey, {
      paddingLeftRef: MenuChild.paddingLeft,
      mergedDisabledRef
    });
    provide(menuItemGroupInjectionKey, null);
    function doClick() {
      const {
        onClick
      } = props;
      if (onClick)
        onClick();
    }
    function handleClick2() {
      if (!mergedDisabledRef.value) {
        if (!mergedCollapsedRef.value) {
          NMenu2.toggleExpand(props.internalKey);
        }
        doClick();
      }
    }
    function handlePopoverShowChange(value) {
      dropdownShowRef.value = value;
    }
    return {
      menuProps: menuProps2,
      mergedTheme: mergedThemeRef,
      doSelect: NMenu2.doSelect,
      inverted: NMenu2.invertedRef,
      isHorizontal: NMenu2.isHorizontalRef,
      mergedClsPrefix: NMenu2.mergedClsPrefixRef,
      maxIconSize: MenuChild.maxIconSize,
      activeIconSize: MenuChild.activeIconSize,
      iconMarginRight: MenuChild.iconMarginRight,
      dropdownPlacement: MenuChild.dropdownPlacement,
      dropdownShow: dropdownShowRef,
      paddingLeft: MenuChild.paddingLeft,
      mergedDisabled: mergedDisabledRef,
      mergedValue: NMenu2.mergedValueRef,
      childActive: useMemo(() => {
        var _a;
        return (_a = props.virtualChildActive) !== null && _a !== void 0 ? _a : NMenu2.activePathRef.value.includes(props.internalKey);
      }),
      collapsed: computed(() => {
        if (menuProps2.mode === "horizontal")
          return false;
        if (mergedCollapsedRef.value) {
          return true;
        }
        return !NMenu2.mergedExpandedKeysRef.value.includes(props.internalKey);
      }),
      dropdownEnabled: computed(() => {
        return !mergedDisabledRef.value && (menuProps2.mode === "horizontal" || mergedCollapsedRef.value);
      }),
      handlePopoverShowChange,
      handleClick: handleClick2
    };
  },
  render() {
    var _a;
    const {
      mergedClsPrefix,
      menuProps: {
        renderIcon,
        renderLabel
      }
    } = this;
    const createSubmenuItem = () => {
      const {
        isHorizontal,
        paddingLeft,
        collapsed,
        mergedDisabled,
        maxIconSize,
        activeIconSize,
        title,
        childActive,
        icon,
        handleClick: handleClick2,
        menuProps: {
          nodeProps
        },
        dropdownShow,
        iconMarginRight,
        tmNode,
        mergedClsPrefix: mergedClsPrefix2,
        isEllipsisPlaceholder,
        extra
      } = this;
      const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(tmNode.rawNode);
      return h("div", Object.assign({}, attrs, {
        class: [`${mergedClsPrefix2}-menu-item`, attrs === null || attrs === void 0 ? void 0 : attrs.class],
        role: "menuitem"
      }), h(NMenuOptionContent, {
        tmNode,
        paddingLeft,
        collapsed,
        disabled: mergedDisabled,
        iconMarginRight,
        maxIconSize,
        activeIconSize,
        title,
        extra,
        showArrow: !isHorizontal,
        childActive,
        clsPrefix: mergedClsPrefix2,
        icon,
        hover: dropdownShow,
        onClick: handleClick2,
        isEllipsisPlaceholder
      }));
    };
    const createSubmenuChildren = () => {
      return h(NFadeInExpandTransition, null, {
        default: () => {
          const {
            tmNodes,
            collapsed
          } = this;
          return !collapsed ? h("div", {
            class: `${mergedClsPrefix}-submenu-children`,
            role: "menu"
          }, tmNodes.map((item) => itemRenderer(item, this.menuProps))) : null;
        }
      });
    };
    return this.root ? h(NDropdown, Object.assign({
      size: "large",
      trigger: "hover"
    }, (_a = this.menuProps) === null || _a === void 0 ? void 0 : _a.dropdownProps, {
      themeOverrides: this.mergedTheme.peerOverrides.Dropdown,
      theme: this.mergedTheme.peers.Dropdown,
      builtinThemeOverrides: {
        fontSizeLarge: "14px",
        optionIconSizeLarge: "18px"
      },
      value: this.mergedValue,
      disabled: !this.dropdownEnabled,
      placement: this.dropdownPlacement,
      keyField: this.menuProps.keyField,
      labelField: this.menuProps.labelField,
      childrenField: this.menuProps.childrenField,
      onUpdateShow: this.handlePopoverShowChange,
      options: this.rawNodes,
      onSelect: this.doSelect,
      inverted: this.inverted,
      renderIcon,
      renderLabel
    }), {
      default: () => h("div", {
        class: `${mergedClsPrefix}-submenu`,
        role: "menu",
        "aria-expanded": !this.collapsed,
        id: this.domId
      }, createSubmenuItem(), this.isHorizontal ? null : createSubmenuChildren())
    }) : h("div", {
      class: `${mergedClsPrefix}-submenu`,
      role: "menu",
      "aria-expanded": !this.collapsed,
      id: this.domId
    }, createSubmenuItem(), createSubmenuChildren());
  }
});
const menuItemProps = Object.assign(Object.assign({}, useMenuChildProps), {
  tmNode: {
    type: Object,
    required: true
  },
  disabled: Boolean,
  icon: Function,
  onClick: Function
});
const NMenuOption = /* @__PURE__ */ defineComponent({
  name: "MenuOption",
  props: menuItemProps,
  setup(props) {
    const MenuChild = useMenuChild(props);
    const {
      NSubmenu: NSubmenu2,
      NMenu: NMenu2
    } = MenuChild;
    const {
      props: menuProps2,
      mergedClsPrefixRef,
      mergedCollapsedRef
    } = NMenu2;
    const submenuDisabledRef = NSubmenu2 ? NSubmenu2.mergedDisabledRef : {
      value: false
    };
    const mergedDisabledRef = computed(() => {
      return submenuDisabledRef.value || props.disabled;
    });
    function doClick(e) {
      const {
        onClick
      } = props;
      if (onClick)
        onClick(e);
    }
    function handleClick2(e) {
      if (!mergedDisabledRef.value) {
        NMenu2.doSelect(props.internalKey, props.tmNode.rawNode);
        doClick(e);
      }
    }
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      dropdownPlacement: MenuChild.dropdownPlacement,
      paddingLeft: MenuChild.paddingLeft,
      iconMarginRight: MenuChild.iconMarginRight,
      maxIconSize: MenuChild.maxIconSize,
      activeIconSize: MenuChild.activeIconSize,
      mergedTheme: NMenu2.mergedThemeRef,
      menuProps: menuProps2,
      dropdownEnabled: useMemo(() => {
        return props.root && mergedCollapsedRef.value && menuProps2.mode !== "horizontal" && !mergedDisabledRef.value;
      }),
      selected: useMemo(() => {
        if (NMenu2.mergedValueRef.value === props.internalKey)
          return true;
        return false;
      }),
      mergedDisabled: mergedDisabledRef,
      handleClick: handleClick2
    };
  },
  render() {
    const {
      mergedClsPrefix,
      mergedTheme,
      tmNode,
      menuProps: {
        renderLabel,
        nodeProps
      }
    } = this;
    const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(tmNode.rawNode);
    return h("div", Object.assign({}, attrs, {
      role: "menuitem",
      class: [`${mergedClsPrefix}-menu-item`, attrs === null || attrs === void 0 ? void 0 : attrs.class]
    }), h(NTooltip, {
      theme: mergedTheme.peers.Tooltip,
      themeOverrides: mergedTheme.peerOverrides.Tooltip,
      trigger: "hover",
      placement: this.dropdownPlacement,
      disabled: !this.dropdownEnabled || this.title === void 0,
      internalExtraClass: ["menu-tooltip"]
    }, {
      default: () => renderLabel ? renderLabel(tmNode.rawNode) : render$1(this.title),
      trigger: () => h(NMenuOptionContent, {
        tmNode,
        clsPrefix: mergedClsPrefix,
        paddingLeft: this.paddingLeft,
        iconMarginRight: this.iconMarginRight,
        maxIconSize: this.maxIconSize,
        activeIconSize: this.activeIconSize,
        selected: this.selected,
        title: this.title,
        extra: this.extra,
        disabled: this.mergedDisabled,
        icon: this.icon,
        onClick: this.handleClick
      })
    }));
  }
});
const NMenuDivider = /* @__PURE__ */ defineComponent({
  name: "MenuDivider",
  setup() {
    const NMenu2 = inject(menuInjectionKey);
    const {
      mergedClsPrefixRef,
      isHorizontalRef
    } = NMenu2;
    return () => isHorizontalRef.value ? null : h("div", {
      class: `${mergedClsPrefixRef.value}-menu-divider`
    });
  }
});
const groupPropKeys = keysOf(menuItemGroupProps);
const itemPropKeys = keysOf(menuItemProps);
const submenuPropKeys = keysOf(submenuProps);
function isIgnoredNode(rawNode) {
  return rawNode.type === "divider" || rawNode.type === "render";
}
function isDividerNode(rawNode) {
  return rawNode.type === "divider";
}
function itemRenderer(tmNode, menuProps2) {
  const {
    rawNode
  } = tmNode;
  const {
    show
  } = rawNode;
  if (show === false) {
    return null;
  }
  if (isIgnoredNode(rawNode)) {
    if (isDividerNode(rawNode)) {
      return h(NMenuDivider, Object.assign({
        key: tmNode.key
      }, rawNode.props));
    }
    return null;
  }
  const {
    labelField
  } = menuProps2;
  const {
    key,
    level,
    isGroup: isGroup2
  } = tmNode;
  const props = Object.assign(Object.assign({}, rawNode), {
    title: rawNode.title || rawNode[labelField],
    extra: rawNode.titleExtra || rawNode.extra,
    key,
    internalKey: key,
    // since key can't be used as a prop
    level,
    root: level === 0,
    isGroup: isGroup2
  });
  if (tmNode.children) {
    if (tmNode.isGroup) {
      return h(NMenuOptionGroup, keep(props, groupPropKeys, {
        tmNode,
        tmNodes: tmNode.children,
        key
      }));
    }
    return h(NSubmenu, keep(props, submenuPropKeys, {
      key,
      rawNodes: rawNode[menuProps2.childrenField],
      tmNodes: tmNode.children,
      tmNode
    }));
  } else {
    return h(NMenuOption, keep(props, itemPropKeys, {
      key,
      tmNode
    }));
  }
}
const hoverStyleChildren = [c$1("&::before", "background-color: var(--n-item-color-hover);"), cE("arrow", `
 color: var(--n-arrow-color-hover);
 `), cE("icon", `
 color: var(--n-item-icon-color-hover);
 `), cB("menu-item-content-header", `
 color: var(--n-item-text-color-hover);
 `, [c$1("a", `
 color: var(--n-item-text-color-hover);
 `), cE("extra", `
 color: var(--n-item-text-color-hover);
 `)])];
const horizontalHoverStyleChildren = [cE("icon", `
 color: var(--n-item-icon-color-hover-horizontal);
 `), cB("menu-item-content-header", `
 color: var(--n-item-text-color-hover-horizontal);
 `, [c$1("a", `
 color: var(--n-item-text-color-hover-horizontal);
 `), cE("extra", `
 color: var(--n-item-text-color-hover-horizontal);
 `)])];
const style$2 = c$1([cB("menu", `
 background-color: var(--n-color);
 color: var(--n-item-text-color);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 box-sizing: border-box;
 font-size: var(--n-font-size);
 padding-bottom: 6px;
 `, [cM("horizontal", `
 max-width: 100%;
 width: 100%;
 display: flex;
 overflow: hidden;
 padding-bottom: 0;
 `, [cB("submenu", "margin: 0;"), cB("menu-item", "margin: 0;"), cB("menu-item-content", `
 padding: 0 20px;
 border-bottom: 2px solid #0000;
 `, [c$1("&::before", "display: none;"), cM("selected", "border-bottom: 2px solid var(--n-border-color-horizontal)")]), cB("menu-item-content", [cM("selected", [cE("icon", "color: var(--n-item-icon-color-active-horizontal);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active-horizontal);
 `, [c$1("a", "color: var(--n-item-text-color-active-horizontal);"), cE("extra", "color: var(--n-item-text-color-active-horizontal);")])]), cM("child-active", `
 border-bottom: 2px solid var(--n-border-color-horizontal);
 `, [cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active-horizontal);
 `, [c$1("a", `
 color: var(--n-item-text-color-child-active-horizontal);
 `), cE("extra", `
 color: var(--n-item-text-color-child-active-horizontal);
 `)]), cE("icon", `
 color: var(--n-item-icon-color-child-active-horizontal);
 `)]), cNotM("disabled", [cNotM("selected, child-active", [c$1("&:focus-within", horizontalHoverStyleChildren)]), cM("selected", [hoverStyle(null, [cE("icon", "color: var(--n-item-icon-color-active-hover-horizontal);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active-hover-horizontal);
 `, [c$1("a", "color: var(--n-item-text-color-active-hover-horizontal);"), cE("extra", "color: var(--n-item-text-color-active-hover-horizontal);")])])]), cM("child-active", [hoverStyle(null, [cE("icon", "color: var(--n-item-icon-color-child-active-hover-horizontal);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active-hover-horizontal);
 `, [c$1("a", "color: var(--n-item-text-color-child-active-hover-horizontal);"), cE("extra", "color: var(--n-item-text-color-child-active-hover-horizontal);")])])]), hoverStyle("border-bottom: 2px solid var(--n-border-color-horizontal);", horizontalHoverStyleChildren)]), cB("menu-item-content-header", [c$1("a", "color: var(--n-item-text-color-horizontal);")])])]), cNotM("responsive", [cB("menu-item-content-header", `
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), cM("collapsed", [cB("menu-item-content", [cM("selected", [c$1("&::before", `
 background-color: var(--n-item-color-active-collapsed) !important;
 `)]), cB("menu-item-content-header", "opacity: 0;"), cE("arrow", "opacity: 0;"), cE("icon", "color: var(--n-item-icon-color-collapsed);")])]), cB("menu-item", `
 height: var(--n-item-height);
 margin-top: 6px;
 position: relative;
 `), cB("menu-item-content", `
 box-sizing: border-box;
 line-height: 1.75;
 height: 100%;
 display: grid;
 grid-template-areas: "icon content arrow";
 grid-template-columns: auto 1fr auto;
 align-items: center;
 cursor: pointer;
 position: relative;
 padding-right: 18px;
 transition:
 background-color .3s var(--n-bezier),
 padding-left .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [c$1("> *", "z-index: 1;"), c$1("&::before", `
 z-index: auto;
 content: "";
 background-color: #0000;
 position: absolute;
 left: 8px;
 right: 8px;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), cM("disabled", `
 opacity: .45;
 cursor: not-allowed;
 `), cM("collapsed", [cE("arrow", "transform: rotate(0);")]), cM("selected", [c$1("&::before", "background-color: var(--n-item-color-active);"), cE("arrow", "color: var(--n-arrow-color-active);"), cE("icon", "color: var(--n-item-icon-color-active);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active);
 `, [c$1("a", "color: var(--n-item-text-color-active);"), cE("extra", "color: var(--n-item-text-color-active);")])]), cM("child-active", [cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active);
 `, [c$1("a", `
 color: var(--n-item-text-color-child-active);
 `), cE("extra", `
 color: var(--n-item-text-color-child-active);
 `)]), cE("arrow", `
 color: var(--n-arrow-color-child-active);
 `), cE("icon", `
 color: var(--n-item-icon-color-child-active);
 `)]), cNotM("disabled", [cNotM("selected, child-active", [c$1("&:focus-within", hoverStyleChildren)]), cM("selected", [hoverStyle(null, [cE("arrow", "color: var(--n-arrow-color-active-hover);"), cE("icon", "color: var(--n-item-icon-color-active-hover);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active-hover);
 `, [c$1("a", "color: var(--n-item-text-color-active-hover);"), cE("extra", "color: var(--n-item-text-color-active-hover);")])])]), cM("child-active", [hoverStyle(null, [cE("arrow", "color: var(--n-arrow-color-child-active-hover);"), cE("icon", "color: var(--n-item-icon-color-child-active-hover);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active-hover);
 `, [c$1("a", "color: var(--n-item-text-color-child-active-hover);"), cE("extra", "color: var(--n-item-text-color-child-active-hover);")])])]), cM("selected", [hoverStyle(null, [c$1("&::before", "background-color: var(--n-item-color-active-hover);")])]), hoverStyle(null, hoverStyleChildren)]), cE("icon", `
 grid-area: icon;
 color: var(--n-item-icon-color);
 transition:
 color .3s var(--n-bezier),
 font-size .3s var(--n-bezier),
 margin-right .3s var(--n-bezier);
 box-sizing: content-box;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 `), cE("arrow", `
 grid-area: arrow;
 font-size: 16px;
 color: var(--n-arrow-color);
 transform: rotate(180deg);
 opacity: 1;
 transition:
 color .3s var(--n-bezier),
 transform 0.2s var(--n-bezier),
 opacity 0.2s var(--n-bezier);
 `), cB("menu-item-content-header", `
 grid-area: content;
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 opacity: 1;
 white-space: nowrap;
 color: var(--n-item-text-color);
 `, [c$1("a", `
 outline: none;
 text-decoration: none;
 transition: color .3s var(--n-bezier);
 color: var(--n-item-text-color);
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cE("extra", `
 font-size: .93em;
 color: var(--n-group-text-color);
 transition: color .3s var(--n-bezier);
 `)])]), cB("submenu", `
 cursor: pointer;
 position: relative;
 margin-top: 6px;
 `, [cB("menu-item-content", `
 height: var(--n-item-height);
 `), cB("submenu-children", `
 overflow: hidden;
 padding: 0;
 `, [fadeInHeightExpandTransition({
  duration: ".2s"
})])]), cB("menu-item-group", [cB("menu-item-group-title", `
 margin-top: 6px;
 color: var(--n-group-text-color);
 cursor: default;
 font-size: .93em;
 height: 36px;
 display: flex;
 align-items: center;
 transition:
 padding-left .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)])]), cB("menu-tooltip", [c$1("a", `
 color: inherit;
 text-decoration: none;
 `)]), cB("menu-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 6px 18px;
 `)]);
function hoverStyle(props, children) {
  return [cM("hover", props, children), c$1("&:hover", props, children)];
}
const menuProps = Object.assign(Object.assign({}, useTheme.props), {
  options: {
    type: Array,
    default: () => []
  },
  collapsed: {
    type: Boolean,
    default: void 0
  },
  collapsedWidth: {
    type: Number,
    default: 48
  },
  iconSize: {
    type: Number,
    default: 20
  },
  collapsedIconSize: {
    type: Number,
    default: 24
  },
  rootIndent: Number,
  indent: {
    type: Number,
    default: 32
  },
  labelField: {
    type: String,
    default: "label"
  },
  keyField: {
    type: String,
    default: "key"
  },
  childrenField: {
    type: String,
    default: "children"
  },
  disabledField: {
    type: String,
    default: "disabled"
  },
  defaultExpandAll: Boolean,
  defaultExpandedKeys: Array,
  expandedKeys: Array,
  value: [String, Number],
  defaultValue: {
    type: [String, Number],
    default: null
  },
  mode: {
    type: String,
    default: "vertical"
  },
  watchProps: {
    type: Array,
    default: void 0
  },
  disabled: Boolean,
  show: {
    type: Boolean,
    default: true
  },
  inverted: Boolean,
  "onUpdate:expandedKeys": [Function, Array],
  onUpdateExpandedKeys: [Function, Array],
  onUpdateValue: [Function, Array],
  "onUpdate:value": [Function, Array],
  expandIcon: Function,
  renderIcon: Function,
  renderLabel: Function,
  renderExtra: Function,
  dropdownProps: Object,
  accordion: Boolean,
  nodeProps: Function,
  dropdownPlacement: {
    type: String,
    default: "bottom"
  },
  responsive: Boolean,
  // deprecated
  items: Array,
  onOpenNamesChange: [Function, Array],
  onSelect: [Function, Array],
  onExpandedNamesChange: [Function, Array],
  expandedNames: Array,
  defaultExpandedNames: Array
});
const NMenu = /* @__PURE__ */ defineComponent({
  name: "Menu",
  props: menuProps,
  setup(props) {
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Menu", "-menu", style$2, menuLight$1, props, mergedClsPrefixRef);
    const layoutSider = inject(layoutSiderInjectionKey, null);
    const mergedCollapsedRef = computed(() => {
      var _a;
      const {
        collapsed
      } = props;
      if (collapsed !== void 0)
        return collapsed;
      if (layoutSider) {
        const {
          collapseModeRef,
          collapsedRef
        } = layoutSider;
        if (collapseModeRef.value === "width") {
          return (_a = collapsedRef.value) !== null && _a !== void 0 ? _a : false;
        }
      }
      return false;
    });
    const treeMateRef = computed(() => {
      const {
        keyField,
        childrenField,
        disabledField
      } = props;
      return createTreeMate(props.items || props.options, {
        getIgnored(node) {
          return isIgnoredNode(node);
        },
        getChildren(node) {
          return node[childrenField];
        },
        getDisabled(node) {
          return node[disabledField];
        },
        getKey(node) {
          var _a;
          return (_a = node[keyField]) !== null && _a !== void 0 ? _a : node.name;
        }
      });
    });
    const treeKeysLevelOneRef = computed(() => new Set(treeMateRef.value.treeNodes.map((e) => e.key)));
    const {
      watchProps
    } = props;
    const uncontrolledValueRef = ref(null);
    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultValue")) {
      watchEffect(() => {
        uncontrolledValueRef.value = props.defaultValue;
      });
    } else {
      uncontrolledValueRef.value = props.defaultValue;
    }
    const controlledValueRef = toRef(props, "value");
    const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
    const uncontrolledExpandedKeysRef = ref([]);
    const initUncontrolledExpandedKeys = () => {
      uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? treeMateRef.value.getNonLeafKeys() : props.defaultExpandedNames || props.defaultExpandedKeys || treeMateRef.value.getPath(mergedValueRef.value, {
        includeSelf: false
      }).keyPath;
    };
    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultExpandedKeys")) {
      watchEffect(initUncontrolledExpandedKeys);
    } else {
      initUncontrolledExpandedKeys();
    }
    const controlledExpandedKeysRef = useCompitable(props, ["expandedNames", "expandedKeys"]);
    const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);
    const tmNodesRef = computed(() => treeMateRef.value.treeNodes);
    const activePathRef = computed(() => {
      return treeMateRef.value.getPath(mergedValueRef.value).keyPath;
    });
    provide(menuInjectionKey, {
      props,
      mergedCollapsedRef,
      mergedThemeRef: themeRef,
      mergedValueRef,
      mergedExpandedKeysRef,
      activePathRef,
      mergedClsPrefixRef,
      isHorizontalRef: computed(() => props.mode === "horizontal"),
      invertedRef: toRef(props, "inverted"),
      doSelect,
      toggleExpand
    });
    function doSelect(value, item) {
      const {
        "onUpdate:value": _onUpdateValue,
        onUpdateValue,
        onSelect
      } = props;
      if (onUpdateValue) {
        call(onUpdateValue, value, item);
      }
      if (_onUpdateValue) {
        call(_onUpdateValue, value, item);
      }
      if (onSelect) {
        call(onSelect, value, item);
      }
      uncontrolledValueRef.value = value;
    }
    function doUpdateExpandedKeys(value) {
      const {
        "onUpdate:expandedKeys": _onUpdateExpandedKeys,
        onUpdateExpandedKeys,
        onExpandedNamesChange,
        onOpenNamesChange
      } = props;
      if (_onUpdateExpandedKeys) {
        call(_onUpdateExpandedKeys, value);
      }
      if (onUpdateExpandedKeys) {
        call(onUpdateExpandedKeys, value);
      }
      if (onExpandedNamesChange) {
        call(onExpandedNamesChange, value);
      }
      if (onOpenNamesChange) {
        call(onOpenNamesChange, value);
      }
      uncontrolledExpandedKeysRef.value = value;
    }
    function toggleExpand(key) {
      const currentExpandedKeys = Array.from(mergedExpandedKeysRef.value);
      const index = currentExpandedKeys.findIndex((expanededKey) => expanededKey === key);
      if (~index) {
        currentExpandedKeys.splice(index, 1);
      } else {
        if (props.accordion) {
          if (treeKeysLevelOneRef.value.has(key)) {
            const closeKeyIndex = currentExpandedKeys.findIndex((e) => treeKeysLevelOneRef.value.has(e));
            if (closeKeyIndex > -1) {
              currentExpandedKeys.splice(closeKeyIndex, 1);
            }
          }
        }
        currentExpandedKeys.push(key);
      }
      doUpdateExpandedKeys(currentExpandedKeys);
    }
    const showOption = (key) => {
      const selectedKeyPath = treeMateRef.value.getPath(key !== null && key !== void 0 ? key : mergedValueRef.value, {
        includeSelf: false
      }).keyPath;
      if (!selectedKeyPath.length)
        return;
      const currentExpandedKeys = Array.from(mergedExpandedKeysRef.value);
      const nextExpandedKeys = /* @__PURE__ */ new Set([...currentExpandedKeys, ...selectedKeyPath]);
      if (props.accordion) {
        treeKeysLevelOneRef.value.forEach((firstLevelKey) => {
          if (nextExpandedKeys.has(firstLevelKey) && !selectedKeyPath.includes(firstLevelKey)) {
            nextExpandedKeys.delete(firstLevelKey);
          }
        });
      }
      doUpdateExpandedKeys(Array.from(nextExpandedKeys));
    };
    const cssVarsRef = computed(() => {
      const {
        inverted
      } = props;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: self2
      } = themeRef.value;
      const {
        borderRadius,
        borderColorHorizontal,
        fontSize: fontSize2,
        itemHeight,
        dividerColor
      } = self2;
      const vars = {
        "--n-divider-color": dividerColor,
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-font-size": fontSize2,
        "--n-border-color-horizontal": borderColorHorizontal,
        "--n-border-radius": borderRadius,
        "--n-item-height": itemHeight
      };
      if (inverted) {
        vars["--n-group-text-color"] = self2.groupTextColorInverted;
        vars["--n-color"] = self2.colorInverted;
        vars["--n-item-text-color"] = self2.itemTextColorInverted;
        vars["--n-item-text-color-hover"] = self2.itemTextColorHoverInverted;
        vars["--n-item-text-color-active"] = self2.itemTextColorActiveInverted;
        vars["--n-item-text-color-child-active"] = self2.itemTextColorChildActiveInverted;
        vars["--n-item-text-color-child-active-hover"] = self2.itemTextColorChildActiveInverted;
        vars["--n-item-text-color-active-hover"] = self2.itemTextColorActiveHoverInverted;
        vars["--n-item-icon-color"] = self2.itemIconColorInverted;
        vars["--n-item-icon-color-hover"] = self2.itemIconColorHoverInverted;
        vars["--n-item-icon-color-active"] = self2.itemIconColorActiveInverted;
        vars["--n-item-icon-color-active-hover"] = self2.itemIconColorActiveHoverInverted;
        vars["--n-item-icon-color-child-active"] = self2.itemIconColorChildActiveInverted;
        vars["--n-item-icon-color-child-active-hover"] = self2.itemIconColorChildActiveHoverInverted;
        vars["--n-item-icon-color-collapsed"] = self2.itemIconColorCollapsedInverted;
        vars["--n-item-text-color-horizontal"] = self2.itemTextColorHorizontalInverted;
        vars["--n-item-text-color-hover-horizontal"] = self2.itemTextColorHoverHorizontalInverted;
        vars["--n-item-text-color-active-horizontal"] = self2.itemTextColorActiveHorizontalInverted;
        vars["--n-item-text-color-child-active-horizontal"] = self2.itemTextColorChildActiveHorizontalInverted;
        vars["--n-item-text-color-child-active-hover-horizontal"] = self2.itemTextColorChildActiveHoverHorizontalInverted;
        vars["--n-item-text-color-active-hover-horizontal"] = self2.itemTextColorActiveHoverHorizontalInverted;
        vars["--n-item-icon-color-horizontal"] = self2.itemIconColorHorizontalInverted;
        vars["--n-item-icon-color-hover-horizontal"] = self2.itemIconColorHoverHorizontalInverted;
        vars["--n-item-icon-color-active-horizontal"] = self2.itemIconColorActiveHorizontalInverted;
        vars["--n-item-icon-color-active-hover-horizontal"] = self2.itemIconColorActiveHoverHorizontalInverted;
        vars["--n-item-icon-color-child-active-horizontal"] = self2.itemIconColorChildActiveHorizontalInverted;
        vars["--n-item-icon-color-child-active-hover-horizontal"] = self2.itemIconColorChildActiveHoverHorizontalInverted;
        vars["--n-arrow-color"] = self2.arrowColorInverted;
        vars["--n-arrow-color-hover"] = self2.arrowColorHoverInverted;
        vars["--n-arrow-color-active"] = self2.arrowColorActiveInverted;
        vars["--n-arrow-color-active-hover"] = self2.arrowColorActiveHoverInverted;
        vars["--n-arrow-color-child-active"] = self2.arrowColorChildActiveInverted;
        vars["--n-arrow-color-child-active-hover"] = self2.arrowColorChildActiveHoverInverted;
        vars["--n-item-color-hover"] = self2.itemColorHoverInverted;
        vars["--n-item-color-active"] = self2.itemColorActiveInverted;
        vars["--n-item-color-active-hover"] = self2.itemColorActiveHoverInverted;
        vars["--n-item-color-active-collapsed"] = self2.itemColorActiveCollapsedInverted;
      } else {
        vars["--n-group-text-color"] = self2.groupTextColor;
        vars["--n-color"] = self2.color;
        vars["--n-item-text-color"] = self2.itemTextColor;
        vars["--n-item-text-color-hover"] = self2.itemTextColorHover;
        vars["--n-item-text-color-active"] = self2.itemTextColorActive;
        vars["--n-item-text-color-child-active"] = self2.itemTextColorChildActive;
        vars["--n-item-text-color-child-active-hover"] = self2.itemTextColorChildActiveHover;
        vars["--n-item-text-color-active-hover"] = self2.itemTextColorActiveHover;
        vars["--n-item-icon-color"] = self2.itemIconColor;
        vars["--n-item-icon-color-hover"] = self2.itemIconColorHover;
        vars["--n-item-icon-color-active"] = self2.itemIconColorActive;
        vars["--n-item-icon-color-active-hover"] = self2.itemIconColorActiveHover;
        vars["--n-item-icon-color-child-active"] = self2.itemIconColorChildActive;
        vars["--n-item-icon-color-child-active-hover"] = self2.itemIconColorChildActiveHover;
        vars["--n-item-icon-color-collapsed"] = self2.itemIconColorCollapsed;
        vars["--n-item-text-color-horizontal"] = self2.itemTextColorHorizontal;
        vars["--n-item-text-color-hover-horizontal"] = self2.itemTextColorHoverHorizontal;
        vars["--n-item-text-color-active-horizontal"] = self2.itemTextColorActiveHorizontal;
        vars["--n-item-text-color-child-active-horizontal"] = self2.itemTextColorChildActiveHorizontal;
        vars["--n-item-text-color-child-active-hover-horizontal"] = self2.itemTextColorChildActiveHoverHorizontal;
        vars["--n-item-text-color-active-hover-horizontal"] = self2.itemTextColorActiveHoverHorizontal;
        vars["--n-item-icon-color-horizontal"] = self2.itemIconColorHorizontal;
        vars["--n-item-icon-color-hover-horizontal"] = self2.itemIconColorHoverHorizontal;
        vars["--n-item-icon-color-active-horizontal"] = self2.itemIconColorActiveHorizontal;
        vars["--n-item-icon-color-active-hover-horizontal"] = self2.itemIconColorActiveHoverHorizontal;
        vars["--n-item-icon-color-child-active-horizontal"] = self2.itemIconColorChildActiveHorizontal;
        vars["--n-item-icon-color-child-active-hover-horizontal"] = self2.itemIconColorChildActiveHoverHorizontal;
        vars["--n-arrow-color"] = self2.arrowColor;
        vars["--n-arrow-color-hover"] = self2.arrowColorHover;
        vars["--n-arrow-color-active"] = self2.arrowColorActive;
        vars["--n-arrow-color-active-hover"] = self2.arrowColorActiveHover;
        vars["--n-arrow-color-child-active"] = self2.arrowColorChildActive;
        vars["--n-arrow-color-child-active-hover"] = self2.arrowColorChildActiveHover;
        vars["--n-item-color-hover"] = self2.itemColorHover;
        vars["--n-item-color-active"] = self2.itemColorActive;
        vars["--n-item-color-active-hover"] = self2.itemColorActiveHover;
        vars["--n-item-color-active-collapsed"] = self2.itemColorActiveCollapsed;
      }
      return vars;
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("menu", computed(() => props.inverted ? "a" : "b"), cssVarsRef, props) : void 0;
    const ellipsisNodeId = createId();
    const overflowRef = ref(null);
    const counterRef = ref(null);
    let isFirstResize = true;
    const onResize = () => {
      var _a;
      if (isFirstResize) {
        isFirstResize = false;
      } else {
        (_a = overflowRef.value) === null || _a === void 0 ? void 0 : _a.sync({
          showAllItemsBeforeCalculate: true
        });
      }
    };
    function getCounter() {
      return document.getElementById(ellipsisNodeId);
    }
    const ellipsisFromIndexRef = ref(-1);
    function onUpdateCount(count) {
      ellipsisFromIndexRef.value = props.options.length - count;
    }
    function onUpdateOverflow(overflow) {
      if (!overflow) {
        ellipsisFromIndexRef.value = -1;
      }
    }
    const ellipsisOptionRef = computed(() => {
      const ellipsisFromIndex = ellipsisFromIndexRef.value;
      const option = {
        children: ellipsisFromIndex === -1 ? [] : props.options.slice(ellipsisFromIndex)
      };
      return option;
    });
    const ellipsisTreeMateRef = computed(() => {
      const {
        childrenField,
        disabledField,
        keyField
      } = props;
      return createTreeMate([ellipsisOptionRef.value], {
        getIgnored(node) {
          return isIgnoredNode(node);
        },
        getChildren(node) {
          return node[childrenField];
        },
        getDisabled(node) {
          return node[disabledField];
        },
        getKey(node) {
          var _a;
          return (_a = node[keyField]) !== null && _a !== void 0 ? _a : node.name;
        }
      });
    });
    const emptyTmNodeRef = computed(() => {
      return createTreeMate([{}]).treeNodes[0];
    });
    function renderCounter() {
      var _a;
      if (ellipsisFromIndexRef.value === -1) {
        return h(NSubmenu, {
          root: true,
          level: 0,
          key: "__ellpisisGroupPlaceholder__",
          internalKey: "__ellpisisGroupPlaceholder__",
          title: "···",
          tmNode: emptyTmNodeRef.value,
          domId: ellipsisNodeId,
          isEllipsisPlaceholder: true
        });
      }
      const tmNode = ellipsisTreeMateRef.value.treeNodes[0];
      const activePath = activePathRef.value;
      const childActive = !!((_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some((tmNode2) => {
        return activePath.includes(tmNode2.key);
      }));
      return h(NSubmenu, {
        level: 0,
        root: true,
        key: "__ellpisisGroup__",
        internalKey: "__ellpisisGroup__",
        title: "···",
        virtualChildActive: childActive,
        tmNode,
        domId: ellipsisNodeId,
        rawNodes: tmNode.rawNode.children || [],
        tmNodes: tmNode.children || [],
        isEllipsisPlaceholder: true
      });
    }
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      controlledExpandedKeys: controlledExpandedKeysRef,
      uncontrolledExpanededKeys: uncontrolledExpandedKeysRef,
      mergedExpandedKeys: mergedExpandedKeysRef,
      uncontrolledValue: uncontrolledValueRef,
      mergedValue: mergedValueRef,
      activePath: activePathRef,
      tmNodes: tmNodesRef,
      mergedTheme: themeRef,
      mergedCollapsed: mergedCollapsedRef,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      overflowRef,
      counterRef,
      updateCounter: () => {
      },
      onResize,
      onUpdateOverflow,
      onUpdateCount,
      renderCounter,
      getCounter,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
      showOption,
      deriveResponsiveState: onResize
    };
  },
  render() {
    const {
      mergedClsPrefix,
      mode,
      themeClass,
      onRender
    } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    const renderMenuItemNodes = () => this.tmNodes.map((tmNode) => itemRenderer(tmNode, this.$props));
    const horizontal = mode === "horizontal";
    const finalResponsive = horizontal && this.responsive;
    const renderMainNode = () => h("div", {
      role: mode === "horizontal" ? "menubar" : "menu",
      class: [`${mergedClsPrefix}-menu`, themeClass, `${mergedClsPrefix}-menu--${mode}`, finalResponsive && `${mergedClsPrefix}-menu--responsive`, this.mergedCollapsed && `${mergedClsPrefix}-menu--collapsed`],
      style: this.cssVars
    }, finalResponsive ? h(VOverflow, {
      ref: "overflowRef",
      onUpdateOverflow: this.onUpdateOverflow,
      getCounter: this.getCounter,
      onUpdateCount: this.onUpdateCount,
      updateCounter: this.updateCounter,
      style: {
        width: "100%",
        display: "flex",
        overflow: "hidden"
      }
    }, {
      default: renderMenuItemNodes,
      counter: this.renderCounter
    }) : renderMenuItemNodes());
    return finalResponsive ? h(VResizeObserver, {
      onResize: this.onResize
    }, {
      default: renderMainNode
    }) : renderMainNode();
  }
});
const style$1 = c$1([c$1("@keyframes spin-rotate", `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), cB("spin-container", `
 position: relative;
 `, [cB("spin-body", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [fadeInTransition()])]), cB("spin-body", `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), cB("spin", `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [cM("rotate", `
 animation: spin-rotate 2s linear infinite;
 `)]), cB("spin-description", `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), cB("spin-content", `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [cM("spinning", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]);
const STROKE_WIDTH = {
  small: 20,
  medium: 18,
  large: 16
};
const spinProps = Object.assign(Object.assign({}, useTheme.props), {
  contentClass: String,
  contentStyle: [Object, String],
  description: String,
  stroke: String,
  size: {
    type: [String, Number],
    default: "medium"
  },
  show: {
    type: Boolean,
    default: true
  },
  strokeWidth: Number,
  rotate: {
    type: Boolean,
    default: true
  },
  spinning: {
    type: Boolean,
    validator: () => {
      return true;
    },
    default: void 0
  },
  delay: Number
});
const NSpin = /* @__PURE__ */ defineComponent({
  name: "Spin",
  props: spinProps,
  setup(props) {
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Spin", "-spin", style$1, spinLight$1, props, mergedClsPrefixRef);
    const cssVarsRef = computed(() => {
      const {
        size: spinSize
      } = props;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: self2
      } = themeRef.value;
      const {
        opacitySpinning,
        color,
        textColor
      } = self2;
      const size2 = typeof spinSize === "number" ? pxfy(spinSize) : self2[createKey("size", spinSize)];
      return {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-opacity-spinning": opacitySpinning,
        "--n-size": size2,
        "--n-color": color,
        "--n-text-color": textColor
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("spin", computed(() => {
      const {
        size: size2
      } = props;
      return typeof size2 === "number" ? String(size2) : size2[0];
    }), cssVarsRef, props) : void 0;
    const compitableShow = useCompitable(props, ["spinning", "show"]);
    const activeRef = ref(false);
    watchEffect((onCleanup) => {
      let timerId;
      if (compitableShow.value) {
        const {
          delay: delay2
        } = props;
        if (delay2) {
          timerId = window.setTimeout(() => {
            activeRef.value = true;
          }, delay2);
          onCleanup(() => {
            clearTimeout(timerId);
          });
          return;
        }
      }
      activeRef.value = compitableShow.value;
    });
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      active: activeRef,
      mergedStrokeWidth: computed(() => {
        const {
          strokeWidth
        } = props;
        if (strokeWidth !== void 0)
          return strokeWidth;
        const {
          size: size2
        } = props;
        return STROKE_WIDTH[typeof size2 === "number" ? "medium" : size2];
      }),
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    var _a, _b;
    const {
      $slots,
      mergedClsPrefix,
      description
    } = this;
    const rotate = $slots.icon && this.rotate;
    const descriptionNode = (description || $slots.description) && h("div", {
      class: `${mergedClsPrefix}-spin-description`
    }, description || ((_a = $slots.description) === null || _a === void 0 ? void 0 : _a.call($slots)));
    const icon = $slots.icon ? h("div", {
      class: [`${mergedClsPrefix}-spin-body`, this.themeClass]
    }, h("div", {
      class: [`${mergedClsPrefix}-spin`, rotate && `${mergedClsPrefix}-spin--rotate`],
      style: $slots.default ? "" : this.cssVars
    }, $slots.icon()), descriptionNode) : h("div", {
      class: [`${mergedClsPrefix}-spin-body`, this.themeClass]
    }, h(NBaseLoading, {
      clsPrefix: mergedClsPrefix,
      style: $slots.default ? "" : this.cssVars,
      stroke: this.stroke,
      "stroke-width": this.mergedStrokeWidth,
      class: `${mergedClsPrefix}-spin`
    }), descriptionNode);
    (_b = this.onRender) === null || _b === void 0 ? void 0 : _b.call(this);
    return $slots.default ? h("div", {
      class: [`${mergedClsPrefix}-spin-container`, this.themeClass],
      style: this.cssVars
    }, h("div", {
      class: [`${mergedClsPrefix}-spin-content`, this.active && `${mergedClsPrefix}-spin-content--spinning`, this.contentClass],
      style: this.contentStyle
    }, $slots), h(Transition, {
      name: "fade-in-transition"
    }, {
      default: () => this.active ? icon : null
    })) : icon;
  }
});
const tabsInjectionKey = createInjectionKey("n-tabs");
const tabPaneProps = {
  tab: [String, Number, Object, Function],
  name: {
    type: [String, Number],
    required: true
  },
  disabled: Boolean,
  displayDirective: {
    type: String,
    default: "if"
  },
  closable: {
    type: Boolean,
    default: void 0
  },
  tabProps: Object,
  /** @deprecated */
  label: [String, Number, Object, Function]
};
const NTabPane = /* @__PURE__ */ defineComponent({
  __TAB_PANE__: true,
  name: "TabPane",
  alias: ["TabPanel"],
  props: tabPaneProps,
  setup(props) {
    const NTab = inject(tabsInjectionKey, null);
    if (!NTab) {
      throwError("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`.");
    }
    return {
      style: NTab.paneStyleRef,
      class: NTab.paneClassRef,
      mergedClsPrefix: NTab.mergedClsPrefixRef
    };
  },
  render() {
    return h("div", {
      class: [`${this.mergedClsPrefix}-tab-pane`, this.class],
      style: this.style
    }, this.$slots);
  }
});
const tabProps = Object.assign({
  internalLeftPadded: Boolean,
  internalAddable: Boolean,
  internalCreatedByPane: Boolean
}, omit(tabPaneProps, ["displayDirective"]));
const Tab = /* @__PURE__ */ defineComponent({
  __TAB__: true,
  inheritAttrs: false,
  name: "Tab",
  props: tabProps,
  setup(props) {
    const {
      mergedClsPrefixRef,
      valueRef,
      typeRef,
      closableRef,
      tabStyleRef,
      addTabStyleRef,
      tabClassRef,
      addTabClassRef,
      tabChangeIdRef,
      onBeforeLeaveRef,
      triggerRef,
      handleAdd,
      activateTab,
      handleClose
    } = inject(tabsInjectionKey);
    return {
      trigger: triggerRef,
      mergedClosable: computed(() => {
        if (props.internalAddable)
          return false;
        const {
          closable
        } = props;
        if (closable === void 0)
          return closableRef.value;
        return closable;
      }),
      style: tabStyleRef,
      addStyle: addTabStyleRef,
      tabClass: tabClassRef,
      addTabClass: addTabClassRef,
      clsPrefix: mergedClsPrefixRef,
      value: valueRef,
      type: typeRef,
      handleClose(e) {
        e.stopPropagation();
        if (props.disabled)
          return;
        handleClose(props.name);
      },
      activateTab() {
        if (props.disabled)
          return;
        if (props.internalAddable) {
          handleAdd();
          return;
        }
        const {
          name: nameProp
        } = props;
        const id = ++tabChangeIdRef.id;
        if (nameProp !== valueRef.value) {
          const {
            value: onBeforeLeave
          } = onBeforeLeaveRef;
          if (!onBeforeLeave) {
            activateTab(nameProp);
          } else {
            void Promise.resolve(onBeforeLeave(props.name, valueRef.value)).then((allowLeave) => {
              if (allowLeave && tabChangeIdRef.id === id) {
                activateTab(nameProp);
              }
            });
          }
        }
      }
    };
  },
  render() {
    const {
      internalAddable,
      clsPrefix,
      name,
      disabled,
      label,
      tab,
      value,
      mergedClosable,
      trigger: trigger2,
      $slots: {
        default: defaultSlot
      }
    } = this;
    const mergedTab = label !== null && label !== void 0 ? label : tab;
    return h("div", {
      class: `${clsPrefix}-tabs-tab-wrapper`
    }, this.internalLeftPadded ? h("div", {
      class: `${clsPrefix}-tabs-tab-pad`
    }) : null, h("div", Object.assign({
      key: name,
      "data-name": name,
      "data-disabled": disabled ? true : void 0
    }, mergeProps({
      class: [`${clsPrefix}-tabs-tab`, value === name && `${clsPrefix}-tabs-tab--active`, disabled && `${clsPrefix}-tabs-tab--disabled`, mergedClosable && `${clsPrefix}-tabs-tab--closable`, internalAddable && `${clsPrefix}-tabs-tab--addable`, internalAddable ? this.addTabClass : this.tabClass],
      onClick: trigger2 === "click" ? this.activateTab : void 0,
      onMouseenter: trigger2 === "hover" ? this.activateTab : void 0,
      style: internalAddable ? this.addStyle : this.style
    }, this.internalCreatedByPane ? this.tabProps || {} : this.$attrs)), h("span", {
      class: `${clsPrefix}-tabs-tab__label`
    }, internalAddable ? h(Fragment, null, h("div", {
      class: `${clsPrefix}-tabs-tab__height-placeholder`
    }, " "), h(NBaseIcon, {
      clsPrefix
    }, {
      default: () => h(AddIcon, null)
    })) : defaultSlot ? defaultSlot() : typeof mergedTab === "object" ? mergedTab : render$1(mergedTab !== null && mergedTab !== void 0 ? mergedTab : name)), mergedClosable && this.type === "card" ? h(NBaseClose, {
      clsPrefix,
      class: `${clsPrefix}-tabs-tab__close`,
      onClick: this.handleClose,
      disabled
    }) : null));
  }
});
const style = cB("tabs", `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [cM("segment-type", [cB("tabs-rail", [c$1("&.transition-disabled", [cB("tabs-capsule", `
 transition: none;
 `)])])]), cM("top", [cB("tab-pane", `
 padding: var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left);
 `)]), cM("left", [cB("tab-pane", `
 padding: var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left) var(--n-pane-padding-top);
 `)]), cM("left, right", `
 flex-direction: row;
 `, [cB("tabs-bar", `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("tabs-tab", `
 padding: var(--n-tab-padding-vertical); 
 `)]), cM("right", `
 flex-direction: row-reverse;
 `, [cB("tab-pane", `
 padding: var(--n-pane-padding-left) var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom);
 `), cB("tabs-bar", `
 left: 0;
 `)]), cM("bottom", `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [cB("tab-pane", `
 padding: var(--n-pane-padding-bottom) var(--n-pane-padding-right) var(--n-pane-padding-top) var(--n-pane-padding-left);
 `), cB("tabs-bar", `
 top: 0;
 `)]), cB("tabs-rail", `
 position: relative;
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [cB("tabs-capsule", `
 border-radius: var(--n-tab-border-radius);
 position: absolute;
 pointer-events: none;
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 transition: transform 0.3s var(--n-bezier);
 `), cB("tabs-tab-wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cB("tabs-tab", `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cM("active", `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 `), c$1("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])])]), cM("flex", [cB("tabs-nav", `
 width: 100%;
 position: relative;
 `, [cB("tabs-wrapper", `
 width: 100%;
 `, [cB("tabs-tab", `
 margin-right: 0;
 `)])])]), cB("tabs-nav", `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [cE("prefix, suffix", `
 display: flex;
 align-items: center;
 `), cE("prefix", "padding-right: 16px;"), cE("suffix", "padding-left: 16px;")]), cM("top, bottom", [cB("tabs-nav-scroll-wrapper", [c$1("&::before", `
 top: 0;
 bottom: 0;
 left: 0;
 width: 20px;
 `), c$1("&::after", `
 top: 0;
 bottom: 0;
 right: 0;
 width: 20px;
 `), cM("shadow-start", [c$1("&::before", `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), cM("shadow-end", [c$1("&::after", `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)])])]), cM("left, right", [cB("tabs-nav-scroll-content", `
 flex-direction: column;
 `), cB("tabs-nav-scroll-wrapper", [c$1("&::before", `
 top: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), c$1("&::after", `
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), cM("shadow-start", [c$1("&::before", `
 box-shadow: inset 0 10px 8px -8px rgba(0, 0, 0, .12);
 `)]), cM("shadow-end", [c$1("&::after", `
 box-shadow: inset 0 -10px 8px -8px rgba(0, 0, 0, .12);
 `)])])]), cB("tabs-nav-scroll-wrapper", `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [cB("tabs-nav-y-scroll", `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar", `
 width: 0;
 height: 0;
 `)]), c$1("&::before, &::after", `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 z-index: 1;
 `)]), cB("tabs-nav-scroll-content", `
 display: flex;
 position: relative;
 min-width: 100%;
 min-height: 100%;
 width: fit-content;
 box-sizing: border-box;
 `), cB("tabs-wrapper", `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), cB("tabs-tab-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), cB("tabs-tab", `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("disabled", {
  cursor: "not-allowed"
}), cE("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cE("label", `
 display: flex;
 align-items: center;
 z-index: 1;
 `)]), cB("tabs-bar", `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1("&.transition-disabled", `
 transition: none;
 `), cM("disabled", `
 background-color: var(--n-tab-text-color-disabled)
 `)]), cB("tabs-pane-wrapper", `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), cB("tab-pane", `
 color: var(--n-pane-text-color);
 width: 100%;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [c$1("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), c$1("&.next-transition-leave-active, &.prev-transition-leave-active", `
 position: absolute;
 `), c$1("&.next-transition-enter-from, &.prev-transition-leave-to", `
 transform: translateX(32px);
 opacity: 0;
 `), c$1("&.next-transition-leave-to, &.prev-transition-enter-from", `
 transform: translateX(-32px);
 opacity: 0;
 `), c$1("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
 transform: translateX(0);
 opacity: 1;
 `)]), cB("tabs-tab-pad", `
 box-sizing: border-box;
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), cM("line-type, bar-type", [cB("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [c$1("&:hover", {
  color: "var(--n-tab-text-color-hover)"
}), cM("active", `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), cM("disabled", {
  color: "var(--n-tab-text-color-disabled)"
})])]), cB("tabs-nav", [cM("line-type", [cM("top", [cE("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 bottom: -1px;
 `)]), cM("left", [cE("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 right: -1px;
 `)]), cM("right", [cE("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 left: -1px;
 `)]), cM("bottom", [cE("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 top: -1px;
 `)]), cE("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-nav-scroll-content", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-bar", `
 border-radius: 0;
 `)]), cM("card-type", [cE("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-tab-pad", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [cM("addable", `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 `, [cE("height-placeholder", `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), cNotM("disabled", [c$1("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])]), cM("closable", "padding-right: 8px;"), cM("active", `
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), cM("disabled", "color: var(--n-tab-text-color-disabled);")]), cB("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);")]), cM("left, right", [cB("tabs-wrapper", `
 flex-direction: column;
 `, [cB("tabs-tab-wrapper", `
 flex-direction: column;
 `, [cB("tabs-tab-pad", `
 height: var(--n-tab-gap-vertical);
 width: 100%;
 `)])])]), cM("top", [cM("card-type", [cB("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-bottom: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `)])]), cM("left", [cM("card-type", [cB("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-bottom-left-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-right: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `)])]), cM("right", [cM("card-type", [cB("tabs-tab", `
 border-top-right-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-left: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `)])]), cM("bottom", [cM("card-type", [cB("tabs-tab", `
 border-bottom-left-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-top: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `)])])])]);
const tabsProps = Object.assign(Object.assign({}, useTheme.props), {
  value: [String, Number],
  defaultValue: [String, Number],
  trigger: {
    type: String,
    default: "click"
  },
  type: {
    type: String,
    default: "bar"
  },
  closable: Boolean,
  justifyContent: String,
  size: {
    type: String,
    default: "medium"
  },
  placement: {
    type: String,
    default: "top"
  },
  tabStyle: [String, Object],
  tabClass: String,
  addTabStyle: [String, Object],
  addTabClass: String,
  barWidth: Number,
  paneClass: String,
  paneStyle: [String, Object],
  paneWrapperClass: String,
  paneWrapperStyle: [String, Object],
  addable: [Boolean, Object],
  tabsPadding: {
    type: Number,
    default: 0
  },
  animated: Boolean,
  onBeforeLeave: Function,
  onAdd: Function,
  "onUpdate:value": [Function, Array],
  onUpdateValue: [Function, Array],
  onClose: [Function, Array],
  // deprecated
  labelSize: String,
  activeName: [String, Number],
  onActiveNameChange: [Function, Array]
});
const NTabs = /* @__PURE__ */ defineComponent({
  name: "Tabs",
  props: tabsProps,
  setup(props, {
    slots
  }) {
    var _a, _b, _c, _d;
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Tabs", "-tabs", style, tabsLight$1, props, mergedClsPrefixRef);
    const tabsElRef = ref(null);
    const barElRef = ref(null);
    const scrollWrapperElRef = ref(null);
    const addTabInstRef = ref(null);
    const xScrollInstRef = ref(null);
    const yScrollElRef = ref(null);
    const startReachedRef = ref(true);
    const endReachedRef = ref(true);
    const compitableSizeRef = useCompitable(props, ["labelSize", "size"]);
    const compitableValueRef = useCompitable(props, ["activeName", "value"]);
    const uncontrolledValueRef = ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : slots.default ? (_d = (_c = flatten$2(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name : null);
    const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);
    const tabChangeIdRef = {
      id: 0
    };
    const tabWrapperStyleRef = computed(() => {
      if (!props.justifyContent || props.type === "card")
        return void 0;
      return {
        display: "flex",
        justifyContent: props.justifyContent
      };
    });
    watch(mergedValueRef, () => {
      tabChangeIdRef.id = 0;
      updateCurrentBarStyle();
      updateCurrentScrollPosition();
    });
    function getCurrentEl() {
      var _a2;
      const {
        value
      } = mergedValueRef;
      if (value === null)
        return null;
      const tabEl = (_a2 = tabsElRef.value) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`[data-name="${value}"]`);
      return tabEl;
    }
    function updateBarStyle(tabEl) {
      if (props.type === "card")
        return;
      const {
        value: barEl
      } = barElRef;
      if (!barEl)
        return;
      const barIsHide = barEl.style.opacity === "0";
      if (tabEl) {
        const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;
        const {
          barWidth,
          placement
        } = props;
        if (tabEl.dataset.disabled === "true") {
          barEl.classList.add(disabledClassName);
        } else {
          barEl.classList.remove(disabledClassName);
        }
        if (["top", "bottom"].includes(placement)) {
          clearBarStyle(["top", "maxHeight", "height"]);
          if (typeof barWidth === "number" && tabEl.offsetWidth >= barWidth) {
            const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;
            barEl.style.left = `${offsetDiffLeft}px`;
            barEl.style.maxWidth = `${barWidth}px`;
          } else {
            barEl.style.left = `${tabEl.offsetLeft}px`;
            barEl.style.maxWidth = `${tabEl.offsetWidth}px`;
          }
          barEl.style.width = "8192px";
          if (barIsHide) {
            barEl.style.transition = "none";
          }
          void barEl.offsetWidth;
          if (barIsHide) {
            barEl.style.transition = "";
            barEl.style.opacity = "1";
          }
        } else {
          clearBarStyle(["left", "maxWidth", "width"]);
          if (typeof barWidth === "number" && tabEl.offsetHeight >= barWidth) {
            const offsetDiffTop = Math.floor((tabEl.offsetHeight - barWidth) / 2) + tabEl.offsetTop;
            barEl.style.top = `${offsetDiffTop}px`;
            barEl.style.maxHeight = `${barWidth}px`;
          } else {
            barEl.style.top = `${tabEl.offsetTop}px`;
            barEl.style.maxHeight = `${tabEl.offsetHeight}px`;
          }
          barEl.style.height = "8192px";
          if (barIsHide) {
            barEl.style.transition = "none";
          }
          void barEl.offsetHeight;
          if (barIsHide) {
            barEl.style.transition = "";
            barEl.style.opacity = "1";
          }
        }
      }
    }
    function hideBarStyle() {
      if (props.type === "card")
        return;
      const {
        value: barEl
      } = barElRef;
      if (!barEl)
        return;
      barEl.style.opacity = "0";
    }
    function clearBarStyle(styleProps) {
      const {
        value: barEl
      } = barElRef;
      if (!barEl)
        return;
      for (const prop of styleProps) {
        barEl.style[prop] = "";
      }
    }
    function updateCurrentBarStyle() {
      if (props.type === "card")
        return;
      const tabEl = getCurrentEl();
      if (tabEl) {
        updateBarStyle(tabEl);
      } else {
        hideBarStyle();
      }
    }
    function updateCurrentScrollPosition() {
      var _a2;
      const scrollWrapperEl = (_a2 = xScrollInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el;
      if (!scrollWrapperEl)
        return;
      const tabEl = getCurrentEl();
      if (!tabEl)
        return;
      const {
        scrollLeft: scrollWrapperElScrollLeft,
        offsetWidth: scrollWrapperElOffsetWidth
      } = scrollWrapperEl;
      const {
        offsetLeft: tabElOffsetLeft,
        offsetWidth: tabElOffsetWidth
      } = tabEl;
      if (scrollWrapperElScrollLeft > tabElOffsetLeft) {
        scrollWrapperEl.scrollTo({
          top: 0,
          left: tabElOffsetLeft,
          behavior: "smooth"
        });
      } else if (tabElOffsetLeft + tabElOffsetWidth > scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {
        scrollWrapperEl.scrollTo({
          top: 0,
          left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,
          behavior: "smooth"
        });
      }
    }
    const tabsPaneWrapperRef = ref(null);
    let fromHeight = 0;
    let hangingTransition = null;
    function onAnimationBeforeLeave(el) {
      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
      if (tabsPaneWrapperEl) {
        fromHeight = el.getBoundingClientRect().height;
        const fromHeightPx = `${fromHeight}px`;
        const applyFromStyle = () => {
          tabsPaneWrapperEl.style.height = fromHeightPx;
          tabsPaneWrapperEl.style.maxHeight = fromHeightPx;
        };
        if (!hangingTransition) {
          hangingTransition = applyFromStyle;
        } else {
          applyFromStyle();
          hangingTransition();
          hangingTransition = null;
        }
      }
    }
    function onAnimationEnter(el) {
      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
      if (tabsPaneWrapperEl) {
        const targetHeight = el.getBoundingClientRect().height;
        const applyTargetStyle = () => {
          void document.body.offsetHeight;
          tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;
          tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;
        };
        if (!hangingTransition) {
          hangingTransition = applyTargetStyle;
        } else {
          hangingTransition();
          hangingTransition = null;
          applyTargetStyle();
        }
      }
    }
    function onAnimationAfterEnter() {
      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
      if (tabsPaneWrapperEl) {
        tabsPaneWrapperEl.style.maxHeight = "";
        tabsPaneWrapperEl.style.height = "";
        const {
          paneWrapperStyle
        } = props;
        if (typeof paneWrapperStyle === "string") {
          tabsPaneWrapperEl.style.cssText = paneWrapperStyle;
        } else if (paneWrapperStyle) {
          const {
            maxHeight,
            height
          } = paneWrapperStyle;
          if (maxHeight !== void 0) {
            tabsPaneWrapperEl.style.maxHeight = maxHeight;
          }
          if (height !== void 0) {
            tabsPaneWrapperEl.style.height = height;
          }
        }
      }
    }
    const renderNameListRef = {
      value: []
    };
    const animationDirectionRef = ref("next");
    function activateTab(panelName) {
      const currentValue = mergedValueRef.value;
      let dir = "next";
      for (const name of renderNameListRef.value) {
        if (name === currentValue) {
          break;
        }
        if (name === panelName) {
          dir = "prev";
          break;
        }
      }
      animationDirectionRef.value = dir;
      doUpdateValue(panelName);
    }
    function doUpdateValue(panelName) {
      const {
        onActiveNameChange,
        onUpdateValue,
        "onUpdate:value": _onUpdateValue
      } = props;
      if (onActiveNameChange) {
        call(onActiveNameChange, panelName);
      }
      if (onUpdateValue)
        call(onUpdateValue, panelName);
      if (_onUpdateValue)
        call(_onUpdateValue, panelName);
      uncontrolledValueRef.value = panelName;
    }
    function handleClose(panelName) {
      const {
        onClose
      } = props;
      if (onClose)
        call(onClose, panelName);
    }
    function updateBarPositionInstantly() {
      const {
        value: barEl
      } = barElRef;
      if (!barEl)
        return;
      const disableTransitionClassName = "transition-disabled";
      barEl.classList.add(disableTransitionClassName);
      updateCurrentBarStyle();
      barEl.classList.remove(disableTransitionClassName);
    }
    const segmentCapsuleElRef = ref(null);
    function updateSegmentPosition({
      transitionDisabled
    }) {
      const tabsEl = tabsElRef.value;
      if (!tabsEl)
        return;
      if (transitionDisabled)
        tabsEl.classList.add("transition-disabled");
      const activeTabEl = getCurrentEl();
      if (activeTabEl && segmentCapsuleElRef.value) {
        segmentCapsuleElRef.value.style.width = `${activeTabEl.offsetWidth}px`;
        segmentCapsuleElRef.value.style.height = `${activeTabEl.offsetHeight}px`;
        segmentCapsuleElRef.value.style.transform = `translateX(${activeTabEl.offsetLeft - depx(getComputedStyle(tabsEl).paddingLeft)}px)`;
        if (transitionDisabled) {
          void segmentCapsuleElRef.value.offsetWidth;
        }
      }
      if (transitionDisabled) {
        tabsEl.classList.remove("transition-disabled");
      }
    }
    watch([mergedValueRef], () => {
      if (props.type === "segment") {
        void nextTick(() => {
          updateSegmentPosition({
            transitionDisabled: false
          });
        });
      }
    });
    onMounted(() => {
      if (props.type === "segment") {
        updateSegmentPosition({
          transitionDisabled: true
        });
      }
    });
    let memorizedWidth = 0;
    function _handleNavResize(entry) {
      var _b2;
      if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {
        return;
      }
      if (memorizedWidth === entry.contentRect.width) {
        return;
      }
      memorizedWidth = entry.contentRect.width;
      const {
        type: type4
      } = props;
      if (type4 === "line" || type4 === "bar") {
        {
          updateBarPositionInstantly();
        }
      }
      if (type4 !== "segment") {
        const {
          placement
        } = props;
        deriveScrollShadow((placement === "top" || placement === "bottom" ? (_b2 = xScrollInstRef.value) === null || _b2 === void 0 ? void 0 : _b2.$el : yScrollElRef.value) || null);
      }
    }
    const handleNavResize = throttle(_handleNavResize, 64);
    watch([() => props.justifyContent, () => props.size], () => {
      void nextTick(() => {
        const {
          type: type4
        } = props;
        if (type4 === "line" || type4 === "bar") {
          updateBarPositionInstantly();
        }
      });
    });
    const addTabFixedRef = ref(false);
    function _handleTabsResize(entry) {
      var _a2;
      const {
        target,
        contentRect: {
          width
        }
      } = entry;
      const containerWidth = target.parentElement.offsetWidth;
      if (!addTabFixedRef.value) {
        if (containerWidth < width) {
          addTabFixedRef.value = true;
        }
      } else {
        const {
          value: addTabInst
        } = addTabInstRef;
        if (!addTabInst)
          return;
        if (containerWidth - width > addTabInst.$el.offsetWidth) {
          addTabFixedRef.value = false;
        }
      }
      deriveScrollShadow(((_a2 = xScrollInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el) || null);
    }
    const handleTabsResize = throttle(_handleTabsResize, 64);
    function handleAdd() {
      const {
        onAdd
      } = props;
      if (onAdd)
        onAdd();
      void nextTick(() => {
        const currentEl = getCurrentEl();
        const {
          value: xScrollInst
        } = xScrollInstRef;
        if (!currentEl || !xScrollInst)
          return;
        xScrollInst.scrollTo({
          left: currentEl.offsetLeft,
          top: 0,
          behavior: "smooth"
        });
      });
    }
    function deriveScrollShadow(el) {
      if (!el)
        return;
      const {
        placement
      } = props;
      if (placement === "top" || placement === "bottom") {
        const {
          scrollLeft,
          scrollWidth,
          offsetWidth
        } = el;
        startReachedRef.value = scrollLeft <= 0;
        endReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;
      } else {
        const {
          scrollTop,
          scrollHeight,
          offsetHeight
        } = el;
        startReachedRef.value = scrollTop <= 0;
        endReachedRef.value = scrollTop + offsetHeight >= scrollHeight;
      }
    }
    const handleScroll = throttle((e) => {
      deriveScrollShadow(e.target);
    }, 64);
    provide(tabsInjectionKey, {
      triggerRef: toRef(props, "trigger"),
      tabStyleRef: toRef(props, "tabStyle"),
      tabClassRef: toRef(props, "tabClass"),
      addTabStyleRef: toRef(props, "addTabStyle"),
      addTabClassRef: toRef(props, "addTabClass"),
      paneClassRef: toRef(props, "paneClass"),
      paneStyleRef: toRef(props, "paneStyle"),
      mergedClsPrefixRef,
      typeRef: toRef(props, "type"),
      closableRef: toRef(props, "closable"),
      valueRef: mergedValueRef,
      tabChangeIdRef,
      onBeforeLeaveRef: toRef(props, "onBeforeLeave"),
      activateTab,
      handleClose,
      handleAdd
    });
    onFontsReady(() => {
      updateCurrentBarStyle();
      updateCurrentScrollPosition();
    });
    watchEffect(() => {
      const {
        value: el
      } = scrollWrapperElRef;
      if (!el)
        return;
      const {
        value: clsPrefix
      } = mergedClsPrefixRef;
      const shadowStartClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-start`;
      const shadowEndClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-end`;
      if (startReachedRef.value) {
        el.classList.remove(shadowStartClass);
      } else {
        el.classList.add(shadowStartClass);
      }
      if (endReachedRef.value) {
        el.classList.remove(shadowEndClass);
      } else {
        el.classList.add(shadowEndClass);
      }
    });
    const exposedMethods = {
      syncBarPosition: () => {
        updateCurrentBarStyle();
      }
    };
    const handleSegmentResize = () => {
      updateSegmentPosition({
        transitionDisabled: true
      });
    };
    const cssVarsRef = computed(() => {
      const {
        value: size2
      } = compitableSizeRef;
      const {
        type: type4
      } = props;
      const typeSuffix = {
        card: "Card",
        bar: "Bar",
        line: "Line",
        segment: "Segment"
      }[type4];
      const sizeType = `${size2}${typeSuffix}`;
      const {
        self: {
          barColor,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          tabColor,
          tabBorderColor,
          paneTextColor,
          tabFontWeight,
          tabBorderRadius,
          tabFontWeightActive,
          colorSegment,
          fontWeightStrong,
          tabColorSegment,
          closeSize,
          closeIconSize,
          closeColorHover,
          closeColorPressed,
          closeBorderRadius,
          [createKey("panePadding", size2)]: panePadding,
          [createKey("tabPadding", sizeType)]: tabPadding,
          [createKey("tabPaddingVertical", sizeType)]: tabPaddingVertical,
          [createKey("tabGap", sizeType)]: tabGap,
          [createKey("tabGap", `${sizeType}Vertical`)]: tabGapVertical,
          [createKey("tabTextColor", type4)]: tabTextColor,
          [createKey("tabTextColorActive", type4)]: tabTextColorActive,
          [createKey("tabTextColorHover", type4)]: tabTextColorHover,
          [createKey("tabTextColorDisabled", type4)]: tabTextColorDisabled,
          [createKey("tabFontSize", size2)]: tabFontSize
        },
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        }
      } = themeRef.value;
      return {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-color-segment": colorSegment,
        "--n-bar-color": barColor,
        "--n-tab-font-size": tabFontSize,
        "--n-tab-text-color": tabTextColor,
        "--n-tab-text-color-active": tabTextColorActive,
        "--n-tab-text-color-disabled": tabTextColorDisabled,
        "--n-tab-text-color-hover": tabTextColorHover,
        "--n-pane-text-color": paneTextColor,
        "--n-tab-border-color": tabBorderColor,
        "--n-tab-border-radius": tabBorderRadius,
        "--n-close-size": closeSize,
        "--n-close-icon-size": closeIconSize,
        "--n-close-color-hover": closeColorHover,
        "--n-close-color-pressed": closeColorPressed,
        "--n-close-border-radius": closeBorderRadius,
        "--n-close-icon-color": closeIconColor,
        "--n-close-icon-color-hover": closeIconColorHover,
        "--n-close-icon-color-pressed": closeIconColorPressed,
        "--n-tab-color": tabColor,
        "--n-tab-font-weight": tabFontWeight,
        "--n-tab-font-weight-active": tabFontWeightActive,
        "--n-tab-padding": tabPadding,
        "--n-tab-padding-vertical": tabPaddingVertical,
        "--n-tab-gap": tabGap,
        "--n-tab-gap-vertical": tabGapVertical,
        "--n-pane-padding-left": getMargin(panePadding, "left"),
        "--n-pane-padding-right": getMargin(panePadding, "right"),
        "--n-pane-padding-top": getMargin(panePadding, "top"),
        "--n-pane-padding-bottom": getMargin(panePadding, "bottom"),
        "--n-font-weight-strong": fontWeightStrong,
        "--n-tab-color-segment": tabColorSegment
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("tabs", computed(() => {
      return `${compitableSizeRef.value[0]}${props.type[0]}`;
    }), cssVarsRef, props) : void 0;
    return Object.assign({
      mergedClsPrefix: mergedClsPrefixRef,
      mergedValue: mergedValueRef,
      renderedNames: /* @__PURE__ */ new Set(),
      segmentCapsuleElRef,
      tabsPaneWrapperRef,
      tabsElRef,
      barElRef,
      addTabInstRef,
      xScrollInstRef,
      scrollWrapperElRef,
      addTabFixed: addTabFixedRef,
      tabWrapperStyle: tabWrapperStyleRef,
      handleNavResize,
      mergedSize: compitableSizeRef,
      handleScroll,
      handleTabsResize,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      animationDirection: animationDirectionRef,
      renderNameListRef,
      yScrollElRef,
      handleSegmentResize,
      onAnimationBeforeLeave,
      onAnimationEnter,
      onAnimationAfterEnter,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    }, exposedMethods);
  },
  render() {
    const {
      mergedClsPrefix,
      type: type4,
      placement,
      addTabFixed,
      addable,
      mergedSize,
      renderNameListRef,
      onRender,
      paneWrapperClass,
      paneWrapperStyle,
      $slots: {
        default: defaultSlot,
        prefix: prefixSlot,
        suffix: suffixSlot
      }
    } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    const tabPaneChildren = defaultSlot ? flatten$2(defaultSlot()).filter((v) => {
      return v.type.__TAB_PANE__ === true;
    }) : [];
    const tabChildren = defaultSlot ? flatten$2(defaultSlot()).filter((v) => {
      return v.type.__TAB__ === true;
    }) : [];
    const showPane = !tabChildren.length;
    const isCard = type4 === "card";
    const isSegment = type4 === "segment";
    const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;
    renderNameListRef.value = [];
    const scrollContent = () => {
      const tabs = h("div", {
        style: this.tabWrapperStyle,
        class: [`${mergedClsPrefix}-tabs-wrapper`]
      }, mergedJustifyContent ? null : h("div", {
        class: `${mergedClsPrefix}-tabs-scroll-padding`,
        style: {
          width: `${this.tabsPadding}px`
        }
      }), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {
        renderNameListRef.value.push(tabPaneVNode.props.name);
        return justifyTabDynamicProps(h(Tab, Object.assign({}, tabPaneVNode.props, {
          internalCreatedByPane: true,
          internalLeftPadded: index !== 0 && (!mergedJustifyContent || mergedJustifyContent === "center" || mergedJustifyContent === "start" || mergedJustifyContent === "end")
        }), tabPaneVNode.children ? {
          default: tabPaneVNode.children.tab
        } : void 0));
      }) : tabChildren.map((tabVNode, index) => {
        renderNameListRef.value.push(tabVNode.props.name);
        if (index !== 0 && !mergedJustifyContent) {
          return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));
        } else {
          return justifyTabDynamicProps(tabVNode);
        }
      }), !addTabFixed && addable && isCard ? createAddTag(addable, (showPane ? tabPaneChildren.length : tabChildren.length) !== 0) : null, mergedJustifyContent ? null : h("div", {
        class: `${mergedClsPrefix}-tabs-scroll-padding`,
        style: {
          width: `${this.tabsPadding}px`
        }
      }));
      return h("div", {
        ref: "tabsElRef",
        class: `${mergedClsPrefix}-tabs-nav-scroll-content`
      }, isCard && addable ? h(VResizeObserver, {
        onResize: this.handleTabsResize
      }, {
        default: () => tabs
      }) : tabs, isCard ? h("div", {
        class: `${mergedClsPrefix}-tabs-pad`
      }) : null, isCard ? null : h("div", {
        ref: "barElRef",
        class: `${mergedClsPrefix}-tabs-bar`
      }));
    };
    const resolvedPlacement = isSegment ? "top" : placement;
    return h("div", {
      class: [`${mergedClsPrefix}-tabs`, this.themeClass, `${mergedClsPrefix}-tabs--${type4}-type`, `${mergedClsPrefix}-tabs--${mergedSize}-size`, mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`, `${mergedClsPrefix}-tabs--${resolvedPlacement}`],
      style: this.cssVars
    }, h("div", {
      class: [
        // the class should be applied here since it's possible
        // to make tabs nested in tabs, style may influence each
        // other. adding a class will make it easy to write the
        // style.
        `${mergedClsPrefix}-tabs-nav--${type4}-type`,
        `${mergedClsPrefix}-tabs-nav--${resolvedPlacement}`,
        `${mergedClsPrefix}-tabs-nav`
      ]
    }, resolveWrappedSlot(prefixSlot, (children) => children && h("div", {
      class: `${mergedClsPrefix}-tabs-nav__prefix`
    }, children)), isSegment ? h(VResizeObserver, {
      onResize: this.handleSegmentResize
    }, {
      default: () => h("div", {
        class: `${mergedClsPrefix}-tabs-rail`,
        ref: "tabsElRef"
      }, h("div", {
        class: `${mergedClsPrefix}-tabs-capsule`,
        ref: "segmentCapsuleElRef"
      }, h("div", {
        class: `${mergedClsPrefix}-tabs-wrapper`
      }, h("div", {
        class: `${mergedClsPrefix}-tabs-tab`
      }))), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {
        renderNameListRef.value.push(tabPaneVNode.props.name);
        return h(Tab, Object.assign({}, tabPaneVNode.props, {
          internalCreatedByPane: true,
          internalLeftPadded: index !== 0
        }), tabPaneVNode.children ? {
          default: tabPaneVNode.children.tab
        } : void 0);
      }) : tabChildren.map((tabVNode, index) => {
        renderNameListRef.value.push(tabVNode.props.name);
        if (index === 0) {
          return tabVNode;
        } else {
          return createLeftPaddedTabVNode(tabVNode);
        }
      }))
    }) : h(VResizeObserver, {
      onResize: this.handleNavResize
    }, {
      default: () => h("div", {
        class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`,
        ref: "scrollWrapperElRef"
      }, ["top", "bottom"].includes(resolvedPlacement) ? h(VXScroll, {
        ref: "xScrollInstRef",
        onScroll: this.handleScroll
      }, {
        default: scrollContent
      }) : h("div", {
        class: `${mergedClsPrefix}-tabs-nav-y-scroll`,
        onScroll: this.handleScroll,
        ref: "yScrollElRef"
      }, scrollContent()))
    }), addTabFixed && addable && isCard ? createAddTag(addable, true) : null, resolveWrappedSlot(suffixSlot, (children) => children && h("div", {
      class: `${mergedClsPrefix}-tabs-nav__suffix`
    }, children))), showPane && (this.animated && (resolvedPlacement === "top" || resolvedPlacement === "bottom") ? h("div", {
      ref: "tabsPaneWrapperRef",
      style: paneWrapperStyle,
      class: [`${mergedClsPrefix}-tabs-pane-wrapper`, paneWrapperClass]
    }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames)));
  }
});
function filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {
  const children = [];
  tabPaneVNodes.forEach((vNode) => {
    const {
      name,
      displayDirective,
      "display-directive": _displayDirective
    } = vNode.props;
    const matchDisplayDirective = (directive) => displayDirective === directive || _displayDirective === directive;
    const show = value === name;
    if (vNode.key !== void 0) {
      vNode.key = name;
    }
    if (show || matchDisplayDirective("show") || matchDisplayDirective("show:lazy") && renderedNames.has(name)) {
      if (!renderedNames.has(name)) {
        renderedNames.add(name);
      }
      const useVShow = !matchDisplayDirective("if");
      children.push(useVShow ? withDirectives(vNode, [[vShow, show]]) : vNode);
    }
  });
  if (!animationDirection) {
    return children;
  }
  return h(TransitionGroup, {
    name: `${animationDirection}-transition`,
    onBeforeLeave,
    onEnter,
    onAfterEnter
  }, {
    default: () => children
  });
}
function createAddTag(addable, internalLeftPadded) {
  return h(Tab, {
    ref: "addTabInstRef",
    key: "__addable",
    name: "__addable",
    internalCreatedByPane: true,
    internalAddable: true,
    internalLeftPadded,
    disabled: typeof addable === "object" && addable.disabled
  });
}
function createLeftPaddedTabVNode(tabVNode) {
  const modifiedVNode = cloneVNode(tabVNode);
  if (modifiedVNode.props) {
    modifiedVNode.props.internalLeftPadded = true;
  } else {
    modifiedVNode.props = {
      internalLeftPadded: true
    };
  }
  return modifiedVNode;
}
function justifyTabDynamicProps(tabVNode) {
  if (Array.isArray(tabVNode.dynamicProps)) {
    if (!tabVNode.dynamicProps.includes("internalLeftPadded")) {
      tabVNode.dynamicProps.push("internalLeftPadded");
    }
  } else {
    tabVNode.dynamicProps = ["internalLeftPadded"];
  }
  return tabVNode;
}
const _hoisted_1$m = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 16 16"
};
const _hoisted_2$m = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M1.5 14a.5.5 0 0 1 0-1h13a.5.5 0 0 1 0 1h-13zm.5-3.75c0 .966.784 1.75 1.75 1.75h1.5A1.75 1.75 0 0 0 7 10.25v-6.5A1.75 1.75 0 0 0 5.25 2h-1.5A1.75 1.75 0 0 0 2 3.75v6.5zm1.75.75a.75.75 0 0 1-.75-.75v-6.5A.75.75 0 0 1 3.75 3h1.5a.75.75 0 0 1 .75.75v6.5a.75.75 0 0 1-.75.75h-1.5zM9 10.25c0 .966.784 1.75 1.75 1.75h1.5A1.75 1.75 0 0 0 14 10.25v-4.5A1.75 1.75 0 0 0 12.25 4h-1.5A1.75 1.75 0 0 0 9 5.75v4.5zm1.75.75a.75.75 0 0 1-.75-.75v-4.5a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-.75.75h-1.5z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$l = [_hoisted_2$m];
const AlignBottom16Regular = /* @__PURE__ */ defineComponent({
  name: "AlignBottom16Regular",
  render: function render2(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$m, _hoisted_3$l);
  }
});
const _hoisted_1$l = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 16 16"
};
const _hoisted_2$l = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M15 7.5a.5.5 0 0 1-.5.5H14v1.25A1.75 1.75 0 0 1 12.25 11h-1.5A1.75 1.75 0 0 1 9 9.25V8H7v2.25A1.75 1.75 0 0 1 5.25 12h-1.5A1.75 1.75 0 0 1 2 10.25V8h-.5a.5.5 0 0 1 0-1H2V4.75C2 3.784 2.784 3 3.75 3h1.5C6.216 3 7 3.784 7 4.75V7h2V5.75C9 4.784 9.784 4 10.75 4h1.5c.966 0 1.75.784 1.75 1.75V7h.5a.5.5 0 0 1 .5.5zM3 10.25c0 .414.336.75.75.75h1.5a.75.75 0 0 0 .75-.75v-5.5A.75.75 0 0 0 5.25 4h-1.5a.75.75 0 0 0-.75.75v5.5zm7-1c0 .414.336.75.75.75h1.5a.75.75 0 0 0 .75-.75v-3.5a.75.75 0 0 0-.75-.75h-1.5a.75.75 0 0 0-.75.75v3.5z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$k = [_hoisted_2$l];
const AlignCenterHorizontal16Regular = /* @__PURE__ */ defineComponent({
  name: "AlignCenterHorizontal16Regular",
  render: function render3(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$l, _hoisted_3$k);
  }
});
const _hoisted_1$k = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 16 16"
};
const _hoisted_2$k = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M8.5 15a.5.5 0 0 1-.5-.5V14H6.75A1.75 1.75 0 0 1 5 12.25v-1.5C5 9.784 5.784 9 6.75 9H8V7H5.75A1.75 1.75 0 0 1 4 5.25v-1.5C4 2.784 4.784 2 5.75 2H8v-.5a.5.5 0 0 1 1 0V2h2.25c.966 0 1.75.784 1.75 1.75v1.5A1.75 1.75 0 0 1 11.25 7H9v2h1.25c.966 0 1.75.784 1.75 1.75v1.5A1.75 1.75 0 0 1 10.25 14H9v.5a.5.5 0 0 1-.5.5zM5.75 3a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75h5.5a.75.75 0 0 0 .75-.75v-1.5a.75.75 0 0 0-.75-.75h-5.5zm1 7a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75h3.5a.75.75 0 0 0 .75-.75v-1.5a.75.75 0 0 0-.75-.75h-3.5z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$j = [_hoisted_2$k];
const AlignCenterVertical16Regular = /* @__PURE__ */ defineComponent({
  name: "AlignCenterVertical16Regular",
  render: function render4(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$k, _hoisted_3$j);
  }
});
const _hoisted_1$j = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 16 16"
};
const _hoisted_2$j = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M2 1.5a.5.5 0 0 1 1 0v13a.5.5 0 0 1-1 0v-13zm3.75.5A1.75 1.75 0 0 0 4 3.75v1.5C4 6.216 4.784 7 5.75 7h6.5A1.75 1.75 0 0 0 14 5.25v-1.5A1.75 1.75 0 0 0 12.25 2h-6.5zM5 3.75A.75.75 0 0 1 5.75 3h6.5a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-.75.75h-6.5A.75.75 0 0 1 5 5.25v-1.5zM5.75 9A1.75 1.75 0 0 0 4 10.75v1.5c0 .966.784 1.75 1.75 1.75h4.5A1.75 1.75 0 0 0 12 12.25v-1.5A1.75 1.75 0 0 0 10.25 9h-4.5zM5 10.75a.75.75 0 0 1 .75-.75h4.5a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-.75.75h-4.5a.75.75 0 0 1-.75-.75v-1.5z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$i = [_hoisted_2$j];
const AlignLeft16Regular = /* @__PURE__ */ defineComponent({
  name: "AlignLeft16Regular",
  render: function render5(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$j, _hoisted_3$i);
  }
});
const _hoisted_1$i = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 16 16"
};
const _hoisted_2$i = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M14 1.5a.5.5 0 0 0-1 0v13a.5.5 0 0 0 1 0v-13zm-3.75.5c.966 0 1.75.784 1.75 1.75v1.5A1.75 1.75 0 0 1 10.25 7h-6.5A1.75 1.75 0 0 1 2 5.25v-1.5C2 2.784 2.784 2 3.75 2h6.5zM11 3.75a.75.75 0 0 0-.75-.75h-6.5a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75h6.5a.75.75 0 0 0 .75-.75v-1.5zM10.25 9c.966 0 1.75.784 1.75 1.75v1.5A1.75 1.75 0 0 1 10.25 14h-4.5A1.75 1.75 0 0 1 4 12.25v-1.5C4 9.784 4.784 9 5.75 9h4.5zm.75 1.75a.75.75 0 0 0-.75-.75h-4.5a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75v-1.5z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$h = [_hoisted_2$i];
const AlignRight16Regular = /* @__PURE__ */ defineComponent({
  name: "AlignRight16Regular",
  render: function render6(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$i, _hoisted_3$h);
  }
});
const _hoisted_1$h = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 16 16"
};
const _hoisted_2$h = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M1.5 2a.5.5 0 0 0 0 1h13a.5.5 0 0 0 0-1h-13zM2 5.75C2 4.784 2.784 4 3.75 4h1.5C6.216 4 7 4.784 7 5.75v6.5A1.75 1.75 0 0 1 5.25 14h-1.5A1.75 1.75 0 0 1 2 12.25v-6.5zM3.75 5a.75.75 0 0 0-.75.75v6.5c0 .414.336.75.75.75h1.5a.75.75 0 0 0 .75-.75v-6.5A.75.75 0 0 0 5.25 5h-1.5zM9 5.75C9 4.784 9.784 4 10.75 4h1.5c.966 0 1.75.784 1.75 1.75v4.5A1.75 1.75 0 0 1 12.25 12h-1.5A1.75 1.75 0 0 1 9 10.25v-4.5zM10.75 5a.75.75 0 0 0-.75.75v4.5c0 .414.336.75.75.75h1.5a.75.75 0 0 0 .75-.75v-4.5a.75.75 0 0 0-.75-.75h-1.5z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$g = [_hoisted_2$h];
const AlignTop16Regular = /* @__PURE__ */ defineComponent({
  name: "AlignTop16Regular",
  render: function render7(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$h, _hoisted_3$g);
  }
});
const _hoisted_1$g = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 16 16"
};
const _hoisted_2$g = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M7.146.646a.5.5 0 0 1 .708 0l1.5 1.5a.5.5 0 0 1 0 .708l-1.5 1.5a.5.5 0 1 1-.708-.708l.643-.642a5 5 0 0 0-2.937 8.88a.5.5 0 1 1-.63.777A6 6 0 0 1 7.797 2.003l-.65-.65a.5.5 0 0 1 0-.707zm3.929 2.766a.5.5 0 0 1 .703-.073a6 6 0 0 1-3.575 10.658l.65.65a.5.5 0 0 1-.707.707l-1.5-1.5a.5.5 0 0 1 0-.708l1.5-1.5a.5.5 0 0 1 .708.708l-.643.642a5 5 0 0 0 2.937-8.88a.5.5 0 0 1-.073-.704z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$f = [_hoisted_2$g];
const ArrowSync16Regular = /* @__PURE__ */ defineComponent({
  name: "ArrowSync16Regular",
  render: function render8(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$g, _hoisted_3$f);
  }
});
const _hoisted_1$f = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 16 16"
};
const _hoisted_2$f = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M7.3 1.5a.5.5 0 0 0-1 0v.8c0 .289.072.561.2.8A2.504 2.504 0 0 0 4.76 4.946A1.1 1.1 0 0 1 4 3.9V2.5a.5.5 0 0 0-1 0v1.4a2.1 2.1 0 0 0 1.7 2.062V7H2.5a.5.5 0 0 0 0 1h2.2v1.7c0 .108.005.215.015.32A2 2 0 0 0 3 12v1.5a.5.5 0 0 0 1 0V12a1 1 0 0 1 .966-1a3.3 3.3 0 0 0 6.068 0A1 1 0 0 1 12 12v1.5a.5.5 0 0 0 1 0V12a2 2 0 0 0-1.715-1.98a3.32 3.32 0 0 0 .015-.32V8h2.2a.5.5 0 0 0 0-1h-2.2V5.962A2.1 2.1 0 0 0 13 3.9V2.5a.5.5 0 0 0-1 0v1.4c0 .49-.32.904-.761 1.047A2.504 2.504 0 0 0 9.5 3.1c.127-.239.199-.511.199-.8v-.8a.5.5 0 0 0-1 0v.8a.7.7 0 1 1-1.4 0v-.8zm-1.6 6V5.491A1.5 1.5 0 0 1 7.2 4h1.6a1.5 1.5 0 0 1 1.5 1.5v4.2a2.3 2.3 0 0 1-4.6 0V7.5z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$e = [_hoisted_2$f];
const Bug16Regular = /* @__PURE__ */ defineComponent({
  name: "Bug16Regular",
  render: function render9(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$f, _hoisted_3$e);
  }
});
const _hoisted_1$e = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 16 16"
};
const _hoisted_2$e = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12zm0-1A5 5 0 1 1 8 3a5 5 0 0 1 0 10z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$d = [_hoisted_2$e];
const Circle16Regular = /* @__PURE__ */ defineComponent({
  name: "Circle16Regular",
  render: function render10(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$e, _hoisted_3$d);
  }
});
const _hoisted_1$d = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 20 20"
};
const _hoisted_2$d = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M15.5 4a1.5 1.5 0 1 0 0 3a1.5 1.5 0 0 0 0-3zM13 5.5a2.5 2.5 0 1 1 1.557 2.316l-1.282 1.923a2.5 2.5 0 1 1-3.83 3.185l-2.496 1.07a2.5 2.5 0 1 1-.394-.919l2.496-1.07a2.5 2.5 0 0 1 3.392-2.822l1.282-1.922A2.492 2.492 0 0 1 13 5.5zm-3 6a1.5 1.5 0 1 0 3 0a1.5 1.5 0 0 0-3 0zm-7 3a1.5 1.5 0 1 0 3 0a1.5 1.5 0 0 0-3 0z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$c = [_hoisted_2$d];
const DataLine20Regular = /* @__PURE__ */ defineComponent({
  name: "DataLine20Regular",
  render: function render11(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$d, _hoisted_3$c);
  }
});
const _hoisted_1$c = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 20 20"
};
const _hoisted_2$c = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M4.5 3A1.5 1.5 0 0 0 3 4.5v2A1.5 1.5 0 0 0 4.5 8H5v3.84a1.003 1.003 0 0 0-.207.16L3 13.793a1 1 0 0 0 0 1.414L4.793 17a1 1 0 0 0 1.414 0L8 15.207c.063-.063.116-.133.16-.207H12v.5a1.5 1.5 0 0 0 1.5 1.5h2a1.5 1.5 0 0 0 1.5-1.5v-2a1.5 1.5 0 0 0-1.5-1.5h-2a1.5 1.5 0 0 0-1.5 1.5v.5H8.16a1.001 1.001 0 0 0-.16-.207L6.207 12A.999.999 0 0 0 6 11.84V8h.5A1.5 1.5 0 0 0 8 6.5v-2A1.5 1.5 0 0 0 6.5 3h-2zM4 4.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-2zm-.293 10L5.5 12.707L7.293 14.5L5.5 16.293L3.707 14.5zM13.5 13h2a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$b = [_hoisted_2$c];
const Flowchart20Regular = /* @__PURE__ */ defineComponent({
  name: "Flowchart20Regular",
  render: function render12(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$c, _hoisted_3$b);
  }
});
const _hoisted_1$b = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 24 24"
};
const _hoisted_2$b = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M4.5 5.75c0-.69.56-1.25 1.25-1.25h2a.75.75 0 0 0 0-1.5h-2A2.75 2.75 0 0 0 3 5.75v2a.75.75 0 0 0 1.5 0v-2zm0 12.5c0 .69.56 1.25 1.25 1.25h2a.75.75 0 0 1 0 1.5h-2A2.75 2.75 0 0 1 3 18.25v-2a.75.75 0 0 1 1.5 0v2zM18.25 4.5c.69 0 1.25.56 1.25 1.25v2a.75.75 0 0 0 1.5 0v-2A2.75 2.75 0 0 0 18.25 3h-2a.75.75 0 0 0 0 1.5h2zm1.25 13.75c0 .69-.56 1.25-1.25 1.25h-2a.75.75 0 0 0 0 1.5h2A2.75 2.75 0 0 0 21 18.25v-2a.75.75 0 0 0-1.5 0v2z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$a = [_hoisted_2$b];
const FullScreenMaximize24Regular = /* @__PURE__ */ defineComponent({
  name: "FullScreenMaximize24Regular",
  render: function render13(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$b, _hoisted_3$a);
  }
});
const _hoisted_1$a = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 24 24"
};
const _hoisted_2$a = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M8.5 3.75a.75.75 0 0 0-1.5 0v2.5a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 0 0 1.5h2.5A2.25 2.25 0 0 0 8.5 6.25v-2.5zm0 16.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 0-.75-.75h-2.5a.75.75 0 0 1 0-1.5h2.5a2.25 2.25 0 0 1 2.25 2.25v2.5zM16.25 3a.75.75 0 0 0-.75.75v2.5a2.25 2.25 0 0 0 2.25 2.25h2.5a.75.75 0 0 0 0-1.5h-2.5a.75.75 0 0 1-.75-.75v-2.5a.75.75 0 0 0-.75-.75zm-.75 17.25a.75.75 0 0 0 1.5 0v-2.5a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 0 0-1.5h-2.5a2.25 2.25 0 0 0-2.25 2.25v2.5z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$9 = [_hoisted_2$a];
const FullScreenMinimize24Regular = /* @__PURE__ */ defineComponent({
  name: "FullScreenMinimize24Regular",
  render: function render14(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$9);
  }
});
const _hoisted_1$9 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 20 20"
};
const _hoisted_2$9 = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M17.854 2.15a.5.5 0 0 1 0 .706l-15 15a.5.5 0 0 1-.708-.707l15-15a.5.5 0 0 1 .708 0z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$8 = [_hoisted_2$9];
const Line20Regular = /* @__PURE__ */ defineComponent({
  name: "Line20Regular",
  render: function render15(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$9, _hoisted_3$8);
  }
});
const _hoisted_1$8 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 20 20"
};
const _hoisted_2$8 = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M7.004 3a.5.5 0 0 1 .479.37l3.043 11.303l2.495-8.317a.5.5 0 0 1 .947-.032L15.347 10H17.5a.5.5 0 0 1 0 1H15a.5.5 0 0 1-.468-.324l-.98-2.612l-2.573 8.58a.5.5 0 0 1-.962-.014L6.986 5.37L5.48 10.637A.5.5 0 0 1 5 11H2.5a.5.5 0 0 1 0-1h2.123l1.896-6.637A.5.5 0 0 1 7.004 3z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$7 = [_hoisted_2$8];
const Pulse20Regular = /* @__PURE__ */ defineComponent({
  name: "Pulse20Regular",
  render: function render16(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$8, _hoisted_3$7);
  }
});
const _hoisted_1$7 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 16 16"
};
const _hoisted_2$7 = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M1 5.5A2.5 2.5 0 0 1 3.5 3h9A2.5 2.5 0 0 1 15 5.5v5a2.5 2.5 0 0 1-2.5 2.5h-9A2.5 2.5 0 0 1 1 10.5v-5zM3.5 4A1.5 1.5 0 0 0 2 5.5v5A1.5 1.5 0 0 0 3.5 12h9a1.5 1.5 0 0 0 1.5-1.5v-5A1.5 1.5 0 0 0 12.5 4h-9z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$6 = [_hoisted_2$7];
const RectangleLandscape16Regular = /* @__PURE__ */ defineComponent({
  name: "RectangleLandscape16Regular",
  render: function render17(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$7, _hoisted_3$6);
  }
});
const _hoisted_1$6 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 20 20"
};
const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("rect", {
      x: "3",
      y: "9.5",
      width: "14",
      height: "1",
      rx: ".5",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$5 = [_hoisted_2$6];
const Subtract20Regular = /* @__PURE__ */ defineComponent({
  name: "Subtract20Regular",
  render: function render18(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$6, _hoisted_3$5);
  }
});
const _hoisted_1$5 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 20 20"
};
const _hoisted_2$5 = /* @__PURE__ */ createBaseVNode(
  "g",
  {
    fill: "none"
  },
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M4 3.75A.75.75 0 0 1 4.75 3h10a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0V4.5h-3.5v11h1.25a.75.75 0 0 1 0 1.5h-4a.75.75 0 0 1 0-1.5H9v-11H5.5v.75a.75.75 0 0 1-1.5 0v-1.5z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$4 = [_hoisted_2$5];
const TextT20Filled = /* @__PURE__ */ defineComponent({
  name: "TextT20Filled",
  render: function render19(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$5, _hoisted_3$4);
  }
});
const _imports_0 = "" + new URL("../logo.png", import.meta.url).href;
const _imports_1 = "" + new URL("../donate2.jpg", import.meta.url).href;
const _imports_2 = "" + new URL("../donate.jpg", import.meta.url).href;
const _hoisted_1$4 = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  x: "0px",
  y: "0px",
  viewBox: "0 0 512 512",
  "enable-background": "new 0 0 512 512",
  "xml:space": "preserve"
};
const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode(
  "g",
  null,
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M32,432h2.9c1.8,0,3.5-1.1,4.1-2.8c2.2-5.7,8.3-19.8,21.4-39.7c21.5-32.7,58.4-67.4,94.5-83.5c27.6-12.4,53-21.5,97.1-23.2\n		c2.3-0.1,4.2,1.7,4.2,4v81.6c0,3.2,3.6,5.1,6.2,3.4l215.9-142.2c2.4-1.6,2.4-5.1,0-6.7L262.3,80.7c-2.7-1.8-6.2,0.1-6.2,3.4v82.6\n		c0,2.2-1.7,3.9-3.8,4c-71.6,3.8-123.1,24.8-163.4,65.5c-61,61.6-56.8,139.1-56.8,158.7C32.1,405.2,32,420.2,32,432z"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$3 = [_hoisted_2$4];
const IosRedo = /* @__PURE__ */ defineComponent({
  name: "IosRedo",
  render: function render20(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$4, _hoisted_3$3);
  }
});
const _hoisted_1$3 = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  x: "0px",
  y: "0px",
  viewBox: "0 0 512 512",
  "enable-background": "new 0 0 512 512",
  "xml:space": "preserve"
};
const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode(
  "g",
  null,
  [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M479.9,394.9c0-19.6,4.2-97.1-56.8-158.7c-40.4-40.7-91.9-61.7-163.4-65.5c-2.1-0.1-3.8-1.9-3.8-4V84\n		c0-3.2-3.5-5.1-6.2-3.4L33.8,222.8c-2.4,1.6-2.4,5.1,0,6.7l215.9,142.2c2.7,1.8,6.2-0.1,6.2-3.4v-81.6c0-2.3,1.9-4.1,4.2-4\n		c44.1,1.7,69.5,10.9,97.1,23.2c36.1,16.2,72.9,50.9,94.5,83.5c13.1,19.9,19.2,33.9,21.4,39.7c0.7,1.7,2.3,2.8,4.1,2.8h2.9\n		C480,420.2,479.9,405.2,479.9,394.9z"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$2 = [_hoisted_2$3];
const IosUndo = /* @__PURE__ */ defineComponent({
  name: "IosUndo",
  render: function render21(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$3, _hoisted_3$2);
  }
});
const _withScopeId$1 = (n) => (pushScopeId("data-v-be806274"), n = n(), popScopeId(), n);
const _hoisted_1$2 = { class: "main-header" };
const _hoisted_2$2 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("img", {
  class: "main-header__logo",
  src: _imports_0,
  alt: ""
}, null, -1));
const _hoisted_3$1 = { class: "main-header__title" };
const _hoisted_4$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", null, "Designer Sample", -1));
const _hoisted_5$1 = { class: "main-header__menu" };
const _hoisted_6$1 = { class: "main-header__action" };
const _hoisted_7$1 = { class: "main-header__scale" };
const _hoisted_8$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_9$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_10$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_11$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("img", {
  style: { "width": "48%", "float": "left" },
  src: _imports_1
}, null, -1));
const _hoisted_12$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("img", {
  style: { "width": "48%", "float": "right" },
  src: _imports_2
}, null, -1));
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "MainHeader"
  },
  __name: "index",
  props: {
    render: {},
    full: { type: Boolean, default: () => false },
    graphType: {},
    texting: { type: Boolean, default: () => false },
    readonly: { type: Boolean }
  },
  emits: ["update:full", "update:graphType", "update:texting"],
  setup(__props, { emit: __emit }) {
    const emit2 = __emit;
    const props = __props;
    const showShortCut = ref(false);
    const showDonate = ref(false);
    function onRestore() {
      if (props.render) {
        const input = document.createElement("input");
        input.type = "file";
        const event = new MouseEvent("click");
        input.dispatchEvent(event);
        input.remove();
        input.onchange = () => {
          const files = input.files;
          if (files) {
            let reader = new FileReader();
            reader.onload = async function() {
              await props.render.importExportTool.restore(this.result.toString());
              props.render.positionTool.positionFit();
            };
            reader.readAsText(files[0]);
          }
        };
      }
    }
    function onSave() {
      if (props.render) {
        const a = document.createElement("a");
        const event = new MouseEvent("click");
        a.download = "data.json";
        a.href = window.URL.createObjectURL(new Blob([props.render.importExportTool.save()]));
        a.dispatchEvent(event);
        a.remove();
      }
    }
    async function onSaveSvg() {
      if (props.render) {
        const svg = await props.render.importExportTool.getSvg();
        const a = document.createElement("a");
        const event = new MouseEvent("click");
        a.download = "image.svg";
        a.href = window.URL.createObjectURL(new Blob([svg]));
        a.dispatchEvent(event);
        a.remove();
      }
    }
    function onSaveAsset() {
      if (props.render) {
        const a = document.createElement("a");
        const event = new MouseEvent("click");
        a.download = "asset.json";
        a.href = window.URL.createObjectURL(new Blob([props.render.importExportTool.getAsset()]));
        a.dispatchEvent(event);
        a.remove();
      }
    }
    function onSavePNG() {
      if (props.render) {
        const url2 = props.render.importExportTool.getAssetImage(2);
        const a = document.createElement("a");
        const event = new MouseEvent("click");
        a.download = "image";
        a.href = url2;
        a.dispatchEvent(event);
        a.remove();
      }
    }
    function onSaveAssetPNG() {
      if (props.render) {
        const url2 = props.render.importExportTool.getAssetImage();
        const a = document.createElement("a");
        const event = new MouseEvent("click");
        a.download = "image";
        a.href = url2;
        a.dispatchEvent(event);
        a.remove();
      }
    }
    const history = ref([]);
    const historyIndex = ref(-1);
    function onPrev() {
      if (props.render) {
        props.render.prevHistory();
      }
    }
    function onNext() {
      if (props.render) {
        props.render.nextHistory();
      }
    }
    const selection = ref([]);
    const noAlign = computed(() => selection.value.length <= 1);
    function onAlign(type4) {
      var _a;
      (_a = props.render) == null ? void 0 : _a.alignTool.align(type4);
    }
    const currentLinkType = ref(LinkType.manual);
    function onLinkTypeChange(linkType) {
      var _a, _b;
      (_b = (_a = props.render) == null ? void 0 : _a.draws[LinkDraw.name]) == null ? void 0 : _b.changeLinkType(linkType);
    }
    const debug = ref(false);
    function onDebug() {
      var _a;
      debug.value = ((_a = props.render) == null ? void 0 : _a.changeDebug(!debug.value)) ?? false;
    }
    const activeMenuKey = ref("");
    const menuOptions = [
      {
        label: "文件",
        key: "file",
        children: [
          {
            label: () => h(
              "a",
              {
                target: "_blank",
                rel: "noopenner noreferrer",
                onClick: onRestore
              },
              "导入"
            ),
            key: "import"
          },
          ...props.readonly ? [] : [
            {
              label: () => h(
                "a",
                {
                  target: "_blank",
                  rel: "noopenner noreferrer",
                  onClick: onSave
                },
                "导出"
              ),
              key: "export"
            },
            {
              type: "divider"
            },
            {
              label: () => h(
                "a",
                {
                  target: "_blank",
                  rel: "noopenner noreferrer",
                  onClick: onSavePNG
                },
                "另存为图片"
              ),
              key: "png"
            },
            {
              label: () => h(
                "a",
                {
                  target: "_blank",
                  rel: "noopenner noreferrer",
                  onClick: onSaveSvg
                },
                "另存为矢量图"
              ),
              key: "svg"
            },
            {
              type: "divider"
            },
            {
              label: () => h(
                "a",
                {
                  target: "_blank",
                  rel: "noopenner noreferrer",
                  onClick: onSaveAsset
                },
                "另存为素材"
              ),
              key: "json"
            },
            {
              label: () => h(
                "a",
                {
                  target: "_blank",
                  rel: "noopenner noreferrer",
                  onClick: onSaveAssetPNG
                },
                "另存为素材封面"
              ),
              key: "asset-png"
            }
          ]
        ]
      },
      {
        label: "示例",
        key: "sample",
        children: [
          {
            type: "group",
            label: "测试数据",
            key: "test",
            children: [
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onLinkTest
                  },
                  "连接线方向"
                ),
                key: "连接线方向"
              },
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onRotateTest
                  },
                  "连接线出入口"
                ),
                key: "连接线出入口"
              },
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onAlignTest
                  },
                  "对齐"
                ),
                key: "对齐"
              },
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onBigTest
                  },
                  "大图"
                ),
                key: "大图"
              },
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onHugeTest
                  },
                  "大量素材"
                ),
                key: "大量素材"
              },
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onHugeManualLinkTest
                  },
                  "大量手动连接线"
                ),
                key: "大量手动连接线"
              },
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onHugeAutoLinkTest
                  },
                  "大量自动连接线"
                ),
                key: "大量自动连接线"
              },
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onSvgExportTest
                  },
                  "图形旋转导出测试"
                ),
                key: "图形旋转导出测试"
              },
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onLinkRotateTest
                  },
                  "拐点旋转测试"
                ),
                key: "拐点旋转测试"
              },
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onAdjustTransformTest
                  },
                  "变换后调整测试"
                ),
                key: "变换后调整测试"
              },
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onAreaSizeTest
                  },
                  "占用区域大小测试"
                ),
                key: "占用区域大小测试"
              },
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer",
                    onClick: onLinkStrokeTest
                  },
                  "连接线颜色测试"
                ),
                key: "连接线颜色测试"
              }
            ]
          }
        ]
      },
      {
        label: "帮助",
        key: "help",
        children: [
          {
            label: () => h(
              "a",
              {
                rel: "noopenner noreferrer",
                onClick: () => {
                  showShortCut.value = true;
                }
              },
              "快捷键"
            ),
            key: "shortCut"
          },
          {
            type: "divider"
          },
          {
            type: "group",
            label: "网站",
            key: "website",
            children: [
              {
                label: () => h(
                  "a",
                  {
                    target: "_blank",
                    rel: "noopenner noreferrer"
                  },
                  "CSDN"
                ),
                key: "CSDN"
              },
              {
                label: () => h(
                  "a",
                  {
                    href: "https://juejin.cn/column/7353542036232585225",
                    target: "_blank",
                    rel: "noopenner noreferrer"
                  },
                  "稀土掘金"
                ),
                key: "稀土掘金"
              },
              {
                label: () => h(
                  "a",
                  {
                    href: "https://i.cnblogs.com/collections/detail?collectionId=14920",
                    target: "_blank",
                    rel: "noopenner noreferrer"
                  },
                  "博客园"
                ),
                key: "博客园"
              }
            ]
          },
          {
            type: "divider"
          },
          {
            type: "group",
            label: "仓库",
            key: "repo",
            children: [
              {
                label: () => h(
                  "a",
                  {
                    href: "https://github.com/xachary/konva-designer-sample",
                    target: "_blank",
                    rel: "noopenner noreferrer"
                  },
                  "GitHub"
                ),
                key: "GitHub"
              },
              {
                label: () => h(
                  "a",
                  {
                    href: "https://gitee.com/xachary/konva-designer-sample",
                    target: "_blank",
                    rel: "noopenner noreferrer"
                  },
                  "Gitee"
                ),
                key: "Gitee"
              }
            ]
          },
          {
            type: "divider"
          },
          {
            label: "v0.0.1",
            key: "version",
            disabled: true
          }
        ]
      },
      {
        key: "donate",
        label: () => h(
          "a",
          {
            rel: "noopenner noreferrer",
            onClick: () => {
              showDonate.value = true;
            },
            style: {
              color: "blue"
            }
          },
          "请我喝杯奶茶呗!"
        ),
        children: []
      }
    ];
    const scale = ref(100);
    const scaleOptions = [
      {
        label: "自适应大小",
        key: "fit"
      },
      {
        label: "重置位置大小",
        key: "reset"
      },
      {
        label: "仅重置位置",
        key: "position"
      }
    ];
    function scaleChange(key) {
      var _a, _b, _c;
      switch (key) {
        case "fit":
          (_a = props.render) == null ? void 0 : _a.positionTool.positionFit();
          break;
        case "reset":
          (_b = props.render) == null ? void 0 : _b.positionTool.positionZoomReset();
          break;
        case "position":
          (_c = props.render) == null ? void 0 : _c.positionTool.positionReset();
          break;
      }
    }
    watch(() => props.render, () => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (props.render) {
        (_a = props.render) == null ? void 0 : _a.on("selection-change", (nodes) => {
          selection.value = nodes;
        });
        (_b = props.render) == null ? void 0 : _b.on("history-change", ({ records, index }) => {
          history.value = records;
          historyIndex.value = index;
        });
        (_c = props.render) == null ? void 0 : _c.on("link-type-change", (value) => {
          currentLinkType.value = value;
        });
        (_d = props.render) == null ? void 0 : _d.on("debug-change", (value) => {
          debug.value = value;
        });
        (_e = props.render) == null ? void 0 : _e.on("scale-change", (value) => {
          scale.value = value * 100;
        });
        (_f = props.render) == null ? void 0 : _f.on("loading", (value) => {
          loading.value = value;
        });
        (_g = props.render) == null ? void 0 : _g.on("graph-type-change", (value) => {
          emit2("update:graphType", value);
        });
        (_h = props.render) == null ? void 0 : _h.on("texting-change", (value) => {
          emit2("update:texting", value);
        });
      }
    }, {
      immediate: true
    });
    async function onLinkTest() {
      var _a, _b;
      const json = await (await fetch("./test/link.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    async function onRotateTest() {
      var _a, _b;
      const json = await (await fetch("./test/rotate.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    async function onAlignTest() {
      var _a, _b;
      const json = await (await fetch("./test/align.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    async function onBigTest() {
      var _a, _b;
      const json = await (await fetch("./test/big.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    async function onHugeTest() {
      var _a, _b;
      const json = await (await fetch("./test/huge.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    async function onHugeManualLinkTest() {
      var _a, _b;
      const json = await (await fetch("./test/huge-manual-link.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    async function onHugeAutoLinkTest() {
      var _a, _b;
      const json = await (await fetch("./test/huge-auto-link.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    async function onSvgExportTest() {
      var _a, _b;
      const json = await (await fetch("./test/svg-export.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    async function onLinkRotateTest() {
      var _a, _b;
      const json = await (await fetch("./test/link-rotate.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    async function onAdjustTransformTest() {
      var _a, _b;
      const json = await (await fetch("./test/adjust-transform.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    async function onAreaSizeTest() {
      var _a, _b;
      const json = await (await fetch("./test/area-size.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    async function onLinkStrokeTest() {
      var _a, _b;
      const json = await (await fetch("./test/link-stroke.json")).text();
      await ((_a = props.render) == null ? void 0 : _a.importExportTool.restore(json));
      (_b = props.render) == null ? void 0 : _b.positionTool.positionFit();
    }
    function onFull() {
      emit2("update:full", !props.full);
    }
    const loading = ref(false);
    function onGraph(type4) {
      emit2("update:graphType", props.graphType === type4 ? void 0 : type4);
    }
    function onText() {
      emit2("update:texting", true);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createBaseVNode("header", null, [
          _hoisted_2$2,
          createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_3$1, [
              _hoisted_4$1,
              withDirectives(createVNode(unref(NSpin), { size: "small" }, {
                icon: withCtx(() => [
                  createVNode(unref(NIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(ArrowSync16Regular))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 512), [
                [vShow, loading.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_5$1, [
              createVNode(unref(NMenu), {
                mode: "horizontal",
                responsive: "",
                options: menuOptions,
                value: activeMenuKey.value,
                "onUpdate:value": _cache[0] || (_cache[0] = ($event) => activeMenuKey.value = $event),
                "on-update:value": () => activeMenuKey.value = ""
              }, null, 8, ["value", "on-update:value"])
            ])
          ])
        ]),
        createBaseVNode("footer", _hoisted_6$1, [
          createBaseVNode("section", null, [
            createVNode(unref(NDropdown), {
              trigger: "hover",
              options: scaleOptions,
              onSelect: scaleChange
            }, {
              default: withCtx(() => [
                createVNode(unref(NButton), {
                  tag: "div",
                  size: "tiny",
                  quaternary: "",
                  focusable: false
                }, {
                  default: withCtx(() => [
                    createBaseVNode("span", _hoisted_7$1, toDisplayString(scale.value.toFixed(0)) + "%", 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            !props.readonly ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createVNode(unref(NDivider), { vertical: "" }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: onPrev,
                    disabled: historyIndex.value <= 0
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(IosUndo))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                default: withCtx(() => [
                  createTextVNode(" 撤销 ")
                ]),
                _: 1
              }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: onNext,
                    disabled: historyIndex.value >= history.value.length - 1
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(IosRedo))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                default: withCtx(() => [
                  createTextVNode(" 恢复 ")
                ]),
                _: 1
              }),
              createVNode(unref(NDivider), { vertical: "" }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[1] || (_cache[1] = ($event) => onAlign(AlignType.垂直居中)),
                    disabled: noAlign.value
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(AlignCenterVertical16Regular))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                default: withCtx(() => [
                  createTextVNode(" 垂直居中 ")
                ]),
                _: 1
              }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[2] || (_cache[2] = ($event) => onAlign(AlignType.水平居中)),
                    disabled: noAlign.value
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(AlignCenterHorizontal16Regular))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                default: withCtx(() => [
                  createTextVNode(" 水平居中 ")
                ]),
                _: 1
              }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[3] || (_cache[3] = ($event) => onAlign(AlignType.左对齐)),
                    disabled: noAlign.value
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(AlignLeft16Regular))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                default: withCtx(() => [
                  createTextVNode(" 左对齐 ")
                ]),
                _: 1
              }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[4] || (_cache[4] = ($event) => onAlign(AlignType.右对齐)),
                    disabled: noAlign.value
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(AlignRight16Regular))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                default: withCtx(() => [
                  createTextVNode(" 右对齐 ")
                ]),
                _: 1
              }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[5] || (_cache[5] = ($event) => onAlign(AlignType.上对齐)),
                    disabled: noAlign.value
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(AlignTop16Regular))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                default: withCtx(() => [
                  createTextVNode(" 上对齐 ")
                ]),
                _: 1
              }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[6] || (_cache[6] = ($event) => onAlign(AlignType.下对齐)),
                    disabled: noAlign.value
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(AlignBottom16Regular))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                default: withCtx(() => [
                  createTextVNode(" 下对齐 ")
                ]),
                _: 1
              }),
              createVNode(unref(NDivider), { vertical: "" }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[7] || (_cache[7] = ($event) => onLinkTypeChange(LinkType.manual)),
                    disabled: currentLinkType.value === LinkType.manual
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(Flowchart20Regular))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                default: withCtx(() => [
                  createTextVNode(" 连接线：手动 ")
                ]),
                _: 1
              }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[8] || (_cache[8] = ($event) => onLinkTypeChange(LinkType.auto)),
                    disabled: currentLinkType.value === LinkType.auto
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(Pulse20Regular))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                default: withCtx(() => [
                  createTextVNode(" 连接线：自动 ")
                ]),
                _: 1
              }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[9] || (_cache[9] = ($event) => onLinkTypeChange(LinkType.straight)),
                    disabled: currentLinkType.value === LinkType.straight
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(Line20Regular))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                default: withCtx(() => [
                  createTextVNode(" 连接线：直线 ")
                ]),
                _: 1
              }),
              createVNode(unref(NDivider), { vertical: "" }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[10] || (_cache[10] = ($event) => onGraph(GraphType.Line))
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), {
                        depth: props.graphType === GraphType.Line ? 1 : 3
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(Subtract20Regular))
                        ]),
                        _: 1
                      }, 8, ["depth"])
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createTextVNode(" 画直线 ")
                ]),
                _: 1
              }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[11] || (_cache[11] = ($event) => onGraph(GraphType.Curve))
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), {
                        depth: props.graphType === GraphType.Curve ? 1 : 3
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(DataLine20Regular))
                        ]),
                        _: 1
                      }, 8, ["depth"])
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createTextVNode(" 画曲线 ")
                ]),
                _: 1
              }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[12] || (_cache[12] = ($event) => onGraph(GraphType.Rect))
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), {
                        depth: props.graphType === GraphType.Rect ? 1 : 3
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(RectangleLandscape16Regular))
                        ]),
                        _: 1
                      }, 8, ["depth"])
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createTextVNode(" 画矩形 ")
                ]),
                _: 1
              }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: _cache[13] || (_cache[13] = ($event) => onGraph(GraphType.Circle))
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), {
                        depth: props.graphType === GraphType.Circle ? 1 : 3
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(Circle16Regular))
                        ]),
                        _: 1
                      }, 8, ["depth"])
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createTextVNode(" 画圆 ")
                ]),
                _: 1
              }),
              createVNode(unref(NDivider), { vertical: "" }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: onText
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), {
                        depth: props.texting ? 1 : 3
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(TextT20Filled))
                        ]),
                        _: 1
                      }, 8, ["depth"])
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createTextVNode(" 插入文字 ")
                ]),
                _: 1
              }),
              createVNode(unref(NDivider), { vertical: "" }),
              createVNode(unref(NTooltip), {
                trigger: "hover",
                delay: 1e3
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(NButton), {
                    tag: "div",
                    size: "tiny",
                    quaternary: "",
                    focusable: false,
                    onClick: onDebug
                  }, {
                    icon: withCtx(() => [
                      createVNode(unref(NIcon), {
                        depth: debug.value ? 1 : 3
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(Bug16Regular))
                        ]),
                        _: 1
                      }, 8, ["depth"])
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createTextVNode(" " + toDisplayString(debug.value ? "关闭调试" : "开启调试"), 1)
                ]),
                _: 1
              })
            ], 64)) : createCommentVNode("", true)
          ]),
          createBaseVNode("section", null, [
            createVNode(unref(NTooltip), {
              trigger: "hover",
              delay: 1e3
            }, {
              trigger: withCtx(() => [
                createVNode(unref(NButton), {
                  tag: "div",
                  size: "tiny",
                  quaternary: "",
                  focusable: false,
                  onClick: onFull
                }, {
                  icon: withCtx(() => [
                    createVNode(unref(NIcon), null, {
                      default: withCtx(() => [
                        withDirectives(createVNode(unref(FullScreenMaximize24Regular), null, null, 512), [
                          [vShow, !_ctx.full]
                        ]),
                        withDirectives(createVNode(unref(FullScreenMinimize24Regular), null, null, 512), [
                          [vShow, _ctx.full]
                        ])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(_ctx.full ? "最小化" : "最大化"), 1)
              ]),
              _: 1
            })
          ])
        ]),
        createVNode(unref(NModal), {
          show: showShortCut.value,
          "onUpdate:show": _cache[14] || (_cache[14] = ($event) => showShortCut.value = $event)
        }, {
          default: withCtx(() => [
            createVNode(unref(NCard), {
              style: { "width": "630px" },
              title: "快捷键",
              "aria-modal": "false"
            }, {
              default: withCtx(() => [
                createTextVNode(" 1、复制、粘贴、多选、全选、删除、上一步、下一步等快捷键与一般文档编辑器类似；"),
                _hoisted_8$1,
                createTextVNode(" 2、放大缩小，【Win】鼠标上滚动下滚动，【Mac】触控板双指放大、缩小；"),
                _hoisted_9$1,
                createTextVNode(" 3、画布拖动，在空白处，【Win】右键按下移动，【Mac】control + 触控板三指移动；"),
                _hoisted_10$1
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["show"]),
        createVNode(unref(NModal), {
          show: showDonate.value,
          "onUpdate:show": _cache[15] || (_cache[15] = ($event) => showDonate.value = $event)
        }, {
          default: withCtx(() => [
            createVNode(unref(NCard), {
              style: { "width": "630px" },
              title: "谢谢你的支持!",
              "aria-modal": "false"
            }, {
              default: withCtx(() => [
                _hoisted_11$1,
                _hoisted_12$1
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["show"])
      ]);
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const MainHeader = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-be806274"]]);
const assetsModules = {
  svg: [
    {
      url: "./img/svg/ARRESTER_1.svg",
      points: [
        { x: 101, y: 1, direction: "top" },
        { x: 101, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/ARRESTER_2.svg",
      points: [
        { x: 101, y: 1, direction: "top" },
        { x: 101, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/ARRESTER_2_1.svg",
      points: [
        { x: 101, y: 1, direction: "top" },
        { x: 101, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/BREAKER_CLOSE.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/BREAKER_OPEN.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/CAPACITOR.svg",
      points: [
        { x: 99, y: 1, direction: "top" },
        { x: 99, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/CT_1.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/CT_2.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/HL.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/POTENTIAL_TRANSFORMER_2.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/POT_TRANS_3_WINDINGS.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 70, y: 199, direction: "bottom" },
        { x: 130, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/PT.svg",
      points: [
        { x: 34, y: 100, direction: "left" },
        { x: 98, y: 100, direction: "right" }
      ]
    },
    {
      url: "./img/svg/PT_1.svg",
      points: [
        { x: 101, y: 1, direction: "top" },
        { x: 101, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/REACTOR.svg",
      points: [
        { x: 98, y: 1, direction: "left" },
        { x: 98, y: 199, direction: "right" }
      ]
    },
    {
      url: "./img/svg/REGYCAPACITOR.svg",
      points: [
        { x: 1, y: 101, direction: "left" },
        { x: 199, y: 101, direction: "right" }
      ]
    },
    {
      url: "./img/svg/SERIES_CAPACITOR.svg",
      points: [
        { x: 1, y: 101, direction: "left" },
        { x: 199, y: 101, direction: "right" }
      ]
    },
    {
      url: "./img/svg/SHUNT_REACTOR.svg",
      points: [
        { x: 98, y: 1, direction: "top" },
        { x: 98, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/SHUNT_REACTOR_1.svg",
      points: [
        { x: 98, y: 1, direction: "top" },
        { x: 98, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/SIX_CIRCLE.svg",
      points: [
        { x: 99, y: 1, direction: "top" },
        { x: 99, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/ST.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/THERR_CIRCLE.svg",
      points: [
        { x: 99, y: 43, direction: "top" },
        { x: 99, y: 157, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/combin.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/combin3.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/combin4.svg",
      points: [
        { x: 101, y: 1, direction: "top" },
        { x: 101, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/combin5.svg",
      points: [
        { x: 99, y: 1, direction: "top" },
        { x: 99, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/xianshideng.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" }
      ]
    },
    {
      url: "./img/svg/MEMRISTOR_1.svg",
      points: [
        { x: 1, y: 101, direction: "left" },
        { x: 199, y: 101, direction: "right" }
      ]
    },
    {
      url: "./img/svg/guangfufadian.svg",
      points: [
        { x: 100, y: 62, direction: "top" },
        { x: 100, y: 138, direction: "bottom" },
        { x: 27, y: 100, direction: "left" },
        { x: 173, y: 100, direction: "right" }
      ]
    },
    {
      url: "./img/svg/REGUINDUCTOR.svg",
      points: [
        { x: 100, y: 66, direction: "top" },
        { x: 100, y: 134, direction: "bottom" },
        { x: 1, y: 100, direction: "left" },
        { x: 199, y: 100, direction: "right" }
      ]
    },
    {
      url: "./img/svg/AC_2.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" },
        { x: 1, y: 100, direction: "left" },
        { x: 199, y: 100, direction: "right" }
      ]
    },
    {
      url: "./img/svg/AC_SOURCE.svg",
      points: [
        { x: 100, y: 1, direction: "top" },
        { x: 100, y: 199, direction: "bottom" },
        { x: 1, y: 100, direction: "left" },
        { x: 199, y: 100, direction: "right" }
      ]
    },
    { url: "./img/svg/EQUIVALENTSOURCE.svg", points: [{ x: 100, y: 100 }] }
  ],
  image: [
    {
      url: "./img/png/1.png",
      points: [
        { x: 52, y: 2, direction: "top" },
        { x: 52, y: 100, direction: "bottom" },
        { x: 2, y: 51, direction: "left" },
        { x: 101, y: 51, direction: "right" }
      ]
    },
    { url: "./img/png/2.png" },
    { url: "./img/jpg/big.jpg" }
  ],
  gif: [
    { url: "./img/gif/5.gif", points: [{ x: 100, y: 100 }] },
    { url: "./img/gif/6.gif" },
    { url: "./img/gif/8.gif" }
  ],
  json: [
    { url: "./json/1.json", avatar: "./json/1.png" },
    { url: "./json/2.json", avatar: "./json/2.png" },
    { url: "./json/3.json", avatar: "./json/3.png" },
    { url: "./json/4.json", avatar: "./json/4.png" },
    { url: "./json/5.json", avatar: "./json/5.png" },
    { url: "./json/6.json", avatar: "./json/6.png" },
    { url: "./json/7.json", avatar: "./json/7.png" }
  ],
  more: [
    { url: "./img/svg/a-CT2xianghu.svg" },
    { url: "./img/svg/a-CTsanxiang.svg" },
    { url: "./img/svg/combin2.svg" },
    { url: "./img/svg/ARCSUPPCOIL.svg" },
    { url: "./img/svg/INDUCTOR.svg" },
    { url: "./img/svg/IRONCOREGAPINDUCTOR.svg" },
    { url: "./img/svg/IRONCOREINDUCTOR.svg" },
    { url: "./img/svg/IRONCOREVARINDUCTOR.svg" },
    { url: "./img/svg/CT.svg" },
    { url: "./img/svg/GROUND.svg" },
    { url: "./img/svg/LOAD.svg" },
    { url: "./img/svg/PROTECT_GROUND.svg" },
    { url: "./img/svg/CT_3.svg" },
    { url: "./img/svg/DDCT.svg" },
    { url: "./img/svg/FLANGED_CONNECTION.svg" },
    { url: "./img/svg/jiedidaozha.svg" },
    { url: "./img/svg/sukeduanluqi.svg" },
    { url: "./img/svg/DELTAWINDING.svg" },
    { url: "./img/svg/MULTIPLIER.svg" },
    { url: "./img/svg/WINDING.svg" },
    { url: "./img/svg/WINDINGX.svg" },
    { url: "./img/svg/YWINDING.svg" },
    { url: "./img/png/3.png" },
    { url: "./img/png/7.png" },
    { url: "./img/png/9.png" }
  ]
};
const _hoisted_1$1 = { class: "asset-bar" };
const _hoisted_2$1 = { class: "asset-bar__list" };
const _hoisted_3 = ["onDragstart"];
const _hoisted_4 = ["src"];
const _hoisted_5 = { class: "asset-bar__list" };
const _hoisted_6 = ["onDragstart"];
const _hoisted_7 = ["src"];
const _hoisted_8 = { class: "asset-bar__list" };
const _hoisted_9 = ["onDragstart"];
const _hoisted_10 = ["src"];
const _hoisted_11 = { class: "asset-bar__list" };
const _hoisted_12 = ["onDragstart"];
const _hoisted_13 = ["src"];
const _hoisted_14 = { class: "asset-bar__list" };
const _hoisted_15 = ["onDragstart"];
const _hoisted_16 = ["src"];
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "AssetBar"
  },
  __name: "index",
  props: {
    render: {}
  },
  setup(__props) {
    const assetsSvg = computed(() => {
      return assetsModules.svg.map((o) => ({
        url: o.url,
        avatar: o.avatar,
        // 子素材需要额外的封面
        points: Array.isArray(o.points) ? o.points : []
      }));
    });
    const assetsImage = computed(() => {
      return assetsModules.image.map((o) => ({
        url: o.url,
        avatar: o.avatar,
        // 子素材需要额外的封面
        points: Array.isArray(o.points) ? o.points : []
      }));
    });
    const assetsGif = computed(() => {
      return assetsModules.gif.map((o) => ({
        url: o.url,
        avatar: o.avatar,
        // 子素材需要额外的封面
        points: Array.isArray(o.points) ? o.points : []
      }));
    });
    const assetsJson = computed(() => {
      return assetsModules.json.map((o) => ({
        url: o.url,
        avatar: o.avatar,
        // 子素材需要额外的封面
        points: Array.isArray(o.points) ? o.points : []
      }));
    });
    const assetsMore = computed(() => {
      return assetsModules.more.map((o) => ({
        url: o.url,
        avatar: o.avatar,
        // 子素材需要额外的封面
        points: Array.isArray(o.points) ? o.points : []
      }));
    });
    function onDragstart(e, item) {
      var _a;
      if (e.dataTransfer) {
        e.dataTransfer.setData("src", item.url);
        e.dataTransfer.setData("points", JSON.stringify(item.points));
        e.dataTransfer.setData("type", ((_a = item.url.match(/([^./]+)\.([^./]+)$/)) == null ? void 0 : _a[2]) ?? "");
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        createVNode(unref(NCollapse), {
          "arrow-placement": "right",
          "default-expanded-names": ["svg", "image", "gif", "json"]
        }, {
          default: withCtx(() => [
            createVNode(unref(NCollapseItem), {
              name: "svg",
              title: "矢量图"
            }, {
              default: withCtx(() => [
                createBaseVNode("ul", _hoisted_2$1, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(assetsSvg.value, (item, idx) => {
                    return openBlock(), createElementBlock("li", {
                      key: idx,
                      draggable: "true",
                      onDragstart: ($event) => onDragstart($event, item)
                    }, [
                      createBaseVNode("img", {
                        src: item.avatar || item.url
                      }, null, 8, _hoisted_4)
                    ], 40, _hoisted_3);
                  }), 128))
                ])
              ]),
              _: 1
            }),
            createVNode(unref(NCollapseItem), {
              name: "image",
              title: "图片"
            }, {
              default: withCtx(() => [
                createBaseVNode("ul", _hoisted_5, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(assetsImage.value, (item, idx) => {
                    return openBlock(), createElementBlock("li", {
                      key: idx,
                      draggable: "true",
                      onDragstart: ($event) => onDragstart($event, item)
                    }, [
                      createBaseVNode("img", {
                        src: item.avatar || item.url
                      }, null, 8, _hoisted_7)
                    ], 40, _hoisted_6);
                  }), 128))
                ])
              ]),
              _: 1
            }),
            createVNode(unref(NCollapseItem), {
              name: "gif",
              title: "GIF"
            }, {
              default: withCtx(() => [
                createBaseVNode("ul", _hoisted_8, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(assetsGif.value, (item, idx) => {
                    return openBlock(), createElementBlock("li", {
                      key: idx,
                      draggable: "true",
                      onDragstart: ($event) => onDragstart($event, item)
                    }, [
                      createBaseVNode("img", {
                        src: item.avatar || item.url
                      }, null, 8, _hoisted_10)
                    ], 40, _hoisted_9);
                  }), 128))
                ])
              ]),
              _: 1
            }),
            createVNode(unref(NCollapseItem), {
              name: "json",
              title: "图形组合"
            }, {
              default: withCtx(() => [
                createBaseVNode("ul", _hoisted_11, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(assetsJson.value, (item, idx) => {
                    return openBlock(), createElementBlock("li", {
                      key: idx,
                      draggable: "true",
                      onDragstart: ($event) => onDragstart($event, item)
                    }, [
                      createBaseVNode("img", {
                        src: item.avatar || item.url
                      }, null, 8, _hoisted_13)
                    ], 40, _hoisted_12);
                  }), 128))
                ])
              ]),
              _: 1
            }),
            createVNode(unref(NCollapseItem), {
              name: "more",
              title: "更多"
            }, {
              default: withCtx(() => [
                createBaseVNode("ul", _hoisted_14, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(assetsMore.value, (item, idx) => {
                    return openBlock(), createElementBlock("li", {
                      key: idx,
                      draggable: "true",
                      onDragstart: ($event) => onDragstart($event, item)
                    }, [
                      createBaseVNode("img", {
                        src: item.avatar || item.url
                      }, null, 8, _hoisted_16)
                    ], 40, _hoisted_15);
                  }), 128))
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]);
    };
  }
});
const AssetBar = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-0d76df1f"]]);
const _withScopeId = (n) => (pushScopeId("data-v-a4dd2c0b"), n = n(), popScopeId(), n);
const _hoisted_1 = { class: "page" };
const _hoisted_2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("footer", null, null, -1));
const readonly = false;
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const boardElement = ref();
    const stageElement = ref();
    let render22 = null;
    const ready = ref(false);
    const resizer = /* @__PURE__ */ (() => {
      let resizeObserver = null;
      let x = 0;
      function init22(target, config) {
        function getStageSize() {
          const { width, height } = target.getBoundingClientRect();
          return [0, 0, width, height];
        }
        if (resizeObserver) {
          resizeObserver.observe(target);
        } else {
          resizeObserver = new ResizeObserver(() => {
            const [, , w, h2] = getStageSize();
            config.resize(x - target.getBoundingClientRect().x, 0, w, h2);
          });
          resizeObserver.observe(target);
          x = target.getBoundingClientRect().x;
        }
      }
      function pause() {
        resizeObserver == null ? void 0 : resizeObserver.disconnect();
      }
      return {
        init: init22,
        pause
      };
    })();
    const full = ref(false);
    const graphType = ref();
    watch(() => graphType.value, () => {
      render22 == null ? void 0 : render22.changeGraphType(graphType.value);
    });
    const texting = ref(false);
    const textInputRef = ref();
    watch(() => texting.value, () => {
      render22 == null ? void 0 : render22.changeTexting(texting.value);
    });
    function init2() {
      if (boardElement.value && stageElement.value) {
        resizer.init(boardElement.value, {
          resize: async (x, y, width, height) => {
            if (render22 === null) {
              render22 = new Render(stageElement.value, {
                width,
                height,
                //
                showBg: true,
                showRuler: true,
                showRefLine: true,
                showPreview: true,
                showContextmenu: true,
                //
                attractResize: true,
                attractBg: true,
                attractNode: true,
                //
                readonly
              });
              pageSettingsModel.value = render22.getPageSettings();
              await nextTick();
              ready.value = true;
            }
            render22.resize(width, height);
            render22.on("page-settings-change", (settings) => {
              pageSettingsModelInnerChange.value = true;
              pageSettingsModel.value = settings;
            });
            render22.on("selection-change", (nodes) => {
              assetSettingsModelInnerChange.value = true;
              if (nodes.length === 0) {
                assetCurrent.value = void 0;
                assetSettingsModel.value = void 0;
                tabCurrent.value = linkCurrent.value ? "link" : "page";
              } else if (nodes.length === 1) {
                assetCurrent.value = nodes[0];
                assetSettingsModel.value = render22.getAssetSettings(nodes[0]);
                tabCurrent.value = "asset";
              } else {
                assetCurrent.value = void 0;
                assetSettingsModel.value = void 0;
                tabCurrent.value = linkCurrent.value ? "link" : "page";
              }
            });
            render22.on("link-selection-change", (link) => {
              linkSettingsModelInnerChange.value = true;
              linkCurrent.value = link;
              linkSettingsModel.value = render22.getLinkSettings(link);
              tabCurrent.value = linkCurrent.value ? "link" : "page";
            });
            render22.on("asset-position-change", (nodes) => {
              var _a;
              assetPositionChange.value = true;
              for (const node of nodes) {
                if (node.id() === ((_a = assetCurrent.value) == null ? void 0 : _a.id())) {
                  if (assetSettingsModel.value) {
                    assetSettingsModel.value.x = parseFloat(node.position().x.toFixed(1));
                    assetSettingsModel.value.y = parseFloat(node.position().y.toFixed(1));
                  }
                }
              }
              nextTick(() => {
                assetPositionChange.value = false;
              });
            });
            render22.on("asset-rotation-change", (nodes) => {
              var _a;
              assetRotationChange.value = true;
              for (const node of nodes) {
                if (node.id() === ((_a = assetCurrent.value) == null ? void 0 : _a.id())) {
                  if (assetSettingsModel.value) {
                    assetSettingsModel.value.rotation = parseFloat(node.rotation().toFixed(1));
                  }
                }
              }
              nextTick(() => {
                assetRotationChange.value = false;
              });
            });
          }
        });
      }
    }
    onMounted(() => {
      init2();
    });
    const tabCurrent = ref("page");
    const pageSettingsModel = ref();
    const pageSettingsModelInnerChange = ref(false);
    const pageSettingsModelBackground = ref("");
    const pageSettingsModelStroke = ref("");
    const pageSettingsModelFill = ref("");
    const pageSettingsModelLinkStroke = ref("");
    const pageSettingsModelTextFill = ref("");
    const assetCurrent = ref();
    watch(() => assetCurrent.value, async () => {
      var _a, _b;
      await nextTick();
      (_a = textInputRef.value) == null ? void 0 : _a.focus();
      (_b = textInputRef.value) == null ? void 0 : _b.select();
    });
    const assetSettingsModel = ref();
    const assetSettingsModelInnerChange = ref(false);
    const assetSettingsModelStroke = ref("");
    const assetSettingsModelFill = ref("");
    const linkCurrent = ref();
    const linkSettingsModel = ref();
    const linkSettingsModelInnerChange = ref(false);
    const linkSettingsModelStroke = ref("");
    watch(() => pageSettingsModel.value, () => {
      if (pageSettingsModel.value) {
        pageSettingsModelBackground.value = pageSettingsModel.value.background;
        pageSettingsModelStroke.value = pageSettingsModel.value.stroke;
        pageSettingsModelFill.value = pageSettingsModel.value.fill;
        pageSettingsModelLinkStroke.value = pageSettingsModel.value.linkStroke;
        pageSettingsModelTextFill.value = pageSettingsModel.value.textFill;
        if (ready.value) {
          render22 == null ? void 0 : render22.setPageSettings(pageSettingsModel.value, !pageSettingsModelInnerChange.value);
        }
      }
      pageSettingsModelInnerChange.value = false;
    }, {
      deep: true
    });
    const assetPositionChange = ref(false);
    const assetRotationChange = ref(false);
    watch(() => assetSettingsModel.value, () => {
      if (!assetPositionChange.value && !assetRotationChange.value) {
        if (assetSettingsModel.value && assetCurrent.value) {
          assetSettingsModelStroke.value = assetSettingsModel.value.stroke;
          assetSettingsModelFill.value = assetSettingsModel.value.fill;
          if (ready.value) {
            render22 == null ? void 0 : render22.setAssetSettings(assetCurrent.value, assetSettingsModel.value, !assetSettingsModelInnerChange.value);
          }
        }
        assetSettingsModelInnerChange.value = false;
      }
    }, {
      deep: true
    });
    watch(() => linkSettingsModel.value, () => {
      if (linkSettingsModel.value && linkCurrent.value) {
        linkSettingsModelStroke.value = linkSettingsModel.value.stroke;
        if (ready.value) {
          render22 == null ? void 0 : render22.setLinkSettings(linkCurrent.value, linkSettingsModel.value, !linkSettingsModelInnerChange.value);
        }
      }
      linkSettingsModelInnerChange.value = false;
    }, {
      deep: true
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        withDirectives(createBaseVNode("header", null, [
          ready.value ? (openBlock(), createBlock(MainHeader, {
            key: 0,
            render: unref(render22),
            full: full.value,
            "onUpdate:full": _cache[0] || (_cache[0] = ($event) => full.value = $event),
            graphType: graphType.value,
            "onUpdate:graphType": _cache[1] || (_cache[1] = ($event) => graphType.value = $event),
            texting: texting.value,
            "onUpdate:texting": _cache[2] || (_cache[2] = ($event) => texting.value = $event),
            readonly
          }, null, 8, ["render", "full", "graphType", "texting"])) : createCommentVNode("", true)
        ], 512), [
          [vShow, !full.value]
        ]),
        createBaseVNode("section", null, [
          withDirectives(createBaseVNode("header", null, [
            ready.value ? (openBlock(), createBlock(AssetBar, {
              key: 0,
              render: unref(render22)
            }, null, 8, ["render"])) : createCommentVNode("", true)
          ], 512), [
            [vShow, !full.value && !readonly]
          ]),
          createBaseVNode("section", {
            ref_key: "boardElement",
            ref: boardElement
          }, [
            createBaseVNode("div", {
              ref_key: "stageElement",
              ref: stageElement
            }, null, 512)
          ], 512),
          withDirectives(createBaseVNode("footer", null, [
            createVNode(unref(NTabs), {
              type: "line",
              size: "small",
              animated: "",
              value: tabCurrent.value,
              "onUpdate:value": _cache[53] || (_cache[53] = ($event) => tabCurrent.value = $event)
            }, {
              default: withCtx(() => [
                createVNode(unref(NTabPane), {
                  name: "page",
                  tab: "页面"
                }, {
                  default: withCtx(() => [
                    pageSettingsModel.value ? (openBlock(), createBlock(unref(NForm), {
                      key: 0,
                      ref: "formRef",
                      model: pageSettingsModel.value,
                      rules: {},
                      "label-placement": "top",
                      size: "small"
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(NFormItem), {
                          label: "背景色",
                          path: "background"
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(NColorPicker), {
                              value: pageSettingsModelBackground.value,
                              "onUpdate:value": _cache[3] || (_cache[3] = ($event) => pageSettingsModelBackground.value = $event),
                              "onUpdate:show": _cache[4] || (_cache[4] = (v) => {
                                pageSettingsModel.value && !v && (pageSettingsModelBackground.value = pageSettingsModel.value.background);
                              }),
                              actions: ["clear", "confirm"],
                              "show-preview": "",
                              onConfirm: _cache[5] || (_cache[5] = (v) => {
                                pageSettingsModel.value && (pageSettingsModel.value.background = v);
                              }),
                              onClear: _cache[6] || (_cache[6] = ($event) => pageSettingsModel.value && (pageSettingsModel.value.background = unref(Render).PageSettingsDefault.background))
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), {
                          label: "线条颜色",
                          path: "stroke"
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(NColorPicker), {
                              value: pageSettingsModelStroke.value,
                              "onUpdate:value": _cache[7] || (_cache[7] = ($event) => pageSettingsModelStroke.value = $event),
                              "onUpdate:show": _cache[8] || (_cache[8] = (v) => {
                                pageSettingsModel.value && !v && (pageSettingsModelStroke.value = pageSettingsModel.value.stroke);
                              }),
                              actions: ["clear", "confirm"],
                              "show-preview": "",
                              onConfirm: _cache[9] || (_cache[9] = (v) => {
                                pageSettingsModel.value && (pageSettingsModel.value.stroke = v);
                              }),
                              onClear: _cache[10] || (_cache[10] = ($event) => pageSettingsModel.value && (pageSettingsModel.value.stroke = unref(Render).AssetSettingsDefault.stroke))
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), {
                          label: "线条粗细",
                          path: "strokeWidth"
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(NInputNumber), {
                              value: pageSettingsModel.value.strokeWidth,
                              "onUpdate:value": _cache[11] || (_cache[11] = ($event) => pageSettingsModel.value.strokeWidth = $event),
                              placeholder: "Input",
                              min: 1
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), {
                          label: "填充颜色",
                          path: "fill"
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(NColorPicker), {
                              value: pageSettingsModelFill.value,
                              "onUpdate:value": _cache[12] || (_cache[12] = ($event) => pageSettingsModelFill.value = $event),
                              "onUpdate:show": _cache[13] || (_cache[13] = (v) => {
                                pageSettingsModel.value && !v && (pageSettingsModelFill.value = pageSettingsModel.value.fill);
                              }),
                              actions: ["clear", "confirm"],
                              "show-preview": "",
                              onConfirm: _cache[14] || (_cache[14] = (v) => {
                                pageSettingsModel.value && (pageSettingsModel.value.fill = v);
                              }),
                              onClear: _cache[15] || (_cache[15] = ($event) => pageSettingsModel.value && (pageSettingsModel.value.fill = unref(Render).AssetSettingsDefault.fill))
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), {
                          label: "连接线颜色",
                          path: "stroke"
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(NColorPicker), {
                              value: pageSettingsModelLinkStroke.value,
                              "onUpdate:value": _cache[16] || (_cache[16] = ($event) => pageSettingsModelLinkStroke.value = $event),
                              "onUpdate:show": _cache[17] || (_cache[17] = (v) => {
                                pageSettingsModel.value && !v && (pageSettingsModelLinkStroke.value = pageSettingsModel.value.linkStroke);
                              }),
                              actions: ["clear", "confirm"],
                              "show-preview": "",
                              onConfirm: _cache[18] || (_cache[18] = (v) => {
                                pageSettingsModel.value && (pageSettingsModel.value.linkStroke = v);
                              }),
                              onClear: _cache[19] || (_cache[19] = ($event) => pageSettingsModel.value && (pageSettingsModel.value.linkStroke = unref(Render).LinkSettingsDefault.stroke))
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), {
                          label: "连接线粗细",
                          path: "strokeWidth"
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(NInputNumber), {
                              value: pageSettingsModel.value.linkStrokeWidth,
                              "onUpdate:value": _cache[20] || (_cache[20] = ($event) => pageSettingsModel.value.linkStrokeWidth = $event),
                              placeholder: "Input",
                              min: 1
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), {
                          label: "文字颜色",
                          path: "textFill"
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(NColorPicker), {
                              value: pageSettingsModelTextFill.value,
                              "onUpdate:value": _cache[21] || (_cache[21] = ($event) => pageSettingsModelTextFill.value = $event),
                              "onUpdate:show": _cache[22] || (_cache[22] = (v) => {
                                pageSettingsModel.value && !v && (pageSettingsModelTextFill.value = pageSettingsModel.value.textFill);
                              }),
                              actions: ["clear", "confirm"],
                              "show-preview": "",
                              onConfirm: _cache[23] || (_cache[23] = (v) => {
                                pageSettingsModel.value && (pageSettingsModel.value.textFill = v);
                              }),
                              onClear: _cache[24] || (_cache[24] = ($event) => pageSettingsModel.value && (pageSettingsModel.value.textFill = unref(Render).PageSettingsDefault.textFill))
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), {
                          label: "文字大小",
                          path: "fontSize"
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(NInputNumber), {
                              value: pageSettingsModel.value.fontSize,
                              "onUpdate:value": _cache[25] || (_cache[25] = ($event) => pageSettingsModel.value.fontSize = $event),
                              placeholder: "Input",
                              min: 1
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["model"])) : createCommentVNode("", true)
                  ]),
                  _: 1
                }),
                createVNode(unref(NTabPane), {
                  name: "asset",
                  tab: "素材",
                  disabled: assetCurrent.value === void 0
                }, {
                  default: withCtx(() => [
                    assetSettingsModel.value ? (openBlock(), createBlock(unref(NForm), {
                      key: 0,
                      ref: "formRef",
                      model: assetSettingsModel.value,
                      rules: {},
                      "label-placement": "top",
                      size: "small"
                    }, {
                      default: withCtx(() => {
                        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
                        return [
                          createVNode(unref(NFormItem), {
                            label: "id",
                            path: "id"
                          }, {
                            default: withCtx(() => {
                              var _a2;
                              return [
                                createVNode(unref(NInput), {
                                  value: (_a2 = assetCurrent.value) == null ? void 0 : _a2.id(),
                                  placeholder: "Input",
                                  readonly: ""
                                }, null, 8, ["value"])
                              ];
                            }),
                            _: 1
                          }),
                          ((_a = assetCurrent.value) == null ? void 0 : _a.attrs.imageType) === ImageType.svg || ((_b = assetCurrent.value) == null ? void 0 : _b.attrs.assetType) === AssetType.Graph ? (openBlock(), createBlock(unref(NFormItem), {
                            key: 0,
                            label: "线条颜色",
                            path: "stroke"
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(NColorPicker), {
                                value: assetSettingsModelStroke.value,
                                "onUpdate:value": _cache[26] || (_cache[26] = ($event) => assetSettingsModelStroke.value = $event),
                                "onUpdate:show": _cache[27] || (_cache[27] = (v) => {
                                  assetSettingsModel.value && !v && (assetSettingsModelStroke.value = assetSettingsModel.value.stroke);
                                }),
                                actions: ["clear", "confirm"],
                                "show-preview": "",
                                onConfirm: _cache[28] || (_cache[28] = (v) => {
                                  assetSettingsModel.value && (assetSettingsModel.value.stroke = v);
                                }),
                                onClear: _cache[29] || (_cache[29] = ($event) => assetSettingsModel.value && (assetSettingsModel.value.stroke = unref(Render).AssetSettingsDefault.stroke))
                              }, null, 8, ["value"])
                            ]),
                            _: 1
                          })) : createCommentVNode("", true),
                          ((_c = assetCurrent.value) == null ? void 0 : _c.attrs.assetType) === AssetType.Graph ? (openBlock(), createBlock(unref(NFormItem), {
                            key: 1,
                            label: "线条粗细",
                            path: "strokeWidth"
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(NInputNumber), {
                                value: assetSettingsModel.value.strokeWidth,
                                "onUpdate:value": _cache[30] || (_cache[30] = ($event) => assetSettingsModel.value.strokeWidth = $event),
                                placeholder: "Input"
                              }, null, 8, ["value"])
                            ]),
                            _: 1
                          })) : createCommentVNode("", true),
                          ((_d = assetCurrent.value) == null ? void 0 : _d.attrs.imageType) === ImageType.svg || ((_e = assetCurrent.value) == null ? void 0 : _e.attrs.graphType) === GraphType.Rect || ((_f = assetCurrent.value) == null ? void 0 : _f.attrs.graphType) === GraphType.Circle ? (openBlock(), createBlock(unref(NFormItem), {
                            key: 2,
                            label: "填充颜色",
                            path: "fill"
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(NColorPicker), {
                                value: assetSettingsModelFill.value,
                                "onUpdate:value": _cache[31] || (_cache[31] = ($event) => assetSettingsModelFill.value = $event),
                                "onUpdate:show": _cache[32] || (_cache[32] = (v) => {
                                  assetSettingsModel.value && !v && (assetSettingsModelFill.value = assetSettingsModel.value.fill);
                                }),
                                actions: ["clear", "confirm"],
                                "show-preview": "",
                                onConfirm: _cache[33] || (_cache[33] = (v) => {
                                  assetSettingsModel.value && (assetSettingsModel.value.fill = v);
                                }),
                                onClear: _cache[34] || (_cache[34] = ($event) => assetSettingsModel.value && (assetSettingsModel.value.fill = unref(Render).AssetSettingsDefault.fill))
                              }, null, 8, ["value"])
                            ]),
                            _: 1
                          })) : createCommentVNode("", true),
                          ((_g = assetCurrent.value) == null ? void 0 : _g.attrs.graphType) === GraphType.Line || ((_h = assetCurrent.value) == null ? void 0 : _h.attrs.graphType) === GraphType.Curve ? (openBlock(), createBlock(unref(NFormItem), {
                            key: 3,
                            label: "箭头"
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(NCheckbox), {
                                checked: assetSettingsModel.value.arrowStart,
                                "onUpdate:checked": _cache[35] || (_cache[35] = ($event) => assetSettingsModel.value.arrowStart = $event)
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(" 开始 ")
                                ]),
                                _: 1
                              }, 8, ["checked"]),
                              createVNode(unref(NCheckbox), {
                                checked: assetSettingsModel.value.arrowEnd,
                                "onUpdate:checked": _cache[36] || (_cache[36] = ($event) => assetSettingsModel.value.arrowEnd = $event)
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(" 结束 ")
                                ]),
                                _: 1
                              }, 8, ["checked"])
                            ]),
                            _: 1
                          })) : createCommentVNode("", true),
                          createVNode(unref(NFormItem), { label: "坐标" }, {
                            default: withCtx(() => [
                              createVNode(unref(NInputNumber), {
                                value: assetSettingsModel.value.x,
                                "onUpdate:value": _cache[37] || (_cache[37] = ($event) => assetSettingsModel.value.x = $event),
                                placeholder: "Input",
                                precision: 1
                              }, null, 8, ["value"]),
                              createTextVNode("   "),
                              createVNode(unref(NInputNumber), {
                                value: assetSettingsModel.value.y,
                                "onUpdate:value": _cache[38] || (_cache[38] = ($event) => assetSettingsModel.value.y = $event),
                                placeholder: "Input",
                                precision: 1
                              }, null, 8, ["value"])
                            ]),
                            _: 1
                          }),
                          createVNode(unref(NFormItem), {
                            label: "角度",
                            path: "rotation"
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(NInputNumber), {
                                value: assetSettingsModel.value.rotation,
                                "onUpdate:value": _cache[39] || (_cache[39] = ($event) => assetSettingsModel.value.rotation = $event),
                                placeholder: "Input",
                                precision: 1
                              }, null, 8, ["value"])
                            ]),
                            _: 1
                          }),
                          ((_i = assetCurrent.value) == null ? void 0 : _i.attrs.assetType) === AssetType.Text ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
                            createVNode(unref(NFormItem), {
                              label: "文字颜色",
                              path: "fill"
                            }, {
                              default: withCtx(() => [
                                createVNode(unref(NColorPicker), {
                                  value: assetSettingsModelFill.value,
                                  "onUpdate:value": _cache[40] || (_cache[40] = ($event) => assetSettingsModelFill.value = $event),
                                  "onUpdate:show": _cache[41] || (_cache[41] = (v) => {
                                    assetSettingsModel.value && !v && (assetSettingsModelFill.value = assetSettingsModel.value.fill);
                                  }),
                                  actions: ["clear", "confirm"],
                                  "show-preview": "",
                                  onConfirm: _cache[42] || (_cache[42] = (v) => {
                                    assetSettingsModel.value && (assetSettingsModel.value.fill = v);
                                  }),
                                  onClear: _cache[43] || (_cache[43] = ($event) => assetSettingsModel.value && (assetSettingsModel.value.fill = unref(Render).AssetSettingsDefault.fill))
                                }, null, 8, ["value"])
                              ]),
                              _: 1
                            }),
                            createVNode(unref(NFormItem), {
                              label: "文字大小",
                              path: "fontSize"
                            }, {
                              default: withCtx(() => [
                                createVNode(unref(NInputNumber), {
                                  value: assetSettingsModel.value.fontSize,
                                  "onUpdate:value": _cache[44] || (_cache[44] = ($event) => assetSettingsModel.value.fontSize = $event),
                                  placeholder: "Input",
                                  min: 1
                                }, null, 8, ["value"])
                              ]),
                              _: 1
                            }),
                            createVNode(unref(NFormItem), {
                              label: "文字内容",
                              path: "text"
                            }, {
                              default: withCtx(() => [
                                createVNode(unref(NInput), {
                                  type: "textarea",
                                  value: assetSettingsModel.value.text,
                                  "onUpdate:value": _cache[45] || (_cache[45] = ($event) => assetSettingsModel.value.text = $event),
                                  placeholder: "Input",
                                  ref_key: "textInputRef",
                                  ref: textInputRef
                                }, null, 8, ["value"])
                              ]),
                              _: 1
                            })
                          ], 64)) : createCommentVNode("", true)
                        ];
                      }),
                      _: 1
                    }, 8, ["model"])) : createCommentVNode("", true)
                  ]),
                  _: 1
                }, 8, ["disabled"]),
                createVNode(unref(NTabPane), {
                  name: "link",
                  tab: "连接线",
                  disabled: linkCurrent.value === void 0
                }, {
                  default: withCtx(() => [
                    linkSettingsModel.value ? (openBlock(), createBlock(unref(NForm), {
                      key: 0,
                      ref: "formRef",
                      model: linkSettingsModel.value,
                      rules: {},
                      "label-placement": "top",
                      size: "small"
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(NFormItem), {
                          label: "线条颜色",
                          path: "stroke"
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(NColorPicker), {
                              value: linkSettingsModelStroke.value,
                              "onUpdate:value": _cache[46] || (_cache[46] = ($event) => linkSettingsModelStroke.value = $event),
                              "onUpdate:show": _cache[47] || (_cache[47] = (v) => {
                                linkSettingsModel.value && !v && (linkSettingsModelStroke.value = linkSettingsModel.value.stroke);
                              }),
                              actions: ["clear", "confirm"],
                              "show-preview": "",
                              onConfirm: _cache[48] || (_cache[48] = (v) => {
                                linkSettingsModel.value && (linkSettingsModel.value.stroke = v);
                              }),
                              onClear: _cache[49] || (_cache[49] = ($event) => linkSettingsModel.value && (linkSettingsModel.value.stroke = unref(Render).LinkSettingsDefault.stroke))
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), {
                          label: "线条粗细",
                          path: "strokeWidth"
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(NInputNumber), {
                              value: linkSettingsModel.value.strokeWidth,
                              "onUpdate:value": _cache[50] || (_cache[50] = ($event) => linkSettingsModel.value.strokeWidth = $event),
                              placeholder: "Input"
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), { label: "箭头" }, {
                          default: withCtx(() => [
                            createVNode(unref(NCheckbox), {
                              checked: linkSettingsModel.value.arrowStart,
                              "onUpdate:checked": _cache[51] || (_cache[51] = ($event) => linkSettingsModel.value.arrowStart = $event)
                            }, {
                              default: withCtx(() => [
                                createTextVNode(" 开始 ")
                              ]),
                              _: 1
                            }, 8, ["checked"]),
                            createVNode(unref(NCheckbox), {
                              checked: linkSettingsModel.value.arrowEnd,
                              "onUpdate:checked": _cache[52] || (_cache[52] = ($event) => linkSettingsModel.value.arrowEnd = $event)
                            }, {
                              default: withCtx(() => [
                                createTextVNode(" 结束 ")
                              ]),
                              _: 1
                            }, 8, ["checked"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["model"])) : createCommentVNode("", true)
                  ]),
                  _: 1
                }, 8, ["disabled"])
              ]),
              _: 1
            }, 8, ["value"])
          ], 512), [
            [vShow, !full.value && !readonly]
          ])
        ]),
        _hoisted_2,
        withDirectives(createVNode(unref(NFloatButton), {
          shape: "square",
          position: "fixed",
          top: 40 + 8,
          right: 8,
          style: { "z-index": "100" },
          onClick: _cache[54] || (_cache[54] = ($event) => full.value = !full.value)
        }, {
          default: withCtx(() => [
            createVNode(unref(NIcon), null, {
              default: withCtx(() => [
                createVNode(unref(FullScreenMinimize24Regular))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512), [
          [vShow, full.value]
        ])
      ]);
    };
  }
});
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-a4dd2c0b"]]);
const optionsDefault = {
  colors: ["purple", "blue", "green", "blueviolet", "goldenrod", "brown", "chocolate"],
  type: "log"
};
const logArray = (words2) => {
  try {
    const { colors: colors2, type: type4 } = { ...optionsDefault };
    if (Array.isArray(words2)) {
      const length = words2.length;
      const format2 = new Array(length).fill("%c%s").join("");
      const array4 = [...words2].reduce((t, v, i) => {
        const radius = length === 1 ? "4px" : { 0: "4px 0 0 4px", [(length - 1).toString()]: "0 4px 4px 0" }[i];
        return [
          ...t,
          `color:#fff;background:${colors2[i] || "black"};padding:2px 4px;border-radius:${radius};`,
          v
        ];
      }, []);
      console[type4](format2, ...array4);
    }
  } catch (e) {
    console.error(e);
  }
};
var define_BUILD_INFO_default = { lastBuildTime: "2024-12-02 14:34:24", git: { branch: "master", hash: "655d7ec15cfd3c774db644c192ced96c7ac005ae", tag: "chapter23-dirty" } };
const {
  lastBuildTime,
  git: { branch, tag, hash }
} = define_BUILD_INFO_default;
logArray(["branch", branch]);
logArray(["tag", tag]);
logArray(["hash", hash]);
logArray(["build", lastBuildTime]);
createApp(App).mount("#app");
